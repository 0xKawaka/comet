{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "Lending",
  "functions": [
    {
      "name": "borrow_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "decompose_hint",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "compute_total_deposited_assets",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "deposit_accumulator",
            "type": {
              "kind": "struct",
              "path": "accumulator::Accumulator",
              "fields": [
                {
                  "name": "value",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "last_updated_ts",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "compute_total_deposited_assets"
      ]
    },
    {
      "name": "_withdraw",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5235018679007078561": {
            "error_kind": "string",
            "string": "Invalid asset or market id"
          },
          "6787403583199288031": {
            "error_kind": "string",
            "string": "Insufficient balance"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10435052277855889085": {
            "error_kind": "string",
            "string": "Function _withdraw can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15333773746166717806": {
            "error_kind": "string",
            "string": "Insufficient collateral"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBTJwAABAMnAgYEBScCBwQAHxgABwAGgE4dAIBQgFAGLgiATgABLgiATwACLgiAUAADLgiAUQAELgiAUgAFJQAAAGQlAAAA3igCAAEEgFMnAgIEADsNAAEAAiwAgEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAoAIBEBAADKACARQEAACgAgEYEAAAoAIBHAAAAKACASAEAASgAgEkEAAEoAIBKBAACKACASwAAbSgAgEwAAHIrAIBNAAAAAAAAAAACAAAAAAAAAAAmJQAAICQtCAEHAAABAgEuCoBFAActCAEIAAABAgEuCoBHAAgtCAEJAAABAgEnAgoAAi0OCgkeAgAKAB4CAAsAMzgACgALAAwkAgAMAAABMiUAACBNHgIACgEeAgALAAo4CgsMJAIADAAAAU4lAAAgXycCCgABLQgBCycCDAQDABABDAEnAwsEAQAoCwIMLQwMDS0OCg0AKA0CDS0OBA0tCAEMJwINBAQAEAENAScDDAQBACgMAg0tDA0OLgqARwAOACgOAg4uCoBHAA4AKA4CDi4KgEcADi0NDA0AKA0CDS0ODQwtCAENJwIOBAUAEAEOAScDDQQBACgNAg4tDA4PLgqARwAPACgPAg8uCoBHAA8AKA8CDy4KgEcADwAoDwIPLgqATQAPLQ0MDgAoDgIOLQ4ODC0NDQ4AKA4CDi0ODg0tCAEOAAABAgEtDgwOLQgBDAAAAQIBLQ4NDC0IAQ0AAAECAS4KgEYADS0IAQ8AAAECAS4KgEUADy4IgEYABiMAAAJhDSgABoBKABAkAgAQAAAfyCMAAAJ2LQ0PCwsoAAuARQAQJAIAEAAAApMnAhEEADwJAREnAgsEEC0IABAtDA4RLQwMEi0MDRMtDA8UABAACwAlAAAgcS0EAAAtDQ4LLQ0MEC0NDREtDgsOLQ4QDC0OEQ0uCoBIAA8BKAAQgEkADC0NDAsLKAALgEcADAsoAAyARQANJAIADQAAAwElAAAhhC0IAQwnAg0EAwAQAQ0BJwMMBAEAKAwCDS0MDQ4tDgsOACgOAg4tDgUOLQgBCycCDQQEABABDQEnAwsEAQAoCwINLQwNDi4KgEcADgAoDgIOLgqARwAOACgOAg4uCoBHAA4tDQsNACgNAg0tDg0LLQgBDScCDgQFABABDgEnAw0EAQAoDQIOLQwODy4KgEcADwAoDwIPLgqARwAPACgPAg8uCoBHAA8AKA8CDy4KgE0ADy0NCw4AKA4CDi0ODgstDQ0OACgOAg4tDg4NLQgBDgAAAQIBLQ4LDi0IAQsAAAECAS0ODQstCAENAAABAgEuCoBGAA0tCAEPAAABAgEuCoBFAA8uCIBGAAYjAAAEDw0oAAaASgAQJAIAEAAAH2wjAAAEJC0NDwwLKAAMgEUAECQCABAAAARBJwIRBAA8CQERJwIMBBAtCAAQLQwOES0MCxItDA0TLQwPFAAQAAwAJQAAIHEtBAAALQ0ODC0NCxAtDQ0RLQ4MDi0OEAstDhENLgqASAAPASgAEIBJAAwtDQwLCygAC4BHAAwLKAAMgEUADSQCAA0AAASvJQAAIYQtCAEMJwINBAkAEAENAScDDAQBACgMAg0tDA0OLgqARwAOACgOAg4uCoBHAA4AKA4CDi4KgEcADgAoDgIOLgqARwAOACgOAg4uCoBHAA4AKA4CDi4KgEcADgAoDgIOLgqARwAOACgOAg4uCoBHAA4tCAENAAABAgEtDgwNJwIMBAguCIBGAAYjAAAFOww4BgwOJAIADgAAHx0jAAAFTS0NDQYBKAAGgEkADS0NDQsBKAAGgEoADi0NDg0tCAEOJwIPBAIAEAEPAScDDgQBACgOAg8tDA8QLQ4NECcCDwQQLQgAEC0MDhEAEAAPACUAACGWLQQAAC0MEQ0BKAAGgEQADy0NDw4nAg8EBQA4Bg8RLQ0REC0IAQ8nAhEEAgAQAREBJwMPBAEAKA8CES0MERItDhASJwIRBBItCAASLQwPEwAQABEAJQAAIZYtBAAALQwTECcCDwQGADgGDxItDRIRLQgBDycCEgQCABABEgEnAw8EAQAoDwISLQwSEy0OERMnAhIEEy0IABMtDA8UABAAEgAlAAAhli0EAAAtDBQRJwIPBAcAOAYPEy0NExItCAEPJwITBAIAEAETAScDDwQBACgPAhMtDBMULQ4SFCcCEwQULQgAFC0MDxUAEAATACUAACGWLQQAAC0MFRIAOAYMEy0NEw8tCAEGJwIMBAIAEAEMAScDBgQBACgGAgwtDAwTLQ4PEycCDwQTLQgAEy0MBhQAEAAPACUAACGWLQQAAC0MFAwKOAsFBiQCAAYAAAb1JQAAIbseAgAGACcCDwQBJwIUBAMAOA8UEy0IAQsAEAETAScDCwQBACgLAhMtDg8TACgTAhMtDg8TJwITBAMAOAsTDy0MDxMtDgQTLQ0LDwAoDwIPLQ4PCycCEwQBJwIVBAMAOBMVFC0IAQ8AEAEUAScDDwQBACgPAhQtDhMUACgUAhQtDhMUJwIUBAMAOA8UEy0MExQtDgUUJwIVBBYtCAAWLgiASQAXLQwLGC4IgEkAGS0MDxoAEAAVACUAACHNLQQAAC0MFxMtDBgULQ0UDwAoDwIPLQ4PFCkCAA8AcW4J0ScCFgQXLQgAFy0MDxgAEAAWACUAACKcLQQAAC0MGBUtDRQPACgPAg8tDg8UHAwVDwAAKBMCFS4EABSAAygAgAQEAAElAAAisS4IgAUAFi4IgAYAFy0ODxctDRYPACgPAg8tDg8WJwITBBctCAAXLgiARQAYLgiARwAZLgiARQAaLgiARwAbABAAEwAlAAAkKy0EAAAtDBgPACgPAhMAKBYCGC0NGBcnAhkEAgA4GBkUOfUAEwAGABQAFyACAAYhAgAPLQgBFAAoFAIXLQ0XFicCGAQCADgXGBUiNIBGAA8AFS0MDxYnAhgEAwA4FhgXABABFwEnAxQEAQAoFAIYLQ4WGAAoGAIYLQ4WGC0MFhMGKBMCEy0NFA8AKA8CDy0ODxQkAgAGAAAJHCMAAAkAACgUAg0tDQ0MJwIPBAIAOA0PBjwNBgwjAAAJHC0NFAwAKAwCDC0ODBQLKAATgEYADCQCAAwAAAlCJwINBAA8CQENJwIMAAgtCAENJwIPBAMAEAEPAScDDQQBACgNAg8tDA8QLQ4MEAAoEAIQLQ4EEC0IAQwnAg8EBAAQAQ8BJwMMBAEAKAwCDy0MDxAuCoBHABAAKBACEC4KgEcAEAAoEAIQLgqARwAQLQ0MDwAoDwIPLQ4PDC0IAQ8nAhAEBQAQARABJwMPBAEAKA8CEC0MEBEuCoBHABEAKBECES4KgEcAEQAoEQIRLgqARwARACgRAhEuCoBNABEtDQwQACgQAhAtDhAMLQ0PEAAoEAIQLQ4QDy0IARAAAAECAS0ODBAtCAEMAAABAgEtDg8MLQgBDwAAAQIBLgqARgAPLQgBEQAAAQIBLgqARQARLgiARgAGIwAAClUNKAAGgEoAEiQCABIAAB7BIwAACmotDRENCygADYBFABIkAgASAAAKhycCEwQAPAkBEycCDQQSLQgAEi0MEBMtDAwULQwPFS0MERYAEAANACUAACBxLQQAAC0NEA0tDQwSLQ0PEy0ODRAtDhIMLQ4TDy4KgEgAEQEoABKASQANLQ0NDAsoAAyARwANCygADYBFAA8kAgAPAAAK9SUAACGELQgBDScCDwQDABABDwEnAw0EAQAoDQIPLQwPEC0ODBAAKBACEC0OBRAtCAEMJwIPBAQAEAEPAScDDAQBACgMAg8tDA8QLgqARwAQACgQAhAuCoBHABAAKBACEC4KgEcAEC0NDA8AKA8CDy0ODwwtCAEPJwIQBAUAEAEQAScDDwQBACgPAhAtDBARLgqARwARACgRAhEuCoBHABEAKBECES4KgEcAEQAoEQIRLgqATQARLQ0MEAAoEAIQLQ4QDC0NDxAAKBACEC0OEA8tCAEQAAABAgEtDgwQLQgBDAAAAQIBLQ4PDC0IAQ8AAAECAS4KgEYADy0IAREAAAECAS4KgEUAES4IgEYABiMAAAwDDSgABoBKABIkAgASAAAeZSMAAAwYLQ0RDQsoAA2ARQASJAIAEgAADDUnAhMEADwJARMnAg0EEi0IABItDBATLQwMFC0MDxUtDBEWABAADQAlAAAgcS0EAAAtDRANLQ0MEi0NDxMtDg0QLQ4SDC0OEw8uCoBIABEBKAASgEkADS0NDQwLKAAMgEcADQsoAA2ARQAPJAIADwAADKMlAAAhhC8MAAwADQA4DAoPLwwADwAKLQgBDCcCDwQCABABDwEnAwwEAQAoDAIPLQwPEC0ODRAnAg8EEC0IABAtDAwRABAADwAlAAAhli0EAAAtDBENJwIMAAQtCAEPJwIQBAMAEAEQAScDDwQBACgPAhAtDBARLQ4MEQAoEQIRLQ4EES0IAQwnAhAEBAAQARABJwMMBAEAKAwCEC0MEBEuCoBHABEAKBECES4KgEcAEQAoEQIRLgqARwARLQ0MEAAoEAIQLQ4QDC0IARAnAhEEBQAQAREBJwMQBAEAKBACES0MERIuCoBHABIAKBICEi4KgEcAEgAoEgISLgqARwASACgSAhIuCoBNABItDQwRACgRAhEtDhEMLQ0QEQAoEQIRLQ4REC0IAREAAAECAS0ODBEtCAEMAAABAgEtDhAMLQgBEAAAAQIBLgqARgAQLQgBEgAAAQIBLgqARQASLgiARgAGIwAADgYNKAAGgEoACiQCAAoAAB4JIwAADhstDRIKCygACoBFAA8kAgAPAAAOOCcCEwQAPAkBEycCCgQTLQgAEy0MERQtDAwVLQwQFi0MEhcAEAAKACUAACBxLQQAAC0NEQotDQwPLQ0QEy0OChEtDg8MLQ4TEC4KgEgAEgEoAA+ASQAMLQ0MCgsoAAqARwAMCygADIBFAA8kAgAPAAAOpiUAACGELQgBDCcCDwQDABABDwEnAwwEAQAoDAIPLQwPEC0OChAAKBACEC0OBRAtCAEKJwIPBAQAEAEPAScDCgQBACgKAg8tDA8QLgqARwAQACgQAhAuCoBHABAAKBACEC4KgEcAEC0NCg8AKA8CDy0ODwotCAEPJwIQBAUAEAEQAScDDwQBACgPAhAtDBARLgqARwARACgRAhEuCoBHABEAKBECES4KgEcAEQAoEQIRLgqATQARLQ0KEAAoEAIQLQ4QCi0NDxAAKBACEC0OEA8tCAEQAAABAgEtDgoQLQgBCgAAAQIBLQ4PCi0IAQ8AAAECAS4KgEYADy0IAREAAAECAS4KgEUAES4IgEYABiMAAA+0DSgABoBKABIkAgASAAAdrSMAAA/JLQ0RBgsoAAaARQAMJAIADAAAD+YnAhIEADwJARInAgYEEi0IABItDBATLQwKFC0MDxUtDBEWABAABgAlAAAgcS0EAAAtDRAGLQ0KDC0NDxItDgYQLQ4MCi0OEg8uCoBIABEBKAAMgEkACi0NCgYLKAAGgEcACgsoAAqARQAMJAIADAAAEFQlAAAhhCcCEQQSLQgAEi0MBxMtDAgULQwJFS0MBhYuCIBMABctDAEYABAAEQAlAAAkni0EAAAtDBMKLQwUDC0MFQ8tDBYQLwwAEAAGLQgBEScCEgQCABABEgEnAxEEAQAoEQISLQwSEy0OBhMnAhIEEy0IABMtDBEUABAAEgAlAAAhli0EAAAtDBQGBDgGDREnAhMGAAo4Ew0SJAIAEgAAEQgGOBENFQo4FQYUJAIAFAAAEQglAAAo8ikCABIGO5rKAAY4ERITDDgTAxELKAARgEUAEyQCABMAABEwJQAAKQQeAgARAC0NCxMAKBMCEy0OEwsnAhQEAScCFgQDADgUFhUtCAETABABFQEnAxMEAQAoEwIVLQ4UFQAoFQIVLQ4UFScCFQQDADgTFRQtDBQVLQ4BFScCFQQWLQgAFi4IgEkAFy0MCxguCIBJABktDBMaABAAFQAlAAAhzS0EAAAtDBcBLQwYFC0NFBUAKBUCFS0OFRQpAgAVADoJF3cnAhcEGC0IABgtDBUZABAAFwAlAAAinC0EAAAtDBkWLQ0UFQAoFQIVLQ4VFBwMFhUAACgBAhYuBAAUgAMoAIAEBAABJQAAIrEuCIAFABcuCIAGABgtDhUYLQ0XAQAoAQIBLQ4BFycCFAQYLQgAGC4IgEUAGS4IgEcAGi4IgEUAGy4IgEcAHAAQABQAJQAAJCstBAAALQwZAQAoAQIUACgXAhktDRkYJwIaBAIAOBkaFTn1ABQAEQAVABggAgABIQIAES0IARUAKBUCGC0NGBcnAhkEAgA4GBkWIjSARgARABYtDBEXJwIZBAMAOBcZGAAQARgBJwMVBAEAKBUCGS0OFxkAKBkCGS0OFxktDBcUBigUAhQtDRURACgRAhEtDhEVJAIAAQAAExYjAAAS+gAoFQIMLQ0MCicCDwQCADgMDwE8DQEKIwAAExYtDRUBACgBAgEtDgEVJwIKBBYtCAAWLQwUFy0MFRgAEAAKACUAACkWLQQAAC0MFwEnAgwEFC0IABQtDAEVABAADAAlAAApZS0EAAAtDBUKHgIAAQAtDQsMACgMAgwtDgwLLQ0TDAAoDAIMLQ4MEycCEQQULQgAFC4IgEkAFS0MCxYuCIBJABctDBMYABAAEQAlAAAhzS0EAAAtDBUMLQwWDy0NDwsAKAsCCy0OCw8pAgALAKYEhqwnAhMEFC0IABQtDAsVABAAEwAlAAAinC0EAAAtDBURLQ0PCwAoCwILLQ4LDxwMEQsAACgMAhEuBAAPgAMoAIAEBAABJQAAIrEuCIAFABMuCIAGABQtDgsULQ0TCwAoCwILLQ4LEycCDAQULQgAFC4IgEUAFS4IgEcAFi4IgEUAFy4IgEcAGAAQAAwAJQAAJCstBAAALQwVCwAoCwIMACgTAhUtDRUUJwIWBAIAOBUWDzn1AAwAAQAPABQgAgABIQIACy0IAQ8AKA8CFC0NFBMnAhUEAgA4FBURIjSARgALABEtDAsTJwIVBAMAOBMVFAAQARQBJwMPBAEAKA8CFS0OExUAKBUCFS0OExUtDBMMBigMAgwtDQ8LACgLAgstDgsPJAIAAQAAFRcjAAAU+wAoDwIRLQ0RCycCEwQCADgREwE8DQELIwAAFRctDQ8BACgBAgEtDgEPJwILBBMtCAATLQwMFC0MDxUAEAALACUAACkWLQQAAC0MFAEnAgwEEy0IABMtDAEUABAADAAlAAApZS0EAAAtDBQLKQIAAQAp1agvJwIPBBMtCAATLQwBFAAQAA8AJQAAIpwtBAAALQwUDBwMDAEAJwIPBAInAhMEAwA4DxMRLQgBDAAQAREBJwMMBAEAKAwCES0ODxEAKBECES0ODxEnAhEEAwA4DBEPLQwPES0OAREAKBECES4KgEcAES0NDAEAKAECAS0OAQwnAg8EEy0IABMuCIBFABQuCIBHABUuCIBFABYuCIBHABcAEAAPACUAACQrLQQAAC0MFAEAKAECDwAoDAIULQ0UEycCFQQCADgUFRE69QAPAA4AEQATIAIAASECAAwtCAEPACgPAhQtDRQTJwIVBAIAOBQVESI0gEYADAARLQwMEycCFQQDADgTFRQAEAEUAScDDwQBACgPAhUtDhMVACgVAhUtDhMVLQwTDgYoDgIOLQ0PDAAoDAIMLQ4MDyQCAAEAABbRIwAAFrUAKA8CES0NEQwnAhMEAgA4ERMBPA0BDCMAABbRLQ0PDAAoDAIMLQ4MDycCEQQTLQgAEy0MDhQtDA8VABAAEQAlAAApFi0EAAAtDBQMASgADIBJAA8tDQ8OHAwODwYcDA8MABwMDA4GBDgDDgwnAhEGAAo4EQ4PJAIADwAAF0oGOAwOFAo4FAMTJAIAEwAAF0olAAAo8igCAA4GJxAGOAwODwI4Cg8MDjgPCg4kAgAOAAAXbSUAACmKDDgMCwoLKAAKgEUACyQCAAsAABeHJQAAKZwEOAMSCicCDAYACjgMEgskAgALAAAXtQY4ChIPCjgPAw4kAgAOAAAXtSUAACjyBjgKDQsCOAYLCg44CwYMJAIADAAAF9ElAAApihwMCgYAMAwABgAQJwIGAAYtCAEKJwIMBAMAEAEMAScDCgQBACgKAgwtDAwNLQ4GDQAoDQINLQ4EDS0IAQQnAgYEBAAQAQYBJwMEBAEAKAQCBi0MBgwuCoBHAAwAKAwCDC4KgEcADAAoDAIMLgqARwAMLQ0EBgAoBgIGLQ4GBC0IAQYnAgwEBQAQAQwBJwMGBAEAKAYCDC0MDA0uCoBHAA0AKA0CDS4KgEcADQAoDQINLgqARwANACgNAg0uCoBNAA0tDQQMACgMAgwtDgwELQ0GDAAoDAIMLQ4MBi0IAQwAAAECAS0OBAwtCAEEAAABAgEtDgYELQgBBgAAAQIBLgqARgAGLQgBDQAAAQIBLgqARQANLgiARgABIwAAGO8NKAABgEoADiQCAA4AAB1RIwAAGQQtDQ0BCygAAYBFAAokAgAKAAAZIScCDgQAPAkBDicCAQQOLQgADi0MDA8tDAQQLQwGES0MDRIAEAABACUAACBxLQQAAC0NDAEtDQQKLQ0GDi0OAQwtDgoELQ4OBi4KgEgADQEoAAqASQAELQ0EAQsoAAGARwAECygABIBFAAYkAgAGAAAZjyUAACGEJwINBA4tCAAOLQwHDy0MCBAtDAkRLQwBEi4IgEsAEy0MBRQAEAANACUAACSeLQQAAC0MDwQtDBAGLQwRCi0MEgwvDAAMAAEtCAEHJwIIBAIAEAEIAScDBwQBACgHAggtDAgJLQ4BCScCCAQNLQgADS0MBw4AEAAIACUAACGWLQQAAC0MDgECOAELBw44CwEIJAIACAAAGiwlAAApihwMBwEAMAwAAQAMHgIAAQAnAggEACcCCwQDADgICwktCAEHABABCQEnAwcEAQAoBwIJLQ4ICQAoCQIJLQ4ICScCCQQDADgHCQgnAgkEAScCDAQDADgJDAstCAEIABABCwEnAwgEAQAoCAILLQ4JCwAoCwILLQ4JCycCCwQDADgICwktDAkLLQ4BCycCCwQMLQgADC4IgEYADS0MBw4uCIBJAA8tDAgQABAACwAlAAAhzS0EAAAtDA0BLQwOCS0NCQcAKAcCBy0OBwknAggEAScCDAQDADgIDAstCAEHABABCwEnAwcEAQAoBwILLQ4ICwAoCwILLQ4ICycCCwQDADgHCwgtDAgLLQ4CCycCCwQMLQgADC0MAQ0tDAkOLgiASQAPLQwHEAAQAAsAJQAAIc0tBAAALQwNAi0MDggtDQgBACgBAgEtDgEIHAwDAQAAKAICAy4EAAiAAygAgAQEAAElAAApri4IgAUABy4IgAYACS0OAQktDQcBACgBAgEtDgEHACgDAgEuBAAHgAMoAIAEBAABJQAAKa4uCIAFAAIuCIAGAAguCoBHAAgtDQIDACgDAgMtDgMCKQIAAwCMnlRyJwIIBAstCAALLQwDDAAQAAgAJQAAIpwtBAAALQwMBy0NAgMAKAMCAy0OAwIcDAcDAAAoAQIHLgQAAoADKACABAQAASUAACKxLgiABQAILgiABgAJLQ4DCS0NCAEAKAECAS0OAQgnAgIECy0IAAsuCIBFAAwuCIBHAA0uCIBFAA4uCIBHAA8AEAACACUAACQrLQQAAC0MDAEAKAECAgAoCAILLQ0LCScCDAQCADgLDAM59QACAAUAAwAJIAIAASECAAItCAEFACgFAgktDQkIJwILBAIAOAkLByI0gEYAAgAHLQwCCCcCCwQDADgICwkAEAEJAScDBQQBACgFAgstDggLACgLAgstDggLLQwIAwYoAwIDLQ0FAgAoAgICLQ4CBSQCAAEAAB03IwAAHRsAKAUCBC0NBAInAgYEAgA4BAYBPA0BAiMAAB03CygAA4BGAAEkAgABAAAdUCcCAgQAPAkBAiYkAgAOAAAdXiMAAB2cACgKAg8AOA8BEC0NEA4nAg8EEC0IABAtDAwRLQwEEi0MBhMtDA0ULQwOFQAQAA8AJQAAKy4tBAAAIwAAHZwBKAABgEkADi0MDgEjAAAY7yQCABIAAB26IwAAHfgAKAwCEwA4EwYULQ0UEicCEwQULQgAFC0MEBUtDAoWLQwPFy0MERgtDBIZABAAEwAlAAArLi0EAAAjAAAd+AEoAAaASQASLQwSBiMAAA+0JAIACgAAHhYjAAAeVAAoDwITADgTBhQtDRQKJwITBBQtCAAULQwRFS0MDBYtDBAXLQwSGC0MChkAEAATACUAACsuLQQAACMAAB5UASgABoBJAAotDAoGIwAADgYkAgASAAAeciMAAB6wACgNAhMAOBMGFC0NFBInAhMEFC0IABQtDBAVLQwMFi0MDxctDBEYLQwSGQAQABMAJQAAKy4tBAAAIwAAHrABKAAGgEkAEi0MEgYjAAAMAyQCABIAAB7OIwAAHwwAKA0CEwA4EwYULQ0UEicCEwQULQgAFC0MEBUtDAwWLQwPFy0MERgtDBIZABAAEwAlAAArLi0EAAAjAAAfDAEoAAaASQASLQwSBiMAAApVLQ0NDhwMBg8AADgLDxAvDAAQAA8uBAAOgAMoAIAEBAAJJQAALFcuCIAFABAAKBACEQA4EQYSLQ4PEi0OEA0BKAAGgEkADi0MDgYjAAAFOyQCABAAAB95IwAAH7cAKAwCEQA4EQYSLQ0SECcCEQQSLQgAEi0MDhMtDAsULQwNFS0MDxYtDBAXABAAEQAlAAArLi0EAAAjAAAftwEoAAaASQAQLQwQBiMAAAQPJAIAEAAAH9UjAAAgEwAoCwIRADgRBhItDRIQJwIRBBItCAASLQwOEy0MDBQtDA0VLQwPFi0MEBcAEAARACUAACsuLQQAACMAACATASgABoBJABAtDBAGIwAAAmEoAIAEBHgADQAAAIAEgAMkAIADAAAgTCoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEFkNDAwmo7Jr08AQECJiUAACAkLgiARgAFIwAAIIENKAAFgEQABiQCAAYAACDxIwAAIJYtDQEFLQ0CBi0NAwctDQQIJwIJBAQtCAEKJwILBAUAEAELAScDCgQBACgGAgsnAgwEBAAoCgINPw8ACwANLQ0KBgAoBgIGLQ4GCi0OBQEtDgoCLQ4HAy0OCAQmLQ0DBgw4BQYHASgABYBJAAYkAgAHAAAhDyMAACF7LQ0BBy0NAggtDQMJLQ0ECgAoCAIMADgMBQ0tDQ0LACgHAg0AOA0FDi0NDgwAOAsMDS4EAAiAAygAgAQEAAUlAAAsVy4IgAUACwAoCwIMADgMBQ4tDg0OLQ4HAS0OCwItDgkDLQ4KBCMAACF7LQwGBSMAACCBKgEAAQUC3G4ngHYSnTwBAQImJQAAICQBKAABgEkAAy0NAwIcDAIDBhwMAwEAHAwBAgYtDAIBJioBAAEFSKaFwJLAaKE8AQECJiUAACAkLQgBBgAAAQIBLQ4BBi0IAQEAAAECAS0OAgEtDQQCACgCAgItDgIELgiARgAFIwAAIgQMOAUDAiQCAAIAACInIwAAIhYtDQYCLQ0BAy0MAgEtDAMCJiQCAAIAACI0JQAALOUnAggEAwA4BAgHADgHBQgtDQgCLQ0GBy0NAQgAKAcCCS4EAAiAAygAgAQEAAElAAApri4IgAUACi4IgAYACy0OAgstDQoCACgCAgItDgIKLQ4JBi0OCgEBKAAFgEkAAi0MAgUjAAAiBCUAACAkHAwBAwQcDAMCABwMAgEEJi4BgAOABwEAgAMAAoALLgGAC4AIAQCACwACgAsuAYALgAkBAIALAAKACgEAgAiABIALDwCAC4AJgAwLAIAHAAKADSQAgAwAACMAIwAAI3AkAIANAAAjDSMAACMmLgCAA4AFAQCABQACgA4uAoALgA4jAAAjaygAgA8EAAMBAIAJgA+ADi4AAAGABQEAAAGADgABKAGABQQAAQEAgAUAAoAOLgKAC4AOAQCADgACgA4uAoAJgA4jAAAjayMAACPEKACADwQAAgUAgAuAD4AOKACAEAQAAwEAgA6AEIAPLgAAAYAFAQAAAYAPAAEoAYAFBAABAQCABQACgA8uAoALgA8BAIAPAAKADy4CgA6ADyMAACPEKACADQQAAwEAgAWADYAMAQCADIAEgA0DAIAIAAKADgEAgA2ADoAPAQCACoAOgBANAIAQgAqADiQAgA4AACQkLgGAEIARLgKAEYAPAwCAEAACgBADAIAPAAKADyMAACPzLgCADIAGJiUAACAkFgwBBRwMAQYAHAwFAQAEOAYCBQUoAAGAQwACADgFAgEWDAMCHAwDBQAcDAIDAAQ4BQQCBSgAA4BDAAQAOAIEAy0IAQInAgQEAwAQAQQBJwMCBAEAKAICBC0MBAUtDgEFACgFAgUtDgMFLQwCASYlAAAgJC0IAQgnAgkEAwAQAQkBJwMIBAEAKAgCCS0MCQotDgQKACgKAgotDgYKLQgBBCcCBgQEABABBgEnAwQEAQAoBAIGLQwGCS4KgEcACQAoCQIJLgqARwAJACgJAgkuCoBHAAktDQQGACgGAgYtDgYELQgBBicCCQQFABABCQEnAwYEAQAoBgIJLQwJCi4KgEcACgAoCgIKLgqARwAKACgKAgouCoBHAAoAKAoCCi4KgE0ACi0NBAkAKAkCCS0OCQQtDQYJACgJAgktDgkGLQgBCQAAAQIBLQ4ECS0IAQQAAAECAS0OBgQtCAEGAAABAgEuCoBGAAYtCAEKAAABAgEuCoBFAAouCIBGAAcjAAAlsQ0oAAeASgALJAIACwAAKJYjAAAlxi0NCg0LKAANgEUADiQCAA4AACXjJwIPBAA8CQEPJwINBA4tCAAOLQwJDy0MBBAtDAYRLQwKEgAQAA0AJQAAIHEtBAAALQ0JDS0NBA4tDQYPLQ4NCS0ODgQtDg8GLgqASAAKASgADoBJAAYtDQYEJwIGAFwKOAUGCQsoAASARwAGJAIACQAAKFsjAAAmUycCCQBnCjgFCQokAgAKAAAoMSMAACZqJwIJAGkKOAUJCiQCAAoAACgHIwAAJoEnAgkAawo4BQkKJAIACgAAJ90jAAAmmAsoAAWASwAJJAIACQAAJ7MjAAAmrScCCQBwCjgFCQokAgAKAAAniSMAACbECygABYBMAAkkAgAJAAAnXyMAACbZJwIJAHUKOAUJCiQCAAoAACc1IwAAJvAnAgkAeAo4BQkKJAIACgAAJwsnAg0EADwJAQ0LKAAGgEUABSQCAAUAACcgJQAAIYQtDAEHLQwCCC0MAwstDAQMIwAAKIULKAAGgEUABSQCAAUAACdKJQAAIYQtDAEHLQwCCC0MAwstDAQMIwAAKIULKAAGgEUABSQCAAUAACd0JQAAIYQtDAEHLQwCCC0MAwstDAQMIwAAKIULKAAGgEUABSQCAAUAACeeJQAAIYQtDAEHLQwCCC0MAwstDAQMIwAAKIULKAAGgEUABSQCAAUAACfIJQAAIYQtDAEHLQwCCC0MAwstDAQMIwAAKIULKAAGgEUABSQCAAUAACfyJQAAIYQtDAEHLQwCCC0MAwstDAQMIwAAKIULKAAGgEUABSQCAAUAACgcJQAAIYQtDAEHLQwCCC0MAwstDAQMIwAAKIULKAAGgEUABSQCAAUAAChGJQAAIYQtDAEHLQwCCC0MAwstDAQMIwAAKIULKAAGgEUABSQCAAUAAChwJQAAIYQtDAEHLQwCCC0MAwstDAQMIwAAKIUtDAcBLQwIAi0MCwMtDAwEJiQCAAsAACijIwAAKOEAKAgCDAA4DAcNLQ0NCycCDAQNLQgADS0MCQ4tDAQPLQwGEC0MChEtDAsSABAADAAlAAArLi0EAAAjAAAo4QEoAAeASQALLQwLByMAACWxKgEAAQVkYYioxs+UyzwBAQImKgEAAQVeMbOZA86a3zwBAQImJQAAICQLKAABgEkAAyQCAAMAACk0JwIEBAA8CQEEASgAAoBEAAMtDQMBLQgBAicCAwQCABABAwEnAwIEAQAoAgIDLQwDBC0OAQQtDAIBJiUAACAkASgAAYBJAAMtDQMCHAwCAwYcDAMBABwMAQIGLQwCASYqAQABBSiGkrBH3P1DPAEBAiYqAQABBdTMgfr2el1uPAEBAiYuAYADgAcBAIADAAKACy4BgAuACAEAgAsAAoALLgGAC4AJAQCACwACgAoBAIAIgASACw8AgAuACYAMCwCABwACgA0kAIAMAAAp/SMAACptJACADQAAKgojAAAqIy4AgAOABQEAgAUAAoAOLgKAC4AOIwAAKmgoAIAPBAADAQCACYAPgA4uAAABgAUBAAABgA4AASgBgAUEAAEBAIAFAAKADi4CgAuADgEAgA4AAoAOLgKACYAOIwAAKmgjAAAqwSgAgA8EAAIFAIALgA+ADigAgBAEAAMBAIAOgBCADy4AAAGABQEAAAGADwABKAGABQQAAQEAgAUAAoAPLgKAC4APAQCADwACgA8uAoAOgA8jAAAqwSgAgA0EAAMBAIAFgA2ADAsAgAOABYANJACADQAAKyUBAIAKgAiADy4AgAqAEC4AgAyAEQsAgBCAD4ASJACAEgAAKyUuAYAQgA4uAoAOgBEBAIAQAAKAEAEAgBEAAoARIwAAKvQBAIAMgAiABiYlAAAgJC0NAwYtDQQHCygAB4BFAAgkAgAIAAArVCcCCQQAPAkBCQsoAAaARAAHJAIABwAAK+MjAAAraS0NAQYtDQIHLQ0DCC0NBAkNKAAIgEQACiQCAAoAACuOJQAALOUuBAAGgAMoAIAEBAAEJQAALFcuCIAFAAoAKAoCCwA4CwgMLQ4FDAEoAAiASQAFDjgIBQYkAgAGAAArziUAACz3LQ4KAS0OBwItDgUDLQ4JBCMAACxWJwIGBActCAAHLQwBCC0MAgktDAMKLQwECwAQAAYAJQAAIHEtBAAALQ0BBi0NAgctDQQILgQABoADKACABAQABCUAACxXLgiABQAJACgJAgoBKAAKgEYACy0OBQstDgkBLQ4HAi4KgEkAAy0OCAQjAAAsViYuAYADgAYLAIAGAAKAByQAgAcAACxyIwAALH0uAIADgAUjAAAs5C4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAACzQLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAACyfKAGABQQAAQMAgAYAAoAGIwAALOQmKgEAAQXFa8RaDhAAAjwBAQImKgEAAQVFp8pxGUHkFTwBAQIm",
      "debug_symbols": "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",
      "brillig_names": [
        "_withdraw"
      ]
    },
    {
      "name": "withdraw_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "1ZzbTuQ4EIbfpa/7wnV0eV5ltRpxaEZICBCHlVaId990D0ln6UA0pv8mvkEEXPV/VbEd23H8srrcnD//+nl9e3X3uPrx18vq5u7i7On67ra7enldr84frm9urn/9HP95lbY/yGJn8Hh/dru9fnw6e3ha/SBhS+vV5vZy+7uEdU6urm823VVKr+vD8om5L56Uh9IlTxRWd3orrJ7TUNhtonBYsrfCYUzjwn+vV+RyHPxS+uJE5YT4R8q+xZD9mMk+Wc59YRf5HL9Y6WMtLvoeP/ux8Yn/h78VCT2FSJkSyc59vciu+3phAq4XRadxsg84RWdwQrTHiVGT/AAn84AT+QDng+xQHnCyfY7zecCcFK4Aj4HgMVCgFVjgCvAYBB6DZLSCMlzB0QpGcIWvx8BOfRfPnvPoKaI7CSe8BD6KjI8iG1wiEl4CH0XBR1EUL1HQEpIELxFwCcJHQRkuwV/vQFz6AbjbftpR/Ld/x/qXBPYP5lcwv4L5DcxvhvXvYH5XsP/A+s8M9g+unwHu3/DjCsGPK6TAo9CU8BKKl4CPjpTwURA+Cha8BHyMp8J4CfgYTxUfhcKnugoeaSh4pKFWsP5dwP4z1n8G82cwfzDYP5i/ENg/uH0VbPuyJGD/2JG80dfrJ0XqXz1RUBwoYGuoMYP9g++AYFuAgdcSDLyWYAa+vwbmB68lmIPrj4N70KxY/wHOP/gJbAVc/wu2f/OkYP9gfmKwf2z9cYa/DHSGz/Nc8FEIPgpNeAn4op0bPgo7QRTw5S4/wjL/rAR8ucuz4CXwUQTjJbAjSQfPxR08F3fwXDyD5+I5gfkJzE/YkVJmMD9jR0pZCOz/6+0rSPvCIVHGCn9UeIdTFoWjuiyc2caSzT/HIeKhdPe7juintupL0n5HuaSR79+7H7PlhQE5Lw1oabdsfpPkiYHm10JODeQLAypLq9RlYRmKtLA6FGlhrSzmx4lHB6LUf9AjXekx0MSDT0yGB1+O9/Tzo9BF00fL9Nx07rnp3EvTuZfcMr02nXttut6bnv7xWfJAP5omT9JTotzjd1EnPeAvbfN74/n/jlnXMfmzNM7feP7j9PxdiZ6frczxO/nA7/L+a/n4hhmjpCH/Mtf7d8wxnHaRujXmA/7TTzA5Ys9vc/y5jI670PdfBZdvmI8el98a5y9t889/WbFw/sbzP//WZeH8jfef2nj+tfH8W+P5t8bz742PH7zx8YM3/vz6hvnjcfljQfxboOClAeVlAVFKenIiTcMrL52dcxIHDb4l+WEApfEAvuEt2ZEDiMYD4NbvgByjn5MYvr0jTTwOYCei6RQicQIRE7wITX9MSKqDmdp+BZDd38y8ymx66jtvZnVmpcpsel/evFlUmVndDZjeHDdrNn2ODe33eZOP2rm+WU0fvUKuwzqxezq00gorTrmCkMlqrDhVWVVpSZWW1GmVGqvpd9KzVrnmLn9Q6+esosbKrcYqpyorr7GKqmxElVZVW+ZSlcNSKqw+OBdx1uqP6+Frd/XP2cP12fnN5u0g+avn24vRufJP/95v3h0xf/9wd7G5fH7YbA+b358zv+3quuq5FpKOZpssIV2Lx+5Jvv1n8jUT7TrG7SVxd6kdQ8fxHw==",
      "brillig_names": [
        "withdraw_public"
      ]
    },
    {
      "name": "get_total_borrowed_assets",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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M8pqSJmmlJWUaUpZSZmmlJWUaUpZPbLOKCsp05SykjJNKSsp05SykjJNKSsp04yyWlKmKWUlZZpSVlKmKWUlZZpSVo+sM8pKyjSlrKRMU8pKyjSlrKRMU8pKyjSjrI6UaUpZSZmmlJWUaUpZSZmmlNUj64yykjJNKSsp05SykjJNKSsp05SykjLNKKsnZVIiq/XhQJhbsvpyyBq2rXyXlZRpSllJmaaUlZRpSlk9ss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLIGUqYpZSVlmlJWUqYpZSVlmlJWj6wzykrKNKWspExTykrKNKWspExTykrKNKOskZRpSllJmaaUlZRpSllJmaaU1SPrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oayJlmlJWUqYpZSVlmlJWUqYpZfXIOqOspExTykrKNKWspExTykrKNKWspEwzyppJmaaUlZRpSllJmaaUlZRpSlk9ss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLIWUqYpZSVlmlJWUqYpZSVlmlJWj6wzykrKNKWspExTykrKNKWspExTykrKNKGst/8OWWeUlZRpSllJmaaUlZRpSlk9ss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLIaUqYpZSVlmlJWUqYpZSVlmlJWj6wzykrKNKWspExTykrKNKWspExTykrKNKOslpRpSllJmaaUlZRpSllJmaaU1SPrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oqyNlmlJWUqYpZSVlmlJWUqYpZfXIOqOspExTykrKNKWspExTykrKNKWspEwzyupJmaaUlZRpSllJmaaUlZRpSlk9ss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLIGUqYpZSVlmlJWUqYpZSVlmlJWj6wzykrKNKWspExTykrKNKWspExTykrKNKOskZRpSllJmaaUlZRpSllJmaaU1SPrjLKSMk0pKynTlLKSMv1c1riZQ9b0PPCqrLePNAeUZ1lfFEHe9iJIprSOtlvZj7Y2/Xb0X7KSMk0pKynTjLImUqYpZSVlmlJWUqYpZSVlmlJWj6wzykrKNKWspExTykrKNKWspExTykrKNKOsmZRpSllJmYaU1Tu3H+1za4kw+l3MGB8l4GJNnPJYfNyehlE/OJrj6GjD1jjaJBN33rd/F9f69HLwjsU81W6uHJxv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",
      "brillig_names": [
        "get_total_borrowed_assets"
      ]
    },
    {
      "name": "get_accumulators",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "tuple",
            "fields": [
              {
                "kind": "struct",
                "path": "accumulator::Accumulator",
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "last_updated_ts",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ]
              },
              {
                "kind": "struct",
                "path": "accumulator::Accumulator",
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "last_updated_ts",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ]
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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3/8R5e0f8WT5p+lHuPd/hH//R4T3f4S8/yPW939EfP9HvP/bvb7/272+/9sd3//tju//dsf3f7vj+7/d8f3f7vj+b3d8/7c7/vjbfT0t151Wqk5LS91pru40X3daqDtN6k5b606LdafVVUmqq5JUVyW5rkpyXZXkuirJdVWS66ok11VJrquSXFclua5Kcl2VlLoqKXVVUuqqpNRVSamrklJXJaWuSkpdlZS6KilVVZKWpe40V3earzst1J0mdaetdafFutNS3Wm57rS6KnF1VeLqqsTVVYmrqxJXVyWurkpcXZW4uipxdVXi6qrE11WJr6sSX1clvq5KfF2V+Loq8XVV4uuqxNdVia+rklBXJaGuSkJdlYS6Kgl1VRLqqiTUVUmoq5JQVyWhrkqkrkqkrkqkrkqkrkqkrkqkrkqkrkqkrkqkrkqkrkrWuipZ66pkrauSta5K1roqWeuqZK2rkrWuSta6KlnrqiTWVUmsq5JYVyWxrkpiXZXEuiqJdVVSl72muuw11WWvqS57TXXZa6rLXlNd9prqstdUl72muuw11WWvqS57TXXZa6rLXlNd9prqstdUl72muuw11WWvqS57TXXZa6rLXlNd9prqstdUl72muuw11WWvqS57TXXZa6rLXlNd9prqstdUl73muuw112WvuS57zXXZa67LXnNd9prrstdcl73muuw112WvuS57zXXZa67LXnNd9prrstdcl73muuw112WvuS57zXXZa67LXnNd9prrstdcl73muuw112WvuS57zXXZa67LXnNd9prrstdcl73muuw112WvuS57zXXZa67LXnNd9prrstdcl73muuw112WvuS57zXXZa67LXnNd9prrstdcl73muuw112WvuS57zU+y17I/vOeKuIPTnlRJ2vd/LMX/cdrjE4KXpvTr4Ms3Yz/W56MXBZS8bfhZyp/HXocTbA1HbA1ntTWcaGs4ydZwsq3hFFPDebZ2oDUcZ2s4tq7K0dZVOdq6KkdbV+Vo66ocbV2Vo62rcrR1VU6fvirHffON5W7/99t4nLHxeGPjCcbGI8bGsxobz4+vzdfTUt1pue60w2uSd3nbwsN7t55AczGF7Upz+Xe8baxz+BOzS1r0dXBY7jfhWY63Al32DbCWcPsx+WUuv8d/vJRsaPzrsgkQ1xAex+86H7/vfPyh8/FL5+NfOx9/7Hz8qfPx587Hb/3+ezL+0vn9t3R+/y2d339L5/ff0vn9t3R+/y2d339L5/ff0vn9t/R9/y1L3/ffsvR9/y1L3/ffsvR9/y1L3/ffsvR9/y1L3/ffsvR9/y1L3/ffsnR+/3Wd339d5/df1/n913V+/3Wd339d5/df1/n913V+/3Wd339d5/df3/n913d+//Wd33995/df3/n913d+//Wd33995/df3/n913d+/w2d339D5/ff0Pn9N3R+/w2d339D5/ff0Pn9N3R+/w2d339D5/df6fz+K53ff6Xz+690fv+Vzu+/0vn9Vzq//0rn91/p/P4rnd9/187vv2vn99+18/vv2vn9d+38/rt2fv9dO7//rp3ff9fO779r5/ff2Pn9N3Z+/42d339j5/ff2Pn9N3Z+/42d339j5/ff2Pn9N3Z+/02d339T5/ff1Pn9N3V+/02d339T5/ff1Pn9N3V+/02d33/N7391Mv7O978qne9/VTrf/6p0vv9V6Xz/q9L5/lel8/2vSuf7X5XO978qne9/VTrf/6p0vv9V6Xz/q9L5/lel8/2vSuf7X5XO978qne9/VTrf/6r0vf9VXPre/+rX7tadj7/r++9l/F3ffy/j7/r+exl/1/ffy/i7vv9ext/1/fcy/q7vv5fxd37/7Xv/q8v4O7//9r3/1WX8nd9/+97/6jL+zu+/fe9/dRl/5/ffvve/uoy/8/tv3/tfXcbf+f237/2vLuPv/P7b9/5Xl/F3fv/te/+ry/g7v//2vf/VZfyd33/73v/qMv7O77997391GX/n99++97+6jL/z+2/f+19dxt/5/bfv/a8u4+/8/tv3/leX8Xd+/+17/6vL+Du///a9/9Vl/J3ff/ve/+oy/s7vv33vf3UZf+f33773v7qMv/P7b9/7X13G3/n9t+/9ry7j7/z+2/f+V5fxd37/7Xv/q8v4O7//9r3/1WX8nd9/+97/6jL+zu+/fe9/dRl/5/ffvve/uoy/8/tv3/tfXcbf+f237/2vLuPv/P7b9/5Xl/F3fv/te/+ry/g7v//2vf/VZfyd33/73v/qMv7O77997391GX/n91/z+1/d/nRMxd2P/+jgbdQxx9sfzuvXXK3fq1vO1fp9veVcrfcALedqvV9oOVfrvUXLuRrvQ369KeM2V/96rn4pxW/jvvw774f7y7+v8zXet7Ser/V9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",
      "brillig_names": [
        "get_accumulators"
      ]
    },
    {
      "name": "withdraw_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "decompose_hint",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "_compute_borrow_rate",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "asset",
            "type": {
              "kind": "struct",
              "path": "asset::Asset",
              "fields": [
                {
                  "name": "asset_address",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "loan_to_value",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "oracle",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "is_borrowable",
                  "type": {
                    "kind": "boolean"
                  }
                },
                {
                  "name": "optimal_utilization_rate",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "under_optimal_slope",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "over_optimal_slope",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "deposit_cap",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "utilization_rate",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "precision",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17134621154673181869": {
            "error_kind": "string",
            "string": "Function _compute_borrow_rate can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBPJwAABAMnAgsECicCDAQAHxgADAALgEQdAIBFgEUGHQCAR4BHAR0AgEiASAYdAIBJgEkGHQCASoBKBh0AgEuASwYdAIBMgEwGHQCATYBNBi4IgEQAAS4IgEUAAi4IgEYAAy4IgEcABC4IgEgABS4IgEkABi4IgEoABy4IgEsACC4IgEwACS4IgE0ACiUAAAC5JQAAALouBAABgE4oAgACBIBOJwIDBAE7DQACAAMmJQAAAeUeAgALAB4CAAwAMzgACwAMAA0nAgsBASQCAA0AAADjJQAAAg4eAgALAR4CAAwACjgLDA0kAgANAAAA/yUAAAIgLQgBCwAAAQIBJwIMBgAtDgwLDDgJBQwkAgAMAAABpCMAAAEjAjgJBQEOOAUJAiQCAAIAAAE6JQAAAjIEOAEHAicCBAYACjgEBwMkAgADAAABaAY4AgcJCjgJAQgkAgAIAAABaCUAAAJEAjgKBQEOOAUKAyQCAAMAAAF/JQAAAjIGOAIBAwA4BgMBDjgGAQIkAgACAAABmyUAAAJWLQ4BCyMAAAHgBDgJBgEnAgMGAAo4AwYCJAIAAgAAAdIGOAEGBwo4BwkEJAIABAAAAdIlAAACRAY4AQUCLQ4CCyMAAAHgLQ0LASYoAIAEBHgADQAAAIAEgAMkAIADAAACDSoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEF7cpnKDUwRK08AQECJioBAAEFKIaSsEfc/UM8AQECJioBAAEFZGGIqMbPlMs8AQECJioBAAEFRafKcRlB5BU8AQECJg==",
      "debug_symbols": "vZfRbuowDIbfpde9iB3HifcqR0dTgTJVqgoqcKQjxLsv2WjpaLtuFuIGJej/+J3UNvU525Sr09tr1Wx3h+zlzzmrd+viWO2auDtf8mzVVnVdvb0Ov85M+gCBD+CwL5q0PxyL9pi9gEVn8qxsNmltg4s/sq3qMu6MueRjvUHs5IawV4ufEBMzXMXE3vRidhPi4Iy7ioNDGIr/5jF8fkz4Ip0cQJ4WPpoH3b4L/e2HhdsH530nZmu/D1+cdGcVtjQKXx4dPuCX8JMJ0BNMEJ9h4idNQKSnYkbwggkFS13+hUGtzeSfxz7/gr9/gHb62DgoZxzW80xED6wI+5M7IvoSUeIIdZwzSs5NcQhiuoRJ61srcfYTExXGpMN0bt7OYH1WxLWHe2z6rwTRQtdw4pp5hLEGswZ0mKiw6SaUML5hQiNMVBjq3FDnNl1yi9h0xS1jOreZelvC2MxgfXkjEpkR5lSY17n5oMKCXb4SIhhhM24YwneYWB2mciPDKgxAheHMczO+75MIQCPMqTCrc7M6N7I6LKgwp3Nj0GEzWWJYbhiFe8yDCgvm98l1ibt/RVsVq7q8DmPbU7MezGbH//vybkzbt7t1uTm1ZRrYBrNa8g+cC6TJJ50h9of4PhJNotE7",
      "brillig_names": [
        "_compute_borrow_rate"
      ]
    },
    {
      "name": "deposit_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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BAAIgAMoAIAEBAABJQAAB08uCIAFAAouCIAGAAstDgILLQ0KAgAoAgICLQ4CCi0OCQYtDgoBASgABYBGAAItDAIFIwAABrcuAYADgAcBAIADAAKACy4BgAuACAEAgAsAAoALLgGAC4AJAQCACwACgAoBAIAIgASACw8AgAuACYAMCwCABwACgA0kAIAMAAAHniMAAAgOJACADQAAB6sjAAAHxC4AgAOABQEAgAUAAoAOLgKAC4AOIwAACAkoAIAPBAADAQCACYAPgA4uAAABgAUBAAABgA4AASgBgAUEAAEBAIAFAAKADi4CgAuADgEAgA4AAoAOLgKACYAOIwAACAkjAAAIYigAgA8EAAIFAIALgA+ADigAgBAEAAMBAIAOgBCADy4AAAGABQEAAAGADwABKAGABQQAAQEAgAUAAoAPLgKAC4APAQCADwACgA8uAoAOgA8jAAAIYigAgA0EAAMBAIAFgA2ADAsAgAOABYANJACADQAACMYBAIAKgAiADy4AgAqAEC4AgAyAEQsAgBCAD4ASJACAEgAACMYuAYAQgA4uAoAOgBEBAIAQAAKAEAEAgBEAAoARIwAACJUBAIAMgAiABiYuAYADgAcBAIADAAKACy4BgAuACAEAgAsAAoALLgGAC4AJAQCACwACgAoBAIAIgASACw8AgAuACYAMCwCABwACgA0kAIAMAAAJHiMAAAmOJACADQAACSsjAAAJRC4AgAOABQEAgAUAAoAOLgKAC4AOIwAACYkoAIAPBAADAQCACYAPgA4uAAABgAUBAAABgA4AASgBgAUEAAEBAIAFAAKADi4CgAuADgEAgA4AAoAOLgKACYAOIwAACYkjAAAJ4igAgA8EAAIFAIALgA+ADigAgBAEAAMBAIAOgBCADy4AAAGABQEAAAGADwABKAGABQQAAQEAgAUAAoAPLgKAC4APAQCADwACgA8uAoAOgA8jAAAJ4igAgA0EAAMBAIAFgA2ADAEAgAyABIANAwCACAACgA4BAIANgA6ADwEAgAqADoAQDQCAEIAKgA4kAIAOAAAKQi4BgBCAES4CgBGADwMAgBAAAoAQAwCADwACgA8jAAAKES4AgAyABiYqAQABBcVrxFoOEAACPAEBAiY=",
      "debug_symbols": "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",
      "brillig_names": [
        "deposit_public"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "951653053333916160": {
            "error_kind": "string",
            "string": "Deposit cap exceeded"
          },
          "1602191554767750373": {
            "error_kind": "string",
            "string": "Function _borrow can only be called internally"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4270187767586857285": {
            "error_kind": "string",
            "string": "Function _compute_total_collateral_value can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5235018679007078561": {
            "error_kind": "string",
            "string": "Invalid asset or market id"
          },
          "6787403583199288031": {
            "error_kind": "string",
            "string": "Insufficient balance"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7969124557626779129": {
            "error_kind": "string",
            "string": "Function _compute_total_min_collateral_value can only be called internally"
          },
          "10435052277855889085": {
            "error_kind": "string",
            "string": "Function _withdraw can only be called internally"
          },
          "12348881442450494403": {
            "error_kind": "string",
            "string": "Function _compute_utilization_rate can only be called internally"
          },
          "13135008234568508716": {
            "error_kind": "string",
            "string": "Function _repay can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14687457983715723088": {
            "error_kind": "string",
            "string": "Asset is not borrowable"
          },
          "15333773746166717806": {
            "error_kind": "string",
            "string": "Insufficient collateral"
          },
          "16022896159229267359": {
            "error_kind": "string",
            "string": "Function _deposit can only be called internally"
          },
          "17134621154673181869": {
            "error_kind": "string",
            "string": "Function _compute_borrow_rate can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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DgYELQgBBgAAAQIBLgqARgAGLQgBCgAAAQIBLgqARQAKLgiARgAHIwAAfrwNKAAHgEwACyQCAAsAAIISIwAAftEtDQoOCygADoBFAA8kAgAPAAB+7icCEAQAPAkBECcCDgQPLQgADy0MCRAtDAQRLQwGEi0MChMAEAAOACUAAL8fLQQAAC0NCQ4tDQQPLQ0GEC0ODgktDg8ELQ4QBi4KgEkACgEoAA+ASgAGLQ0GBAsoAAWAVwAGCygABIBIAAkkAgAGAACBzSMAAH9cCygABYBYAAYkAgAGAACBnSMAAH9xCygABYBaAAYkAgAGAACBbSMAAH+GCygABYBbAAYkAgAGAACBPSMAAH+bCygABYBcAAYkAgAGAACBDSMAAH+wCygABYBdAAYkAgAGAACA3SMAAH/FCygABYBeAAYkAgAGAACArSMAAH/aCygABYBfAAYkAgAGAACAfSMAAH/vCygABYBkAAYkAgAGAACATSMAAIAECygABYBmAAYkAgAGAACAHScCCgQAPAkBCgsoAAmARQAFJAIABQAAgDIlAADALS0MAQctDAIILQwDCy0MBAwuCIBnAA0jAACB/QsoAAmARQAFJAIABQAAgGIlAADALS0MAQctDAIILQwDCy0MBAwuCIBlAA0jAACB/QsoAAmARQAFJAIABQAAgJIlAADALS0MAQctDAIILQwDCy0MBAwuCIBgAA0jAACB/QsoAAmARQAFJAIABQAAgMIlAADALS0MAQctDAIILQwDCy0MBAwuCIBhAA0jAACB/QsoAAmARQAFJAIABQAAgPIlAADALS0MAQctDAIILQwDCy0MBAwuCIBiAA0jAACB/QsoAAmARQAFJAIABQAAgSIlAADALS0MAQctDAIILQwDCy0MBAwuCIBjAA0jAACB/QsoAAmARQAFJAIABQAAgVIlAADALS0MAQctDAIILQwDCy0MBAwuCIBkAA0jAACB/QsoAAmARQAFJAIABQAAgYIlAADALS0MAQctDAIILQwDCy0MBAwuCIBmAA0jAACB/QsoAAmARQAFJAIABQAAgbIlAADALS0MAQctDAIILQwDCy0MBAwuCIBoAA0jAACB/QsoAAmARQAFJAIABQAAgeIlAADALS0MAQctDAIILQwDCy0MBAwuCIBpAA0jAACB/S0MBwEtDAgCLQwNBS0MCwMtDAwEJiQCAAsAAIIfIwAAgl0AKAgCDAA4DAcNLQ0NCycCDAQNLQgADS0MCQ4tDAQPLQwGEC0MChEtDAsSABAADAAlAADAPy0EAAAjAACCXQEoAAeASgALLQwLByMAAH68JQAAcvctCAEIJwIJBAMAEAEJAScDCAQBACgIAgktDAkKLQ4ECgAoCgIKLQ4GCi0IAQQnAgYEBAAQAQYBJwMEBAEAKAQCBi0MBgkuCoBIAAkAKAkCCS4KgEgACQAoCQIJLgqASAAJLQ0EBgAoBgIGLQ4GBC0IAQYnAgkEBQAQAQkBJwMGBAEAKAYCCS0MCQouCoBIAAoAKAoCCi4KgEgACgAoCgIKLgqASAAKACgKAgouCoBxAAotDQQJACgJAgktDgkELQ0GCQAoCQIJLQ4JBi0IAQkAAAECAS0OBAktCAEEAAABAgEtDgYELQgBBgAAAQIBLgqARgAGLQgBCgAAAQIBLgqARQAKLgiARgAHIwAAg4ENKAAHgEwACyQCAAsAAIZYIwAAg5YtDQoNCygADYBFAA4kAgAOAACDsycCDwQAPAkBDycCDQQOLQgADi0MCQ8tDAQQLQwGES0MChIAEAANACUAAL8fLQQAAC0NCQ0tDQQOLQ0GDy0ODQktDg4ELQ4PBi4KgEkACgEoAA6ASgAGLQ0GBAsoAAWAWQAGCygABIBIAAkkAgAGAACGHSMAAIQhCygABYBgAAYkAgAGAACF8yMAAIQ2CygABYBhAAYkAgAGAACFySMAAIRLCygABYBiAAYkAgAGAACFnyMAAIRgCygABYBjAAYkAgAGAACFdSMAAIR1CygABYBlAAYkAgAGAACFSyMAAISKCygABYBnAAYkAgAGAACFISMAAISfCygABYBoAAYkAgAGAACE9yMAAIS0CygABYBpAAYkAgAGAACEzScCCgQAPAkBCgsoAAmARQAFJAIABQAAhOIlAADALS0MAQctDAIILQwDCy0MBAwjAACGRwsoAAmARQAFJAIABQAAhQwlAADALS0MAQctDAIILQwDCy0MBAwjAACGRwsoAAmARQAFJAIABQAAhTYlAADALS0MAQctDAIILQwDCy0MBAwjAACGRwsoAAmARQAFJAIABQAAhWAlAADALS0MAQctDAIILQwDCy0MBAwjAACGRwsoAAmARQAFJAIABQAAhYolAADALS0MAQctDAIILQwDCy0MBAwjAACGRwsoAAmARQAFJAIABQAAhbQlAADALS0MAQctDAIILQwDCy0MBAwjAACGRwsoAAmARQAFJAIABQAAhd4lAADALS0MAQctDAIILQwDCy0MBAwjAACGRwsoAAmARQAFJAIABQAAhgglAADALS0MAQctDAIILQwDCy0MBAwjAACGRwsoAAmARQAFJAIABQAAhjIlAADALS0MAQctDAIILQwDCy0MBAwjAACGRy0MBwEtDAgCLQwLAy0MDAQmJAIACwAAhmUjAACGowAoCAIMADgMBw0tDQ0LJwIMBA0tCAANLQwJDi0MBA8tDAYQLQwKES0MCxIAEAAMACUAAMA/LQQAACMAAIajASgAB4BKAAstDAsHIwAAg4ElAABy9y0IAQYnAgcECQAQAQcBJwMGBAEAKAYCBy0MBwguCoBIAAgAKAgCCC4KgEgACAAoCAIILgqASAAIACgIAgguCoBIAAgAKAgCCC4KgEgACAAoCAIILgqASAAIACgIAgguCoBIAAgAKAgCCC4KgEgACC0IAQcAAAECAS0OBgcuCIBGAAUjAACHQA0oAAWAUwABJAIAAQAAiSQjAACHVS0NBwEBKAABgEoAAy0NAwIBKAABgEwABC0NBAMtCAEEJwIFBAIAEAEFAScDBAQBACgEAgUtDAUGLQ4DBicCBQQGLQgABi0MBAcAEAAFACUAAMFoLQQAAC0MBwMBKAABgEQABS0NBQQBKAABgE0ABi0NBgUcDAUHARwMBwYAHAwGBQEBKAABgE4ABy0NBwYtCAEHJwIIBAIAEAEIAScDBwQBACgHAggtDAgJLQ4GCScCCAQJLQgACS0MBwoAEAAIACUAAMFoLQQAAC0MCgYBKAABgE8ACC0NCActCAEIJwIJBAIAEAEJAScDCAQBACgIAgktDAkKLQ4HCicCCQQKLQgACi0MCAsAEAAJACUAAMFoLQQAAC0MCwcBKAABgFEACS0NCQgtCAEJJwIKBAIAEAEKAScDCQQBACgJAgotDAoLLQ4ICycCCgQLLQgACy0MCQwAEAAKACUAAMFoLQQAAC0MDAgBKAABgFMACi0NCgktCAEBJwIKBAIAEAEKAScDAQQBACgBAgotDAoLLQ4JCycCCgQLLQgACy0MAQwAEAAKACUAAMFoLQQAAC0MDAktDAIBLQwDAi0MBAMtDAUELQwGBS0MBwYtDAgHLQwJCCYtDQcBHAwFAgAAOAQCAy8MAAMAAi4EAAGAAygAgAQEAAklAAC+fy4IgAUAAwAoAwIGADgGBQgtDgIILQ4DBwEoAAWASgABLQwBBSMAAIdAKgEAAQVIpoXAksBooTwBAQImJQAAcvctCAEIJwIJBAMAEAEJAScDCAQBACgIAgktDAkKLQ4ECgAoCgIKLQ4GCi0IAQQnAgYEBAAQAQYBJwMEBAEAKAQCBi0MBgkuCoBIAAkAKAkCCS4KgEgACQAoCQIJLgqASAAJLQ0EBgAoBgIGLQ4GBC0IAQYnAgkEBQAQAQkBJwMGBAEAKAYCCS0MCQouCoBIAAoAKAoCCi4KgEgACgAoCgIKLgqASAAKACgKAgouCoBxAAotDQQJACgJAgktDgkELQ0GCQAoCQIJLQ4JBi0IAQkAAAECAS0OBAktCAEEAAABAgEtDgYELQgBBgAAAQIBLgqARgAGLQgBCgAAAQIBLgqARQAKLgiARgAHIwAAipgNKAAHgEwACyQCAAsAAI3uIwAAiq0tDQoOCygADoBFAA8kAgAPAACKyicCEAQAPAkBECcCDgQPLQgADy0MCRAtDAQRLQwGEi0MChMAEAAOACUAAL8fLQQAAC0NCQ4tDQQPLQ0GEC0ODgktDg8ELQ4QBi4KgEkACgEoAA+ASgAGLQ0GBAsoAAWAVwAGCygABIBIAAkkAgAGAACNqSMAAIs4CygABYBYAAYkAgAGAACNeSMAAItNCygABYBaAAYkAgAGAACNSSMAAItiCygABYBbAAYkAgAGAACNGSMAAIt3CygABYBcAAYkAgAGAACM6SMAAIuMCygABYBdAAYkAgAGAACMuSMAAIuhCygABYBeAAYkAgAGAACMiSMAAIu2CygABYBfAAYkAgAGAACMWSMAAIvLCygABYBkAAYkAgAGAACMKSMAAIvgCygABYBmAAYkAgAGAACL+ScCCgQAPAkBCgsoAAmARQAFJAIABQAAjA4lAADALS0MAQctDAIILQwDCy0MBAwuCIBnAA0jAACN2QsoAAmARQAFJAIABQAAjD4lAADALS0MAQctDAIILQwDCy0MBAwuCIBlAA0jAACN2QsoAAmARQAFJAIABQAAjG4lAADALS0MAQctDAIILQwDCy0MBAwuCIBgAA0jAACN2QsoAAmARQAFJAIABQAAjJ4lAADALS0MAQctDAIILQwDCy0MBAwuCIBhAA0jAACN2QsoAAmARQAFJAIABQAAjM4lAADALS0MAQctDAIILQwDCy0MBAwuCIBiAA0jAACN2QsoAAmARQAFJAIABQAAjP4lAADALS0MAQctDAIILQwDCy0MBAwuCIBjAA0jAACN2QsoAAmARQAFJAIABQAAjS4lAADALS0MAQctDAIILQwDCy0MBAwuCIBkAA0jAACN2QsoAAmARQAFJAIABQAAjV4lAADALS0MAQctDAIILQwDCy0MBAwuCIBmAA0jAACN2QsoAAmARQAFJAIABQAAjY4lAADALS0MAQctDAIILQwDCy0MBAwuCIBoAA0jAACN2QsoAAmARQAFJAIABQAAjb4lAADALS0MAQctDAIILQwDCy0MBAwuCIBpAA0jAACN2S0MBwEtDAgCLQwNBS0MCwMtDAwEJiQCAAsAAI37IwAAjjkAKAgCDAA4DAcNLQ0NCycCDAQNLQgADS0MCQ4tDAQPLQwGEC0MChEtDAsSABAADAAlAADAPy0EAAAjAACOOQEoAAeASgALLQwLByMAAIqYJQAAcvctCAEIJwIJBAMAEAEJAScDCAQBACgIAgktDAkKLQ4ECgAoCgIKLQ4GCi0IAQQnAgYEBAAQAQYBJwMEBAEAKAQCBi0MBgkuCoBIAAkAKAkCCS4KgEgACQAoCQIJLgqASAAJLQ0EBgAoBgIGLQ4GBC0IAQYnAgkEBQAQAQkBJwMGBAEAKAYCCS0MCQouCoBIAAoAKAoCCi4KgEgACgAoCgIKLgqASAAKACgKAgouCoBxAAotDQQJACgJAgktDgkELQ0GCQAoCQIJLQ4JBi0IAQkAAAECAS0OBAktCAEEAAABAgEtDgYELQgBBgAAAQIBLgqARgAGLQgBCgAAAQIBLgqARQAKLgiARgAHIwAAj10NKAAHgEwACyQCAAsAAJKzIwAAj3ItDQoOCygADoBFAA8kAgAPAACPjycCEAQAPAkBECcCDgQPLQgADy0MCRAtDAQRLQwGEi0MChMAEAAOACUAAL8fLQQAAC0NCQ4tDQQPLQ0GEC0ODgktDg8ELQ4QBi4KgEkACgEoAA+ASgAGLQ0GBAsoAAWAVwAGCygABIBIAAkkAgAGAACSbiMAAI/9CygABYBYAAYkAgAGAACSPiMAAJASCygABYBaAAYkAgAGAACSDiMAAJAnCygABYBbAAYkAgAGAACR3iMAAJA8CygABYBcAAYkAgAGAACRriMAAJBRCygABYBdAAYkAgAGAACRfiMAAJBmCygABYBeAAYkAgAGAACRTiMAAJB7CygABYBfAAYkAgAGAACRHiMAAJCQCygABYBkAAYkAgAGAACQ7iMAAJClCygABYBmAAYkAgAGAACQvicCCgQAPAkBCgsoAAmARQAFJAIABQAAkNMlAADALS0MAQctDAIILQwDCy0MBAwuCIBnAA0jAACSngsoAAmARQAFJAIABQAAkQMlAADALS0MAQctDAIILQwDCy0MBAwuCIBlAA0jAACSngsoAAmARQAFJAIABQAAkTMlAADALS0MAQctDAIILQwDCy0MBAwuCIBgAA0jAACSngsoAAmARQAFJAIABQAAkWMlAADALS0MAQctDAIILQwDCy0MBAwuCIBhAA0jAACSngsoAAmARQAFJAIABQAAkZMlAADALS0MAQctDAIILQwDCy0MBAwuCIBiAA0jAACSngsoAAmARQAFJAIABQAAkcMlAADALS0MAQctDAIILQwDCy0MBAwuCIBjAA0jAACSngsoAAmARQAFJAIABQAAkfMlAADALS0MAQctDAIILQwDCy0MBAwuCIBkAA0jAACSngsoAAmARQAFJAIABQAAkiMlAADALS0MAQctDAIILQwDCy0MBAwuCIBmAA0jAACSngsoAAmARQAFJAIABQAAklMlAADALS0MAQctDAIILQwDCy0MBAwuCIBoAA0jAACSngsoAAmARQAFJAIABQAAkoMlAADALS0MAQctDAIILQwDCy0MBAwuCIBpAA0jAACSni0MBwEtDAgCLQwNBS0MCwMtDAwEJiQCAAsAAJLAIwAAkv4AKAgCDAA4DAcNLQ0NCycCDAQNLQgADS0MCQ4tDAQPLQwGEC0MChEtDAsSABAADAAlAADAPy0EAAAjAACS/gEoAAeASgALLQwLByMAAI9dJQAAcvctCAEIJwIJBAMAEAEJAScDCAQBACgIAgktDAkKLQ4ECgAoCgIKLQ4GCi0IAQQnAgYEBAAQAQYBJwMEBAEAKAQCBi0MBgkuCoBIAAkAKAkCCS4KgEgACQAoCQIJLgqASAAJLQ0EBgAoBgIGLQ4GBC0IAQYnAgkEBQAQAQkBJwMGBAEAKAYCCS0MCQouCoBIAAoAKAoCCi4KgEgACgAoCgIKLgqASAAKACgKAgouCoBxAAotDQQJACgJAgktDgkELQ0GCQAoCQIJLQ4JBi0IAQkAAAECAS0OBAktCAEEAAABAgEtDgYELQgBBgAAAQIBLgqARgAGLQgBCgAAAQIBLgqARQAKLgiARgAHIwAAlCINKAAHgEwACyQCAAsAAJb5IwAAlDctDQoNCygADYBFAA4kAgAOAACUVCcCDwQAPAkBDycCDQQOLQgADi0MCQ8tDAQQLQwGES0MChIAEAANACUAAL8fLQQAAC0NCQ0tDQQOLQ0GDy0ODQktDg4ELQ4PBi4KgEkACgEoAA6ASgAGLQ0GBAsoAAWAWQAGCygABIBIAAkkAgAGAACWviMAAJTCCygABYBgAAYkAgAGAACWlCMAAJTXCygABYBhAAYkAgAGAACWaiMAAJTsCygABYBiAAYkAgAGAACWQCMAAJUBCygABYBjAAYkAgAGAACWFiMAAJUWCygABYBlAAYkAgAGAACV7CMAAJUrCygABYBnAAYkAgAGAACVwiMAAJVACygABYBoAAYkAgAGAACVmCMAAJVVCygABYBpAAYkAgAGAACVbicCCgQAPAkBCgsoAAmARQAFJAIABQAAlYMlAADALS0MAQctDAIILQwDCy0MBAwjAACW6AsoAAmARQAFJAIABQAAla0lAADALS0MAQctDAIILQwDCy0MBAwjAACW6AsoAAmARQAFJAIABQAAldclAADALS0MAQctDAIILQwDCy0MBAwjAACW6AsoAAmARQAFJAIABQAAlgElAADALS0MAQctDAIILQwDCy0MBAwjAACW6AsoAAmARQAFJAIABQAAlislAADALS0MAQctDAIILQwDCy0MBAwjAACW6AsoAAmARQAFJAIABQAAllUlAADALS0MAQctDAIILQwDCy0MBAwjAACW6AsoAAmARQAFJAIABQAAln8lAADALS0MAQctDAIILQwDCy0MBAwjAACW6AsoAAmARQAFJAIABQAAlqklAADALS0MAQctDAIILQwDCy0MBAwjAACW6AsoAAmARQAFJAIABQAAltMlAADALS0MAQctDAIILQwDCy0MBAwjAACW6C0MBwEtDAgCLQwLAy0MDAQmJAIACwAAlwYjAACXRAAoCAIMADgMBw0tDQ0LJwIMBA0tCAANLQwJDi0MBA8tDAYQLQwK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BYBhAAYkAgAGAACfxCMAAJ5GCygABYBiAAYkAgAGAACfmiMAAJ5bCygABYBjAAYkAgAGAACfcCMAAJ5wCygABYBlAAYkAgAGAACfRiMAAJ6FCygABYBnAAYkAgAGAACfHCMAAJ6aCygABYBoAAYkAgAGAACe8iMAAJ6vCygABYBpAAYkAgAGAACeyCcCCgQAPAkBCgsoAAmARQAFJAIABQAAnt0lAADALS0MAQctDAIILQwDCy0MBAwjAACgQgsoAAmARQAFJAIABQAAnwclAADALS0MAQctDAIILQwDCy0MBAwjAACgQgsoAAmARQAFJAIABQAAnzElAADALS0MAQctDAIILQwDCy0MBAwjAACgQgsoAAmARQAFJAIABQAAn1slAADALS0MAQctDAIILQwDCy0MBAwjAACgQgsoAAmARQAFJAIABQAAn4UlAADALS0MAQctDAIILQwDCy0MBAwjAACgQgsoAAmARQAFJAIABQAAn68lAADALS0MAQctDAIILQwDCy0MBAwjAACgQgsoAAmARQAFJAIABQAAn9klAADALS0MAQctDAIILQwDCy0MBAwjAACgQgsoAAmARQAFJAIABQAAoAMlAADALS0MAQctDAIILQwDCy0MBAwjAACgQgsoAAmARQAFJAIABQAAoC0lAADALS0MAQctDAIILQwDCy0MBAwjAACgQi0MBwEtDAgCLQwLAy0MDAQmJAIACwAAoGAjAACgngAoCAIMADgMBw0tDQ0LJwIMBA0tCAANLQwJDi0MBA8tDAYQLQwKES0MCxIAEAAMACUAAMA/LQQAACMAAKCeASgAB4BKAAstDAsHIwAAnXwlAABy9y8MAAQABQEoAASASwAGLwwABgAELQgBBicCBwQCABABBwEnAwYEAQAoBgIHLQwHCC0OBQgnAgcECC0IAAgtDAYJABAABwAlAADBaC0EAAAtDAkFLQgBBicCBwQCABABBwEnAwYEAQAoBgIHLQwHCC0OBAgnAgcECC0IAAgtDAYJABAABwAlAADBjS0EAAAtDAkELQwEAi0MBQEmKgEAAQVkYYioxs+UyzwBAQImKgEAAQVeMbOZA86a3zwBAQImKgEAAQUohpKwR9z9QzwBAQImJQAAcvcnAgcECC0IAAgtDAUJABAABwAlAACzYy0EAAAtDAkGASgABoBKAActDQcFMAwA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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "repay_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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BAAIgAMoAIAEBAABJQAAB08uCIAFAAouCIAGAAstDgILLQ0KAgAoAgICLQ4CCi0OCQYtDgoBASgABYBGAAItDAIFIwAABrcuAYADgAcBAIADAAKACy4BgAuACAEAgAsAAoALLgGAC4AJAQCACwACgAoBAIAIgASACw8AgAuACYAMCwCABwACgA0kAIAMAAAHniMAAAgOJACADQAAB6sjAAAHxC4AgAOABQEAgAUAAoAOLgKAC4AOIwAACAkoAIAPBAADAQCACYAPgA4uAAABgAUBAAABgA4AASgBgAUEAAEBAIAFAAKADi4CgAuADgEAgA4AAoAOLgKACYAOIwAACAkjAAAIYigAgA8EAAIFAIALgA+ADigAgBAEAAMBAIAOgBCADy4AAAGABQEAAAGADwABKAGABQQAAQEAgAUAAoAPLgKAC4APAQCADwACgA8uAoAOgA8jAAAIYigAgA0EAAMBAIAFgA2ADAsAgAOABYANJACADQAACMYBAIAKgAiADy4AgAqAEC4AgAyAEQsAgBCAD4ASJACAEgAACMYuAYAQgA4uAoAOgBEBAIAQAAKAEAEAgBEAAoARIwAACJUBAIAMgAiABiYuAYADgAcBAIADAAKACy4BgAuACAEAgAsAAoALLgGAC4AJAQCACwACgAoBAIAIgASACw8AgAuACYAMCwCABwACgA0kAIAMAAAJHiMAAAmOJACADQAACSsjAAAJRC4AgAOABQEAgAUAAoAOLgKAC4AOIwAACYkoAIAPBAADAQCACYAPgA4uAAABgAUBAAABgA4AASgBgAUEAAEBAIAFAAKADi4CgAuADgEAgA4AAoAOLgKACYAOIwAACYkjAAAJ4igAgA8EAAIFAIALgA+ADigAgBAEAAMBAIAOgBCADy4AAAGABQEAAAGADwABKAGABQQAAQEAgAUAAoAPLgKAC4APAQCADwACgA8uAoAOgA8jAAAJ4igAgA0EAAMBAIAFgA2ADAEAgAyABIANAwCACAACgA4BAIANgA6ADwEAgAqADoAQDQCAEIAKgA4kAIAOAAAKQi4BgBCAES4CgBGADwMAgBAAAoAQAwCADwACgA8jAAAKES4AgAyABiYqAQABBcVrxFoOEAACPAEBAiY=",
      "debug_symbols": "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",
      "brillig_names": [
        "repay_public"
      ]
    },
    {
      "name": "borrow_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "1ZzbTiM5EIbfJde5cB1dnldZrUYcwggJAeKw0grx7tvJ0J0saeiMyR/aN4gGV/1fVdtu2+32y+Jydf786+f17dXd4+LHXy+Lm7uLs6fru9vu6uV1uTh/uL65uf71c/fPi7T+QRYbg8f7s9v19ePT2cPT4gcJW1ouVreX698lrHNydX2z6q5Sel3ul0/MffGkPJQueaSwutNbYfWchsJuI4XDkr0VDmPaLfz3ckEux8EvpS9OVE6If6TsWwzZj4nsk+XcF3aRz/GLlT7W4qLv8bMfG5/4f/hrkdBTiJQxEY3S50oL5cHIBFwvymjMWrgMODqFE6J94dhpkh/gZB5wIu/hfJCdsAGH43OczwPmpHAFeAwEj4ECrcACV4DHIPAYJKMVlOEKjlYwgit8PQZ26vtU9px3niK6kXDCS+CjyPgossElIuEl8FEUfBRF8RIFLSFJ8BIBlyB8FJThEvz1DsSlH4C7bacdxX/7d6x/SWD/YH4F8yuY38D8Zlj/DuZ3BfsPrP/MYP/g+hng/g0/rhD8uEIKPApNCS+heAn46EgJHwXho2DBS8DHeCqMl4CP8VTxUSh8qqvgkYaCRxpqBevfBew/Y/1nMH8G8weD/YP5C4H9g9tXwbYvSwL2jx3JG329flKk/tUTBcWeAraGGjPYP/gOCLYFGHgtwcBrCWbg+2tgfvBagjm4/ji4B82K9R/g/IOfwFbA9b9g+zdPCvYP5icG+8fWH2f4y0Bn+DzPBR+F4KPQhJeAL9q54aOwE0QBX+7yIyzzT0rAl7s8C14CH0UwXgI7knTwXNzBc3EHz8UzeC6eE5ifwPyEHSllBvMzdqSUhcD+v96+grTfohwSZVfhjwpvcMqscFTnhTPdWIp8jkPENGy+J9btpnUb26ovSfsd5ZLMh8K/dz9myzMDcp4b0Nxu2QGbJE8LdMBayImBfGZAZW6VuswsQ5FmVocizayVxQHjxGMDUeo/6JGu9C7QyINPTIYHX4739AeMQudMHy3Tc9O556ZzL03nXnLL9Np07rXpem96+sfn8J2t0M40eZSeEuUev4s66R5/aZvfG8//d8y6jsmfpXH+xvMfp+fvSvT8bGWK38kHfpf3X8vHN8wYJQ35l6nev2OO4bSL1K0x7/GffoLJEVt+m+LPZee4C33/VXD5hvnocfmtcf7SNv8BX1bMm7/x/B/w1mXe/I33n9p4/rXx/Fvj+bfG8++Njx+88fGDN/78+ob543H5Y0b8a6DguQHleQFRSnpyIk3DKy+dnHMSBw2+Jfl+AKXxAL7hLdmRA4jGA+DW74Aco5+TGL69I028G8BGRNMpROIEIiZ4ERr/mJBUBzO17Qogu7+ZeZXZ+NR32szqzEqV2fi+vGmzqDKzuhswvjlu0mz8HBva7vMm32nn+mY1fvQKuQ7rxO5p30orrDjlCkImq7HiVGVVpSVVWlKnVWqsxt9JT1rlmrv8Qa2fsooaK7caq5yqrLzGKqqyEVVaVW2ZS1UOS6mw+uBcxEmrP66Hr93VP2cP12fnN6u3g+Svnm8vds6Vf/r3fvXuiPn7h7uL1eXzw2p92Pz2nPl1V9dVz6WQdDTrZAnpUjw2T/L1P5MvmWjTMa4vibtL7Rg6jv8A",
      "brillig_names": [
        "borrow_public"
      ]
    },
    {
      "name": "_deposit",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "951653053333916160": {
            "error_kind": "string",
            "string": "Deposit cap exceeded"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5235018679007078561": {
            "error_kind": "string",
            "string": "Invalid asset or market id"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16022896159229267359": {
            "error_kind": "string",
            "string": "Function _deposit can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_deposit"
      ]
    },
    {
      "name": "add_asset",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "oracle",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "loan_to_value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "is_borrowable",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "optimal_utilization_rate",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "under_optimal_slope",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "over_optimal_slope",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "deposit_cap",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "add_asset"
      ]
    },
    {
      "name": "update_accumulators",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "12348881442450494403": {
            "error_kind": "string",
            "string": "Function _compute_utilization_rate can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17134621154673181869": {
            "error_kind": "string",
            "string": "Function _compute_borrow_rate can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3bjuQ2j4DfZa7nQmdSeZUfiyCnPxhgkASTZIFFkHdf96Hs6pZkVdEqtWTyZjA9YzbJT7QoyTb5z6eff/nx71+///Lbf3//89N3//nn09fff/rhry+//7b89M+/nz/9+O3L169ffv3++p8/qac/TNTPAn/+8cNvTz//+dcP3/769B0AwudPv/z286fvUGtYfsV/v3z95dN3Wql//+fzIuUJUlYpklSgSGmSLk3yy2iSFEmXJfllabpiTkovlqtXMW0t+kTOOaIc0uS8IcoFmlxQRDlPkwOiPsiPA8ZgLnIYMaxy3v77Ob1cBXu5Wmu7KfExdzWGy8UR12uXO+TFIBzMILSjGTQaoTgaoTgYIafMaAaNRkgPFkNOQ3+D/MUgo8wbg9JrITr/ejHEuP1mgy5z9ZIeXi921m3XqsylxujLLzbG2v2LvbssDrzD60ufCOaXPELwDoJBCB4jaCUGjxKUGDxI0EkMHiXoheAxgl5i8ChBmQcPEgxGCB4kKHuSgwTBCsE6QdQXgmgSghKDBwmizINHCUourhMM67Xh7aVPBKMSggcJyp7kGEGvJAaPEpQYPEhQSwweJeiE4DGCRmLwKEGZBw8SlOckhwnKnuQgQSf74qME5WzmIEEv54PvCT5jkcDKYZEnGnkskgpzWEDW+VkssnjPYomCJYMFJUFnsaBgyWCJkqCzWCRBZ7AEJYcgWSySoLNYJEHnsMjzgCwWOeTPY5FoyWKRuSWHxbFdt/gNSwjvsbB9LRTc5VoDnn7xE0Pguva7h6EO6C7+gTIJQ66zVkOGKPfyYYZsd/0tGXJNtXcxhAgrDf0+LwPb84SWDLkePrRkKHn5MEPN9blDS4aytjnMkG1RjZYMZW1zmCHbF0ZbMpS1zXGGsrY5zNDJ2uY4Q1nbHGbItkhJS4aSU44zlJxymGGQOLyBYbSrf9ElDNkWK2nJsEle1oiXq43zFYbex4v5Pvrrksu53x1ivEC8uouefvOT+einNr9NZeCPMh/bHOB/nPn1c46olGo6f+zV1MUbvrbvbJAfzCAzGiEzGiE7GiHrRjMIBzPohvOFzgZBf4NOVUcPb9iqC8F9gkEIHiMYJAaPEpQYPEgQJAaPEvRC8BhBlBg8SlDmwYMEb3jlVgjuE5Q9yTGCUVkheKiuclQSgwcJapkHjxKUXHyshln8iDPkkxGUPclBglZi8ChBicGDBJ3E4FGCTggeI+glBo8SlHnwIEF5TnKYoOxJDhIE2RcfJShnMwcJopwPZooqRZTAymGRJxp5LJIKM1i0UrLQz3OR5XueSxQuOS5aknSeCwqXHBcjaTrPRfJ0louVw5A8F8nTeS6Sp7Nc5NFAnosc+Be4SLzkucj8kuUCbNcve6W+tWL7mmi7Wt9aK66LwHYFgheIXGeulhC13M7HIbI9A2gKkWvCbVf0aPFYEksDiFyPIppClOx8HKLj+jCiKURZ4hyHyLbeRlOIssQ5DpHt26RNIcoSpwFEWeIchwiyxGkAUZY4xyGyLWPSFKIklgYQJbEchxglEo8Wr9aGbUmTphCbZGdqFeeAZrM/X8UZwqUeBsBW1WY5sH+xv02R4o+z39i57W9zqP+B9uePPaJybrPfY83+9VZf1rvqjZaMRX592ARBbd4Gn7vY+Mv9u/zVXV/8bH/hO/557Pdz2+8n5+8n5x8m5x/c3PbD5Pxh8vgvHAzMY//k+bfwJew89sPU9tvCJnAe+3Fu+/Xc+cvqOLf9Zu78Ze3c6wc7+f7RurnXD9ZNnr/85Pz95PEPw9uParUfdWJ/HD3/2rCeglvI2P8R6x/Y7Ddq336jYjTrmX+86pdl4ssRolNhehe0mt8FN78LcXoXzPyjYOYfBTv/KNj584IzY7vgIF6eZju0OQdgcgc+ZHHd1AE/uQNh8IVF3YHpR2DwdFZ1AOz0mQDmT2Y4/yjg4OnsBhfi4AntFhem3y17Nf0o+PnPLLyefxT04IuLW1yYfHnhRz+xqDsw+OKi6oCdfJ/s7eT7ZD/7SYV3g6ezqgN++gN4P/pZxQ0ujH5acYsLg6ezW1yYfrfs5z+z8POfWfj5zyw8zj8KcfDFxS0uTL68CKOfWNQdmPwYPqjJ98lh9Pcr6g7MPgJm8HRWd2D6A/gw+lnFLS7MPwpu+qPf4KbfLYf5zyzC/GcWYf4zizD6Oxa3uDD9S4Nh9DOL6vJi9BOLqgM4+TF8wNn3yaO/X1F3YPIRADX5C4Og3OyZAEY/q7jBBT390S/o6fdpYKbfLcP8ZxYw/5kFzH9mAfOfWcDoZxbV3Dz6iUXdATe7A5Pv0SBMvkuG0d+uqDoAk++SoVRyQCu1OqCtvnbgWa5U6qsqR9QXFVHOEeWQJIfKEOVoXFAT9WmiPqOJckR9VhHlHFGOOO6OOA6OyMXfwuWqeu0q54lykSZXSlFVOaDJgSbKEbkAkQsSuSDS5CJRX6SNQ1SaKOeJcrRxiKWzGaO3SuXG6VQOaXKlU4iqXKDJlebPqpwjyhG5OOI4OKI+TxwHTxyHQByHQByH0jPAmhwQx6HQWKcqh8RxKK0jDW6l3q02iVzpoUpVjqTPqNIjhKqcI8ohTa60jqzKEbkYoj5D1Gc1UY6ozxHH3RHH3RHH3RPHwRO5hFu4mJDKeaJcpMkV58GaHNDkUBPliFyQyCUSuUQkyWlliXK0cdBaE+U8UY42Drr0/q2NVx12rk6HVjmkyZWe21TlAk2uNH9W5RxRjsjFE8fBE/UF4jgE4jgAcRyAOA6l/XRNDonjUKrDUpOLxHEorSOdi5tceHO/p6e6YasjG0x4U0c2vRiXw+jXi3HZfl5f/GSRKe3Udyx6kSvMeC6uh9nRu2QFYErlPatyRH2lmbIqV7hDg9KrXNApF2tpcqX6cMHhJpcZh9KJHugtg6D2+xEFgJcegbg8g1gvXo5PXrXEHlpKu922WkpzWmMtfXzpMi7YJcawiy+xy7jEHr4UG47cpeWpb8N6SGot+owe7KOndArRXE/oo8eoTnpcJz2xjx7byR/bJK6X08GtY6S6Su1PejLP5JeHk6+XO3SmsnrzcDEFPcL71Zt1TWaAp/O4zYMrmwoehLWPpQugah4ov3pgdOrBA8bAuXSsve2jJ+hOelrMYctqPKxdhPXyw/vlpQXdR00fb1D1UeP6qMEuaqLpo6ZLCDhl+qjp443WfdT08caoPmpcHzVdbk9n+wS07RMC7gEhkJ7DOef7qIld1DRZ29ygBrqoCbqPmj4hEPqEAPQJAcAuarCPN9gnoGOfgI59Ajp2CWivHhACTtW2XQ/sPYdr7z9nKrt+/dQLcDXEqfh+1+xVPBmdvc58y7ORswVDxV1k5a7hNbqG1+haXqNrgZW7To/vbvGDuRcPwuweeDW9B256DyZYkO17EKYfgzBBYt33ANqc5WncPDDGJ3srgC5qsI83GLqoiaqPGtdHDfZQE5Tpo6aPN7qPN7rL7RlMH29Ml9szWNVHjeujpk9Auz4h4B4QAjYmarzuo8b3URO7qAm2jxroogb6hAD0CQHoEwLo+qjp403sE9CxS0CD0n3U+D5qHhACPrbdoX3YQx3Q/mR0do8OQZ8tGPbdNY6Xu7xG1/IaXctrdJ3l5S6M7+7uQSp4M70HYXYPgpregwkWZPsewPRj0OQ72o/1oM1ZnlVm9cC+rSn7rKbRO5NVNX28iV28wUbb66qa0EWN7uNNo41bTU2jDZNdCy8sfwedqLG2j5o2943TalXjrmp/XNQ0WqlW1fTxxvfxptEXB1U1oYsa6ONNo8PpmppGh9PLedumBiBV08Ybr92qxhubqGmU1qpqsIeaqGwfNW22o97Cpiakakyb1b6PW6QFmxQWio0eVFfV9PHG9fGmUb6pqWmUb6pq+njTKN/U1DTKN36teLCoSZeDEUIXNdjmvgG1qQGVPAmLjV7zqqopRBr69VFUjG/rtGY2uPt1iKwqveXVWAv00FL61Kixli6+mC7jYrrEmO3ii+0yLq6LL6W3ru7SUq2iZFXptavmenwnPbGPnmA76YE+esB00tPJH2wS1x9XHWzxoMkM8HHVwayKDxiDtJrWoid00aOV66SnxRxmdFTb4UxMlpdWN1ks3aAGu6hpslx6qg29nWvH5CTYFmub36fGWL0eZzxVg0vV+C5qfB9vPHZR0yQnP6kJm5roUjXYRQ308Qb6eNMkm9XVNEk5N6jp4o1pknBuUBPbqNkOZ55KgSVqtOujpo83BrqoabJzfhsCLmnJtahp483yKGZXjTN91PTxxvsuaoLqo6bNfaNgXac9fYGdqAHXR00fb7CPN9H0UQM91FjVxRurVR81bWYBFeKmxmGixqg+amKPycbm39sx6qp8g9LKp3JIk3NEfY6oL/8CcF0u/zLLDXJEffnZ+Aa5WJLzm5xOwwsdUa4wDjqsbx+o5e5M5KIlytH0OUXTVygFfYNcoMkZoj4TaXK2MO5GX8klj6cXuVv0ZeScI8oR9XmivnxLuBvkgCYHRH352vs3yPmSnN3kfCoXHVGuOH5mkwvJfOaVI8oV5onl2HOVsz45rSzUxLxBjqjPEPVZTZQLNDlH1Fe6b2typfv2jRyqVC7S5AJRXyDqA6DJoSHKEfVFT5ILSpXk1kW7ciojV9K3vWmqnLaJnC7ocwY3OcBUztPkDFGfQZpcaV1elQOaXOl+936bdz3Wyri5rT2jM1cvU2S/+EEFlxyCCrchzn/378z17/bb9s/E3C/X3qydN68bUy4ryleHw8kc3h7KLE/iVeqw/4gRtmF1+OotwfzntGgvIwYYK0+8l/0/bh+X+avezq/PvIOH0d1d288CAib2B89quKAQneFqX5I2bl3kAk0Oifow0uRK6+iqHJLkQBXWDeC2PA5wnvkcFHyAwx92v0Bp3zKOu7vTG5TOPU46XKXPI5Vz62muevsefVbNw2pZGLys05e/6tR+GNx+t+5PwKVvwEHpeecw9tsYdu0fnX/LGl4W/Oi3y27pl8X+OLf9pW+eZrG/9DHVNPYPf7vv24/DT7cV+yfnHyeP/1ITtknsx8JH0BjD9l2iUrXVrVqfsWh9dQSqn47P06v99qD4anv0tJZIzY8rGYhx+80GXeZqu753sTw93K7NfbWwPHla3wxenr1fX/zMpfDVtnCReMlziVy56PXxqr3aTl645J+qC5dCgQP2XAqFHIVLEC45LoFtnq5wkXk3z0Xm3SyXwqdjwkXiJculcO7AnUvUdS4YMXDbH0VjhEuWi8RLlkv+LVIOXPbnFxuES46LU8Ily8UJlywXFC45Lp5tnq5wkXk3yyXIvJvn4oVLjgtIvOS5ROGScnGl0plXJequK9RFyKhoWKBusSe/X1NrzeQFfOxoTyFfK78WjFNY4aM9rN9jBFt5Gzr6eDE+hqvBvdhTyAdX9mjzxp4XKaRIxawuCOv7ocG9jyed/2o6rvdNhJDKeIJMvF8m/8VlRaYQj05t4x8TqUKJoJpUoEjlv9eqSpF0eZIuT9IVSLoCSReQxgtIupDkV6GMek0qUqQKTTVqUpQ7xeS/TtmdY0y++1M0l4k8ulSGMC8VCn3t67EE2/JnKxUZR5DB+xl4S5Ah6MlXXYjrtwhvFkUXGbhfBgh68vf5lT8ZGSTEW/6Zz75M/muyisz9udOq+3N0odpTRYaih+APYS1gzf3jY+39cWAL2Shsn/WGq5X863dvzuYLgtTFXFXsah26iUWSWCRpc4V6mPftx3Crl4Vv9mPPKgq1l5uqwIerMI/3wjzeC/t4LwrfsbVUUVqZt1QRHq6iUJB6wqMQo9eKZsba/Yu9u0xI/qok3+sMXagtxZxJFCbvmQSJk5SJxEnCBCROUiYoTN4zQYmTlInMJwmTwleTnJl4JevYlElgyQQvj9j81bO7CxPNM072mfCcT/aZsMw7Yb022OTU2zc5fTobE5br2H0mVuIkZSJxkjBxEicpExAm75l4iZOUicwnCROe57EVJrKOTZgAy/3OPhNkuS+uMGFwfvLsaGQw+C+OMrjzXxxlMO0/ORoUg7Xhi6MMFnzPjmrDxVEm6SUYzcVRJuklGC7pxTLYUr44yiW9OC7phcNJ4rOjHI4HXxzlMqKByz0K58mjfnM0JB+9wHlez4H1i0cDnn7xCxXHkYoOawV+DSp59QLOswFsScWwvIOqVE6z42pK5TRp5S4qENfPDFGnOeg8e7mmVE6z8WtJ5Ty7xKZUTnNi2ZLKeT6hbEpFZtscFcnMGSrneXGnKRXJzBkqIJk5R0Uyc4bKeV5qakpFZtscFZltM1SizLY5KjxjJdrVv+gSKniez01bUil8cKpxLc5qnH9D5UUM7xVLTfM+Xvzw0V9drWzm6rAW4YWrkF8NKrTorPkRaO4XymhWxGK+3mRVrPBhY02s0B2iJlYobl4TK7yNvC/mlQKSmPYkMRLJRQxJYtYMdZN45dRoBo01jXiFoxHC0QjFMJZB2gxGqFRJ++MMuj8RPNggGI0QjkYoDpY6jBmMkBktuZrRkmuh2vQHGjRacjWjJVdrBiNkR0uudrTkasNohEZLrna05Or0YITcaMnVjZZcS7VsP86g0ZKrGy25+vO8jbPbzdh7f5rvB2uOchnRcJoHs7sN+BZHT/N+cs3R07zYVHEUTvO1Wc3R03xtVnEUz5NeKo5ymYzOUzS84mih39IJHWUyoicq81Jx1LZYAu71NvJtijdUVMSHq3CP98I93gv/eC88PlxFkw/TKyrg4SqAQT2ezNnLTq+EhYn01EiY8KwJWWEicZIw4VA+8m4mEicpE+nl9J4JKImThAnTHj37THj2ctplwqGu5N1MWPaP2OvltJzY84yTfSbSGy5h4qQGfsrECZOEifTUSJjw7JleYSJxkjCRHj0ZJtLLKWHCs2d6hYnMJwkTnuex+0x4nsdWmLDc7+wyQcVyX1xhwqPG+rIR5tGUZXGUR5ud5UCDRxe3xVHHxVEebXY8cugY/uIol/TCpM3O4iiX9HKeMsc1R3l0cVsc5ZJeApf0wuEk8dlRDseDL45yGVFkco/G87TC2u355eN5Xs9p1/NroSIdi5KORT6eZwPYkopjeQdVqfCsM1yhIl1o0krdTzVWhEqGinShyVA5zy6xKZXTnFi2pHKeTyibUpHZNkNFutBkqUis5KhIZs5QiZKZc1QkMydUgjrPS01Nqchsm6Mis22GipbZNkeFZ6zsdrcK6jyfm7akYindqxaxu1tspaZdVRgOaDY/8hWGIVy+hwTYviVejhpfDCI17wqK1LwraFLzrqBJLaeCJjXvCprUvCtoUvOuYEjNu4IhNe8KhkbSkJp3hdb9RQ5He+v+Ig0MwsEMAjeYQThaDMXBYsg2bsVw3CAzWAzZ0eYh6we77W0YLYZGm4ecGuy2d2qwGHKjzUPODXbbOz9aDI02Dzkc7baPg8WQH20e8maw297bwWLIjzYP+TDYbe9htBgabR4K5ylctds3aHH0PB0s9h09z9t8NUcdi34Hi6M8OliEcJ7X6GqO8miQFE7UL6DmKI8GSYujXCaj83xVVnOUR9+gEM7zLti+o6BOU0Gh4mjpicBqjtag3mx6Msb79esYCGpbZgafu9jixSBwxuxfvECGtZuOdipeX/5sf6GT1SPtj2GzX6cG4dxAXZOAgM1+o/ZNMipGs94o8apnkon4ahOOZ5O3A9o0IKcwIKcwIKdSy/UPtSl0tsnBOrk6tBmLSm83faBFfjiL4mgWRTecRaMxQmWHswgGsiizlHFq/SbbXf1qa1/ecUNtJrd/cv7w6H6di4rwcBVNGpRXVDzei/h4L+LDvWhTvaeiwj1eRXy4ivN8RdKqOdfChGdzrl0mhkGh0LuZSJwkTKzEScpE4iRhcp6aWQ2ZSJwkTLzMJykTlo2o9plwqB18NxOejbx3moeGCDzjZJ8Jz/lklwmyzDt7TZcWJtKcK2ESpTlXykTi5B0TOFG9o4ZMJE4SJlqaQqZMJE4SJuep2t+QCcvzk30mPM9jK0ykkXfCxLHcF1eY8Gi8BcrzaOqzOMqjTROowKOv4+Ioj76OoM7zdV/NUR59HRdHuaSXQiGGEzrKJb1ELunlPMXb9x3VHM4nXxxlkl40h5PEF0eZLAG14TKi52m+WXHUnSeP7jWZBc2zadt+k9mFCs+y/LstMkEzbU9WoXKeEilNqZxmx9WSynm2Z+1awyxUpBFXSsVII64sFWnElaMijbgyVKQRV5aKzLYZKuf5jLIpFYmVDBUrmTlHRTJzjopk5gyV87zU1JSKzLYZKl5m2xwVmW0zVALPWNltp7pQkda7GSpA6dYJ5v7mrKlpV81LfPRXV2ebl4QYLzSvQv5ikCW1fQVLalYKltT2FSyp7StYUtvXJUiAJEZqxArORZIYKJoYzUgiyahpYn6sm8QrO5hBerBpxLvRCPnRCPk4mEFxNEJxMELh/kTwYIPsaITcaIT8YKkj4GiERkuuMFpyBTsaodGSK4yWXAFHIzRacoXRkivawQjhaMkVR0uuCKMRGi254mjJtVTL9uMMGi25xsGSK6rzvI2z23wWlXZcHOUyooZHd8DFUR79HvFEdWZqjp7ma7OKoyfqVl9x9DzppeIol8noPEXDa47y6G2OJ6pnU3GUSRN3VE0aRO/1NsI2xRt2VWhlHq/i8V7ox3uhH++F0Y9X4R+uwqrHq3As673v9EpYmEhPjYQJz5qQFSYSJwkTDuUj72YicZIw4VCU8m4mEicJE6Y9evaZ8OzltMuEQ13Je5lElv0j9no5LUx4xsk+E+kN956JUVIDP2UiPTUSJlp6aqRMJE4SJjx7pleYSJwkTM5T6KMhE4mThMmJqsW2YyK9nBImPM9jK0xY7nf2mQQnTN4zAR411hdHGQz+i6M82uygOU+F6JqjPJqyoGHSZmdxlEcLD7SKSXqxTNrsLI4ySS/2PGWOa47y6OKGlsP55IujXNILh5PEF0eZLAGt4zKijss9ep5WWLs9v9Ce5/Wcdj2/FirSsSjpWIT2PBvAhlScYnkHVanwrDNcoSJdaNJK3QsVnrNthYp0oclS4ZmDKlTsaU4sm1LhmZlrVGS2zVCRLjRZKhIrGSrnqVzSlIpk5gyVIJk5R0Uyc46KzLYZKiCzbY6KzLYZKsgzVna7W6E7z+emTak4Qjsj9Pe32EpNu6owHNBsfuQrDEO4fA8JsH1LvBw1vhhEat6F3tHcJzXvQk9qOYWB1LwLA6l5FwZS8y4MpOZdixjNSCJJUvMubN1f5HC0t+4vctygxs27jhtkYTCD3Ggx5EeLocatGI4bhKPF0GjzEJrBbns0g8UQjjYPYRjstkcYLYZGm4eiGuy2j3qwGIqjzUPRDXbbRz9aDI02D0Uc7baPY8VQVIPNQ1HZsW77xaCxYiiqweahqM9TuGq3b9Di6Hk6WOw7ep63+WqO8uhgEfV53rmrOcqjQVLU53kzruao4+IojwZJUZ+nklTNUS6TkefRN2hxlMuIhtNUUNh31Jbq1qwP5Jdlf0ylgCJVelbp129rNJhUKhKkXOkJ875UobhsTar06HZtBGRUQsMVztGduew2l7+mugqfJNekPEkqUqQKT+EqUoHkVyBZWKi+5d06yh50IoWKJAUUqULtoZoUEqR84fyiJkXSVbi/fFyn1aBtImUUScpTpKwlSSFFypFoFFZVFSlPYlgo3Gi3N7CsT+4vX3gLuCaFFKnCW6Q1qUCRKswANSkSDSSRjyRdkUI+KEOSopAPukA+rIe+FnUqFShShffualJIkSps7mtSkSJVODivSHlKXg7ek6Qo2TyEu3X9u/z0vz98+/LDj19/+XORefrPv3/76a8vv//2+uNf//fH5X9+/Pbl69cvv37/x7fff/rl57+//fL9199/evq/T+r1j/9oiPhZo46LPc+Risp8RgVPPz7hW85w/OflD1g0L9r/Hw==",
      "brillig_names": [
        "update_accumulators"
      ]
    },
    {
      "name": "_borrow",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1602191554767750373": {
            "error_kind": "string",
            "string": "Function _borrow can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14687457983715723088": {
            "error_kind": "string",
            "string": "Asset is not borrowable"
          },
          "15333773746166717806": {
            "error_kind": "string",
            "string": "Insufficient collateral"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_borrow"
      ]
    },
    {
      "name": "_compute_total_collateral_value",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "4270187767586857285": {
            "error_kind": "string",
            "string": "Function _compute_total_collateral_value can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_compute_total_collateral_value"
      ]
    },
    {
      "name": "repay_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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Ul2WpLosqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rOem9pv3lvVsDTWeGnWRJCPuwZL4Ny+04y3SexS0cN1Y4fqxwwljhxLHCSUOFc9aL7xWOHiscM1Y4dqxwxrorp7Huymmsu3Ia666cxrorp6HuylYNdVe2aqi7slWt78ovj2K6xWMHi4cGi8cNFo8fLJ4wWDwf35vvw1LVMK3qhmXvSbfnitsWHrend64ATftg99N9ffDHxjrZn5hFu20ic7sj2sJne6X2DbCUPX5MfpvLPX4zePxObQJ4Z+1z/FZ4/CQ8fic8fi88/iA8/ig8/iQ7/vwrKYLiH339LcUvfP01wtdfI3z9NcLXXyN8/TXC118jfP01wtdfK3z9tcLXXyt8/bXC118rfP21wtdfK3z9tcLXXyt8/bXC118Svv6S8PWXhK+/JHz9JeHrLwlff0n4+kvC118Svv6S8PXXCV9/nfD11wlff53w9dcJX3+d8PXXCV9/nfD11wlff53w9dcLX3+98PXXC19/vfD11wtff73w9dcLX3+98PXXC19/vfD1Nwhff4Pw9TcIX3+D8PU3CF9/g/D1Nwhff4Pw9TcIX3+D8PU3Cl9/o/D1Nwpff6Pw9TcKX3+j8PU3Cl9/o/D1Nwpff6Pw9TcJX3+T8PU3CV9/k/D1Nwlff5Pw9TcJX3+T8PU3CV9/k+z1l5Ts9ZeU7PWXlOz1l5Ts9ZeU7PWXlOz1l5Ts9ZeU7PWXlOz1l5Tw9VcLX3+H3/+qFL/w9Vf4/lckfP8rEr7/FQnf/4qE739Fwve/IuH7X5Hw/a9I+P5XJHz/KxK+/xUJ3/+KhO9/RcL3vyLh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",
      "brillig_names": [
        "discover_new_messages",
        "decompose_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_position",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "position::Position",
            "fields": [
              {
                "name": "collateral",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "scaled_debt",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "debt",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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XIvuYNiTKillH9b8b8O+/0KwbrdHKGu4P9zo69Gu+K3edrds7fdjr9PxuqYTdE0n6ppO0jWdrGs6Rdd0qq7pNFXTeXZPQmo6us7KUddZOeo6K0ddZ+Wo66wcdZ2Vo66zctR1Vo6fPivnffON7WGz830+aVM2H6dsPl7ZfIKy+URl8/njc/N1WO4bVvqGHZ6TvKu3LTy8d+kEmssl3M40l3/n+8Y6h4+Y1XDbRCZsj5vwbMdbgW77BlhbuD9MflnLdf5N+fzTdhPg16+Rvs3/+J72RPN3k8/fTz7/MPn84+TzT5PPP08+/zL5/LVff8/mP/n1t0x+/S2TX3/L5NffMvn1t0x+/S2TX3/L5NffMvn1t0x+/S2TX3/r5NffOvn1t05+/a2TX3/r5NffOvn1t05+/a2TX3/r5NffOvn1t01+/W2TX3/b5NffNvn1t01+/W2TX3/b5NffNvn1t01+/W1zX3/LNvf1t2xzX3/LNvf1t2xzX3/LNvf1t2xzX3/LNvf1t2xzX3/LNvf1t2yTX3/d5NdfN/n1101+/XWTX3/d5NdfN/n1101+/XWTX3/d5NdfN/n1109+/fWTX3/95NdfP/n1109+/fWTX3/95NdfP/n1109+/fWTX3/D5NffMPn1N0x+/Q2TX3/D5NffMPn1N0x+/Q2TX3/D5NffMPn1N05+/Y2TX3/j5NffOPn1N05+/Y2TX3/j5NffOPn1N05+/Y2TX3/T5NffNPn1N01+/U2TX3/T5NffNPn1N01+/U2TX3/V7391Nv/Jr7+T739VJt//qky+/1WZfP+rMvn+V2Xy/a/K5Ptflcn3vyqT739VJt//qky+/1WZfP+rMvn+V2Xy/a/K5Ptflcn3vyqT739VJt//qky+/1WZfP+rMvn+V2Xy/a/K5Ptflcn3vyqT739VJt//qky+/1WZfP+rMvn+V2Xy/a/K5Ptflcn3vyqT739VJt//qky+/1WZfP+rMvn+V2Xy/a/K5Ptflcn3v6qT739VJ9//qk6+/1WdfP+rus19/a2T739VJ9//qk6+/1WdfP+rOvn+V3Xy/a/q5Ptf1cn3v6qT739VJ9//qk6+/1WdfP+rOvn+V3Xy/a/q5Ptf1cn3v6qT739VJ9//qk6+/1WdfP+rOvn+V3Xy/a/q5Ptf1cn3v6qT739VJ9//qk6+/1WdfP+rOvn+V3Xy/a/q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",
      "brillig_names": [
        "get_position"
      ]
    },
    {
      "name": "get_total_deposited_assets",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+29CZBc13Ul+LM2oBIoVhIEuGEjCFLiKuZai1q2SwushRS1S9RmOasyi6QFEiQWkiAJ4hd2CCAIgJRIWbItL/Iiy7a8ymvL8nR32D0TjlHYPXZ093jGjvB4wjMOT8g97Ql32zH45L+ZJ0/e//7PyvsKSQAvAqif/9137n333Xfffcv/Pxe8loYu/MvF1yNwj5PQzMV/i/2lkiFW0aecOUM5cyDnUNcFCI/XWv6PbH3t7zjRRPnDhpUfJ76W+DPF2cZ40JmM5a+MA6YH/LLgj/jBL66KcX447MQPiO9E/BvtR8pIHtrRl+K81Rf+XRW0r58GvCh9GfgK9jjhGdvEguc2K12TIL/ULUpvD4NWavMtVWamKuWZqXK50SzWG1PTi7OV6WJlvlaZXZgvFSu18kxjul4pFpuV5kK12JiarTWa9dlaZXG+Pjsl2O9QsSvN+QtQtfrUzHxpsT61WJyvTs9U6ovT0416Y7banK4VG6WFqdJCubQ4M1Ov1eoLtdlSabE5W1ucaWHvCL3orCz43+8Fv1IT/HcC/oid/EXBf5cf/JaffLcf/Jb+3+NF/235743xg8Be9/d5kb3Uwn+vH91UBf9+P/gVwX8f4Oc84L/fD37Ldj7gB79l+x/0o/9Fwf9QjB8AdmmmUi5PV2ani7MzjWKp2lgoz1zw/vPV4kKxvlBuzlZLs4vVcrWy0FiYn6nO1EuLxcX6wuzizGvggv1hBbvYWyrxDcH+iBe9VFp2/9HQR7tWWmPWx3rXTSkNXbAf6B07LbXGqo8nYy/bbAT7Ewp2uV5ZKM4uFuu1mfp0c6Z2IcwoXriYn2kuTpXr8xcCjnKjVCo1qxf+Kzcb1dn5xlRpfqo5Xa7NX2DX0sknQx/2UloQ/E8Z40/Vi7PNqalpwf+0Mf78/NR0/YI+Bf8HjPErC1PNxcp0y499xhi/XqsuLtYqdcH/QWP8WqnYrJWnW7ZZN8afnS/WpmZmWvYzb4x/IV6uNGbr84K/YK2f+WZxoVGalTlTI8YXHlES3k1j3nGazRG/IOicPwXEP0+yWseTOeKH8jTgnszBRHeLYbesBSUPfQznDSv3hI+G9WlDrB8wxPqMIdYPGmLVDbHmDbGkX/vta9XWOLroBb8yI/gPesEvNgX/IR/4pXbs9TDgB3byt/B/CPBzHvA/60f/LfydfvTTmo89EuP7wH7UHrsVH+3yo/dWfPeYH/zWfOZxP/it+He3H/yW39njB39W8Pf6wW/Fv/v84Lfixyf84Lfi3yf94Lf2Wp7ygl9q6Wc/4Nv55XLLbz7tBb/Swn/GD37Ldz7rBb/awj/gB7+1HvScH/yWfz7oB7/ln0M/+K24askLfq01/z7kBX+qZT+H/eC31qGP+MFv2edRP/gt+zzmB79ln8f94LfihxN+8Fvxw0k/+K344XN+8Fvj1yk/+K3x/bQf/Nb4/rwf/JZ/O+MHv+XfXvCCP90a38/6wW/NX875wW/5z/N+8Fv+80U/+C3/+ZIf/Jb//Lwf/JZ/+4If/JZ/e9kPfsu/veIHv+V/vhjjB8vHrvCNNcFr55OOrX8Nb23QPrf0YHPv23buWvjs/fsemW/uxtVumeHItXYfU4S6ro369l2P7t1dX9j71kZjd3PPHkYYUZCDBNQ8oD5Uf/jRdzcYbXR5aB9t7t7z8K5HGW0sI5qctVoF9IYxa1HOnq0m+ZA3njE0nI82suyJIP88yWo8/y7liJ/Iw/rBPZFc0G5tLFtQ8rgN8wqfvMKnoORxDN0P1llDrGOGWGcMsSzreNoQ66Qh1vOGWMcNsfYbYlnq3rIPnRtQrEOGWJY2Yal7S/s6Yohl2bctbeKwIZalj37JEGtQx0eZm/iNrYr1CYW3JMlbA7wxpuLEkTjKHZU7vb6Ny3SS1kKZPfsfXbh/197mnsBRIEpyyJ/vD5ry+CGPtRnqEATpiv1KBsVyAI+yTRAmls0pWNpUjI0Zdb46QQbEkLbCQNhwElHJUg/kv1KTCM1JaJMI0c8aP/op5wgf5Vmj6IdtmNsuF7TtcRSwkH4N1BHp8VrK473/Nf5bCLr7kTz4kFPyhpV7ot9oov1nVDdsG7ZTP+1QLWW1U+GfD3z2m7adanahDWbjQXc7Wx7aytKumm+bUPIESxag0E6Rfi3UEenxWsrjvf8r/lsIum2a7XRCqQ/eQzv96/h6PKE+c/HvYl9pelobp7gfoJ4sD6Fn7QfCPx/4tLt2P9DaSfMnorurFFkLSh4v+lyl8LlK4VNQ8jgQ7QfrjCHWYUOso4ZY5wYU66Qh1vOGWMcNsfYbYp0yxLK0+0HUl2sc7BUrSpa2et4Q64QhlqWtWtbxkCHWoPbtlw2xnjbEkk1YjjMFP0rjQXffs567IT+pB95D/nmS1Vaedqyk6VWLaUU/k37005JnUpFnUtGPtGVByROsq+PfOGdA+kmoI9LjtZTHe7W4wQqEGSWeMxSU+uA9nDPck+usG7YN26nPdkB+IjfeQ/75wGe/KTrtQuv/40F3Oxvqp5ilXVFeacurlTzBkmMQaKdIX4A6Ij1eS3m893ayU7RpttOrlfrgPbTT7yE7xbZhO/XSDqXFzHYq/POBz37TtlPNLiYVPY4H3e1sqJ9ilnZFeaUt1yl5gnVN/BvtFOmvhjoiPV5Lebz3AbJTtGl+8GydUh+8h3Z6b4w7nlCfufh3sa9Uq2ptaYc/XZpQ6sn9DHVtZ9eVzP1M+OeDbrvw0c+uIXmS7EB0t16RtaDksY2sV/isV/gUlDye1/SDddQQa78h1mFDrFOGWIcMsU4aYp02xLK0iSOGWEuGWOeMsDT/3I9cZ43kitJ5QyzLvv2yIZalL7Tsj88bYlm24yuGWJY2Yal7q74dGNfR0ibOGGINqp+wlOtyiJmujGkXT/eW/fGYIZZlHT8/oHJZxhOWdeT9AZxb5uK/40F33zOcZzdzxE/qgfeQf55ktZWnPc/W9HqNolfR3QZF1oKSx/PsDQqfDQqfgpLHY0Y/WEcNsfYbYlnW8aQh1vOGWOcNsSx1/7Ih1pV27A3rFUMsS5s4Yoh1xhDL0n+dM8Sy1L2lrVrqflD91xFDLEv7Om2IZdmOlvZl2Ycs7eusIdYhQyzLOlraqmV/tKyjZTwxqO04qLHc5w2xBjXOsYwxr8QTl0YfsvQTlnJZ2Vd0zeuq/cj1opFcUbLUvWUMIGMtn3cT/Cj5XUMrZz5jy2toXs5gpayhaWfrxoNuOzTUTylLO6O80pbXKnmCdV38G8+EIf0GqCPS47WUx3s7YqUUCDNKfCbsWqU+eE/0G50J+774x3hCfebi38X+0gyvhwoP5I16MrS7TB+oQP75wKfdtfuB1k6afxHdXafIWgi6bYft4TqFz3UKnytYg4X1fiMslw+T/CiNK+Ws/S3yk3rgPeSfD7z6hZJLr5q/FP1c70c/rTPK1yvyXK/oR9ryBiVPsG6Mf+N4hPTXQx2RHq+lPN57mMajG4CW+8ANSn3wHo5HC0OddcO2YTv10w7Zn/kQ/vnAZ79p26lmF1r/Hw+629lQP8Us7YrySlveqOQJ1sb4N9op0t8AdUR6vJbyeO9JslO0abbTG5X64D2008fjH5NBcv/M0p8RV/PbrEMsx/3BS3uXmsWs/UH45wOf/bPdH27IqFfRz41e9NNYzGI/KK+05UYlT7A2xb+xPyD9jVBHpMdrKY/3TlB/wL7D/WGjUh+8h/3hEPltbBu2Uy/tUCwuZrVT4Z8PfPrJtp1qdqGNf+NBdzsbytPM0q4or7TlJiVPsDbHv9FOkX4j1BHp8VrK470vkJ2iTfOzepuU+uA9tNOzNN/l+szFv4t9pWZJa0s7/HpxXNG1HX55dlxpLzv8+RnB3+IHf0rwt3rBn2m1701e8Gst/Wzzg98Q/Jv92E9L/u1e8CsVwb/FC36zJf+tXvCrLfw3eMGfb/XfN3rBn23Z/21+9NNq39u94C/WBP8OP/ppyX+nH/lb/v9uwLdcixD8e7zgFyuijzcF7TSs1En4SyxyF9DnEv4KFucJrzxh+Yr7tLqh/DzvexPIgzpIwnpTj1jjSp6PNr3bUW/kP+GQlesRJX4HznJ1EqUjhlihIdZZIywttu1HrmcM5dpoJJcW//aDtdkQa5URVpT4o4f9yLXFSK7oeuuAYt1kiLXNEOtmQ6zthli3GGLdaoQVJf7YVT9yvcFQrhcM5XqjkVzR9W2GWFZjR3R9uyHWHYZYdxphRYnXTgcFS/aQ/a53VWf9rndV6n7Xu6oNv+tdtYrf9a7qtN/1ruqCxOrbgnbKBZ22heOb3byimvlZUOGfJ1lt5WnP724meVg/fH5nuyJrQcnjPrpd4bNd4VNQ8vgsbz9YLxliHTLEOmWIddIQ64gh1n5DrNOGWEcNsc4NKJalrR43xLLSvTZuD4qtWvbH84ZYg9ofXzTEsuxDg6r7E4ZYln7Ccqy19NGWurfU16Dal2VsYtmOlrq/HPzEy0ZY0TXPYfuR6zlDuTYbyWWJFaVnQzu5thjKZaX7KC0ZYlnaxE2BHdYqI6woWdlElEJDrAOGWJb2ZSmXla0Osi8sGMplaauW7WjpVwdVX5a2ymurg9K3Lf3XK4ZYlvHXMUMsyzWFo4ZYlnOFI4ZYEt/LOvZNkJeL//rdAyguew/gJj/yOPcAbgq69aqdhzWUp5GlnVFeactblDzBkr18PNuP9NuhjkiP11Ie7/1M3HAFwowSn+2/RakP3hP9Rmf7f3y4s27YNmynftoh+zdghX8+8NpvSi67uFnRo2YXUrag5HFMn7W9tLbns2/9YJ0xxDpsiHXUEOvcgGKdNMR63hDruCHWfkOsFwyxLPuQZTu+ZIh1yBDrvCGWZd+2tC/LPmTpVy8H3Z82xLL00eILteeoDOOPovackyF+65mDWx26QP58Fkfytb+CxXnCK09YxnUruermmrthHM5nezWsW3vE0p6N89Gmtzjqjfz9PgtYK/t9FrA25fdZwOqi2PwbQZ850t3tXtpyJvO7VIR/nmT11aduJ3lYPzwfukORtaDk8dm9OxQ+dyh8Ckoej9v9YL1kiHXIEOuUIdZJQ6wjhlj7DbFeMMQ6a4hlqftBtdXzhlhHDbEs7cvS55wxxLocdH/aEMuyjucGFMuybx83xLLSfXTN53IHxVYHNQawxLoybl8Zt3361Svj9pVx+8q4femN21Gy1Neg2uqLhliW+rL0OZa6P2GIZdmHLMftQfXRgxpPWNbRMva1bEdL3V8OfuJlI6zoms/n9IN1iyGW1Tp5dH2rEVaU+OxxP3IVDOV6zkiuKC0ZYoVGWNE1739d0b27jvzsRD9Ymw2xthhhRclSX7cZyWVpq1Gy7EODaveDWsdL3RdayhWlK2PH63/siNJBI6zo2vLMg5W+ouuthnIdMJTLaqyNkuX4aKmvQRw7ovSKIZblnO+YIZblns5RQyzL9Ykjhlj8fBueDcvFf7X3xUd85uLfxf5SI0f8pB54D/nnSVZjeUouvd6u6FV7372hPAs5wkd57lT0I215t5InWPKeTHy+DenvhDoiPV5Lebw3Mvra3wJhRomfb9PelY73RL/R823/MtJZN2wbtlM/7VDO/Hyb8M8HXvtNyWUXWv/X7ELKau3F437W9tKwThpinTPEOmyIdcYQ6yVDrKOGWGcHVK4jhlj7DbFeNsR62hDrFUMsS309b4hl2R/PG2JZ2r2lL7Rsx2OGWJY+x9ImThtiWer+0IDK9YIhlqVNWMYmluO2ZTsOqv+ytC/L/jioPtoSy9K+jhtiie4n4jyc3+Tiv56/AVfNET+pB95D/nmS1Vae9lxP0+udil5Fd1m+LxZdW36zyeo7XlE6Y4h12BDrqCHWuQHFOmmI9bwh1nFDrP2GWFbfRorSIUMsy/543hDL0r4s9XXKEMvSviz7kKVftbQJS786qH3bsj9a9qGXDLEs++PlYF+nDbEsYwAZayfjPIy3twedfHqN+bG80E0o5XLxX7/f8J3N/L4O4Z9XdOIj5n9TRr2K7u5RZC0oeXx25R6Fzz0Kn4KSx2NTP1gvGWIdMsQ6ZYh10hDriCHWfkOsFwyxzhpiWep+UG31vCHWUUMsS/uy9DlnDLEuB92fNsSyrOO5AcWy7NvHDbGsdB9d8/s6BsVWBzUGsMQa1HHbUveWMYClj7aMJwbVVq+M2xdvTLsSk/eGdSUmv3j2dSUuvHj2NYhxYZQs9TWotvqiIZalvix9jqXuTxhiWfYhy7FjUH30oI5plnW0jH0t29FS95eDn3jZCCu65jNO/cj1rKFctxjJlYvvWWFZ7g9Z6muroVxLRnJFKTTCiq75mf5BsIko8bPNg6B7y75t3R+t+lB0fasRVpQs++PlYF/8vqF+sDYbYm0xwoqSpb5uM5LL0hdGydJHD6rdD2odL/Wx1lKuKF2JTV7/Y0eUDhphWcYTUbLSV3RtGZMfMJTLaqyNkuX4aKmvQRw7ovSKIZblmsIxQyzLfaujhlinDLGOGGLx+4YKkJeL/8o5X/R1EZ+5+Hexr1TK/L4h4Z8PuscqO3na53xvDLr1WlD0KrrbqMhaUPJ4brxR4bNR4VNQ8njPtx+sM4ZYhw2xjhpinRtQrJOGWM8bYh03xNpviPWCIZZlH7Jsx5cMsQ4ZYp03xLLs25b2ZSmXZTtaymXpJyxtwrIdTxtiWfp78asSW3FMMBf/LvaVajWJTTCWyQWdvDE2MYzrZnLET/SE95B/nmS1lacd12nthvrhuG6TImtByeM23KTw2aTwKSh53Df7wfqcIZalXGeMsKLrNYENlnUd9xtinTbEOmeIddwQy1Jf5w2xvmCI9YIh1lFDLEvdnzTEOmKIZVnHlw2xnjbEknU+ji2iNBf/vTAcVmamKuWZqXK50SzWG1PTi7OV6WJlvlaZXZgvFSu18kxjul4pFpuV5kK12JiarTWa9dlaZXG+PjvtN3aozY4H3T7eMDYpCf5mP/hlwd/iB78i+Fv94FcF/xY/+DXBv9UP/pTgv8EP/rTfdx+UZgT/Hj/4rf5V9INfF/ySH/yG4Jf94DcFv+IHf1Hwq17wy0XBr/nBb/nPKT/4Lf857Qe/5T9n/OC3/OesH/yW/3yzH/yW//xXfvBb/vMtfvBb/vN7/OC3/Of3+sFv+c/v84M/L/hzfvAXBP+tfvBb/v9tfvBb/v/tfvBb/v8dXvArLf+/ww9+y/9/vx/8lv9/px/8lv9/lx/8lv98tx/8lv98jx/8ln+71w9+y7/d5we/5d/e6we/5d/u94Pf8m/v84Pf8m/v94Pf8m8f8IJfbfmfD/rBb/mfD/nBb/mfD/vBb8WfH/GD34o/P+oHv+U/P+YHv+U/H/CD34o/P+4Hv+WfP+EHv+WfP+kHv+WfP+UHv+WfP+0Hv+Wff8APfss/f8YPfss//6AX/For/qz7wW/5/3k/+C3/v+AHv+X/G37wW/6/6Qe/5f8X/eC3/P+DfvBb/v8hP/gt//9w0E5t7Epz/sJWS60+NTNfWqxPLRbnq9Mzlfri9HSj3pitNqdrxUZpYaq0UC4tzszUa7X6Qm22VFpsztYWZ1qy/5CK3U9q74t81odeSostv7AT8HNm8s+08B/xgl9s9atHvdhNW/5dXvTfaPn9xwJj2ykVi9F3Qc/Gm42TMZ9RqMc4tclY/Fu+eRqlz4ZtmlHIR/rvWfva3+j3SzG/CSojGEHQ3gcd89Jmpdkc8QsC/ZyT8M8ruvFxzmmM5GH98DmnVYqsBcqLEu97r1L4rFL4aFivGGLtN8R6wRDrqCHW84ZYRwyxThpiWdbxuCHWoNrXIUOss4ZY5w2xLO3LUl+nDLEs7cuyD50xxLK0CUu/KuchtfPYdmPzVF3GWozdJUkext4jlLcT6N8Rtuk4DdNvrNPqC/++sb6Ny3QsD8ZNnwX8pJghSqLH1ZBvGeMIft4PfkVsajzo1CnXKZ+gK8nX/goW5wmvfNCtdx/xoVY3lJ/7C8bvqIMkrPEescaVPB9tutpRb+Q/4ZBVqwef/9f8kRZ/C33eIRfSTyq8pazocC3kGeqw7NIh9kXhvxZoG835fQ/et+vBgNIw6UH0dj3RvSds64FtcDwBK6Df19O9YcDD5HfOeHHHAalTr+MAzlc/S3nL9XtRYt+AOhee0b3vOtYWsAzaUNa1BaGfH2/z+6/xTbaFKM3Ff4v9pSmee4t8yNfTGFrJOi4J/3zgMzZqj0uab9HiuF79M9tIP2MWt5GBbZT5hmdf3hD9cd9H3V6VoD9Omp8RuaM2+f0e/Aza+1WUh20wSXk4/hQoD58Puzq+ngy69ctxzdqgs458j20Ey6918Bnvk8+4wmdCKdevL9Z0w+1kwUcby7nNLfhoMRPbjwUftMU1xAdjQBmTor61dXW7DJaTMYzL7gjb+Uj/PhjDbo4xx4PufnAxfQnb7CTksZ3he17YNq6GPNQ5J80/iS4ifn/Zg3/C8e8qohXZOa6I0r1hmw7rMqKUj9LDYSeW0BdXt+X+p/Wdsml9ciXmVcgvCLLNb32tDbB+RR7WD8cReUVWrT/zPE+bt+UVPhqW5F2uY73Wl1ZqrOd27HUMxvKX2li/ivisMuSDertcx/qPGY31b4Gx/hOvw7Ge7WzQxnptLsKyjxJtlLKM9dinksb6h5SxXlt7H1Zk1/qS53XzctZYQPjng8BnbFJyjdHaXD+yVbGVPXt37a4/2Pxgs97xikLN/Dgfk/weoXv8m0O3VYTzSNiN40qTQbK7zQXdPLJsmbmWu7VlG1SxLN9qcmWZWnoOYzOb7qUWxnrWa10bcgOSGYcq1CcnzbWL3FG5f15m6LmGdIH6nYv/FvtLMxfRLWeeog2qW9bsRMoWArcNYR7yWaPw0bC4jS63KRraB0/RUM8+pmg8rvY6dcLyrimaj2Vf31O0HPHJGfLBciu17DtoU7SvGU3Rbocp2i+8DqdobGc4RWPbuBhTNByjeIom9DytihJP0aQuI0r5KPEUTeh/x7Ecq/XJQd3WzfmRx7mtq/VZbfzgbV0txs0F3X6j3+VYT/1zQRsbAqr/BPDudazHvtTLWI9HkiYoz3JbdlKpFx+H0h5fcB1Pw/JjDj6r++SzWuHj+xgM940hQz6ot0t9izdprP8rGuulXNaxXuivhbH+r2ms9/S4T8/za7ZZjCnZztAHsW1g/IA656T5J9FFr2M92sQaohXZR4k2SjzWC/8RpXyUeKwX+n9wLMdiP9KWY4dJ3ih5to3MsYDwz5OsvmKBUZKH9dPjcuwoFeP8QIFOW47N0e8hwnk07MZxpZyCo1Wdl0lzigyuYWA88NqEmZdJ5V4+0LvHnI08LZMaVvSK+mHdjSiyFpS8FdLrjDbkBiQzulm29YDqjwnl7nWZFNuUQ22RIfrLJ1403aFeI/q5+Hexz8Q2MALyaG05SvTrxjtpZIgcBtohBUcbTvhpZdQJDyfCN2qT0Q2dusoZ66oyP1tfqHfrKq2Omh1I2TVBdwh0PYRAbyC9asuwaHPMX1uGW0N6idIkyYBlB3Uqp4VR7KMu9qm41RvauEwnSWtnbQqOQ76McRyWY1kMy3lJ7U6wsVniPaHw1rYUhP4qhR7bi20M7UjKjivlDG2sOaHIKkmzFV7OK1CdMQ9thW1sHeTxVOoayEOdcNJsTPTUi43NZvAlWW1sDeB+LcHGvhds7L4MNqZtyV6uNsanetDG2FcNko3d58nGPpZgYx8AG/tMBhvTjmZcrjbm2noYZBv7jCcbk6cHpH2TtopZx8NBd5sIT6EvAJ9hhUbKjhL9gxDfvi3Wj7a8KfKMB93tbGd/F/epS6lTr09dYjuibIiJy5TYtkntsgfaZceGtszMbzJIrof8fljhx/1O8qMkbYz9zq6NS6Uc8ZO64T3knw+6fYSP9YlrSB7Wj7bktXNXvfH2+mN79u1s8lIPujuELxCc0CAtpgKIhPS8HFagcveF3eU4iSong+5uvY5kQvxh5R6v8q9TZBMzF918EYbXML6eCHQzjtJ40K1by6liVtMU/iv1oeurSZ4k3Yt+PHWV+VzQ3S2GFZ4irzaEc7+IPW2Hi0T6dVBHpMdrKY/3zsT2VAi6uzfvNmhdH++JfiM7PRHjTir14Wmc1m5XK7gFpTzrEEMO2f3gk5JYN225kvPGHXmu02G4lPJZKjehYL6620ZhlaYbtCteZtd0k9V17yAsLH8NYa1PwbqfsLD8esLakIL1XsLC8hsI69oUrF2EheWvJazrUrAeIywsfx1hXZ+C9ThhYfnrCeuGFKzdhIXlbyCsG1Ow9hAWlr+RsDamYO0lLCy/kbA2pWDtIywsv4mwNqdgPUFYWH4zYW1JwXqSsLD8FsLamoL1IGFheSk7oWBxHHAT3L8YcYDwz5OsvuKAm4JuvaJ+eHl6myJrQcljv7VN4bNN4aNhbTDEutYQ6zpDrOsNsW4wxLrREGujIdYmQ6zNhljst9LG6w+Gr/11jddSDm0X6YaBRhujESMpHsA5G97fmqE+eI91szWBX5J8qBuZb7rij0kqp8m8LoWPS2ah02LmnWFnHm6Dc3yLJ+E4Dsct9msoL6/Ui2NmbFeOmVFvGDPztvT/Gd/3uxxXLGI7JelKe6E3/w2C7vEzStyWuHQ6sgJ8ovRA6J+PVp+CIR/EekfYyWfll/iKzSz1QP6+l/hEFxscurjWC+9q5uXOa0kXGzzpQvxs2ryNt6+0uZk2luDy6IPNvfftevBt+z9cf5DfT8FTeBFnguiuod/rE8SaI7pr6beEf0nvycDm0eTg5Vemn0uhx+tVyv0oadNaXobVmg3vuZZhr3fw2dAnnw0KH+laGOJamrLg+/nGfft9tNpSAtZJ+E8oeurFtSOvfNDdRj7cgFY3VzvjFCPLksuNPWKNK3k+2vQGR72R/4RDVq0efJJQ/NypODaMwroN+U5s1zdR/LzLszKV1R6F/0p9EyXrO5m1UF3K8gMtUToYtuk4z3VCSMM6Y4j1oiHW84ZYRwyx9htiWdbRsh0t63jYEMuyjqcNsV4wxDpliHXUEOu8IdZJQyxLm7Dsj5Z9yNImLPV13BDrnCGWpe6PGWJZ6v6sIZalvix94SFDLEt9DaovtNSXpc+5HGImS5uwHLetdB9d84uqBsXuLXV/whDL0u4t62jpJyxjAEt9vWyIleW7ob1+a0lbl7pcvrVUIzqLby3V6N4w4GHCb/vwelgA9H7XYyuZn2wX/nmS1bj9W2tW2vEwbd1TdLdJkbWg5N0G15iHfDYpfApKHo/b/WCdNsR6wRDrlCHWUUOs84ZYJw2xLG3ieUOs/YZYljZhqa/jhliW+jpmiGWprxcNsSxt9Ygh1uXQjmcNsSz1ZTkOHTLEstTXoI5Dlvqy9PeW9mXpcyz7o6VNWMZMVrqPrnkNZlDs3lL3JwyxLO3eso6WfmJQ46+XDbFeibG0R4n4EQZtDrvRwQfLb8yApc2HhV579Mi11qM9eiRrD54ewSm72kN7fGk5az2itxLR8VoP+rbNCVgB/S7RvaS1Hj639C/xQpbo19N5NPWoOZ9XxDOjfC6y10dttceVNT4b+uSzQeHjV5e9v0WDH5vYCXn8iMMjgIXf6+Y0TL+xvlG/eFeGt7Fob475bALmqEI7QnlCW1jTluPD9FY/P2uFK9cmO8I2HSetTaS+kS4+1meb8PlXlFt7XDrLY9zaY/gFpfw1Dj6398nndoXPhFIul/BX+PA95qPJ7FpvXy4fxJI+7Hftvnf7Zz2j/fPZ3Ecgj98e9Sjk4T4QJ61viC6ivvGlDH3D737TyumQH3lDHWLf5qTpED9qlEWH2sd/uG9frdRD6/f8MZ5e+70mw6CNExsoD9v4WsrDNr6O8h4FPg+EnXm7oBw/xvYY5K2mvMchj9/4thvy+C1yeyAP25pT2nj2Rz2MZ2g3WcYz7RUqguv3kbJK5pfG8yNlvj8Wpz0i7PpY3HWKrAXKi9KBsE3HecPKvSEH1klDrHOGWIcNsc4YYr1kiHXUEOvsgMp1xBBrvyHWy4ZYTxtivWKIZamv5w2xLPvjeUMsS7u39IWW7XjMEMuyHS39l6W+XjDEOmSIZakvyz5kGU9Y6uuUIdYVv3rx/KqV7qNr3gcdFLu31P0JQyxLu7eso6WfOG6INajx6jOGWBKvSjmc4+Oepef3GJQFf5Mf/NZ7Elx7ucif5/SSr/0VLM7jc9vX+amb89y2yw5wbTzLK0I39oh1Md9ngrrm95losmr1uNZQJ/yVMu35EddXg7K2reuVrZ77WOtMwbUOPSH/fp4fKRPdjrCtB267GxOwAvpdpntJZwomg+42zSfIKXz5HtsKll/l4LO2Tz5rM/JZ1yefdRn5bOiTz4aMfK60Tyefi9k+4ofxnUX4ceS/WaPzxFfq47ua+MyE0G9Z28b82zXJdeQvFeE7gQrxtfhOP3sOve+TsS53KvXJKVjaHpPUKfLFvXwpBp/R4y/FCGbSl2JWQz7S/yOcZfndzTpmDjDxWUX+ihB+2W9YoWEZhP6/gQzyFSHGHEmo13gC5tVgi/+yRscMFEytXmupXixDnmQQ+qG17Xp9C961jjTyG59lfSTslG1C4RUk3GOfNpGQ5+KbVja6xq8IcR7bCusLyyfplG1F6NeATtlWVisyYH25XVkGplmbIMOkIgO+tnJh12P746/6BJT4qzv8OkluSm6C1QpOUhI1RNW7eq2OI79d5odD8bjCY22CjFh2LdSl0dzZ3NtMUNAQga1KYDYU6Gk80G1hLv5d7Cv5GTe08xXoezlpY4rUN/r7B5vbuEwnCZ/JvhJXLS+uYiwtXopSM2znI/0d4Ee+s1nHHErAlM/IuMY07WyS0GtzRlfMjfbI83SNN+qS/e51Pcqatt6QJ1m1uWhWWXeEKyvrqh5lXavwxrHngnN9+Inm7vt37W29RTtQxAjomo8h8TjF48V4gqg8FlxNv/m1yuze19PvCUU+LYkcmFiW4SA9SRcVXb0ZuuifJnTRINC7KH/YE6dQUhanX2IS+4GO9fw01QfpkafQPwN8tBBnP9Vb6N+mhDgFRSaRZ5zK2w67062PsD8bdCfJOwC8+Zjhc0D/9rBNx0kbWqVOkS6+0sN0DdsRZUNMHDKwbZPa5X5oF/6wJ/J7Okiuh/xepfBjXUp+lKSNn4P7dm1cq+eIn9QN7yH/fNCtWx/L/M+RPKwfzQ07Puz5LFwj/McJTmiQFtPHQSSkZ9fNzb5RKcdJVDlKMu+CWfUD8fVk0N31V5PcKMOwco+jrdWK/BqffJ988hn5vJ7rk+UDkGNKXfkUdpT4Y427IY8/ALlHqZfk7XVg7nNgPuHIe9KR95SSF9X5/55oy8jDi9bV+aOS2HZJ/ToJawdhYfnnCOtgChZ/VBLLHySsMAWLPyqJ5UPCWkrB4o9KYvklwjqUgsUflcTyhwjrcAoWf1QSyx8mrCMpWPxRSSx/hLCOpmDtISwsf5SwjqVg7SUsLH+MsI6nYPFHJbH8ccI6kYLFH5XE8icI62QKFn9UEsufJKzPpWA9SFhY/nOEdSoFiz/0huVPEdbpFKz7CAvLnyas5x1Y0bXsBE8q5Z8nrDMpWJsJC8tL2QkFKxf/lXDyBbhvF76VMj/lIvzzJKutPO1w8oWgW6+oH37K5awia0HJw7EI85DPWYWPhvWsIdZzhlgHDbFCQ6wlQ6xDhliHDbGOGGIdNcQ6Zoh13BDrhCHWSUOszxlinTLEOm2IxWOZK66PruUNLK64XsqhP+PlrmEqg/SIkTRvGA70+cCZDPXBe6ybMwn8kuRD3cgbafqdp0TXtxDWcucp0fWthLXceUp0/QbCwvLs2w+lYL2JsLB8L/OU6PoewlruPCW6LhJWP/OUp8JOrH7mKZ8krOXOU6LrEtVxufOU6LpMWMudp0TXFcJa7jwluq4S1nLnKdF1jbCWO0+JrqcIq595yjRhueYpL6RgzRAWln+BsM6mYM0SFpY/S1jnUrDeTFhY/hxhnU/B+leEheXPE9aLKVhvISws/yJhvZSC9T2EheVfIqzPp2B9L2Fh+c8T1hdSsL6PsLD8Fwjr5RSsOcLC8i8T1ispWG8lLCz/CmF9MQXrbYSF5b9IWD+cgvV2wsLyP0xYX0rBegdhYfkvEdaXU7B2EBaW/zJh/UgK1vcTFpb/EcL60RSsdxIWlv9RwvoxB1aUPhJ2YmH5HyOsr6RgfT9hYfmvENaPB+46vivoxMLyP05YP5GC9W7CwvI/QVg/6cCK0mLYiYXlf5KwfipFrveQXFj+pwjrqylY9xIWlv8qYf10CtZ9hIXlf5qwfiYF672EheV/hrB+NgXrfsLC8j9LWD+XgvU+wsLyP0dYX0vBej9hYfmvEdbPO7Ci1Aw7sbD8zxPW11Pk+gDJheW/Tli/kIL1QcLC8r9AWL+YgvUhwsLyv0hYv5SC9WHCwvK/RFjfSMH6CGFh+W8Q1i+nYH2UsLD8LxPWr6RgfYywsPyvENavpmA9QFhY/lcJ69dSsD5OWFj+1wjr11OwPkFYWP7XCes3UrA+SVhY/jcI65spWJ8iLCz/TcL6zRSsTxMWlv9NwvqtFKwfICws/1uE9dspWJ8hLCz/24T1OylYP0hYWP53COt3U7DqhIXlf5ewfi8Fa56wsPzvEda/TsFaICws/68J61spWA3CwvJSdkLBysV/ZZ/r9+G+3b5StZQjflIPvIf88ySrrTztfa7fD7r1ivrhfa5vK7IWlDxec/y2wufbCh8N66AhVmiItWSIdcgQ67Ah1hFDrKOGWMcMsY4bYp0wxDppiPU5Q6xThlinDbGeN8R6wRDrrCHWOUOs84ZYLxpivWSI9XlDrC8YYr1siPWKIdYXDbF+2BDrS4ZYXzbE+hFDrB81xPoxQ6yvGGL9uCHWTxhi/aQh1k8ZYn3VEOunDbF+xhDrZw2xfs4Q62uGWD9viPV1Q6xfMMT6RUOsXzLE+oYh1i8bYv2KIdavGmL9miHWrxti/YYh1jcNsX7TEOu3DLF+2xDrdwyxftcQ6/cMsXjNMe2cnLwWw3VOTsqFkMePZg5TGaRHjKRzeMOBfr7uWxnqg/dYN99K4JckH+pmMb62OPf3IGFh+SXCOpSC9RBhYflez/1tJCzt3N+kUo7PiR5w8ImS65zoAQefb/XJ51sKH+05xZ1hZ96YUlftazH87CN+LeZZytuj1IufU8Q+ws8pog3yc4poU/ycItoIP6eIbY7PKcrzuKKjv4/vj1PdpO/Oxb+LfSbt64qsR2y3XMLfIOjem4gS2we+UW1kBfhEib9atFL1edaQD2LJaw60/stv9+m1/2L5AwlY8mqDKMkzvthPR7l8/Hqt6PnjP9vciamdUR+De+9x1FXKSh/h8W0u/l3sL5UEf8kPfsU1PmKd2Keg7nqxL+SVJyxr3bnqhvKzHYYgT5Y4IuwRa1zJ89GmBx311sYQTVatHkl9E/lobxQS+iWHXEjvip9EhxjDGOqw7NIh9kXhv5y3IIveNhIdf1lZi0UZK6DfG+necOB+CzK26USCnMI3zY9jeY7DDpBc2l/hw/eYjyaz8MH3Wcg4Efn2rVe1y6Dd4Stz8DmqTZCP9HvXtzFvjjG157yS+koO+OG7MPhVS8Iv6VVLjyfI90YY9/iNlo8rdd7kkFkwR4JuvlGS936wDHfFMngeI9U4UnhNkrzcPlwXrU3Y7p5R9JCk2yhhnIJxDNKXe4xT0L45TkGZpKw25+e3rWp8XOPkVQqffuMDjY8mM8/dooT9/C3Uz8Ue0OaxrLwPYZTo56Gff5+jn/P5IY5p2PdxPxd+Sf2c7Ubo3+Ho51rMfF+YLLNgYj9HmbmfC/27qZ+HQWfd5+LfxT6T1s+FlzaOcT/vdRzT/LjGZ7JPPpMKH9/j5STxOWjIB7GkT6b1149Rf42z1P7K4zbS3w399RPUX9HeXe3JY8dBhS/3mSDItkbpejaZfVSUXGNHy0c5xg7XHCBKrjmua00Y6ZDGtW467OCB9oT3JWbFMe1xog2J9qCDNmk+F13L25f9zrlnytIXcO1XkuQdVmSWPHwm+0Nhm47TMP3GOkW28h83t3GZjuUJIe9wAibrNEr89nep85CCu0S4kjcadOvr3rAzT2gPxX0h6v9PXqXjsZ1ESdbp/M4rZyrcvpi4fVk/nLT2Fbmj9h3f0sZlOuaJbXiE8tBn8zv+cIwUjIj+NMUEg9aXltNfetFnCHmHKQ/1yXsRqE/BQH2OEsYvgb2fIXsXGh4voiT9R/qs6G9EKR8ljv2E/jyMPR/ZovN39bcg0P0C6oHfNXo40GXR6iy0Xyd7xD5mZ4/VkrTjUZIZeR/zxDtH/IJAX38V/hOKPCJ3Xskb6UPWWml6ujxVbdQW56dmarVmjvBFVr7Ha4fauzq0N6eLrk940XWlIT5gOGzjHwe9RmkE8o5R3ijkiYxRH3pgS6f8xz3Jn0X/yL+g0O8I23S9tGVB4cNztX6wDi4Ta13Q2Qe0sTCEcjwWLkGe+NfIH/2PCX45i68T38Z+H+vJfvAPydfh+GdoQ1UtHmVfd9QT76y+TvhPBMltm1fy+vF1jVq1VF2crc03FivNxvRiLugeE4aVe+zrNLtdp9B79hVFzdexPxuBvKOUh75OZNR8nZ9xsVLMon/kX1Do2ddlbcuCwod9XT9YB5eJJb4O4yCOU0Mox3HqklIf9HU8L/tj8kl+PumgrxGyT0V5o4Rz6CXQE+uXcfAexs1YhtdshP5/gbj9T67S5ZM63KvIp51dwnr9+VXJdEsKXbR/KWuCDzb3fuih+u5m40PNhd3NvcOBLh5XkavP06mA6KI0QveeoN+8fDNGODIEjwTpCU0CsbSmQ2weev8zTHkWyIU9Trzm4r/FPpM2deSh1s/2WjnztEL454Nuk/NxrENb2kT98PAY+tFPMfoaEW8ZROmhsFs3LIfYi7Z1h/rjvpBlm3JM4aN9fiGX8Ff48D3mo8ksv12uNsk1/ndwjX9H2wLa1orryFaWrXi8h/Q7KQ+36HIOfF5u+QfwF9+iJVcMqaQe8iWkEciz7M+RHIuwlMV2i+FaUj/TPhci9KFCr20JuY4WabaFtvTfHVuxrj7lY+tf43N1n3yuVvj47rtXE5+krbrVk+0ybPfaVl0V8pF+C2zVrYkxJwO373q1XmE7b4X6TLnXPqP5KVefSXt0Q3SobbF+NOzM0+yd9RqlRtgpw5gigzaeFpTyQpclTkH57NqolDlOEf4rFac8nlGvop8DfvRTdNnmAUU/fDSA2w59N/Z9bfqjbfeFIAdPF2+N/YHrSIGr72hb8K8e/5vsrJvvOIj71jDIWAMs+TyS72Mf6C+5PQxtvyr1XnLUm/lH/3AbSDtuy/Q852H8Q0Qv5fHD75ptsT3OxnYT6a8yqWMGgTsmZZ2MBfp4KXijRD8d88U4UmvjEPBnaVxFXfJRIykXpY6jdBnG+xBwl0h+of+ra9qY30dyaf5Hi6s4hu81rtL4MFbWI4JC//3QLvzB5VCRTzsKxraB9CHQiDyabpYCnbf0jSiJn+G+k2SX2DekLNvle6H+b6Ovh2L/C4mf6zi95LvsK0f/5P4Q3Fuv8Ne2RaJ/c/HvYp+JfdkI8DisyMPbNw9Qf5Pl22Glrppejyh8ccl4PfE9Qnyjdhylo6Qi25qgu59pbcLH0lnORyhf6H8A/OynaKxOOtLfmNR55wPdDpP6Ccq6BLz2h535Qj8P+no2YW6A8miyhkAnfRQ/wt5rH72fZBX6hxx91GVLWky3RDJrfZTlztH9rHYh9I+BXTzqiOHQLp4jXfORwjT/wLHDXPy72GfitsR+qvlLbsunqF7Sf4eVumpteljhi9tA7B8OE1/NP4QxDfa5RwEzyY5HFZmjxH1O6J919LnHlTprdrAEfHhuzjjYJmMJ9FwXoT+kxGvaGobEA37XMErquh/2ndGws97aZ4K12Ir1FCToSWKXQpDuk/EYlzZfWgzb+Uj/MviJ0+QnXGsSnrYjZ3PET3SD95D/Sq1J9Nq2BxT5G2EyvdbHtDWPaM2R13ALgCV88VPXS3RPW6fg9agQeOMY8SXyDdoaGNqdzOW0xyYaoc4TcZGnttbJfrKXNbk0HWj2n8U+NT6uvaVnDPlox2Fdc8Yke+V7rrUb9Mfsm3yskRwCObPMdw5DHbLEt9ojp4jP8yApP5KgO14jEfq/AN/7i9SvXHWMEs5LWSZt7srrABK/jCXIzHNXof9VJS5mveEYhGMcrwcI/W841gOOQPksflc7zoOxmsij9QmeN+IckNtcw+ajexrOEcLheibF2oKhHV2L/s3Fv4t9JsE7FuNhzHtckWeU6P8N2fFJ0qlLZ9G/EwpffE02x9oniK8Wa4tsOBfHduc24X1plpPnXEL/76E//yHFUktBO+F4+j8nrBXivOCYQ9ajiqzYZ3heIPR/7JgXoD8UeVBWLSaXPnkxYnL0W6Nhp340/+FaT8zqP7SjhUuUh2N+lleAhECTNMaMJdCzzQr9f3asgWtnMSL8v6B4KwQ6Pg/wDNTBNU5xW2HZiOdfTeq4OJagzh4MO+sr9H8Ca+Z/nXE97G8yrNdj2R3EW+hPAe+/dazX85q0FhvmlLws8ezjGfkcSOATZOSj1ccybtbW668lmXvdy8DyK3VG5FriEyp8PMfNmefUwj8fdPd7H3PqJZInzTdr6yUHHfSHFfpQocc5NfrwgPjinPow3dP6eUjy9DrHwvJ8zkvb/0zzc6sKujxJfm532M5H+s+An8vHmIN6ruy6Pvlcp/Dx7TOuo/occNSnV5vC8iv16ozriE/SOblNZJ/LfQXNHNjn1mXap+t1Fyv1mhQfazSXQ30u5T5SM+ojb4I+MkN9RDuP5nrdyXL1nJXPpdCeoSGfEPKyvi7onWQ3SzFNVrsR+mvBbt6TwW403SS9KhP5rpS9ubBcsWWo0LvWJZcUeu18s/Z6DrEFv48nZz8PLPzzJKutPO15graGc0jR3dqgvTZVb+4plWfe0VzYvf+xvdwYAlgIOpV8mACFPqDfXC4SaoRoDig8ooTvk0NDKlD5JbrP+FlkSqNNy9c64aGEegZBtk6I5ZM6YdL7vA5DPtJ/JhY46/u80Hh6eZ9XkgMZVuqQTyiHi/qYh3V+j6POQr/oqHNcPLHOO8LOOie9Lxd/M512eGZ1oC+wC4am4+uDTtl7tScsv1KD+/XEJ2nQ3U2DbpyV+ODPLsjvaAsYdPfRoJv1HX38Hr5e9azx8a1nfhdrGCTXJwy66xNmrE+YgIXttAtokg5njSiYUeIHo4X+SNyWnt/NrT7jL7y0593xwc1jRjb8/65rY54kGw6hvMuGkW45NpyVT1JfyQXL7ysrVR8XVqhg5UhmpH9dB7SlZjGLD0L+r/uA9n/LdSo5a0DL5VwBLdOyMxRD6jeg1WRKou01oMWVJA5oe10hxvK4C44dwtaQyl1PJuLuK3YmXtl7DuqgBWpJq/K5BHx2lPhyF013fBJK6H8agtmD8e6+1lY3JMgXBNnaCsuv1Gr+DcTHx2m/KPFTnmm2USW5koLYX6EAQPsAhLazzB83+CoEAL9OAYC2SuzaNdJW83kA1E7sagOUFngmnXJIs2vW0YiCGaWkD0B8hwJCP2+oqRUv3m50LfOgLPy1U0lhfJ1X8vp5EV1terFUnJqariyW6zPN2hSPXSIr38uyU71Nofe7oldVX7qJgX+URiBvifJGIQ93vPlFdH4Cpmoji/6Rf0GhT3qaWMOK0pAHLHl5XAgyc9zEJ56ihH6FnxAU+j91LARpQf0BpT6aP32OyuFYj76MfVWU5uK/aS28mJKEXxjjrVJk4SfkhPY/gV4Obemsi/aSOvEdww4egXIvFyTrjnkMK3gfDjvzwgyyaQt2iPFMgpwRhjbpvonqomHiPe4jNyny+Nz5Qp5p8cvf9rjz9WTYzkf6FyF++TuKX7TTOMJPWzxwfcBKystJT6ZhPyD03wV7T/uAFdaTZURMjF9cH7AS+n+k+GUJyvte0BJeWtw4Fuj6CIJs8wbXCc3HQVdyah394zvDoENXQv/7V7/2N8L+50JvmO9KwLwDMOX1VFkx352AuREwh+Nrze5vDDr59XqiFMvzW1f8vAGp/bHQPX7wWx+W3K3oAusk/Ps9QYu8VurJSK1urnbGj0BzX9KwdveINa7k+WhT11uqkP+EQ1atHhxXaHxuVHQi9HsdciG99GG0fSkrOsSPaxvqsOxqb/zYt/BfzsdCRW/XER1/LBR1vycBK6Df19G94UD/WGik92o8WGnjUiFBZpEhbVzC8mz/fnzm9KL2JK8k7UlelJHTMP1GuaP2Pr2+jct0iMF2zB8TdPncJAxt7TOt30cJF+9ls3/P3l27m+/f/fAT9b3NHU80H92r2O/qoLN+I/Sb3/SMsqJcE0THm7O76feT9PspRR5OrBNMEwpdUkrrH3fC9XL6B5Z3rStu75PPdoWPC+tOBcvlv7cr9JeL/95OdDK368d/b6d7Sf6bZcH5046wTcNr3kJ/Xxwv+41JZlsfSdtDsiPvvZ5454hfEOhxqfCfUOQRufNKXj/rueWZSqk0c2EruFmsFuuNoquP4T3uk/sU+rsVetH1k4EXXasfFtkHeo3SCOTtpbxRyBMZtfVcP35jNpP+kX9Boef1kqxtqWHtWCaWrOei75W+7bev9x5/8dOZS5DHB7lw3wLXnjlpcZvUN7Knd21o4zIdy6q9hcrvvHzldIi2yknTodS3Vx2irYXxtd++vHI6xD7KSdOh1DfS4cd60CHaWkh56JtE7kHT7wjlLQH9O8I2Hac0HX4jwxxMO0QYAj7raUzB4nnIw4o84qefCjrlx/aLEu9rYfmnCOuZFKwdhIXlszw5h1j3E5br/MLBFKz3EpbrSZkwBWsXYbnehriUgvUYYWH5JcI6lIL1OGFheT63dTgFazdhYfnDhHUkBWsPYWH5pDe0JGHtJSzX23GOpWDtIyztY23aWgfGOBPKPenrfj88V+r5g6zafMHHGremdy0uFN0dV2QtKHk4bmMe8jmu8NGwHjfEes4Qa58h1lOGWM8YYh0wxDpoiBUaYi0ZYh0yxDpsiHXEEOuoIdYeQyxZR9bWQfcSn17XQbF8lnVQzYeujf9F6dV187fXH9uzb2czoIRxa4TF6+VPJvAvKOUDKpuje1n2aTCm5TUK8fNjgb5XyGc6hP6b8fohvr1rXClvOO9oaA91SZI8HB943oFx6zvCzrxQqXNO4aPNSaS+kS7+YHMbl+kkaXsLaBM3wzXmCX++x7aO5YVO47O9Tz7bFT4urJsVLKHX5hSuvQXtHJnnL+G09ha0OZ42L1nO3oLobSPR8d6CNtdjrIB+b6R7aXsLIkvSA8C8tyD0f0V7C08Rz7n4d7GvNFNxPbfg95z6TOa9BeE/ocjDbwrn85Bzy5R1caZcXKgsNou1yvz8QrHh6mO9vknijQq93zN1M+reQgh6jdII5B2kvFHIExm1vYXQk/xZ9I/8Cwo9j9tZ29ISS/YW0PdK3/bb1wd3bwHPJPSyLo7jZRhfa+t4t8M15ok8fI/b/XZF1gmlXC7hr/Dhe8xHk1l7fg3PP/8DnQPV3qyKZZ8I2/lIvwTnn/8rnQPFWI7n6GyraBtR4n6Cb4XNMh4K/X+DWJnPP2vPVjwRJsssPLI+v9WqT6wjv+Oifv5ZeLnedMf6CIJ2m7iejdOewfM89qvPqEnS/A2focU1Bj57cBjy9lEerv0+EHbm4Zye5z24Jvok5Wlra5J3AvL4mVR88znaKCfNZ+JLWf6oB5+pfamH54SoX+0c0h1wjXkiK99je8PyexLKsR/xfOap5LlPt84Va89sYZ041tXW6bOML8hrpdbRtbq5zmrgOgOvI2tYz/WINa7k+WjTfY56az5Bk1WrB68Lav3sDkUnQn/QIRfSay8bWun1AE2HVusBorc7iY7PiqMNPpeAFdDvO+le0nqA5kcfT5BT+Kb50azPmGC8KMEF88z6vL/QPwTxYgWueU0OsUaDzrxRyHs2vvZ8vmpeW+8ISHfPAm+eAx1Q6pN1zMYzVF/p4dwFtjPKhpjYfk8DTdLa81vXtWX53c06Zi7Q5xAc04tNZH2mUeh3gAwc0wvNSEK9didgfhJs8V0Jth4omFq99lK9WIY9JIPQ3wf1knX9IOj2v2hDUXok7JRtn8IrSLjHY86+hDwX37Sy0fV+uOY8thXWV/RP9qeSdMq2IvQfcdiK9iyH60wpy8A0exNk+LgiQzQerYnzF3Y9tj9hO4u3r/gRQG5KboLHFZykJGqIeEh3YBz57TI/7fgrlt2bICOWxXdcNZo7m3uT9vuGCGwsgdlQoCfPz0WpZ/AlaecIedzAvjxKeU9AHvpeTtqYgs9TZd03O7vqteuVikmyxBpRaobtfKR/FPodf0FuD8ihYeLXo7ljudZGhD5tvib8RZda3O/irZ1rFPqDPcoaKvQYQ+8jWV0vyUyTdUe4srLu6VFW7RwD+uoLzujhJ5q779+1t4ndg8UI6Hqc7iUdS5DfexNEXUt0vIzMrxjh8YEf83tCkU9LIgcmlmU4SE/8vuLnoIv+aUIXDQL3cQrtmDGGlkWaWmhbKC5zzPJaDnRNiMGvDRH6Yw7XtBS4681dQjsuuwQ0vAQcQp6U1bb5cEk3SiOQZziVb2gf70MdjIbZ66vp57BCj8vA/Ng9LgOHlIf2Ijy16Ra+K/cfaFtkScF31c11hEhkTfq46oNhOx/pX3HYn3bMWXvfrNBrR5nxyBwvCaN+paxmf6Inz/bX1OwPdcD256qvph/tmDBuGUj7FogedaW96kh4av5PdI6vOtK2cXMJf0VWvufa2r437OQTGvIJIU+22dhfaqFcdF2NryXU5w/yzsW/i30m7j+4BHFUkafrI8q07HAc9KP59WrQSX9M4YtbTGPE9xjxxY/k8pJzlHA58NdJ1iOAzcvurjp/B5ZdfpPGaS3M5Fdj/g7IfnRLcnkeAzFW41cAhJDHx8GXlHoKfZTY3wr9t0HOE+BrooQ+D5fPozQCeYa2utjrmKuNCa4xN21MCOPrQtDdP3j6o02lQriXNP0ZU+gRj2PR/0lZftOmp0sk+zM9yp41hn0O6sGv23W1hybHUcDS6LH/Iv1/UHTCmNgXsI0PJ2D+OWD+WY+YuxIw/5MjntHGX4yR2Ha1Y/Q4Jos82uNUxykPZedx9xjwZ9rHiL/2+Feg8A0c8vKYnSZvGF+zz/4u+Oz/g4624HjjY8tUa8u7lPpkbcvnHPVnLBxf2V61PnRM0dffrdMxR3vE/H+UcU+LlXaGbd7fTRizo8RjdpTYNz2nyIWxgDa/4W3AGDL4/5T+etHmAKVmURsPY1avyQ982X9oY1Kvc1CeAyD9D4Wdea5vhYQKn6zjjZTF77u4vsUiPJccPKPrTUQv9UYfjzbzWchH+tXXxH+Dbh+v6Vc79uGyfZyXijzaY8E473q1fNjOiy8vir1iO7C9avpZ6kM/bK/afF+z1yXiEyp8lmOvu8leNR+ktWVI8mTtp6ynsQR6joGEfhPYclJchTK4HhXIur6gjXHHAp039k3UCX8AVOhvVvrmxVvTKZW0/oF65f7h0mGUeo0Red1Ge5xU6x9HKS+EvEMkw5IiQ9a+I2Wje+/M8MHWXvsry6jNlzVfL/QVh6/Xxl6Xr0/r02F8rfkOKXvx5uq6LaMOsvh613ynH1+/RHnaUeA0311z2B9vK2s279ouTNsbYd8YJsj/avmwnXcx2x51wG1vvTeSFJeyrlAniKX5BteaSr/xZpT4W7pp8SavTQr9B3uMN112+LqON5dhh4MWb2o+CNcJNzl8EMd8mv254rM0H8SfrwqVug0rcoWAqz0GGqW5+G+xz+Ta0/H8ndJajviJPvAe8s8rejSUp+Rq1xDu8SO6h/3IU422l7X9uIfCbt0k+R324bKXFqX3Ao7YqvY6CNwf2nVNJ67wQR+MZYUHx4H74BvHuwlTe60a+mCOf7XXqkW4qxxzR44/tDZ3xcuHgY9Gj2MT0j/tmB9qvjKEe73uxfD8WNufZ97aeQNtLBX6cKDmh+XSxd7z5zHLNXdEGzxCfJYUPtpjtNpjCFJW668HoF5a3+LXDIaAmzZeRkn2Sblfcp/Q6iSv7ON47VyP8doGuNdrPOJaU+I20ni7HnXW1pSw3ZLWlF7J4DOS1nVYp0L/JYdOtT7h0mlanxB5sqxTpel0R6jLmlWnQv8TGdbpsupU6L/q0KmmI5dOs65DufYqs+qUj0QLn6w6FfqvO3SK+0VZdCr0v3QRdYp1Pk7l0GdwfMz+Lp9Qbr0D80gCpua/kmLApLbUfBq35W852lKr15GM9TpqVK+jPdZL6L/lqV4HEup1oMd6pe078L6r0P/bDPXS1kmixGv/Qv+HGWO7+PKSXy8VnWlrFQcoTzuz6bKJ5cxv/mbytWvt/DvHajFkYuzFNiD0f5bRBlbmTLluA2G7Gl02gHaeZU6VtqbD7Yz0Mk/WbCAkPtorWbLG9/jKnL+a7KRDeXIJf4Un3xvKUDfuWziPCIFe5hGDcDYX5WG/+Xc0P9LO5h5WcHh8TTqbG5N3ja9/B/2Kz+Ymrb38Pcmqxf4HMtR5aH0b87sxphbz8PnZpJgnaYwJQZakMeYfM/oXkWvQxhhX3BIly/OzHCto40gI91z7MryHF0IejjFvmUyXPykOQnsfC9zxIPePsdhGtXgGz9Zp881aAuYasPvx9Z31x3aUc1kR3TXrbXhfBfXheYw2L3HtOZ1Q6LVXUU+SDFiW681tJfXW5pfc96Ucxs1Iz3Gzdg4yF6TPB44pdWQdjiXQ83xA6G9U7Kyg1JPXfjT5so7fGOP/fQb/KzxDhafLTpYU+hBoeI8c16+l7MXzxeXyxY71eG8S7YFf26/54qx75HGWupeJvnh17Is5Rr8HbJjP3QtN0iP2SXF/2eGvNL257NA1D9PsMIS8w45yIeCOK7zm4r/F4mJfSfhJv12lyJK0dvtm0OOhLbqsuS55+0uuucB4oPtdG97lYo74BUH3XAP55xVdGs4PSi5/rcVpfucrpUXc0w2BP+7pas+EoL1o5zRwnvAOilmET9I5mQrkI/17IF56ZwJmELj9XdoZsY9d1Ynra81G8y1HKM+1D4Rtwr4/7dkmPgsp9B8E3+B6dlDk8nv2fPGin63l87OuT9uEChbaQtLz9GOBe97F+/WfdsSHrvO9B3uUfUmRnfs59513UIyOPJ/LwLOf872bIB/pH1zBuCGMr6+c7w16Plu3RHloL1nP974l9t3ac9lZPm+orXm7xiy0782Qj/T7Hfa3pMiAfaDX+cFy378ievJsf+WLfcZY2jfL+1dcZzu1z9JE7bY1tj+fepyeKbZiWmlDsUlOI5CP9Kdim8xDPeTvSB9yLk7XS4uV+mK9Vm80qgt1fk18lKTNotdcRfZwbH1bZ6Ina51FSfBH/eC3nhsegboOK3US/mJLQ0CfS/gbBPqcRXjlCcu4biVX3VB+3q8ZIXnkOglrpEes8YS8OZt6t9p02FFv5p9Er/UBuT/mwEd67bXEY6SLVX50UXa1G47Hwn85r8GW35uIjj+LhfoeTcAK6Pcmujcc6K/BZr80EXTXW8p49inlrH5A+OcDr/2h5QdGSZ6kvouvM9y5q96I36zKLo+bDtWJcFxtbrrWsEj32ByGqJyEetoQynLmFAxNBfwF8JzCX3Mlwwl8g6Btruw+0rDketghSxJGjjAmHBhXus6VrqOkK11n+V1Haz/PkXI1a9eReysVfbqisACu2e1gWY4moyRvE8wpeb1Epr6wJoPu9mY703Qz7OCj2fqEUo5tzpN7zPzkHc94PPUB54xH06voblSRtUB5UWI70YaFUYXP6wUL/ZwWBsibNV0+kX1gmq3KLIF9qTZr4hmbzGC0mQXKO0r0f0OrF55mX+oH94SX51BqSvtgj6QJpd7c7qshj9t2nGTGPFydwnbhpI37oouI9ynayQoULM1GcpQ3ptRD8rjdo1QIum17lPLQtnl1HH3bKsrDviRvXssRZhC4d1Zc8VXUh6xXB4vlxsJUs3xhAXN6qlSebfSyOuga53KOumm+Q1uVQ7rRQI/3XPGH1s5p8Z61fqeqU6WZmfrMwtTC4mx1Yb4X/Wo2LvXVbJz9p/RxvL8K+LL/FPrJ+KSx+DD2B3PL1AUnzX+OUx1WQR20fnM/1UHob4/rENGu29CpM37qAfNQn+xPVpMeMA/l5nYQm0IbFiytDkJ/Qyx32qlnXG2M0kjYKedcfL/YX6pqO0Ui66vyh531XgN5wwo999O1Cv0aoBGdFYgefbgrRkKd806i6HBMoUc8jjVugTbinX+06zzJjnXncUTbmdBW3MdB5rdSn2WfMRf/LvaXpjm2wKTFFhx3YD/huCNPMmMe2kGvcYfoote4w8JPjASd/Aal3+IXX7jfYh8dVui536b1c37iCduS7VsbC3rpM1HiU7RoL9I22Gd8jPvlmZmp2fJ8sTrdWFhsVCtp4741/4X5qflqc35hqlSdqlSLy4rrRG84bmnx2SjR3wc+kU8aDzkwo8RfzBH69yljIcsZBEGmnT3Xcq82tnMcGqWVjiOn6zPzswuz1Xp1qrhwIVZfTntq9Ubd7ws76bUxURubeEz8lDImMiaejngy7MZkmbF9MP7jGFbofxBk+B/I96EeRH+ex82FHPELAn0tTfjnFX34WEvTdrm1tSTPaynzOcJHeVYp+tFiDR6vZfzQ4m7EHSJ6vJbyeO/R2LYKhBklXqtbrdQH74l+I9kfoic8sW1yCX8Fl+/xGiDqhn0Y+k88Ib6HPpiK/V1bNxf/wX3xKMzFnqC5mGb77NdzQfp+EPJL8lc8Xgn9M+Ar+COxPF5hPVlG5Dei8I0S+yuhDyl+99Tv1Tm38NLGu1yg6yMIutskCLrtThsftTVk0deawH2ixuUnXCebMO7T6AWP10I+5xjLVkOZYUUujmWE/nlHLDOu1Evr13LfFaujPNrcRMpqcxPRvee5yYI2N0Edjobp+lnVh354PwjjNl5v0E5Use9BPtr+ubYPin5rD9iGax2Q66n1hzGlnq7+oNWPbffHe4ztngi7MVmGrLGd0H8VZPh3jtgOx7Kf2eCWlf0Nzn2Q/hdhLPsajWXsc6Kk+UHei9DmtegHXesQ2j6Oq69oa1rcV5LWwDCeQvpfc9iEtvaJbcQxg9B/0+EjtfUGbf9X6NPWFXn8Qx+wNtB5Y31Qz09QfYT+9wZrLVf96irqlf2uS4dRYp1PKPSoS17bmYA8XivFvrOG8pAvrzumzW3YJ2vxBvoO7SwQ6kDkHFfqa9d2C6Uc8ZP64T3knw+6bd7HXDKrjYh+Jvzop+iywQlFPyLPVV7kKVbEVgoKb5E1/khwh19B+gnQIdLjtZTHe39Bc8pJKCf4BcqLEs9jMW9YuTd0kbAKChbqTdo06sd/QrrgL5hrfwWX77GM2J5i8y4fsVw+iCXxjdafon9z8e9iX6lSlnpcpdRDeKNd2fWd2nRWXyf884HXvlxy2TDqh+e6BUXWQtBtw8+Gbbo0+0Y+Gtb5AcU6aoh12hDrBUMsS32dNMR63hDruCHWfkMsyzqeMcSylOuwIZZlf7RsxyOGWJZ96JwhlmU7WtrqS4ZYlvZ11hDrC4ZYlnY/qD7Hso4vG2I9bYj1iiGWpb4sYxNL+xrUuNDS7gc1ljtkiHXKEOtyiOUG1e4tY5MrY1pvWIMayw2qL7SM5Sx9oWU7WuprUOOvZwyxBjX+OmaIZdm3LfuQpb4sxyHLPjSourf0X5brcpaxyaDal2XsO6gx5iCOHdE171lZjB3aXi+eURxX5LDc7xX8dZ7wRVdXO3SF/HnvV/K1v4LFecIrT1jGdSu56ubaI8b9cNRBEtbVPWKNK3k+2rTgqDfyn3DIqtVjwlAno4ZYfLZNO7Oh7asK/TqFXrOTSYW3lJW2vQbyDNu27Gpb9BHCfzlv6RO9fZTo5NnioaC7b1ydgBXQ74/SvWHAwzQZdNva6gQ5hS/fY1vB8hMkh/zmZ7+jJOdEtLM90b+5+HexrzRVdvlWv+PMVCWr7xb+K+W7XT4sSnw2IosPi9JzYZuuH78Tpc8bYr1giHXUEOuwIdZ5QyzLOh4xxNpviGVpE4cMsSxt4nOGWJeDTTxviHXGEGtQ+7al7i31dcwQy7KOpwyxLNvR0u6PG2JZ2v0JQyxLm3jZEMvSJq7EX5eGjz5iiLVkiHU5+MJXDLGsfE50zXPtfuR6MbTDsuxDlj7ackwb1LhwUMe0QZ1bWeresg9Z6svSR18ZO17/Y0eULOdWlr7wrCHWlTWFi9eHLHVvWccvGGIN6nzIUvcnDbGOGGINapxzxU9cvHjiip+4eLofVD+RJf7S3lcte+zaPr5grUvB2kFYWH4dYV2TgnU/YWnnGSYUrFz8V/bI18N967MXyE/qgfeQf55kNZantUe+PujWK+qH98g3KLIWlDw+08LtOWdSj+m61m52+OUG11t4YN2u9dJG1czvahX+eaUdfNjMtSQP64dt5jpF1gLlRSkM23ScN6zcG3JgnTHEOm+IddQQa78h1glDrEOGWOcMsSz1ZVlHK7k0PzsotnrWEMuyb1vaxPOGWFf81xX/5bOOlro/bIhlafcvGmJZ9u1B7Y+WPnpQx1rLdjxiiHU5jEOXQx0t5bL0q4M4bkfXPG8fFPuy1NfnDbFOGmJZxiaDOqZd6Y8Xr46DOm5fDvM0Sx/N5+guRbt/wRBrUNc6XjLE8uGj+RnJKM3Ff4t9pUpV1qJxTyoXdPL1tPfTzBE/0RHeQ/55ktVYHufeD+pniPTjZ5+j2MgRPspzraIfbV+B48jr49/4HnukvxbqiPR4LeXx3lR8Yekno2fPizFuD32gvLBYqtSa07XiVL1aa0xVyo3ydLFRrS2WSjOl8mx1plJZXKjONGbKlcXydHlhIuhud+4Dntq4mrUP8F6Wpz7p3Mtar7RRr3tZj4RtukEaf+VbRlnepe/HFirzy7UF3+/S12zB9S79rLZwMGzT9dt+ljG15VzylCGWZWxxxBDLMt60jPUHdY1uUPcFThtiWc4bXjTEuhz2/AZxDz5KV/aBL57ur+wDXzzdHzPEsrT7Qd3XvOInLp7uLev4BUMsy3hiUHX/siHWlT7UG9aSIdaVPnTxdG85dz9iiCXPk/AaUpTm4r/F/lJ1XOFrhN16Z+71/WM3+IZg32Av96Jg32iOXanJehd+wx6/af4HsbLEfjbGNLj2jt+yHoJ8pL/5hjbmv40xJwA3AIwojRNeLrBcFywXc8QvCPR1SuGfJ1lt5WmvUw6RPKwfXqccVmQtUF6UDoRtOs4bVu65sE4aYp0zxDpsiHXGEOslQ6yjhlhnB1SuI4ZY+w2xDg2oXOcNsSzt3lIuS92fMsSybEdL3R8zxLKs48uGWE8bYr1iiGWpr+cNsQa1b1uOHRJPyLPiGD+uDTrzMHZaQ/xGIA/xJS4do/y5+Hexv1QS/NV+8FvfgFil6BjrJPwlzhwF+lzCX8HiPOGVJyxr3bnqhvKz/awCefhbERrWqh6xxpU8H2065qg38p9wyKrVY4R0MqLwySk6kfurHXIh/aTCW8qKDschz1CHZZcOsS8K/+V8P0P0tpXo5L0bQ0G3Da5KwAro91a6Nwx4mHjOjT5yIuj2mcI38o/SPpsgn7+9sQl4DSv3uL9g+U0JWNpaQ5SaYTsf6W+L1xoi7O9s7sTcrMjnst0tCv1moBF5NN1I2QmFdy8+FOUqKDIMrxCfkRXis3qF+IyvEJ+xFeLD/n2LIZ8tQDNKfLYa8tkKNGuJz02GfG4CGo79tkEe+huR42ZFDhmftsN9w/Ep8xlb4Z8nWY3lacVa20ke1g+PLbcoshYoL0qPhm06zhtW7g0lYEm9rbDENiaDblu5mfhsU/hsc/C5WeEjdvUGqs9c/LvYVypPS7u8MehOkncb3Pti2JaD0zD9Rrkjn/7769u4TMc8Ua+3UR72sdspD9vqDsq7FfLujK8ng279Im/MkzryPW5HLP8GB5/tffLZrvCZUMr16ys13XA7WfBBvW0nPtsN+aDebiE+txjyQVu8lfhshHK437bnhnYZLIcxMJaVd+ONEv3XN7cxn4gxxZfcBnIZ+pJZqdvtQXeSvDuAN9vsnZDHdnYX5LFt3A15qHNOmn8SXUT+6S978E9vhDypk7SBlD8Ge56Hbugsj23Iz23g+Hkv5d2q5EX4Oza15UE9RDG72M04lGW7EfqvkK34GXemprWxRfQsvG/3xDtLf9bGFpRH5M4reSN9yLq4MFOsFKemGs2p6nytupgLuvvUsHKP5613KPTa9xFF13f60XVZ+sJw2MbHcTlKI5B3O+WNQp7IGPXVB7Z0yn+HJ/mz6B/5FxT6+6EOvbSlTyz0BxZYq5aJtS7oHpM4ZkKffg3x6TWWx/JC5znGntF8nSTNt6CMnNJi7H/uYQxDvd5OuhiUGKFAeeinrqY8jBE4rsMYAddXOaXFCH+0pY3LdFwPtKc7EjBl/MX5l4zro0T72xBPfJPiiW1Q/n1hZx7Gu8InwvgOxZrCB9f3JTaJ0s4Euf6YYgY/43a1wfYhPJD3nZ54Z40ZhL9mryJ3XsnrJ2aYLy1WmsX5+Wp5vlGbmprKEb7Iyvc4ZrhLodfe/Su6vtuPrue1mOEu0GuURiDvTsrDmEFk1GKGuzzJn0X/yL+g0H8W6tBLW8p4ij6U49htUO6Hws48nGfj/OI71Mf9xFvlee43mDQ/z+MD2iSPD2+CPB4f7oG8XscH0UWv4wP6SawTyjcC9zQfz/O3/x3GiL+gMQLHdOEd0T1wYyfdyvvX7Ovbwj8f+LTD9vq21u9QP7y+fZcia0HJw/cvJPneuxQ+GtaoIZbYxWTQbaN3EJ9e5wuaTxK7wr5p6E8WuX9jkrwi3Ot1fVvk7nV9G/VapDzsYyXKw7YqUx76vkp8PRl06xd5Y57Uke+55n1vcvC5s08+dyp8JpRyuYS/wofvMR9NN9o8pV8+qLekONGCjxZjsP1Y8EFbvJv44Bwc17fX3tgug+VwfRvL8jql0H8Z1rcnY0y/cWlvvkSz2RLksZ2VIY9towJ5qHNOmn/C+LeX9W301VgnlD1rbCL0m6mdPMUSxXVUL02nWr8e1BjHz3zaHeNo43ivMc51cM2+p9e4ZLshltj2ZBAkxiU5ykM+dzj4aPHS5RrjaD5kpWIcjlV7jT2w/KUW4/C5iDsM+aDeLtcY591GMc5piHHuo7HTz5hgG+OwnfmKcUQXvcY4uP/B/gnXSoQO10qyxkIfCF/7y7HQp29sY37yxmS5bgPe/+HKOg2ny3adRuxiMui2Vx77blP43Obgc4fC53KNYVCvKx3DIG/MkzqmxRZY/lKLYfhM6G2GfFBvl3oMg/M8jGFOZohhtHMpHMM8CzHM6dfhOg3b2etpnQb387PEJkL/wwO0TrNNqb/fMyrZYxw+A7jNjzwlbk+Rh/XDMc6diqya7+F1mqx7zRrWdkMsXqdB7G3EZ7vCZ7uDzzZFZr/nAtrfm7476E7aeNlrjCNy9xrjoF7ZF2Ifu4fyel3fmQy69dvvuh6Wv8vB57Y++dym8PE9Vq/UMxArFUtdrHWnpBjn31GMI+WyxjhCvxNinD9amXWannyJZrN43oXtDOMItg1tfSerf1ruOs02yGP/pD2bp62VaH3HcxyR+dtAHEds9yOPM47Qxsq1Qfu53webe9+/b37nwwv3NvfveeujjffXd+99uL7zrY3G7uaePVgbthquLVsL08h1QbmPGLen1ELeqqCtkGTZ5UGsHYTlOhVzZwrW/YSleS4ekbTe5jpRiPLclSLPe8NkefhU2t0pWLsIS5t5CtabUrAeIyws/yYqd08CH6RBb3iPwlvDZ7stpsj8eNgpM8rFs7NSCtZuwsLyJcIqp2DtISwsX6ZylQQ+SIOz4ArwySn3NHn2hsnyVAirmoK1j7CwfJWwailYTxAWlq9RuakEPkhTg/tTwCen3NPkeTJMlkfKZhnhUFbDESXzqXjhv1IjXJpeeaY8rchaUPJ4FjGt8JlW+GhYtxti3WmIdYch1l2GWG8yxLrHEKtoiFU2xCoZYlUMscQnajsR64hPrzsRWH6ldiLWEZ9tUA5nm9s3tsugDeJsE8vKWDRK9J+A2eYbYkxthcy148OrLr3qWeMjYw3asJ1vb7+pHMdwSZKH4xx+9ZOTNjsVuXtdPUO98piMfmaa8tBvzFAe9t3Z+Hoy6NYv+0QtDsR7LjsuO/jc0yefexQ+E0q5fvulphvf/Z9XRe8x5KPNH7Td8H75aHOLNH/2LvJnUi7Jn0ksO0r07wF/dm+MOR5094OL6UvYZrW4RPJmII9tYxbyUOecNP8kuuh19Qx9NfsnrU+MB922dzF214R/Pujucz7mDNqagDYGav5bymr96Qa45n47rNxz9c3thlgyl3TFDjnKQz6u3TUt1vAcH1R4Fx7TBNU5Sr3uri03PkC9VikP+1iN8rCtuN+iXxRfpI3bbC+9jttY/lKLD1Zqd+1yjQ+WeowPeHdN6N8M8cERig9wPWxQ4wO2M1/xgeii1/gA5/ZTgM/2hXTYhpqtB8q9nILDfa6YwD9KHwtf+6utra8nHtpYjvfYvtcr8rr6q9+x7LU3uiM/qQfeQ/55RSc+YqRyRr1qtlUmnWt2wDaCfCoKHw2L/aBrXbzoR1+ZY1zhv1Lr4lq8uF7R60rYd1I73+OQx4+/b7/9P21/SOSJ3iwyFnTbkLYvxnLjPpLcS2ob5M372a69xbT9wB2ElVSHpDZCLN7P1nQwSnn/Ph7HIx1+Y2Mnzd0xzR8Aza/E19q4zH3a015X5j7Ne101P/I497pQP2izqwK37WDbJZ0DuFupK9vyXSkysS33euYAsdiWXWcO7knBYlvG8hwXoK/mk23aSXCegyL+q6fRNibj3+PALzrwyw78bUDHMSrO3yuUh3PPKuD/sQP/Dgf+XQ78uxV8xhS/geeFtlGe0H4nxohi5ONbdXkFI0p+33aV3afwm+O2+ZGn5VO081CoH9fTdPwmVMtTuNqbiiywZP/c7wnwSllb05CkrV+t1AlwbBfu76hnXr/CfsHrV3gmQcaJlTqZrfHp1160t7VNKOVyCX+FD9/L8pQnt5MFH+08JLe5BR/trCTbjwUf1wlwjFdxjeqfaI1KOwGuxbp8AvwOWKP6Z1qj8vP0lO0JcLYzjAnZNvo5AY5v8P7LPp9QiU4ny5NLDzb33tvc/9H6zocb9b0P73r0g83H9zX37B0hWO4+bOZ3JIiLOIFD3CgNUd52ypeXag4FesqybOFneMoejgj/lVq2SDvCzOHI3YqsBSXvRrjmrjSs3GOXg1i3GGLxx2m0jyblKA/5uF6Avl2R+XJ9uN/1AhDfD/ezvfR6BAvLX2oP96/UR3ku9Yf7t0E5DHuq9LEYfBl9lq05ob8Rwp7pGNPvh/BsH+5nO/P1cL/oop8H39g/4QeE5MX8knczlOOPLOFH0AQfPyCkHQeRj0xO0u/oWh4QGyW5PkX2gB+QNJxSN1w+wu+HPSqZH39I+jgbyp1X8vr5KEC5Ob8wVa8vVhYWiwv1xWaO8EVWvjcE/LGvI/1VCr3fB14rdekv+FEAfsxwBPLeQHmjkIcPovJHAfw8DFqpZ9E/8i8o9O+BOvTSlgWFD8eRWbHWBd3jKH/oGH0T90U/fiD73EX450lWY3lacxftA9IbFb1qU10pq8Xu/GKy7QofbY6kYW02xJKxRxsrNhIf7WPcmx18NioyD9LHm6K0Uh9IRb3yEg32MV5yw7biGAf7NC+lon7ZXnr1Q1je9YHULX3y2aLwmVDK5RL+Ch++5/Krm4mPr499s8/19bFv3hrcbshHW4tIm7ucSPjQZda5SyvegrnLKYpV+ePRc/HvYl+p9w/Bsc3icivbGc432TaSXrjDSfNPoot+5i7sn7Q+MajxwWY/8jjjA20M7DU+4Jd69TOmv9EQS+xiMuhubx5XNN1scfDR/OPlGh+gXpM+AIY+xTI+8DFua3y29clnm8LHd3ywUuP2NuKzzZAP6u1ixQdJH1D/dob4wPUBdaH/p01tzH9D8YGfMcE2PmA76/Xj6ln9k+ii1/gA53K3J2COKrSbKE9ovwPt9Y+0lonl41NfrbxNkHcT5WlzV23cQgzkgTaH/bwZdtZB6P88Bop0eWKLjjmUgCl2rK2T4Vw5SiOQZ2e/C6VI7kX4ACLq9NX6hp112gZ5wwo9r0VqcQf6ItFRlhhGW3vYCvdkrU3T503xvYuhT5Qxiz6Rvld9io5c6zy5oLvdtDjWpU+R8WLoE2XMok8tNs+RTpAe9XlTfF0IunV4K2FtVbCwv/Na8E3x/TGFnn0S0v8X8Dnf2twpn7beJnmbFGz0vTnCwHrklXpMUB6WjXD/4PpOXG1fwtU22usCb1N4aWcuBvXj6Dz+Z10D2EZ5d0Mex3NJZxY4abEBfjh99YY2LtPhNfIRXLYjtpmNioxaLHhbCm6vNiN6vFRshteU0GbYnl4PNrMN7rHNbFNk1NYX014zyjajHZ3HmJ1tRntB8uvpI0/9nqGQPHxsBXXCSbMZ3M/txWbSXqjvshn8MBOfp7k7BZdtRjuTpfUvsRntTJbnj2o0JxRZJbE9ae2b9aXSrg+juh6zQp1w0mxG9NSrzaS93pdtRltP046ea49ZaufyhF57LSrqQ+xNe8WqlB1XyhmeeahOKLJKkjx8PJLPUuKjnDzGaK9zlDx8xQKfm8JXLPDrbTFpNiN66tVmtFf9boN7Lj8jZbVXaqQ9mss2oz3enNVmpKxnmxmoV3NJ3psh7/VmM++iV0Sij+bXPBUz8hT6tMfM2f40e0X/7rI/fgWplMM1NpSfXzcn9PNxkBu1x3fia21NQvTkd02i2NTWJFCvo2FnvV06jFKvfV50Vgi6/XGJ8rTXRbrOqmqvPbWOjSReuFRiIx7nsn6MbFBjI5w/sc+6XZFR+zCL9ti+9nFPlx9D/bPNoF1IWb+vQawUJxRZJWltz2MZtj3bhdb22jyL7RD7PuqEk2YzoqdebUbzB1ltRspqHyy8JwW3V5uRee6lYjNZ/MXryWZw/Ydt5hZFRu1D3dZ+5lKzGZ6bX442s5Zs5o0KLu4DZXmeAvcmeR8C94X4Y8xYblDPIWyjPO1jkdp6M68rop2gTjhpNiN66tVmbiVcbJ8oufYhpGxkM3vidwDniVf0t69nfBqNZqlamp6daVarjdnaOsKPktjfGg/8q7X69EJ9ulSarZaa1VIq/0j/x9Z36nMEymDbTSj3BFfsf5TKzi2zHqzWHPELAv2sqPDPk6zG8rTOio6SPKwfPis6pshaUPKkDSaD5DbJUR7KMKLIUFDKj2TA0uqzNv4XpT17d+1uvr3+2J59O5sBJbYV7tNDCfxzSvnAgYVlfPSrhdrU/MKFzlVsll61x5Xu17XG/ExxulyfbSxMNSq1hZXm35yvzk7Pzy7Uio3ibGm20otfmQi6bSuX8DdKww7sgoL1SPjaX/FB2I8sfZDgryL5jPBLoqdRRU/Ce7WXui0uZvWvwj8fePX3Lf+6muRh/fCzruN+9NOMXtUotoc+a0zRDcuximTMe5JRWzMVmSRvBPJEjojmc1s7ZRzyJKPfPrrY0GIUPIv895vbfLFtcM0a7X4I8pH+v8CzSt+NryeDznEJ/dQayF+l5Mtvaa8hhRav+bfIznpFerHJsYS6jlFdhf6fYH3+bRt0TNQfyjWUgPnPypq/YOJZNFefF/o1Cj32MZFnMujum2uoHMo+HnQmvKe1T45oeQyWcQrLJf0eV3CSZFit4PA4yZjMU4v1eC41rPDBPoVj/rjC33B8qGljpSQt1s5RHtb942GbjpM2d5U6RfX9j7RfhXQsj9bXLGMjuT8K95kvx+NjRIvjOets1EDGgsJnjHBXOeTPEc6IUm4i0Puj9jervDlFXtd8eLl8EOsTYScfbOeOzxjScwnox4eVsk+F7Xykv21LG/MN8XXamMa+BOvwybB9j302x7HcJ3lfm8cupsFxHOnvjuuBYxf7B8SK7t1D+tRiBC3u4xjhfaDPMulTiwEmg27dsA2PEy+Mj2V8YR28GeSY3pLMS/Q64ahjdO8tW3Q6lAHpGEMbOwVD69dSblKRi/se+44xBw9tPNN4jFJev+2jjdsYa2gxjJaP4zny4XtDCn1a/JFPwNZwxxQczc+vprycksc+DOuLPoxjE21Ohr5R63dJbeeKvTXZs8RVYw7ZNf2hH7JeyynOFEvFhena4mKpMVWfr6at5cj9VWFnvV79C/dGoV5RWo30lDcOeSNhJ/98/HsE+CCWyDFK9PPQ1lEagzJSvqDwHyP+HXIr99DWGGtYuSf0UZt+MpbRxxpduTY7U5+dL5bKi+VyZWYqrV01PeHaQZRE19gWY0rdRon+h2DM2Qnjxau0Cr+I7hkHXS7h76sYyr2RsPOe1kZou0IvvPNht4yStwbyRonP2vg36guxRI5Ron+KbBftTcoXFP6riX+H3Mo9tt01Cv0ahT5qn8fJH2Hdrdf+XuVJ+HiPZXvGY79amJ1anK1U5kuV2UZztjS14mvv1cr8Ymnxwvp7ZbFYmSmt+N5DvVi+sJc4P18rNeuzs4srXv9SqbQ4VZ2fmVooX1jiW/G9j+ridH1qcbpYKzeqzXKjvpy9D5w749ztTIa5G5bldyMI/VfB356jmEeb02tx7hDlaXM6LQaWWF3qirFqy/8G3XGl5XpQlnEB+eeD7tjNx/6FtpaJsSDvX6zxI09V5FmryDOuyBPtd1wVdLcZyidYuHb13vC1v5p9cZw8llE3BaU8z+WwjXlffUiRwTUHdM1B1wTueSjPAbR+zGWTdIH9XuYMvMbwNej3384w19H6L/d77hOYh7bAZwc028K5I68BTSj0a4GG591oexMZsFY5eF+l0E84eKNcWJZ5J/UR196c5+cZatrzDLhngnFcUjsifRZdau1YIHrUndaPuT8i3zWUh/2P+zjaqdgv9hceo7E/4hhtHVfUp5uz1alKeaGyOFufKc6sdFwz35haKM5WSo16fbo4PTWznLiG1+6jpJ2TsB7LWE5trBf++UD313M28pTY54s8SeOZ6M61b6etMeaCbp/q8rMa1pAhFsd92B5sC37OE2SP+4R/PujWqQ9bGFL0qvUr3v/LBdnOOuWUvCxn/15PWNq+Vy7hr/Dhe8yH7R/5JM3R/obmaFIu6xxN6PdtbWP+LcVqWvtPKjJzzKXZGd5L0jPSjSvl5uK/xd5SlW/4PZdVrEvb4TxLEsc6rEtO2l6/yN3ruz4xllhDeTgOraU8HDMnKA99r8RQmo3wfL9XG8HyLlsc65OPtvbgu8+PEh/fZxpccdJy+Wj7Rdq5ln75oC2uJj5YDn3lxNZ2GSyHvhLLynoB75c2wVcW6GyinzOwxVlt/SqgemMMzjaLfobtDOdDbBs47+SzxZg0/yS66PVdn9qciPus6JfLauddPD//kTnmvxSe/4gSx1O9rpVpz5JYYLnGA14D63U80M7dep5LzvDYiknzB72+K1zk7jV+0NYsXX13uXGHtlbIMbI2r9XW1rTxdpWDz0iffFxn/3yNgysVp/Dc2sezM9o4tVLxUFL88E6KH7T9MCybtB/2EYgf3kPxg6cxoSdfotls1tiCbUNba83qn1rnW4Le4ge0CakTngfV1pW0cTEXdPtYXodCfq59pUGLD7l9tXmo1obcvtq+hOThWjrqhFNa7NjLM9ha/IB0fL4tp8io9XXNBrQ1I6HX9lZ5jzFK2p6XlB3U9QlX39bsgv0r2gXb4STkoU44pa2H9GIzmj/IajN49ljml9q5dLYPbQ1S21N1yajFxVl9Fu8has8WMW8c57R9dZ4nH4j1kfbuNNHTxdhrRL2OkkwuHUap1z4vOisEyf5Yi7d4fWNUwcS1YOu9uOnyQq1eqc0WF5q16frUdNpeXOt5iLBNZ9iOrfctSHsNB21/MBK2ZRL+2plfoWuNz35kLYqscs5R+lCU8Nyn1GWI6PmazxV/GcapKOGZyyzng7Uzlnj2VGTUzuOuCXvDWk1Yq/rAErm0c6erlimXhjVGWL2cpz4Tt03UJ/5/k+P67VcCBQA=",
      "debug_symbols": "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",
      "brillig_names": [
        "get_total_deposited_assets"
      ]
    },
    {
      "name": "_repay",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5235018679007078561": {
            "error_kind": "string",
            "string": "Invalid asset or market id"
          },
          "6787403583199288031": {
            "error_kind": "string",
            "string": "Insufficient balance"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13135008234568508716": {
            "error_kind": "string",
            "string": "Function _repay can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_repay"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+29CZRcx3Ul+BO1AJVAoZIASZAEuIGQuEu51uK1ZImSRYq0NkvW7qzKTIoWSIAASAEkAP5CFUAIxEpSpGTLm7wvsuVVXmTN6Fjj02O3Pe7RsdvubndPd8+Z6Z6Z9nSPZ3rsPu7jxif/y7x58/34PytfFJIE4hygfv6IuO/FixcvXiw/Ihd0Qi7+OxoMEATk2pte/TsR/14H8SMX/83Hv4uDhdIE0bXEny3OzU0o5TPkvzIRY+b84BcF35P8i+tjnM+HHXwsi9DdcPHfRnh+Mujoh6/yS/35LP9WR5lFd94aBu3QoVuqzE5XyrPT5XKjWaw3pmdac5WZYmWhVplbXCgVK7XybGOmXikWm5XmYrXYmJ6rNZr1uVqltVCfmxbst6nYlebCRahafXp2odSqT7eKC9WZ2Uq9NTPTqDfmqs2ZWrFRWpwuLZZLrdnZeq1WX6zNlUqt5lytNdvGvi/0IrOy4L/dC36lJvjvAPzRwLZNReG7/eC3bdo7/eC35X+/F/l3+H8gxg8Ce9m/ywvvpTb+g35kUxX8h/zgVwT/ewA/5wH/3X7w27rzHj/4bd1/rx/5twT/fTF+ANil2Uq5PFOZmynOzTaKpWpjsTx70fovVIuLxfpiuTlXLc21quVqZbGxuDBbna2XWsVWfXGuNfsquGC/X8Eu9hdK/EKwv9eLXCptvf9A6KNeK+0+64P9y6aUhi7Y39c/dlpo91UfSsZetdoI9ocV7HK9slicaxXrtdn6THO2dtHNKF58WJhttqbL9YWLDke5USqVmtWL/5WbjercQmO6tDDdnCnXFi6Sa8vkI6EPfSktCv5HjfGn68W55vT0jOB/zBh/YWF6pn5RnoL/cWP8yuJ0s1WZaduxTxjj12vVVqtWqQv+9xvj10rFZq0809bNujH+3EKxNj0729afBWP8i/5ypTFXXxD8RWv5LDSLi43S3GSM04jxhUYUhHbTmHYc5nJEL4jx+Z3QzxOv1v5kjughPw14J+MukV0r7OW1oMShjeG4EeWd0NGwPmaI9XFDrE8YYn2/IVbdEGvBEEvatd+2Vm33oy0v+JVZwX/YC36xKfif9IFf6vhejwB+YMd/G/8HAD/nAf9TfuTfxt/tRz7t8dijMb4P7Mf8yKbtg+3xg98ec+z1g9/2UR/3g9+2Dfv84Lfnzvf7wW/7qAf84Ld9vCf84Ld91Cf94DcE/9Ne8Ett+RwEfDvbWW7btkNe8Ctt/Kf84Lft29Ne8Ktt/MN+8NtzNkf84Lft81E/+G37/Iwf/LbvE3rBr7XHyEte8Kfb+nPMD357rnjZD35bP1f84Lf187gf/LZ+nvCD3/YfnvWD3/YfTvrBb/sPn/GD3+6/TvnBb/fvz/nBb/fvp/3gt+3bGT/4bft21gv+TLt/P+cHvz0He94Pftt+XvCD37afz/vBb9vPF/zgt+3ni37w2/bts37w2/btJT/4bfv2sh/8tv35XIwfrB67wi+ivULRPqFtW1/F23Tx3+YY++Hmge/avWfxUw898ehCcx/OSEsJg6B7plpGPhwi1C0d1LfueezAvvrigbc0Gvua+/czwjoFOUhAzQPqJ+uPPPbORhI/faJ9oLlv/yN7HmO00Yxosh9qDNIb+qzFyRhvnPhD2utJCja0Sw2t5lnKSD9PvBqPv0s5oif8sHxw3SKK26DwWlDiuA43KHQ2KHQKStxKaId1zhDruCHWGUMsyzI+Z4h10hDrtCHWCUOsg4ZYlrJfMcQ6P6RYS4ZYljqxYohlqV/LhliWbdtSJ44ZYlna6BcMsVYMsSz7Dhmb+PWtirOTCm0JEoffYqBPxYE9ceQ7wr9xaweX00nYBPT2H3ps8aE9B5r7A0eGKMhGfH4/bMJjhzCfoQxBkC7YUgbBsgOPvE0SJubNKVjaEIeVGWU+nsADYkhdoSNsOIioZCkH0l+rQYRmJLRBhMhnwo98yjnCR34mFPmwDnPdRf/kw6AxwML0+BEZpsdnyY/v/jL+Wwh625F8nJBT4kaUdyLfSObfpLJh3bCe+qmHaimrngr9fOCz3XT0VNMLrTObCHrr2XJjVZZ61WzbRiVOsDbFv1FPMX0eyojp8Vny47v/Pf5bCHp1mvV0o1IefId6+q/j54mE8szHv4sDhZkZrZ/idoBystwonrUdCP184FPvOu1AqyfNnojsNim8FpQ4nvTZpNDZpNApKHHsiA6CdcYQ65gh1ooh1vkhxTppiHXaEOuEIdZBQ6xThliWej+M8nL1g/1iRcFSVy8YYj1riGWpq5ZlXDLEGta2/ZIh1iFDLFmEZT9T8KMwEfS2PeuxG9KTcuA7pJ8nXm356fhKmlw1n1bkM+lHPm1+JhV+JhX5SF1uVuIEayr+jWMGTD8JZcT0+Cz58Z0MAAuEGQUeM2xWyoPvcMxwd667bFg3rKc+6wHpCd/4DunnA5/tpujUC639TwS99Wwon2KWekV+pS6nlDjBko+gUE8x/WYoI6bHZ8mP776T9BR1mvV0SikPvkM9nSM9xbphPfVSD6VWZj0V+vnAZ7vp6KmmF5OKHCeC3no2lE8xS70iv1KXBSVOsK6Kf6OeYvopKCOmx2fJj+8eJD1FneaPwwpKefAd6uk7YtyJhPLMx7+LA4VaVatLO/yZ0qRSTm5nKGs7va5kbmdCPx/06oWPdnYV8ZOkByK7LQqvBSWOdWSLQmeLQqegxPG4ZhCsFUOsg4ZYxwyxThliLRlinTTEes4Qa8UQa9kQKzTEOm+EpdnnQfg6Z8RXFC4YYlm27ZcMsSxtoWV7PG2IZVmPLxtiWeqEpeyt2nZgXEZLnThjiDWsdsKSr8vBZ7rSp1062Vu2x+OGWJZlfHFI+bL0JyzLyOsDOLbMxX8ngt62ZzjObuaInpQD3yH9PPFqy09nnK3J9SpFriK7rQqvBSWOx9lbFTpbFToFJY77jEGwVgyxDhpiWZbxpCHWaUOsC4ZYlrJ/yRDrSj32h/WyIZalTiwbYp0xxFoxxDpviGUpe0tdtZT9sNovS11dMcR6zhDLsh4t9cuyDVnq1zlDrCVDLMsyrhhiWbZHyzJa+hPDWo/D6su9aIg1rH6OpY95xZ94fbQhSzthyZeVfkXPPK86CF/PG/EVBUvZW/oAKzEW73cT/Cj4nUMrZ95jy3NoXvZgpcyhaXvrJoJePTSUTylLPSO/UpdXK3GCdU38G/eEYfqtUEZMj8+SH9+9JRZKgTCjwHvCrlbKg+9EvtGesG+Nf0wklGc+/l0cLMzyfKjQQNooJ0O9y3SJBNLPBz71rtMOtHrS7IvI7hqF10LQqzusD9codK5R6FzBGi6sdxthuWyYxEdhQslnbW+RnpQD3yH9fODVLpRcctXspcjnWj/yae9Rvlbh51pFPlKX25Q4wbou/o39Eaa/FsqI6fFZ8uO7JvVH2yAtt4FtSnnwHfZHn1jXXTasG9ZTP/WQ/ZsPoZ8PfLabjp5qeqG1/4mgt54N5VPMUq/Ir9TldUqcYF0f/0Y9xfTboIyYHp8lP77bT3qKOs16ep1SHnyHevpo/GMqSG6fWdoz4mp2m2WI+bg9eKnvUrOYtT0I/Xzgs3122sO2jHIV+VznRT6NVhb9QX6lLq9X4gTrhvg3tgdMfx2UEdPjs+THdyvUHrDtcHu4XikPvsP2cJTsNtYN66mXeigWW1n1VOjnA592sqOnml5o/d9E0FvPhvw0s9Qr8it1eYMSJ1jb49+op5j+eigjpsdnyY/vnic9RZ3mb/VuUMqD71BPT9N4l8szH/8uDhSaJa0u7fDrxQlF1nb45fZl9du94C/MCv4OP/jTgn+jF/zZdv3e5AW/1pbPzX7wG4J/ix/9afN/qxf8SkXwd3rBb7b5v80LfrWNv8sL/kK7/b7BC/5cW//f6Ec+7fq93Qt+qyb4d/iRT5v/O/3w37b/dwO+5VyE4N/rBb9YEXncE3TCiFImoS++yF2QPpfwV7A4TmjlCcuX36eVDfnncd89wA/KIAnrnj6xJpQ4H3V6t6PcSH/SwSuXIwp8Bs5qZRKFZUOsZwyxzhlhab7tIHw9ZcjX9UZ8af7vIFjbDbHGjLCiwJceDsLXDiO+oucbhxTrJkOsmw2xbjHEutUQa6ch1m1GWFHgy64G4WuXIV9nDfl6gxFf0fMbDbGs+o7o+XZDrDsMse40wooCz50OC5asIfud76rO+Z3vqtT9zndVG37nu2oVv/Nd1Rm/813VRfHVpT8UGqhbt8B7u3FFNfO3oEI/T7za8tMZ391C/LB8eP/OrQqvBSWO2+itCp1bFToFJY738g6C9YIh1pIh1ilDrJOGWMuGWAcNsZ4zxFoxxDo/pFiWunrCEGvFCCt65n57WHTVsj1eMMQa1vb4vCGWZRsaVtk/a4hlaScs+9oVQyxL2VvKa1j1y9I3WTHEspT95WAnXjLCip55DDsIX0cM+dpuxJclVhSeDu342mHIl5XsoxAaYlnqBM+lD4I1ZoQVBSudiMIzhliHDbEs9cuSLytdHWZbuNmQL0tdtaxHS7s6rPKy1FWeWx0GXY2Cpf162RDL0v86bohlOaewYohlOVawnHsU/17msW+CuFz81+8aQHHVawA3+eHHuQZwkyJXbT+sIT+NLPWM/Epd7lTiBOu2+Dfu7cf0t0IZMT0+S3589xNxxRUIMwq8t3+nUh58J/KN9vb/8Eh32W6BdKynfuoh+x2wQj8feG03JZde3KLIUdMLyVtQ4tinz1pfWt3z3rdBsM4YYh0zxFoxxDo/pFgnDbFOG2KdMMQ6aIh11hDLsg1Z1uMLhlhLhlgXDLFWDLEs9cuyDVna1ctB9s8ZYlnaaLGF2ndUhv5HUfvOyRC//c3BbQ5ZIH3eiyPx2l/B4jihlScs47KVXGVD/rme0Q9HGSRh3dYnlvZtnI863ekoN9L3+y1grez3W8DatN9vAast0fk3gDxzJLvbvdTlbOazVIR+nnj11aZuJ35YPtIORHZ3KLwWlDjeu3eHQucOhU5BieN+exCsFwyxlgyxThlinTTEWjbEOmiIddYQ65whlqXsh1VXLxhirRhiWeqXpc05Y4h1Ocj+OUOsFUOs80OKZdm2TxhirRhhRc+8L3dYdHVYfQBLrCv99pV++7XSd1zpt6/021f67den7IdVV583xLKUl6XNsZT9s4ZYlm3Ist9eMcQaVn91WPXL0vddMcSylP3lYCdeMsKKnnl/ziBYOw2xrObJo+fbjLCiwHuPB+FrsyFfR4z4ikJoiPWMEVb0zOtfV2TvLiN/OzEI1nZDrB1GWFGwlNcbjfiy1NUoWLahYdX7YS3j690WWvIVhSt9x2u/74jCUSOs6Nlyz4OVvKLnGw35OmzIl1VfGwXL/tFSXsPYd0ThZUMsyzHfcUMsyzWdFUMsy/kJy/05/H0b7g3LxX+18+IjOvPx7+JgoZEjelIOfIf088SrMT8ll1xvV+SqnXdvyM9ijvCRnzsV+Uhd3q3ECZack4nft2H6O6GMmB6fJX/Xu3jSpUCYUeDv27Sz0vGdyDf6vu2/jHaXDeuG9dRPPZQzf98m9POB13ZTcumF1v41vZC8Wn1xv5+1vjSsk4ZY5w2xjhlinTHEesEQa8UQ69yQ8rVsiHXQEOslQ6xDhlgvG2JZyuu0IZZle7xgiLViiGVpCy3r8bghlqXNsdSJ5wyxLGW/NKR8nTXEstQJS9/Est+2rMdhtV+W+mXZHlcMsSxttCWWpX6dMMRaibFkvILjm1z81/MdcNUc0ZNy4DuknydebfnpjPU0ud6pyLWf+8WiZ8s7m9g2D4J1xhDrmCHWiiHW+SHFOmmIddoQ64Qh1kFDLKu7kaKwZIhl2R4vGGJZ6pelvE4ZYlnql2UbsrSrljqxYog1rG3bsj1atqEXDLEs2+PloF/PGWJZ+gDS107Fcehv3xp00+nX58f8km5SyZeL//q9w3cu83kdQj+vyMSHz39PRrmK7O5VeC0ocbx35V6Fzr0KnYISx33TIFgvGGItGWKdMsQ6aYi1bIh10BDrrCHWOUMsS9kPq65eMMRaMcSy1C9Lm3PGEOtykP1zhlgrhljnhxTLsm2fMMRaMcKKnvm8jmHR1WH1ASyxhrXftpS9pQ9gaaMt/Ylh1dUr/fal69Ou+OT9YV3xyS+dfl3xCy+dfg2jXxgFS3kNq64+b4hlKS9Lm2Mp+2cNsSzbkGXfsWKINazjoWHVL0vfd8UQy1L2l4OdeMkIK3rmPU6D8PW0IV87jfiKnjcbYlmuD1nK60ZDvkIjvqLwjBFW9Mzf9A+DTkSBv20eBtlbtm3r9mjVhqLn24ywomDZHi8H/eLzhgbB2m6ItcMIKwqW8nqjEV+WtjAKljZ6WPV+WMv4eu9rLfmKwhXf5LXfd0ThqBGWpT8RBSt5Rc+WPvlhQ76s+tooWPaPlvIaxr4jCi8bYlnOKRw3xLJct1oxxLKc/7LcX8jnDW2GuFz8V/b5oq2L6MzHv4sDhVLm84aEfj7o7avs+Ons870u6JXrZkWuIrvrFV4LShyPja9X6Fyv0CkocbzmOwjWGUOsY4ZYK4ZY54cU66Qh1mlDrBOGWAcNsc4aYlm2Ict6fMEQa8kQ64Ih1oohlqV+WfJlWY+WfFnaCUudsKzH5wyxLO292FXxrdgnmI9/FwcKtZr4JujLiE81EfT6JoZ+3WyO6Imc8B3SzxOvtvx0/Dqt3lA+7NfdoPBaUOK4Dm9Q6Nyg0Ckocdw2B8H6jCGWJV9njLCi54nABsu6jAcNsZ4zxDpviHXCEMtSXhcMsT5riHXWEGvFEMtS9icNsZYNsSzL+JIh1iFDLJnnY98iCvPx34vdYWV2ulKenS6XG81ivTE905qrzBQrC7XK3OJCqViplWcbM/VKsdisNBerxcb0XK3RrM/VKq2F+tyMX9+hNjcR9Np4Q9+kJPjb/eCXBX+HH/yK4N/oB78q+Dv94NcE/zY/+NOCv8sP/ozfsw9Ks4J/rx/8dvt6kx/8uuC/2Q9+Q/CLfvCbgl/yg98S/LIX/HJR8Ct+8Nv2s+oHv20/a37w2/Zz2g9+237O+MFv289ZP/ht+znnB79tP7/FD37bfn6rH/y2/fw2P/ht+/ntfvAXBP87/OAvCv53+sFv2/95P/ht+/8WP/ht+/9dXvArbfv/Vj/4bfv/Nj/4bft/nx/8tv1/ux/8tv18hx/8tv38bj/4bfv2Tj/4bft2vx/8tn17wA9+2769yw9+27496Ae/bd8e8oPftm/f4wW/2rY/7/aD37Y/7/GD37Y/7/WD3/Y/3+cHv+1/vt8Pftt+fq8f/Lb9/IAf/Lb/+UE/+G37/H1+8Nv2+UN+8Nv2+cN+8Nv2+SN+8Nv2+aN+8Nv2+WN+8Nv2+eNe8Gtt//MTfvDb9v/7/eC37X/dD37b/i/4wW/b/0U/+G373/CD37b/TT/4bfvf8oPftv8PB53Qwa40Fy4utdTq07MLpVZ9ulVcqM7MVuqtmZlGvTFXbc7Uio3S4nRpsVxqzc7Wa7X6Ym2uVGo152qt2Tbvn1SxBwmddZFHfMil1GrbhR8A/JwZ/7Nt/E95wS+229VuL3rT4f9RL/JvtO3+Y4Gx7pSKxehe0NPrX8WaAtlLOdZTncheoDF4/lTYnUbiMf2f5F/9G9E7H4NOUp4Anicov22dleZyRC8gWgHRzyuy8bHPaYT4YfnwPqdRhdcCxUWB171HFTqjCh0N62VDrIOGWGcNsVYMsU4bYi0bYp00xLIs4wlDrGHVryVDrHOGWBcMsSz1y1JepwyxLPXLsg2dMcSy1IkVQyzZDzkR6H3hfPy7OFCYnpW+Fn13CRKHvjf30T8A6d8WdtJxGKHfWKYNF/+9ZWsHl9MxP+jLPAL4mpwkaPvaLX0cwV/vB78iOjUedMuUy7Q+QVYSr/0NAt0/FFr5oFfuPvxDrWzIP7eXceCH97prWON9Yk0ocT7qdMxRbqQ/6eBVK8coyUSzRzlFJvJ+vYMvTD+l0Ja8IsMNEGcow7JLhtgWhf4meG40F554+F17cEqknR/lIHK7jtLdH3bkwDo4noAV0G/+DmYE8DD4HTNe2n5A3vXbD6CteoTiVmv3osC2QavDqH7/2jG3kKRDWecWJP3frO/Q+3/i541Ac6OD5iaKw/RRuJ/oT0LZRpQ0G4lHSf+3MV9R/b0nrj9NdsLPBOV/PemylKlfXcZ6RN4QU3SH6zapXkY3dHh5/9YOz0xvU5BcDvn9sEJPeJ+itFGQOi7Ae8M5rsx3sQn9PPFq3A+1fZgC8cPyEV3bBHLcvafeeGt97/4ndjfXkSj5+COBLxCcpMG0GArAEqbn/Kyq7wp783EQUU4Fvc16inhC/BHlHZveKYU3UXORzV2xmkdm66r4eTLQ1TgKE0GvbA1VYTGragr9fODTHHZUczPxkyR7kY+nprKQC3qbxYhCU/iVuiwocYJ1VfwbTSSmn4IyYnp8lvz47uZYnwpBb/N+IOzmQWv6+E7kG+np9THulFKeSSqbVm/asS8FJT/LEHXykbA7blQpm8SNOeLGHXHrlXJJ3AbI9ynKl1cwIzpPbujgJckG9UrcF802JdnWJKz7CAvzFwjrqhSshwgL819FWFtSsB4kLMy/hbC2pmA9RliYfythXZ2CtYewMP/VhHVNCtZewsL81xDWtSlYjxMW5r+WsLalYO0jLMy/jbCuS8HaT1iYn4/1uz4F6wBhYX6+hu2GFKwnCAvz87G321OwniQszM9H8e1IwXqYsDC/5J1UsNgP8PPJYnY/QOjniVdffsCNQa9cUT48HLpJ4bWgxLHdukmhc5NCR8PaYoi11RDrakOsawyxrjXE2maIdZ0h1vWGWDcYYrHdSuuv3xu++tfVX0s+1F1MNwJptD4aMZL8ARyz4fsdGcqD71g2OxLoJfGHspHxpsv/mKJ8Gs9TKXRcPEs6zWfeHXbH4RQ7+7c4Hcx+OE6VFyhuvVIu9pmxXtlnRrmhzzxG5TkUv/c7HVcsYh0myQplnEv4GwTZpmsx37o1oBOF7wv909HKM2lIB7HeFnbTWfspvmIzSzmQvu8pPpHFFocstnqhXc083bmVZLHFkyxEL9PGbbykqI3NtL4Ep0cfbh64uEj3XYfeX38YVyTRrDI73CwK9PuqBLbmKd1W+i3uH/OBWBiYD55+5fTzKenxeVR5HwVtWMvTsFq14TvXNOw1DjpbBqSzRaEjTQtdXB87Nzyd8tde5demErBMQn9SkVM/ph1p5YPeOvJhBrSyueoZhxhZply29Yk1ocT5qNNrHeVG+pMOXrVy4Gox2rkd8bGCkVv307TUwfYB5eBn91hlOqs+Cv212mmedaeL5qpL3gLFRYFv6tB2nYwpdDSsM4ZYzxtinTbEWjbEOmiIZVlGy3q0LOMxQyzLMj5niHXWEOuUIdaKIdYFQ6yThliWOmHZHi3bkKVOWMrrhCHWeUMsS9kfN8SylP05QyxLeVnawiVDLEt5DasttJSXpc25HHwmS51YMcSykn30PBHYYEXBUu8tZf+sIZal3luW0dJOWPoAlvJ6yRAry9fYOQVL3mtfsGjzUpfLFyw1SmfxBUuN3o0E+hcs+MUEz4cFkN7vfGylnCN6XMaA6OeJV+P6d97up8179nu7H9+0PSw38lnehGR5+9opQ6wVQyzLG60sb4Wz1AnLG8Asb+2y1AlLeZ0wxLKU13FDLEt5PW+IZamry4ZYl0M9Wt6QOay3gC4ZYlnKa1j7IUt5Wdp7S/2ytDmW7fH1fgNr9MxzMMOi95ayf9YQy1LvLctoaSeG1f96yRBL5mC0T4n4EwZtDHudgw7mvy4DljYelvTap0euuR7t0yO/t6R15nq0+tA+X1rNXI/IrUTpeK4HbdsNCVgB/S7Ru6S5nrH4nexbOhcbT5Gvp/1o6lZz3q+Ie0Z5X2S/n9pqnytrdLYMSGeLQsevLPs/RYM/m8ATdfkTh08BFp6CwmGEfmN5o3bxwT5O2MD6eCQBc0xJu47iJO2PT3T4WIz58LvvcO3q5L6wk46DVidS3kgWrQHrhPe/It/a59JZPuPGd9y2tM+4NTq3D0jndoXOpJIvl/BX6PA7pqPx7JpvXy0dxJI27Hfuvn/9Zzmj/vPeXDyhm0/Rw9O1cR2Ig9Y2RBZRvp/P0Db8rjetnQz5kzeUIbZtDpoMRRZZZTgV9MqQ2/ZmpRxau0eM1bR7jYdh6ye2UBzW8VaKwzq+muJ2Ax3+JO5RyMdrWY9B3BjF7YE4PglxL8RtoLjHIQ7rmkNaf/YXffRnqDdZ+jPtCBXB9ftJWaWSxe4j/TzxastPZx1U+0RYO7lTZHe1wmuB4qJwOOyk47gR5d06B9ZJQ6zzhljHDLHOGGK9YIi1Yoh1bkj5WjbEOmiI9ZIh1iFDrJcNsSzlddoQy7I9XjDEWjHEsrSFlvV43BDLsh4t7ZelvM4aYi0ZYlnKy7INWfoTlvI6ZYh1xa5eOrtqJfvomddBh0XvLWX/rCGWpd5bltHSTpwwxBpWf/UpQyzxVyUfjvFxzdLzOQbtW0Wv94PfPifBtZaL9HlML/HaX8HiON63fbWfsjn3bbv0AOfGsxwRel2fWJfyPBOUNZ9novGqlWOroUyy3ICizS31W7euI1s9t7H2noKtDjkh/UG+HylTuvvCjhy47rYlYAX0u0zvkvYUTAW9dbo+gU+hy+9YVzD/qIPOhgHpbMhIZ2pAOlMZ6WwZkM6WjHSu1E83nUtZP2KH8cwiWbeNbODBvE5zDGjiWU28Z0LS/zLchvt0PrmMOSo/9uGy1uL3Bq7+18lYlnxrdAB/MWhrTFKmfm+KwW/0+KYYwcQ6w5tixiAe05/Md3j52nYdMweY+K0i3yIkbTbpFiHmQdKfBh7kFiHGHE0o13gC5hdBF8/ldcxAwdTKtYHKxTysJx4k/QtQrq/DJkVMg3QkPBp285ZXaAUJ79im5RPiXHTT8kbPGwmD9yywvm6i9JI/SaasK5L+Cw5dGVN4wPJyvTIPnGZDAg8/pvCAx1Yu7tl7KL7VJ6CApjun/Oaq5CoYU3CSgoghKt4X8zqO/HapH3bF4wqNDQk8Yt5IPGLiGs3dzQPNBAGtI7DRBGLrAj34ve3TT7+h7a9A28tB61OkvJF8vrG9g8vpJGi32F3xq5LpaH4VY2n+UhSaYSce0/8u2JFvbtcx1yVgyjUyrj5N25sk6bUxo8vnRn3kcbpGG2XJdvfqPnlNm29YT7xqY9GsvN4Xri2vo33yukGhjX3PReP6yJPNfQ/tOdA+RTtQ2AjoeYLesRnm/mI8gdVNlG4z/eZjldm8X0W/8wp/WhA+MDAvI0F6kCYqsvojaKJ/ntBEg0BvoqL2PPzCvDj8EpV4EtLxMPrTVB5MjzQl/UGgo7k4T1K5Jf03FRdHG5oLPxOU37bbnZkTGR4KeoPEPQW0eavY05D+rWEnHQeta5UyRbIo9TFcw3pE3hATuwys26R6+VdQL3yxJ9L7dJBcDvk9ptBjWUp8FKSOn4b3dnVcq+eInpQN3yH9fNArWx/T/E8TPywfzQw7LvY8BM8I/yGCkzSYFsOHgCVMz/m52q9X8nEQUY4Rz1K+yJz8ezJb2PS5e0AeRpR37G2NK/xrdDYMSGdDRjqv5fJkuQByRCmrdjkkX9a4B+L4Asi9QW+5eIe2hrnPgbnfEXfAEfeEEheV88imDo/cvWhNnS+VxLpLatdJWPcRFuZ/mrAOp2DxpZKY/zBhHUnB4kslMf8RwjqagsWXSmL+o4T1TAoWXyqJ+Z8hrDAFay9hYf6QsJZSsPhSScy/RFjHUrD4UknMf4ywllOw+FJJzL9MWCspWAcIC/OvENbxFCy+VBLzHyesEylYfKkk5j9BWM+mYD1MWJj/WcI6mYLFF71h/pOE9ZkULL4YDfN/hrBOObCiZ/nae0rJf4qwnkvB2k5YmF/yTipY0g+JO3ka3tu5b6XMX7kI/TzxastPx508HfTKFeXDQ5czCq8FJQ77IoxDOmcUOhrWIUOspw2xDhtiHTHEOmqI9YwhVmiItWSIdcwQa9kQa8UQ67gh1glDrGcNsU4aYn3GEIv7MpdfHz3LqSsuv17yoT3j6a4RyoPpESNp3DAS6OOB5zKUB9+xbJ5LoJfEH8pGLn4edJwSPe8krNWOU6Ln2whrteOU6HkXYa12nBI930NYqx2nRM/3EtZqxynR85sIC/OzbU8bp3w67MbC/P2OUz5CWKsdp0TPbw66sVY7Tomei4S12nFK9FwirNWOU6LnMmGtdpwSPVcIa7XjlOi5SliDjFNqhOUap5xOwZomLMx/mrDOpGDNEBbmP0NYZ1OwZgkL858lrHMpWHOEhfnPEdb5FKxvISzMf56wLqRgfSthYf4LhPV8Cta3ERbmf56wXkjB+nbCwvwvENaLKVjfQViY/0XC+mwK1ncSFub/LGG9lII1T1iY/yXCejkF6y2EhflfJqzPpWB9F2Fh/s8R1udTsN5KWJj/84T1gylYbyMszP+DhPVDKVj3ERbm/yHC+oIDKwrfG3ZjYf4vENYPp2C9nbAw/w8T1o8E7jK+PejGwvw/Qlg/moL1DsLC/D9KWD/mwIpCK+zGwvw/Rlg/nsLXdxNfmP/HCeuLKVjvJCzM/0XC+okUrPsJC/P/BGH9ZArWA4SF+X+SsH4qBetdhIX5f4qwfjoF60HCwvw/TVg/k4L1EGFh/p8hrJ91YEWhGXZjYf6fJayfS+Hre4gvzP9zhPXzKVjvJizM//OE9QspWO8hLMz/C4T1iylY7yUszP+LhPWlFKz3ERbm/xJh/VIK1vsJC/P/EmH9cgrW9xIW5v9lwvpyCtYHCAvzf5mwfiUF64OEhfl/hbB+NQXr+wgL8/8qYf1aCtaHCAvz/xph/XoK1ocJC/P/OmH9RgrWRwgL8/8GYf1mCtZHCQvz/yZhfSUF62OEhfm/Qli/lYL1ccLC/L9FWL+dgvUJwsL8v01Yv5OC9f2Ehfl/h7B+NwWrTliY/3cJ66spWAuEhfkl76SClYv/yjrX78F7u3WlailH9KQc+A7p54lXW34661y/F/TKFeXD61xfU3gtKHE85/g1hc7XFDoa1mFDrCOGWEcNsZ4xxAoNsZYMsY4ZYi0bYq0YYh03xDphiPWsIdZJQ6zPGGKdMsQ6bYh1xhDrrCHWOUOs84ZYFwyxnjfEesEQ60VDrM8aYr1kiPWyIdbnDLE+b4j1g4ZYP2SI9QVDrB82xPoRQ6wfNcT6MUOsHzfE+qIh1k8YYv2kIdZPGWL9tCHWzxhi/awh1s8ZYv28IdYvGGL9oiHWlwyxfskQ65cNsb5siPUrhli/aoj1a4ZYv26I9RuGWL9piPUVQ6zfMsT6bUOs3zHE4jnHtH1yi/Gza5+c5MN5J/40c4TyYHrESNqHNxLo++u+mqE8+I5l89UEekn8oWwa8bPFvr8mYQ2y769FWJi/331/1xOWtu9vSsnH+0SfctCJgmuf6FMOOl8dkM5XFTrad4q7w+64EaWs/J1i9MzfPu6BuEMUt1cpF3+niG2Ev1NEHeTvFFGn+DtF1BH+ThHrHL9TlO9xRUZh/H6Cyiaymo9/FwcM2u2KLEest1zC3yDorkMJrB+Yb90a0IkC31q0VuU5ZEgHseSYA6394oliq2m/mP+pBCw52iAK8o0vttMxSv98rMvRt8J/SUdtaHvUR+Dd/Y6ySl5pI9y/zce/i4OFkuAf9YNfcfWPWCa2KSi7fvQLaeUJy1p2rrIh/6yH2F9n8SOO9Ik1ocT5qNPDjnJrfYjGq1aOpLaJdPKKTCT9UQdfmN7lP4kM0YcxlGHZJUPNB1vNKcgit+2Ujm9W1nxRxgro93Z6NwJ4GDTbtjGBT6GbZscxP/thTxFf2l+hw++Yjsaz0MHzLKSfiHyeL9PZDKJ3eGQOfkd1A8R3pd/awfy1GFP7ziupreSAnutUM6GXdNTSaAJ/vwX9Hp9oqZ0sd4ODZ8FEXxh5lnM/mIffIz/SUx+p+pFCSzsRjb9p7vfUvoOKHJJkGwX0U9CPwfS/36efgvrNfgryJHm1MT+fnqrRcfWTmxQ6g/oHGh2NZx67RQHb+R9TOxd9QJ3HvHIewhil/5stHcw/dbRz3j/EPg3bPm7nQi+pnbPeSPo/c7RzzWd+V5jMs2Ci/iDP3M4l/T+jdu7Jr1HbudDS+jFu5/32Y5od1+hMDkhnUqHju7+cJDqHDekglrTJtPb676i9Sr1q7ZX7bUz/NWiv/ye1V9R3V31y33FYocttJgiyzVG6vk1mGxUFV9/RtlGOvsM1BoiCa4zrmhPGdJjGNW864qCB+oTvxWdN8j2QjuYvjybg5hQe5fRlv2PumZa0BZz7lSBxocKzxC1B+veFnXQcRug3linSlX+R4URnbWwYJmCyTKPAp79LmdcpuEcJF20Ay+uBsDtO0m6NCxO1/w2TOh7rSRRkns7vuHK2yPWLgeuX5cNBq1/hO6rfjTs6uJyOaWIdLlEc0uEz/rCPFIxI9jfGRIe1La2mvfQjT629aPLktQiUp2CgPMcIYx70/WbSd0nD/UUUpP1ImxX5jSr5o8C+n6S/LaYZyeeDO3T6rvYWBLpdQDnwWaNhoPOilVnSfjvp4xLlmY9/FwcK1ZLU4zHiGWkve6KdxV9D+pMKP8J3XokbHYDXWmlmpjxdbdRaC9OztVozR/jCK7/juUPtrI6rlPQi6+NeZF1pSFMbCTv4KyDXKIxC3DLFjUGc8Bi1oQ/v6OZ/xRP/WeSP9AtK+vvCTrp+6rKg0OGx2iBYh1eJtSXobgNaX4i+DfeF6L+IfY3s8kcT7HIWWye2je0+lpPt4IfI1oVEez7+XRwoVKqaP8q27pgn2lltndCfDJLrNq/EDWLrGrVqqdqaqy00WpVmY6aVC3r7hBHlHds6TW8LSnrPtqKo2Tq2Z6MQd4zi0NYJj5qt89MvVopZ5I/0C0p6tnVZ67Kg0GFbNwjW4VViia1bgvxh/KzZOvZTjyrlQVvH47JPkE3yc6WDPkfINhX5jQKOoY+CnFi+jIPv0G/GPDxnI+kfBr+9ManzJ2V4QOFP27uE5XpkMjndUSVdNIU0Jbw1D7zvk/V9zcb7mov7mgdGAp09LiIXn4dTAaWLAk/P7KffHM+Y0gVnvblM/iKWVnWIzV3vozDkaZIJGyVa8/Hf4oBBGzpyV+tnea2ceVgh9PNBr8r52NahTW2ifLh79LMsUS5Gww9eMojCJ8Ne2TAfrsvFeIm/32XKEYXOZKC3K+1vEGSb7k+aMkgztUmm8QyYxqOTnfRsa7Q6d12l4Nq2klPS86V6uESXc+DzdMsK2Iuv05QrulRSDrmVapTi5uP3xYFCuRTx8UmYymK9RXctqZ1p14VIetdWsijIkoZra5GmW6hLoiNaPbvalI+lf43O1IB0phQ6vtvuFNFJWqr7fEKbTFqqK0M8pv9lWKr7AtVnku16pVxhJ26N2ky53zaj2SlXm0n7dENkqC2xfiDsjtP0neUahUbYzcOIwoPWnxaU/JIui5/C/cV8/Ls4UChl9lOE/lr5KaMZ5SryecqPfIou3XxKkQ9vDeC6Q9uNbV8b/mjLfdhP8HDxN+PG7tpS4Go72hL8K9v/aFjk2w/itjUCPFYAS65H8r3tA+0l14eh7lel3Ecd5Wb60T9cBhohDC09j3kYnz+Rkvx48bumW6yPfwg+6TcmdcwgcPukLJPxQO8vedlb0v8jxY/U6hiXDf+Q+lWUJW81OqLI4ZWtdBn6e20Zn/v7/biVjvjS7I/mV7EP369fpdFhrKxbBCX9P4V64QuX065Fy7I1nttoFDTZJG3DwHxiZ7jtJOklto0HqfyS/l9C+d9Dt4di+0vaDpT0SeNI4NavHP3jqbvo3xaFvrYsEv2bj38XBwxsy0aBRqjww8s3/57am0zfjihl1eS6pNDFKeMtRHeJ6Eb1eHRHN6bwtjHobWdanfC2dObzUxQv6f9vsLP/gfrqpC39/9+kTjsf6HqY1E6QV2yHB8PueEn/NyCvpYSxAfKj8aq1UbyEvd82+hDxKun/ztFGXbqk+XS8lUdro8x3jt5n1Ys2zuZOuf/B4cOhXkxt7uaBtxSm2Qf2Hebj38UBA9cltlPNXnJdTlC5luL3I0pZtToNFbpLkIbtQ0h0NfuAn/QJH7sBM0mPxxSeo8Btrr3sATxwmxtVyqzpgdbHuj7pwE+mtfRcFkm/FXh1zfuJP+B3DqOkzvth2xkLu8utXROs+VYspyBBTmLfCkG6TZa06IvheKkVduIx/R1gJ27c3F1W15yEp+XIuRzRCwJ9TkLor9WcRL91+5TCfyNMTq+1MW3OI1o74TncAmAJXbyC+ii90+YpeD4qaWxzD9kGbQ4M9U7GckwzCo1Qp4m4SFOb62Q72c+cXJoMNP3Pop8aHdfa0kFDOtp2WNeYMUlf+Z1r7gbtMdsmH3MkzwCfWcY7IZQhi3+rfXKqbU/mtjuaIDueI5H0e8D2fie1K1cZo4DjUuZJG7vyPMBS0KGt8cxjV0n/Nuij0z6fw3JEgecDJP07AJPnA5Ygfxa7q23nWYI0wo/WJnjciGPAkOho2Lx1T8NZIhwuZ5KvLRja1rXo33z8uzhgELzlGA993hWFnzFK/72kxyeCbpm6ZBb9O67QxWOy2dc+TnQ1X1t4w7E41jvXCa9LM5885pL0H4H2/CHypbB/x/60vlmnjeOCZQevxxRel4AWjwsk/Scc4wJtzhN51XxyaZOXwidHuzUWdstHsx+u+cSs9kPbWniU4rC/znIESJY+ZjwhPeuspH9UGVO5PteN8PeQv4V0eD/AQSiDq5/iusK8Ec39m3Vc7EtQZg+H3eWV9A2YM3+S2mDSfNjBhDaoHXERhfuItqTfAbSfJhlqa0qutfucEpfFnx3NSOepBDpBRjpaeSz9Zm2+/mriud+1DMy/VntEriY6RxQ6nv3mzGNqoZ8Petu9jzG161hIlKuk1+ZLDjvSh0p67egpHFOjDQ+ILo6pQ3qntXOeR+x3jOXa56Wtf6bZuc/1aeceDzvxmP4/XtXB/CGyc8O2r+yaAelco9DxbTOuofI85ShPvzqF+dfq6IxriA72D6ifX0pYf+j3CJp/Avr55VXqp+u4i7U6JsXHHM3lUJ7Xcxv5A6M28t9BG/kfqY1o+9Fcx52sVs5Z6bwe6vOIIR1tbj5Nb/4iYU0vq95I+p8BvfnnGfRGk03SUZlId630zYXl8i21fUqueUnXGiqm147nEF3w+3ly9v3AQj9PvNry0xknLAW9sntGkd2moDM3VW/uL5Vn39Zc3Hdo7wGuDAEskJBDApT0Af3mfBFTSZ0bpo0CnieHilSg/DwQYfwsPKWlTYvXGuEzCeUMgmyNEPMnNcKk87xCiMf0/xEmubKc54XK0895XkkGZEQpQz4hH07qYxyW+X5HmSX9/+8o85GUMt8Xdpc56bxc/M3pRpQybAj0CXbXQuS1QTfv/eoT5l+rzv1aopPU6Y5MdfKgHJI+/HkU4jH9i9DpjseY/Z7Rx+fw9StnjY5vOfNZrEcc5en3nHHtXG9XPT0KaZI2Z2kbqqLAH0ZL+mviuvR8Nrf6jb/Q0r53xw83txnp8AnQ4RtIh7WJrrWaUOunreSC1beVtSqPC0trDzniGdO/ph3aUrOYxQYh/de8Q/uvct1CDglQ0gf0m/O5HFpOy8ZQFGlQh1bjKSltvw4t0maHtt8ZYsyPq+DYIGwVqdzzZSKuvoZAk2f2noYyaI5a0qx8LgGfDSUe7qLJjndCSfqZuEOIHMiVeHVfq6ttCfwFQba6wvxrNZu/jej42O0XBf7KM003ysRXkhP7VnIAtAsgtJVlvtxgGhyAt5MDoM0Su1aNspxWoe3Y1ToozfFM2uWQptcsI433KLBDKOkXyCH0c0JNrXjpVqNrmTtlPrhJ++omr8SNDsBrbaZVKk5Pz1Ra5fpsszbNfZfwyu+yrFTfrKT3O6NXVQ/dRMc/CqMQd5TixiBOeNQOovPjMFUbWeSP9AtK+qSviTWsKKzzgCWHx7m++OIdT1FwXdgm6ZvQd2a5COUppTyuCzpG6DfbMrZVUZiP/6bVcCslBCS39Qov/IWcpN0Ncnl2R3dZtEPqRMYjDhqB8i4XJMuOaYwoeO8Pu+OOZOBNm7BDjIMJfEYY2qD7JipLv5MpNyn8+Fz5Qppp/svT5L+krXw9GXbiMf0u8F+Okv+i7cZhPywX6L4D2xT8Ek+bEGY7IOmXQd/TLrDCcjKPiIn+C/LM/oukP0n+i6cdbeqEltBaq5PhGGs06OxaR/v4jrBbVpL+PfGgNKrns1P9YX53AubvTnUwL/SJ+c4EzF8EzBcden9d0E0P25TWzljGmF/S+T0BqXNZ6F4/+O2LJfcossAyCf1Bd9AirbX6MlIrm6ue9wA/3JY0rD19Yk0ocT7qdNRRbqQ/6eBVKwf7FRqd6xSZSPrHHXxhemnDqPuSV2SIl2sbyrDsqm+87Fvor+ayUJHbNkrHl4Wi7PcmYAX0exu9Gwn0y0Ijm/k/xHZe65c2J/AsPKT1S5if9d+PzZxZ1L7klaB9yYs8chih38h3VN83bu3gcjrEYD3mywRdNjcJQ5v7TGv3UcDJe9n9v//Ann3Nd+975Mn6geZ9TzYfO6Do74agu3zr6Def9Iy8Il+TlI4XZ/fQ7wP0+wmFHw4sEwyTSrqkkNY+7oTn1bQPzO+aV7x1QDq3KnRcWHcqWC77fauS/nKx37dROhnbDWK/b6N3SfabecHx031hJw3PeUv6v6LxkB+fZK4yGfTaNCmL0H7cE+0c0QsC3S8V+pMKP8J3XokbZD63PFsplWYvLgU3i9VivVF0tTF8x21yn5L+biW9yPpA4EXW6sUi+0CuURiFuMcpbgzihEdtPteP3ZjLJH+kX1DS83xJ1rrUsO5bJZbM56Ltlbbtt63373+NUJzrREtct8C5Zw6a3yblfeViuwx+m+sUKr/j8rWTIeoqB02GUt5+ZYi6xjL005bXTobYRjloMpTyRjJs9SFD1DWew0bb1D5VLhgu+fKGK1yHelvYScchTYZv6UOG2jz4SKDLibF4HPKwwo/Y6SeCbv6x/qLA61qY/wnCOpiCdR9hYf4sX84h1kOE5dq/cDgF60HCcn0pcyQF6zHCcp2GeDQFaw9huU5meiYFay9hJZ18G/0LU7AeJyzMHxLWUgrWPsLC/EuEdSwFaz9hYf5jhLWcgnWAsDD/ckI+tG9RmFTeSVv3e/Fcqe8LWbXxgo85bk3uml8osltReC0ocdhvYxzSWVHoaFijhlhPG2LtM8R6whDroCHWU4ZYhw2xjhhiHTXEesYQKzTEWjLEOmaItdcQS+aRtXnQx4lOv/OgPG+ThqXZ0E3xvyi8Mm/+1vre/U/sbgYUeI2U58sPJNAvKPkDypujd4UELMHJER7PUYidT7rBgvd0SPrvjgnj6V0TSn7DcUdd+6hLgsRh/8B9H/qtbwu747Sb/HIKHW18IO8iWXyDTocOFCxtbQF14hZ4xjihz+9Y1zG/pNPo3DognVsVOi6sWxQsSa+NKW5V0mvjE8nr+Sac9tqCNsbTxiWrWVsQuW2ndLy2oI31GCug39vpXdragvCS9AEwry1I+v2xbk8ovNrVx2zF9d2C333qs5nXFoT+pMIPnxTO+yHnV8lra7ZcXKy0msVaZWFhsdhwtbF+T5J4g5Le7566WXVtAefBojAKcYcpbgzi8MRxXlvwYzdmi1nkj/QLSnrut7PWpSWWrC2g7ZW27betD+/aAu5J6GdeHPtLPoQAZXg7PGOc8MPvuN5vV3idVPLlEv4KHX7HdDSete/XcP/zSqGTB/UK9z9j3ifCTjym3wL7n5917NngMTrrKupGFLid4KmwWfpDSX8afGXe/6x9W/FEmMyz0MByub7fkvQXqE/20y/q+5+FluukO5ZHEHTqxPVtnCYHv2WcaWjfD0jQ7A3vocU5Bt57EELcPopbAjrfF3bH4Ziexz3LEHeA4rS5NYk7DnGjFIcnn6OOctBsJh7K8hd92Eztph4eE6J8tX1Id8Azxgmv/I71DfPvTcjHdsTznqeS5zbd3lesfbOFZWJfV5unz9K/IK21mkfXyubaq4HzDDyPrGE93SfWhBLno073Ocqt2QSNV60cPC+otbM7FJlI+sMOvjC9dtjQWs8HaDK0mg8Qud1N6XivOOrg0wlYAf2+m94lzQdodnQ0gU+hm2ZHs35jgv7i1ws6zazf+0v6v4Pvm74Bzzwnp8lvin5Hfw/Fz573V81q8x0Bye4Q0cY4XgsKgiBzn417qEqr3EN1iOgLJtbfpyFN0tzz/wz+9Ne265i5QB9DsE8vOpH1m0ZJ/+cOn17SjCaUa08C5v8FuviXCboeKJhauR6ncjEPe4kHSf9Xyrx+EPTaX7Ypj4bdvO1TaAUJ77jP2ZcQ56Kbljd6fpIw2Kdgff00pZf1qSSZsq5I+v/NoSvatxyuPaXMA6d5PIGH/0PhIeqPNsbxi3v2HkpYzsLmkwt6l7e4KrkKRhWcpCD4UfGkOTCO/Hapn7b9FfM+nsAj5sUzrhrN3c0DSet965QCaMTWBXrw/F1UUduDL0HbR8j9Bvu3GLcf4tD2ctD6FPyeKuu62en1rz6vlU+SxdeIQjPsxGP6f4B2xzfI7QU+NEy8PZoblmtuRNKnjdeEvshS8/tdtLV9jZL+cJ+8amsN6EPvI15dh2Sm8XpfuLa87u2TV20fA9rqi8bokSeb+x7ac6CJzYPZCOh5gt4lbUuQ348nsLqJ0vE0Mh8xwv0Df+a3X+FPC8IHBuZlJEgPfF7xVDx9HDXRP09ookHg3k6hbTNG1/LrNLTQllBc6uhyYbVzTxGDjw2R9Nug3Gyasl76K+m17bI4BcpTwNgM+NgnXObDKd0ojEKc4VC+oV3ehzIYC7OXV5NPqKTXjmcsUHqUlbbUwtOg2IXhWbkrpH/akWWusrm2EMU/Ey9XfTjsxGP6Ox36t6TwoJ03K+mPKemXIA1PCYcQJ3k1/cNPKqIwCnGG+tfU9A9lwPrnKq8mn2UlPS4ZSP0WKD3KSuJQX4SmZv9E5njUkbaMm0v4GxAel01b2n4g7Kbj63ITWWZje6m5ctFzOX4WV59lPx//Lg4YuP3gFMQxhZ+eS5Sv6i7XCshHs+vloDv9skJ3hcqKdJeJLl6Sy1POUcDpwLcTr0uAzdPurjIvwPLxO+Nnl5vJR2O+C3g/tSM5P/eBvN0H41wXm2rHhKFusr2V9O8FPs+AjKOANg+nz6MwCnGGutrqt89dgrgsfW5an8D9KrYPHv5oQymUedLwJ+lSXDyqFtN/DOqIL8XFvp0v9D3YJ+9ZfdinoRx83K6rPjQ+jgGWlh7bL6ZvKTJhTGwLWMdhAuYjgPmXfWI+moC52+HPaP2vdq46211Mj32y8KN9TrVCccg797vLQJ/TPkb0MQ7bFtMNHPxyn53GL9tciVsGm/3p+Fm7gN7HkqlWl3cp5clal087ys9Y2L+yvmptaFmR19GrdMyxPjGXlH5P85V2hx3aywl9dhS4z44C26anFb7QF9DGN7wMKLx9Rmmvl2wMUGoWtf4Q5cj9oTZOc92jESrp+XjkKBSU9D8Qdse57grRpsey9jd4xOi2DHexCE3XfEX0fAOll3KjjUedeQTiMf3nHTY+VHjQtn24dD+ENHxsKNaV5HVtjb4U+ury30KlvEcHkA/rK9pNPnYb9YU/F7TS1xHSV80GaXXJ7SdU+NHaKctpPCG94HEf+qUMfhXy4PpUIOv8gtbHLQc6bWybIeDzBaCS/teGyZ4XSyWtfaBcuX24ZBiFfn3EMH52fU6qtY9jFKfN1Waxu1FwtR3Ji5fAamPjpCOg02gyj9p4WbP1kv4bDluv9b0uWx8q6TUboNkOyXvpxuq6LqMMsth613hnSUkfBt1liYJm63ksrG0FTrPdf+DQP15Wznq/mEtX+FMppJ11beRS1v1aro0k+aUsK5QJYmm2wTWnMqi/GQW+SzfN3+S5SUn/b/v0N116uKSkDyHNUPubq9DDUCnvpfQ3NRuE84Rfctgg9vk0/XP5Z2k2iK+v0mzQiMIX9sXaZ6BRmI//FgcMrjUdz/eU1nJET+SB75B+XpGjIT8lV71qcwB+r3MqViMzpa3HfTLslU2S3WEbLmtpUXgQcERXteMgcH1ILrTmNoM2GPMKDfYDx7d0MEcIUztWDW0w+7/asWoR7ueo7fO1YUhTq3OXvxwCHS099k2YfmNcVm18uKTw4Jp7SluL4fFxCHHHAp22tt9A60sl/VVQnks/PiyXLvWaP/dZrrEj6uAS0dH6Iu0zWu0zBBwDBgltC9fUsW3xMYPa599JPEZB1km5XXKb0MokR/axv7ZT0TFuhwFgboV3/fojrjklrqNQwXJ96iz5x5X0iMdt7M4MNiNpXodlKunvcchUaxMumaa1iTB+zjJPFSpYKNP7Qp3XrDKV9BWHTNPmylimkn7aIVNNRi6ZZp2Hcq1VZpUpb4kWOlllKum/3SFTXC/KIlNJP38JZYplXqF8IcSxf8z2Lp+Qb4sDcykBU95jPtfRplpdajaN6/J+R11q5VrKWK5jRuU61me5JP27PZXrqYRyPdVnuZZSysXrrpL+AxnKpc2TRIHn/iX9hzL6dpdyrmIt50t5ThR14ymKQ1+J5/etxjcHaXzD188jTW0/O/LBOiDpP5lRB9ZmT7muA671fM2Pdo2p0uZ0uJ61Y440HeA5Ve1Ilqz+PR6Zs39zdzrkJ5fwV2jyu3UZysZtC8cRKFcZRwzD3lzkh+3mURofaXtzQwWH+9ekvbm812qZ6Gp7c5PmXkLiFfu4LHMvkv4FmHtZjp81n0fGp9r8Ads0rY9BfUjqY05mtC/C17D1MUsQl6WPGWT/bEhYWj+i7Z/V5ht4DU9bl4n0448n0/kPlbzcPsYDtz/I7eNlhz+zDHm08WYlAfMLoPc/uKW7/FiPsi8rSveTW2xo/6hjHKONS1xrTseV9GhzhJ8p4gHzcrm5rn6S7II2x8UyQb8Z07PfrO2DzAXp44FlpYwsw/GE9GgrMf0vKHpWUMq5RPQ0/rL230vAa5jB/gpN19XvUWA9cfk+Im+kjfPXuL72Sv6wE7c2trhcvtS+nshH0wc+tl+zxSPwzmWL+foh9M3QFn8+rgz20f970GHed6/5/chXkt//+w57pcnNpYehkl7bi6DNOYeOfNo6KdKaj/8Wi62BgtBbivHWK7wIXfa1/gjk+OwOnddcD7+DBddYYCLQ7a4N7XIxR/SCoHesgfTzga4P8yb8dNZ0l4gflg+v6foZr5RauKaL+otrulg3mv+n7dPAccKfkc+i2QC0cyWIx/T/HPylv0jADAK3vUvbI/bvNnXjhgquxZyNZluWKA7z8ToQ1gnb/rRvm3gvpKT/t2AbXN8OCl9+9563LvneWpGZtrc2y/cQqAtJ39OPB+5xF6/X/7XDP3Tt7z3cJ+9HFd65nXPb+TPyHZHm0xloau01RzST9vfeAPGY/m/X0G+4sr+3N30YdJclCln296K+ZN3f+8ex7da+y85yvaE25+3qs1C/t0M8ps/HC4DDfP6KyMmz/pUv9R5jqd8s56+49nZq19JE+vflWP98ynFmttj2aaUO8Vh5DKMQj+l3xDqZh3LI39EB+GzN1EutSr1Vr9UbjepinY+Jj4LUWXTMVaQP27Z2ZMZt23JeXvDH/OC3vxsehbKOKGUS+qJL6yB9LuFvEOhjFqGVJyzjspVcZUP+eb1mlPiR5ySs0T6x/B6p2KnTEUe5mX5Seq0NyPtxBz6mF7uOOjxOsljvRxZlV72NA02hv5pjsOX3DkrH12KhvMcSsAL6vYPejQT6Mdhsl7TrTSSPZ5tSzmoHhH4+8Noe2nZgjPhJart4nOHuPfVGfLIqmzyuOhQnwnGxuera3SK9Y3VYR/nE1dO6UOYzp2BoIuAbwHMKfc2UjCTQDYKOurL5SMOS5xEHL0kYOcKYdGBcaTpXmo4SrjSdbE3H2hsvz85Oz5UXitWZxmKrUa2keePW9BcXpheqzYXF6VJ1ulItNvoZDbC3kXT5wzqIx/QfgVE3r0Ctc2BGgU9SlfQfd4zkNa9IK2cWM4D8TAW9esUjiLXSp5n67MLc4ly1Xp0uLhZnpldTn1q5UfYHwu704lkmXVwseGOU/lNQV7xbYxzyCNaTYS8m84z1gx47X8Ym6fcAD+dp1gPlwF0ietOGXdBijugFgd4lCv184LWLLnF9CD8sH14J8zTCWcgRPvKzXpGP1OUGJU6wZCYIbQ2mXw9lxPT4LPnx3ZFYtwqEGQU5HTWnxI0o70S+r5yyRq4b1k0u4a/g8jsewaNs2Iah/cSVw2MJ9gPliXnFfnBbfHFrB/N4/Kz5F1x/bJNdfgLSS7JX3F9J+lNgK/jyEO6vsJzMI9IbVehGge2VpD9HM3Ge2r16eaTQ0vq7XKDLIwiyzUJp/eOkQkfktTFwz7S47IRrxkva3HhCesEbo/Sfd/RlGyDPiMIX+zKS/gsOX2ZCKZfWruV9Xkk/oZRrKui1f5JXW5UQ2Xs+oXZRW5VAGY6F6fJZP4B8RAcKlB5lpdnQ9UQnbWjJq7jaLBraXPTfphT6XE6tPYwr5XS1B618rLtf7tO3w4t21yfwkNW3k/S/Djy84PDtsC/7za1uXtne4NgH0/8e9GW/TfWjzYJqdpBXYrEuRUZoB8cVXK09s05obQXTs68tuj+ekB79KUz/+w6dyEMezb9kn0HS/4HDRm4MesuF4xiWwyYl/cagVw5TQa8N2BTotLE8KGe+QFvS/2OlPJrdxRWFKIxCnKHdVW/jQLmy3XXJMAos80klPcpSyleg9Ch/re1spDiku4F4SBvbsE3W/A20Hdr0KspA+JxQymtXd4ulHNGT8uE7pJ8PenXex1gyq46IfCb9yKfo0sFJRT7Cz2Yv/BQroisFhbbwGh9C1mVXMP0kyBDT47Pkx3f/gfR1CvIJfoHiosDjWIwbUd6tu0RYBQUL5SZ1GrXjf0Oy4JuttL+Cy++YR6xP0XmXjVgtHcQS/0ZrT9G/+fh3caBQKUs5NivlENqoV3ZtpzaT1dYJ/XzgtS2XXDqM8uGxbkHhtRD06vDTYSddmn4jHQ3rwpBirRhiPWeIddYQy1JeJw2xThtinTDEOmiIZVnGM4ZYlnwdM8RaMcSyrMdlQyzLNnTeEMuyHi119QVDrBVDrHOGWJ81xLLU+2G1OZZlfMkQ65Ah1suGWJbysvRNLPVrWP1CS70fVl9uyRDrlCHW5eDLDaveW/omV/q0/rCG1ZcbVlto6ctZ2kLLerSU17D6X08ZYg2r/3XcEMuybVu2IUt5WfZDlm1oWGVvab8s5+VWDLGGVb8sfd9h9TGHse+InnnNyqLv0NZ6cY/ihMKH5Xqv4G/xhC+yusohK6TPa78Sr/0VLI4TWnnCMi5byVU21xoxroejDJKwruoTa0KJ81GnBUe5kf6kg1etHJOGMhkzxOK9bdqeDW1dVdJvUdJrejKl0Ja8UrdbIc6wbsuuukUbIfRX8/W2yO0DlE5uc1gX9LaNqxKwAvr9AXo3AngYpoJeXduQwKfQ5XesK5h/kviQ37LnBffAyj4RbW9P9G8+/l0cKEyXXbbVbz8zXclqu4X+Wtlulw2LAu+NyGLDonAk7KQbxO5E4UVDrLOGWCuGWMcMsS4YYq0YYi0bYh00xLLUiSVDLEud+Iwh1ooh1rDqxGlDrDOGWMPati1lbymv44ZYlmU8ZYi1YohlqfcnDLEs9f5ZQyxLnXjJEGvFEOuK//X6sNGWfW1oiHU52MKXDbGsbE70zGPtQfh6PrTDsmxDljbask8bVr9wWPu0YR1bWcresg1ZysvSRl/pO177fUcUjhtiWdrCc4ZYV+YULl0bspS9ZRk/a4g1rOMhS9mfNMQa1vlCSz/nip24dP7EFTtx6WQ/rHYii/+F5wTyubzaOr5gbUnBuo+wMP8WwtqagvUQYWn7GSTf1Ql08MwL3INxtUJbwxcMbR9H9G8+/l0cKMzUJ5Ry2OGXG7Iefg2UOxf/FdrXwnu7tftq5vNJhX6eeLXlp7OX4Frih+XDewm2KbwWKC4Kz4SddBw3orxb58A6Y4h1wRBrxRDroCHWs4ZYS4ZY5w2xLOVlWUYrvjQ7Oyy6es4Qy7JtW+rEaUOsK/briv3yWUZL2R8zxLLU++cNsSzb9rC2R0sbPax9rWU9LhtiXQ790OVQRku+LO3qiiGWpb/K4/Zh0a8VQ6wXDbFOGmJZ+ibD2qddaY+XrozD2m9fDuM0SxvNe8dej3p/1hBrWOc6XjDEWjHEkvbI3wVGYT7+WxwoVKoyF41rJ7mgmy76Iobz5s0c0RMZ4Tuknydejflpz+Nrazkon3UkHz/rHMVGjvCRn2sV+WjrCuxHXhf/xnUsTH8tlBHT47Pkx3dviTNa2snoe+tvjXH7aAPlxVapUmvO1IrT9WqtMV0pN8ozxUa11iqVZkvluepspdJarM42ZsuVVnmmvDgZ9NY7twFPdVzN2gZ4LctTm3SuZV2t1FG/a1mPhp10w9T/yv09Wc6P96MLlYXV6oLv8+M1XXCdH59VF46GnXSD1p+lT205ljxliLViiDWsc3SWvv6wztEN67rAc4ZYluMGy/WKy2HNbxjX4KNwZR340sn+yjrwpZP9cUMsS70f1nXNK3bi0snesoyfNcSy9CdWDLEsZf+SIdaVNtQfVmiIdaUNXTrZW47dLcfI8g0FzyFFYT7+WxwslCcUukbYVcG+zh67fQbt9YNjN/iFYN9gz3dLsLebY1dqMpeGd8LjHeF/EiuQ6GZ8PXLXvD7eDb0O4jH9m7Z1MP9JjDkJuAFgRGGC8HKB5ZxjuZgjekGgz4EK/TzxastPZw50HfHD8uE50BGF1wLFReFw2EnHcSPKOxfWSUOs84ZYxwyxzhhivWCItWKIdW5I+Vo2xDpoiLU0pHxdMMSy1HtLvixlf8oQy7IeLWV/3BDLsowvGWIdMsR62RDLUl6nDbGGtW2vGGKJPyHfXqP/KPfRTwW9vtNGojcKcYgvfuk4xc/Hv4uDhZLgb/CD375TYb0iYyyT0Bc/cwzS5xL+ChbHCa08YVnLzlU25J/1Zz3ww3cvaFjr+8SaUOJ81Om4o9xIf9LBq1aOUZLJqEInp8hE3m9w8IXppxTakldkOAFxhjIsu2SIbVHor+Y+CpHbzZROzrFYF/Tq4PoErIB+30zvRgAPA4+50UZOBr02U+hG9lHq50aI57ssbgRaI8o7bi+Y/8YELG2uIQrNsBOP6avxXEOE/c3t3Zg3Kfy5dPdmJf1NkEb40WQjeScV2v3YUOSroPAwskZ0RteIzoY1ojOxRnTG14gO2/ebDencDGnGiM4thnRugTSbiM6thnRuhTTs++2EOLQ3wsdtCh/SP+2C94b9U+b9u0I/T7wa89P2tXYRPywf7lveoPBaUOJw7yvGIZ03KHQ0rBFDLNGNqaBXV24jOjsVOjsddG5T6Ihe3U7lmY9/FwcK5VmplzuC3iBxd8K7z4UdPjiM0G/kO7LpL+3o4HI6polyvZPisI3dRXFYV3dT3Bsh7p74eSrolS/SxjgpI7/jesT8tzvo7BqQzi6FzqSSb1BbqcmG68mCDsptF9HZZUgH5fYGovMGQzqoi28kOjsgH663PbOtkwfzoQ+MeeWsuTFK/0vbO5jHYkyxJXcCX4a2pC5luyvoDRJ3N9Bmnb0H4ljP7oU41o03QRzKnINmn0QWkX36Sh/26Q6IkzJJHUj+52HN8+y27vxYh/xNCPafD1DcG5W4CP8dN3T4QTlEPrvozQTkZb2R9L9IuuKn35me0foW9qXu8kQ7S3vW+hbkR/jOK3GjA/DaWpwtVorT043mdHWhVm3lgt42NaK843Hr3Up67b5BkfU9fmRdlrYwEnbwsV+OwijE3UVxYxAnPEZt9cM7uvm/2xP/WeSP9AtK+oegDP3UpU8stAcWWOtXibUl6O2TxOZ49n3nNBskQWvzBYpDnbuK4rA98Z3T2JfhXB+HNH/6T/vor7BfvCsBU/oCHAtIHzNGab8KfdtvU9+GPuH3hN1x6HsJnQjjm+T3CB2ca5Z+Mgq7E/j60zXxdaoNzdfh/utuT7Sz9l88/kF+hO+8EjdI/7VQalWaxYWFanmhUZuennb1R/iO+697lPTaGbci63v9yHpB67/uAblGYRTiuG/D/kt41PovP/1vdSGL/JF+QUn/KShDP3Uptl3zmzRb8QNhdxyO+dDX/Sa1cT9+YnmB2w0Gzc5z/4A6yf0Djlm4f3gzxPXbP4gs+u0f0E5imRBzFN5pNn6M0v8b6CP+F+ojsE8X2lG6D1/Xne5uhW+/bSb7XKvQ12yoj7lWzSZq7U7TP27fGLcNnjEO6dyr0NGwxgyxRC+mgl4dvZvo3KnQudNB526FjugVtj+7eqwUpV6KQW+QuBK863euVfjud64V5VqiOGxjZYrDuqpQHNq3avw8FfTKF2ljnJSR33E9Yv43O+jcMyCdexQ6k0q+XMJfocPvmI4mG9dcyWrpaPae69yCDsrtXqJzryEd1MU3ER300XGudfN1nTyYD+datbH3GKX/EZhrvSrGnAh628GlsiWazpYhjvWsAnGsG1WIQ5lz0OyTyKLfuVa01Vgm5D2rbyLpb6Z68uRLFLdQuTSZuuZAh83H8TOedvs4Wj/er4+D54ux7enXL9lliCW6PRUEiX5JjuKQzt0OOpq/dLn6OJoNWSsfh33Vfn0PzP9683GS5qgs6GjzG5ebj/OAkY9zFnych6jv9DP/YuvjsJ758nFw/uUrRmOwtLmSHNFO8oXeE776l+dpPnFdB/Nj1yXzdTvQ/qdX5mk4XLbzNK49Ttz39bvHSdsvcrn6MCjXtfZhkDbGSRnTfAvM/3rzYdZq793l6sM8Z+TDHAUf5uxrcJ6G9ey1NE+D6/lZfBNJ/4UhmqfZqZTf7x6V7D6O0M8Tr758HK0f1/a2a/2T5NVsD8/TaL7UPQodDWuXIRbP0yD2TqKjfROxy0FH2/fsd19Ducn9Pwatv+zXx8G9Dv34OChXtoXYxooU1+/8zlTQK99B5/Uw/70OOrcPSOd2hY7vvnqt9uOvlS91qeadknycf0Q+juTL6uNI+sfAx/mjNZmn6c+WaDpbhLhdFId+BOuGNr+T1T6tdp4GbTXbJ5wrkXTaXMkuhYZnPyLzHTjsR+zyw4/Tj0D5SNvaFHS+dX24eeDdTyzsfmTxgeah/W95rPHu+r4Dj9R3v6XR2Nfcvx9Lw1rDpWVt4TTyXFDeI8ZdKaWQL/y1GZK7COvuFKz7CEvbhc5WJAnrIcLSLBf3SFprY28K0yM/96bw82CYzM+9hPWmFKzHCEsbeQrWm1Ow9hAW5n8z5Ssm0ME0aA2LCm0Nn/W2lMLz3rCbZ+SLR2flFKzHCQvzlwmrkoK1j7Awf4XyVRPoYBocBVeBTk55p/GzP0zmp0pYtRSsA4SF+WuENZ2C9QRhYf5pyjeTQAfTTMP7GaCTU95p/DwZJvMjebP0cMirYY+SeVe80F+rHi5NrjxSnlV4LShxPIqYVejMKnQ0rLsMse4xxLrbEOteQ6w3G2IVDbFKhlgVQ6yyIVbVEEtsorYSsZXo9LsSgfnXaiViK9HBGTkcbb7h+k4e1EEcbWJe6YvGKP1HYbR5R4ypzZC5Vnww3WrkrNGRvgZ12HBWf1rki324BInDfu56eOagjU6F735nz1Cu3CejnZmlOLQbcxSHbfdb4uepoFe+bBM1PxDfufS44qBTHJBOUaEzqeQbtF1qsvHd/nlWtGhIRxs/sP5Y0NHGFmn27H6yZ5IvyZ6JLztG6d8F9uzBGHMi6G0Hl9KWsM5qfonEzUEc68a3QBzKnINmn0QW/c6eoa1m+6S1iYmgV/cuxeqa0M8HvW3Ox5hBmxPQ+kDNfkterT3dAM/cbkeUd662ucsQS8aSLt8hR3FIZ5eDjuZrePYPqrwKj2GSyhyFflfXVusfoFxrFIdtbJrisK643aJdFFuk9dusL/3225j/9eYf8KrHLkM6KLfL1T9Y7tM/4NU1Sf9t4B+cIP8A58OG1T9gPfPlH4gs+vUPcGw/A/isX5gO61DT9UB5l1NwuM2VEuhH4YPhq3+1ufWriYbWl+M71u+rFX5d7dVvX/bq6eJIT8qB75B+XpGJDx+pklGumm5VSOaaHrCOIJ2qQkfDYjvomhcv+ZFXZh9X6K/VvLjmL16tyHUt9DupnosOfvzY+85J9GnrQ8JPdLLIeNCrQ9q6GPON60jyLqluXOvZrrXFtPXA+wgrqQxJdeRaz9ZkMEZx/zjuxyMZ/ur13WlkHfYbkObX42etX+Y27WmtK3Ob5rWuaT/8ONe6UD6os+sDt+5g3SXtA3iTUlbW5XtTeGJd7nfPAWKxLrv2HBRTsFiXMT/7BWireWebthOcx6CI/8putOuT8YsO/JIDv+LA13bAanPaVYrDsWcN8P/UgX+3A/9eB/6bFHzGFLtRgLidFCdpvxljRD7y2Rt1fgUjCn5PlctuU4T+Wu001/ZDuXaaa/uUXF+tueyEaxcuYt1liCXr5353gFcq2pyGBG3+aq12gGO9cHtHOfP8FbYLnr/CPQnST6zVzmyNzqD6cpdCZ1LJl0v4K3T4XZavPLmeLOho+yG5zi3oaHslWX8s6Lh2gKO/inNUf09zVNoOcM3X5R3g98Ac1T/QHJWfr6dsd4CznqFPyLoxyA5wPE36KwN+oRLtTpavsx9uHnigeegD9d2PNOoHHtnz2Hubjz/R3H9glGC5+bCa353ALuIEDnajsI7idlH8A2FvOgxZpi38dE/Z3RGhv1bTFmlbmNkdeZPCa0GJ2w7P3JRGlHfrHFh3GmLxRSmIzVNl/R7CuEvh+cohjFcOYUyic+UQxtXRGYaP+5OW5qbp4hI8jD7L0pyk3wFuz1yM6fdSttfmIYwii0E+fGP7hJfZyMH8Encb5OPLlvBCLvxgTi6z0baDyEdgU/Q7epZLCseIr4+TPuBlhob60L4UQLtEyu8HfpXMnz8kDeOQ77wSNzoAr+XmwuJ0vd6qLLaKi/VWk9u68Mrv1gF9tr2SfrOS3vPBZHVpL3gpALbfKIxCHH+COAZx+CEqXwrg57DNSj2L/JF+QUl/P5Shn7rUhvzsR2bFkgsG8HITvnQXbRO3RT92IPvYRejniVdjftpjF+0y4x2KXLWhruTVfHc+mKzfLXqafbfAkr5H6yt2EB3tYuibHHR2KDwP04VFUViryzpRrjxFg22Mp9ywrtjHwTbNU6koX9aXfu0Q5ncdZHfzgHRuVuj4nkq9iej4uniaba6vi6fXapsk+6lJY5dTCZcuZh27SPpNMHY5Q74qX2Q8H/8uDhT6v/yMdRanW1nPcLzJuoHjFZQ5B80+iSwGGbuwfdLaxLD6Bzf54cfpH2h9YL/+AR/qNUiffochlujFVNBb39yvaLK52UFHs4+Xq3+AcuX259qaYeEf+Oi3NTo7B6SzU6Hj2z9Yq357J9HZaUjHtXVorfyDpMu8fz+Df+C6zFvS//0NHcw/IP/AT59g6x+wnvV70XdW+ySy6Nc/wLHcXQmYY0raGylO0n4T6uvvaC4T898SdMfdCHG3Upw2dtX6LcRAGqhz2M6bYXcZJP0/i/mOZHlmh465LgFT9FibJ8OxchRGIc5OfxdLEd+fBB1Amb5S3rC7TGiTRpT0PBep+R1oi26Jn7P4MNrcwy3wTubaNHkKj5dCnrcAj1nkien7lafIyDXPkwt6603zY13yvCV+dynkiTxmkafmm+dIJpge5SkyKgS9MnwjYd2iYGF757lgwR5X0rNNwvT/GWzO17d386fNt0ncjQo22t4cYWA58ko5JikO80a4f3JtN662LuGqG+24wDsVWmLftcu7/a4RlOvaeEGC1sdz/591DoD7f9yz4NoKjjLhoPkGIqdIty7AdmtOh89IR3BZj1hndig8ar7gnSm4/eoMj2Vf6zrDc0qoM6xPrwWdQfvNOrNT4VGbX0w7ZpR1Rts6jz4764x2QPJr6ZKnQfdQSBx+toIy4aDpDK7n9qMzaQfqu3QGL2bi/TRvSsFlndH2ZGntS3RG25Pl91KNcmtS4VUC65NWv1kPlea5Ku2TNE2fUCYcNJ3BCzf60Zm0431ZZ7T5NG3rufaZpbYvT9Jrx6KiPNjOaJ9tTSj5DO1MbVLhVYLE4eeRvJcSP+XkPkY7zlHi8IgF3jeFRyzw8bYYNJ0ROfWrM9pRv1ntjOTVjtRI+zSXdUb7vDmrzkhezzozVEdzSdy3QtxrTWfupyMi0UbzMU+ljDQlfdpn5qx/mr6ifXfpHx9BKvlwjg355+PmJH0jHuNG9fHN+FmbkxA5+Z2TKDa1OQmU61jYXW6XDKPQb5sXmRWCXntcpjjtuEjXXlXt2FNr30j8hdeLb8T9XNbLyIbVN8LxE9usuxQetYtZtM/2tcs9XXYM5c86g3ohef0eg1gpTSq8StDqnvsyrHvWC63utXEW6yG2fb5GAYOmMyKnfnVGswdZdQaPB3gug85o30VdrjqTxV683nXmgSt2pi+d4bmey1FnNpPO3KHg3gbvsnxPgWuTvA6B60L8vSbmG9Z9CLzWoF0Wqc03834P1BOUCQdNZ0RO/erMGwkX6ycKrnUIyRvpzDPxZv080Yr+DvSNT6PRLFVLM3OzzWq1MVfjC1WjIPq30QP9aq0+s1ifKZXmqqVmtZRKP5L/tq3d8hyFPFh3k8o7wRX9H6O886ssB4s1R/SCQN8rKvTzxKsxP+29omPED8uH94qOK7wWlDipg6kguU5yFIc8jCo8FJT8oxmwtPJsiv9FYf+BPfuab63v3f/E7mZAgXWF2/S6BPo5JX/gwMI8PtrVYm16YfFi4yo2S6/o41q361pjYbY4U67PNRanG5Xa4lrTby5U52YW5hZrxUZxrjRX6ceuTAa9upVL+BuFEQd2QcF6NHz1r9ggbEeWNkjw1xN/Rvhtv3BMkZPQ3uClbK1WVvsq9POBV3vftq8biB+WD3/rOuFHPs3oqEbRPbRZ44psmI/1xGPeE4/anKnwJHGjECd8RGn+6MZuHtd54tFvG201NB8F9yL/p+0dulg3OGeNer8O4jH9f4Zvlf7f+Hkq6O6X0E5thPj1Srz8lvpap6TFZ/4tvLNcMb3o5HhCWceprJL+72F+/j1bdUyUH/K1LgHzH5Q5f8HEvWiuNi/pNyrpsY0JP1NBb9vcSPmQ94mgO+A7rX5ylJb7YOmnMF/S7wkFJ4mHDQoO95OMyTQ1X4/HUiMKHWxT2OdPKPQN+4ea1ldK0HztHMVh2T8UdtJx0MauUqaovP+C1qswHfOjtTVL30jej8F7psv++Dilxf6cZTZmwGNBoTNOuOsd/OcIZ1TJNxno7VH7m5XfnMKvazy8WjqI9eGwmw7Wc9c1hvRdAtrxESXvp8NOPKa/a0cH8474Oa1PY1uCZfhI2HnHNpv9WG6TvK7NfRenwX4c0785Lgf2XWwfECt6VyJ5aj6C5vexj/AekGeV5Kn5AFNBr2xYhyeIFvrH0r+wDL4N+JjbkUxL5DrpKGP07jt26OmQB0zHGFrfKRhau5Z8Uwpf3PbYdow7aGj9mUZjjOIGrR+t30ZfQ/NhtHjsz5EOv1unpE/zP/IJ2BruuIKj2fkNFJdT4tiGYXnRhrFvoo3J0DZq7S6p7ly+t8Z7Fr9q3MG7Jj+0Q9ZzOcXZYqm4OFNrtUqN6fpCNW0uR96vD7vL9cpfeDcG5YrCBkxPcRMQNxp208/Hv0eBDmIJH2OUvgF1HYVxyCP5Cwr9caLfxbfyDnWNsUaUd5I+qtOPxTz6mKMr1+Zm63MLxVK5VS5XZqfT6lWTE84dREFkjXUxrpRtjNLvhj7nMfoGdUyhF6U74kiXS/j7CobybjTsfqfVEequpBfa+bCXR4nbCHFjRGdT/BvlhVjCxxilf4p0F/VN8hcU+huIfhffyjvW3Y1K+o1K+qh+9pM9wrJbz/29QpPw8R3zdsRju5quTpdmZ+uzi9OLrbnq4sJaz70vzk235iqVhVJlrtGcK02v+dx/tbLQKrUuzv9XWsXKbGnN1z7qxfLFtcyFhVqpWZ+ba615+UulUmu6ujA7vVi+OMW45msv1dZMfbo1U6yVG9VmuVFfa/r1meZcdbpSXqy05uqzxdm1pr/QmF4szlVKjXp9pjgzPbuatSeeI4mCzFF5WiPOfL5R204Hvb6sjzWVEeKH5cNr1tras7YOJ+fo55S4LOvSvrGmgt765nkJTTYjDjpcV1HIsk/C17xoVp0T+mu1TyLrvgKea8S8PKaMAuuJth9DWzt4rWBJ/ihoc8WPhN1xWMcs06y6KnOLbEunguS6EdoylsX3Ywq/PPf4e3TmL88nzse/iwMG7juQluc9TNPafJmESaXcXO84R8J1y+veGIf9Me+vwTBCv1EWEe1/mWGfnqYjOYobV8qhzc9wX5NT+HKtybvm+bR+Qs5szxFmELjncbQ58jR/hNc8ouBZ9zP7I0I/H/TWl4++IW2+jHXdtd6pzc3mKA7pbFDoaFjrDLFGqTxYH6wLnnzBzH6C0M8HvTL1oQtam8spctV80yx7xFz+SFZ/ctixXGOeLPWu0WH9RzrYv+O65F/TOprkw3U0zMvn/kn6wzd2MP8Tzedr9T+l8Mx+iqZn6xzl1+hMKPnm47/F/kKVX/jdz1ass2+AQeI2KmXOKek1v0H47veMVPQbNlIc9kObKA77zEmKQ9sr92RoOsI+S786gvldujg+IB3Nf/Ld5seIju+9IC4/abV0tHU2bT/QoHRQFzcQHcyHtvLqGzt5MB/aSsz7YNiJx/S7wVZuoz2dfvYOF+d4DIJBG4OwzqKdYT3bBHGsG5MQx3uyMWj2SWTR7xmp2A/kAZ/by4iS1zUf5GnMmdnnfz18NxMF9qe0fQTa2ML1DY4Flqs/4P1t/fYH2nym57HkLPetGDR70O8Z68J3v/4DynWC4rS2u1q/Q5uvYB9ZG9fiO1d/u95BZ3RAOq49k776wbXyU3hs7eObI62fWit/KMl/eIj8B20PKOblsZak/yj4D+8h/8FTn9CXLdF0NqtvwbqBvgXKnINmn9r7goL+/AfUCSkT7qPV5pW0fjEX9NpYnodCetrcq+QdNv+Q61cbh2p1yPWL/iG3180QhzLhkOY79vPtuuY/YDreF5hTeNTauqYD2pyRpNe+r+E9jFHQ9rtK3mGdn3C1bU0v2L6iXrAeTkEcyoRD2nxIPzqj2YOsOoN7tmV86VqrkPfaHOSYQtPFo+YXZ7VZvN9a+yaLaWM/h/wnjZNXYnmknTkncvJ85lxNO3MO5TpGPLlkGIV+2zyvsWv2WPO3eH5DWxvGuWDrvUEz5cVavVKbKy42azP16Zl+9ga5vifI4ndL2TV/Ogq81i3pP0d+lScbqq51J+1Vl/2q3HbZT5T0vwp+4g+RbeH5TYzTxgSub1G0bza5Htr7UQO9LXAZJP0XM9oAKY9nG1DVbAC2W7YBru9eo8A2YJOSHvtQ/j4jyT/m/kCTOfcR6L+4bD6PR74EdcR3YaBe54l3bSytzZfwXJL2vWzEyx9Sm/W0Jj6jjcMlaOsZOYrDdsI+EZ87gHHaOCmn8KD5NiKLfveIWNgJ9Plf4S/s5etStFvsn7nduvriIOhtt2ntXOYBCkFvXbJ+a31BP20mCvcTPe1bPWwzG4HWeNhJa1gH7fOhRNYjwPNo2OFd6GvfKEm69rjYD69F4VW+y5B+C2liWdZRen7m76D+CsaHWEasR9f3TNo3IfitjPCofT+0MewPawNhrR8AS/jSvpNZv0q+NKxxwurn+6//CdqEti8saS/Fv84wv+faSyHp/xb8tv+V/DbLPXtptpptXluWgd5Xzce/i4OFzPuehH4+6O1XfayHaX2CNoYW+Wz0w0/V5StqfVR0LtLmoLfOkD/B0sblrnlJ1vU02RSU/LwXFOvYtYeU+8Yse0hR3zcG7vFljrC0dqz5SJostLkZHq/9V2j3V8eXSrm+idbaL7d7bc+xxCXtOU7SLdfcxaSSXhubCG3UvckMWOsdtDcr6ScdtJEvzMu0k9qI5seKbC7FHBT6nuzHusaTUcgiS60eC5QeZae1Y9f81EaKw/bHbVxbH8b2os1x4bhW+uj/BszZHbEVxgQA",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "_compute_utilization_rate",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "precision",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "deposit_accumulator",
            "type": {
              "kind": "struct",
              "path": "accumulator::Accumulator",
              "fields": [
                {
                  "name": "value",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "last_updated_ts",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "borrow_accumulator",
            "type": {
              "kind": "struct",
              "path": "accumulator::Accumulator",
              "fields": [
                {
                  "name": "value",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "last_updated_ts",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "12348881442450494403": {
            "error_kind": "string",
            "string": "Function _compute_utilization_rate can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_compute_utilization_rate"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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V+jrv8Jc/xX206+4n0Z1p7m603zV1cfXXSJ93SXS110iT+4XFk/TdaeZutNs3WlUd5qrO+3k+X+3X1hDeHzlM/drMUHtT+sEY/74FSe3f1i/Ql//Feb6r7DXfwVd/xXu+q/w139FuP4r4vVfcf2vO13/607X/7rT9b/udP2vO13/607X/7rT9b/udP2vO13/604f/7p/naaVqjtN151m6k6zdadR3Wmu7jRfd1qoOy3WnVaXJbouS3Rdlui6LNF1WaLrskTXZYmuyxJdlyW6Lkt0XZaYuiwxdVli6rLE1GWJqcsSU5clpi5LTF2WmLosMXVZYuuyxNZlia3LEluXJbYuS2xdlti6LLF1WWLrssTWZQnVZQnVZQnVZQnVZQnVZQnVZQnVZQnVZQnVZQnVZYmryxJXlyWuLktcXZa4uixxdVni6rLE1WWJq8sSV5clvi5LfF2W+Los8XVZ4uuyxNdlia/LEl+XJb4uS3xdloS6LAl1WRLqsiTUZUmoy5JQlyWhLktCXZaEuiwJdVkS67Ik1mVJrMuSWJclsS5LYl2WxLosiXVZEuuyJNZlSarLklSXJakuS1JdlqS6LEl1WZLqsiTVZUmqy5K63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZqT3mvaH967NdB05rSTLAlhPy2Zb6flVpxl2s/iFo4bKxw/VjhhrHDiWOGkocI568X3CkePFY4ZKxw7VjhjXZXTWFflNNZVOY11VU5jXZXTUFdlq4a6Kls11FXZqtZX5ZdbMd3isYPFQ4PF4waLxw8WTxgsno+vzffTUtVpWtWdlr0m3e4rbkt43O7euQI07YPdd/f1wR8L62RfMYt2W0TmdkW0hc/2Su0LYCl7vEx+G8s9fjN4/E5tAnhn7XP8Vnj8JDx+Jzx+Lzz+IDz+KDz+JDv+/CMpguIfff4txS98/jXC518jfP41wudfI3z+NcLnXyN8/jXC518rfP61wudfK3z+tcLnXyt8/rXC518rfP61wudfK3z+tcLnXxI+/5Lw+ZeEz78kfP4l4fMvCZ9/Sfj8S8LnXxI+/5Lw+dcJn3+d8PnXCZ9/nfD51wmff53w+dcJn3+d8PnXCZ9/nfD51wuff73w+dcLn3+98PnXC59/vfD51wuff73w+dcLn3+98Pk3CJ9/g/D5Nwiff4Pw+TcIn3+D8Pk3CJ9/g/D5Nwiff4Pw+TcKn3+j8Pk3Cp9/o/D5Nwqff6Pw+TcKn3+j8Pk3Cp9/o/D5Nwmff5Pw+TcJn3+T8Pk3CZ9/k/D5Nwmff5Pw+TcJn3+T7PmXlOz5l5Ts+ZeU7PmXlOz5l5Ts+ZeU7PmXlOz5l5Ts+ZeU7PmXlPD5Vwuff4df/6oUv/D5V/j6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXvyLh61+R8PWvSPj6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXvyLh61+R8PWvSPj6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf/4qEr39Fwte/IuHrX5Hw9a9I+PpXJHz9KxK+/hUJX/+KhK9/RcLXvyLh61+R8PWvSPj6VyR8/SsSvv4VCV//ioSvf0XC178i4etfkfD1r0j4+lckfP0rEr7+FQlf/4qEr39Fwte/IuHrXznh61854etfOeHrXznh6185JXv+dcLXv3LC179ywte/csLXv3LC179ywte/csLXv3LC179ywte/csOvf3V8tA9JP8afO3iL2kd/fHB0X2Mdfa7mHOvo8zrnWEevATjHOnq9wDnW0WsLxrGOvg6YSy4eYzWvx0ohbXHcbtDG/WCTYjZsHfaoLe1HW5u+2Axe43RlM3j91JXN4LVZcGS+jg5e+ddsrN2OtfQQdO5Q590Wsgvq4eBf9d9zzCntn6xU/Hb0HSMBIwfGwatPKRgHL2ylYBy8ZpaCcfByXArGwSt9IRhHX8xQCsbB/YYUjINbEykY4WJYMBIwcmCEi2HBCBfDghEuhgUjXAwLRrgYDoyjLwkrBSNcDAtGuBgWjHAxLBgJGDkwwsWwYISLYcEIF8OCES6GBSNcDAfG0RfWloIRLoYFI1wMC0a4GBaMBIwcGOFiWDDCxbBghIthwQgXw4IRLoYD4+jbE0jBCBfDghEuhgUjXAwLRgJGDoxwMSwY4WJYMMLFsGCEi2HBCBfDgXH0TV6kYISLYcEIF8OCES6GBSMBIwdGuBgWjHAxLBjhYlgwwsWwYISL4cA4+lZZUjDCxbBghIthwQgXw4KRgJEDI1wMC0a4GBaMcDEsGOFiWDDCxXBgHH3DQSkY4WJYMMLFsGCEi2HBSMDIgREuhgUjXAwLRrgYFoxwMSwY4WIYMPrRt22VghEuhgUjXAwLRrgYFowEjBwY4WJYMMLFsGCEi2HBCBfDghEuhgPj6JtfS8EIF8OCES6GBSNcDAtGAkYOjHAxLBjhYlgwwsWwYISLYcEIF8OB0cDFsGCEi2HBCBfDghEuhgUjASMHRrgYFoxwMSwY4WJYMMLFsGCEi+HAaOFiWDDCxbBghIthwQgXw4KRgJEDI1wMC0a4GBaMcDEsGOFiWDDCxXBgJLgYFoxwMSwY4WJYMMLFsGAkYOTACBfDghEuhgUjXAwLRrgYFoxwMRwYHVwMC0a4GBaMcDEsGOFiWDASMHJghIthwQgXw4IRLoYFI1wMC0a4GA6MHi6GBSNcDAtGuBgWjHAxLBgJGDkwwsWwYISLYcEIF8OCES6GBSNcDAfGABfDghEuhgUjXAwLRrgYFowEjBwY4WJYMMLFsGCEi2HBCBfDghEuhgNjHNzFuOTihjHqVMAY4nawjQ9h25QNm8wWiKZwKBRj7qN1VNtH63QcbHzuo62yej/ahSMQrTJHR+23QKJRxxhNpMzRFJT9OprCrxTZPtv5L0kHd1SQ9HNJB3d3kPRzSQd3mpD0c0kJks4m6eAOHJJ+Lung3QBI+rmkg3cmIOnnkg7eJYGkn0s6eMcGkn4saUL3aDpJ0T2aTlJ0j6aTFN2j6SQlSDqbpOgevScp6bR9NEVTkNQpvd8BVXRIqjfqaPD0oI4eTA/qaJP0oI5ORnvqQaHZ0IM6+gE9qMOy96AOV92DOoF6B+rwpj2ow5v2oD6UN72HNJRxu4c0lKv5HZIequS/hzRUPXwPaahi8R7SUJXUPSQaL6Sh5uB7SENNUPeQxrt66/Gu3nq8q7cZ7+ptxrt6m/Gu3mPtcX8Pabyr91h7r99DGu/qPdae4PeQxrt6j7VX9e+Qxtr3+R7SeFfvsfYjvoc03tV7rH1y7yGNd/Uea//We0jjXb3H2lf0HtJ4V++x9ru8hzTe1XusfRjvIY139R5rf8B7SONdvcfat+4e0nhX77H2U7uHNN7Ve6x9vu4hjXf1Hmv/qXtI4129x9oX6R7SeFfvsfbruYc03tV7rH1k7iGNd/Uea3+Te0jjXb3H2nfjHtJ4V++x9oO4hzTe1XusfQruIY139R5r/fx7SONdvcda1/0e0nhX77HWG7+HNN7Ve6x1sO8hjXf1Hmt95ntI4129x1o3+B7SeFfvsdazvYc03tV7rPVE7yGNd/Ueaz3He0jjXb3HWk/vHtJ4V++x1jO7hzTe1Xus9aTuIY139R5rPZ97SONdvcdaT+Ue0nhX77EWy7iHNN7Ve6xlFu4hDXf1jmO9oH8Pabirdxzr1e57SMNdvaMa7uodx3pj9h7ScFfvON67lnG8dy3jeO9axvHetYzjvWsZx3vXMo73rmUc713LON67lnG8dy3jeO9axvHetYzjvWsZx3vXMo73rmUc713LON67lnG8dy3jeO9axvHetYzjvWsZmd5pUuEISYeHkO5f8vH1+Pdpn78jcz9N151m6k6zdadR3Wmu7jRfd1qoOy3WnVaXJa4uS1xdlri6LHF1WeLqssTVZYmryxJXlyWuLktcXZb4uizxdVni67LE12WJr8sSX5clvi5LfF2W+Los8XVZEuqyJNRlSajLklCXJaEuS0JdloS6LAl1WRLqsiTUZUmsy5JYlyWxLktiXZbEuiyJdVkS67Ik1mVJrMuSWJclqS5LUl2WpLosSXVZkuqyJNVlSarLklSXJakuS1JVliSl6k7TdaeZutNs3WlUd5qrO83XnRbqTstmCfn9tG87zhynpfxp+jjNqP95bbdv916/Dr4Z6/3Ym9PPHJvi1itI6fuxv8PJ31PqF44eKxwzVjh2rHBorHDcWOH4scIJY4UTxwpnrKuyGeuqbMa6Kpuxrsqm9VXZb8dqpUwmHhosHjdYPH6weMJg8cSx4mFawPHlDarEtCRj4UuoxZfw3IglfXyJSw9f8tkNyXtIfryQwnghxdYhkU7b9iBkMpmUBguIaclExoCaP0BTuli2Xy+xGJEdLiIaLiI3XER+uIjCcBHF4SJKo0XUfp3EYkTDXbPdcNdsN9w12w13zXbDXbPdcNdsN9w12w13zXbDXbP9cNdsP9w12w93zfbDXbP9cNdsP9w12w93zfbDXbM7rIrolNo+21EqffZt5t0+OkX9MAD6GkAafAAx2e1oZb8PINPb1X57oyAalQpHU9zblRQf+sbWffVQOqzmKAiOBpxzOAZwzuFYwDmHQ4BzDscBzjkcDzjncALgnMMZvYrtCgcV8jmcuEyFfB/uMjXvfbjLVLH34c5Vl96C3YfrTOHocLvR+3V0SMkWjrZhC5ssHceq3BCPMIyx9vHgO3QC9PbQ56qjhUCfqz4XAn2uul8I9Ln8hBDoc/kUGdDTXP5HCPS5XJgQ6HN5QSHQ4Ug7QCdAbw8djrQDdDjSDtDhSDtAhyPtAB2OtDV0rxQcaQfocKQdoMORdoAOR9oBOgF6e+hwpB2gw5F2gA5H2gE6HGkH6HCk7aFrONIO0FGnXwHdHdC9f4aO6uUC6IH2IQZHz9BRvXSAjuqlA3RUL+2hG1QvHaCjn94BOvrpHaCjTu8AnQC9PXT009tDt0PtWf18tHf7C8bePbQxkvmKf6gNriviJ+HxD7V1dkX8Q+2zXRH/UJtyV8QfhcefZMdPSnj8Wnj8wudfEj7/tl9Pnzl+4fMvCZ9/Sfj8S8LnXxI+/zrh868TPv864fOvEz7/tt8bgTl+4fOvEz7/OuHzrxt8/v2168QWfwyZ+Aeff0vx+8Hn32L8g8+/xfgHn3+L8Q8+/xbjH3z+LcY/+PxbjH/w+bcY/+DzbzH+weff2z0783V08L+OOOLP3Be027GWHoLOHer8vu+HC+rh4F81ynPMKe2frFT8dvRvjGHwy8gYGK1KafvkbzyyR4c94mPvVtp4D37Zm4734Jfp6XgPPq1MxxvTYFveg9vm2XjHwW3+dLwHb0tMx3vwNsp0vAdv+0zHm8C7KW/4y7a84S/b8oa/bMsb/rItb/jLprwT/GVb3vCXbXnDX7blDX/Zlvfo9aCJfo/+YWvKLG99I7fFEfzDa602e4dcbW+1OlLfjr2TGb1y60dm9BqrFxmtRq+G+pEZvW7pR2b0CqMfmdFrgX5kCGROyIzev+1HZvROaz8yC9fAnjYyKRaOJeM2jPR7eZYH0/Gbo153Jov7wY/P2uaPNdbsa6USFZfT0f5YTuch6PzRFPe3biiaI9et+8p1ve6cKkcjgkbDa7RunSFHo3UrHjkarVt7ydFo3U6oHI3W7cmK0cis2x2Wo9G6fWo5GqHPML5G6DO01ehOnUC9A3X0AnpQh7u/gPoo24m93MNNG3QN1tUe3Yh1tUeXY1ntLbon62qPrsy62qPbs6726CKtqz1B+2W1R0dtXe3R11tXe/T11tUefb11tUdfb1ntR9+IEdpfqD36eutqj77eutqjr7eu9gTtl9Uefb11tUdfb13t0ddbV3v09dbVHn29ZbUffYN3aH+h9ujrras9+nrrao++3rraw99PrL07tPf+WXvU+fNqH2g71gRHT9p71Pnrao86f13tUeevqz3q/HW1J2i/rPa4f7+u9vD362qP+/frao/79+tqv25fL5ltjMm5wrFOhX0bFa0eM+VrZ5Swbo+Ml+O6/SZejuv2bng5LtwHidtmUFopX5ocj8U8b/cOQ2ly5F2KOBBEGl+khTsLckRauAUgR6SFvbockRY21XJEWvipFjEixYUfP5Ej0sLPicgRaeEHOuSIhI6DAJEIIrUV6Y4dPYQu2NEV6IIdPv8K7DJetonoHywsPvoS64qf0O9YWHz0URYWH/2ZhcVH32dh8Qnirys+uloLi4/e2sLio8O3sPjo8C0sPjp8y4pvFDp8C4uPDt/C4qPDt7D46PAtLD5B/HXFR4dvYfHR4VtYfHT4FhYfHb6FxUeHb13xNTp8C4uPDt/C4qPDt7D46PAtLD5B/HXFh8+fWfyXmyMZg2p/YvFfr6B7kxbirys+qv2FxUe1v7D4BPHXFR/38xcWH/fzFxYfPn9h8XE/f2HxcT9/XfHtVD7fG9rFD0U9k9qONsnZwtGk1JYrpOgxsewXyakm0I9IWqX0Hkgscv9suzHW9U2NnWqmm1alqaakWVWiqe4OTavSVLdxplVp3TpMkkpT3RiZViWCSgJUmupWw7QqTXVPYFqV0HuQoBJ6D61VunNHN6ELd4f+QB/ucPyXcJfxwL5DJ2Fl9dGhWFl9gvoLq4+Oysrqo1OzsvroAK2sPjpLK6uP/tbC6nt02VZWH72+ldVHr29l9dHrW1l9gvoLq49e38rqo9e3svro9a2sPnp9K6uPXt/C6gf0+lZWH72+ldVHr29l9dHrW1l9gvoLq49e38rqo9e3svro9a2sPnp9C6sf4fenVv/13iuRoP7E6hfW5Yyo+VdWHzX/yuqj5l9ZfdT8K6uP+/sLq59wf39l9eH3V1Yf9/dXVh/391dWn9ZVX6u4BaJdKBxNIW2BUCT1cPTXLixp4b4ZM8mFe1DMJBfu5zCTXLg3osNO0pgSyQ/3KuNd5zgt3MMQo9Kt6oJKAlRauCcgSKWFvbsglRb22IJUIqgkQKWVfbYclVb28HJUWrk/IEcl9B4kqITeQ2uVfnPX6Cb04Y7+QB/ucPyXcBfxZo7V6CSsrD5B/YXVR+djZfXRUVlZfXRqVlYfHaCV1UdnaWH1DfpbK6uPLtvK6qPXt7L66PWtrD5B/YXVR69vZfXR61tZffT6VlYfvb6V1Uevb2H1LXp9K6uPXt/K6qPXt7L66PWtrD5B/YXVR69vZfXR61tZffT6VlYfvb6V1Uevb2H1CX5/avVf7rFkCTX/zOq/XnXXEmr+ldVHzb+y+qj5V1YfNf/C6jvc319ZfdzfX1l9+P2V1cf9/ZXVJ6i/sPqD+32X3CZRiLqgvg1x1zM+hG1TNuzbDc4t6tvh+9ExZg6+gd6QxwcebsM4uHGWgnFwByoEox/cyknBOLgnkoJxcHMhBePgVfooGJ3bRuh8DiMBIwfGwe8RD4NxL9VdSBmMg99slYIRLuY9jGmbYryyGYxwMSwY4WI+xaj1M8YAF8OCES7mLYw+bEB8VBmMcDEsGOFi3sMYt6B9ogxGAkYOjHAxb2G83XfZwtAxgxEuhgUjXMynGI3PYISLYcEIF8OBMcLFvIcx7bfLVWamjnAxLBjhYt7CGPcfdczN1BEuhgUjAeNbGK3dMJLJYISLYcEIF/MpRpfp8ES4GBaMcDFvYUx6OzZly2+4GA6MCS7mPYx2A5Iocy8mwcWwYISLeQ/j/gxP8rkfNVwMC0YCxg8xhkxrIsHFsGCEi3kLo1Zue6TsFmimAE/wMUwgF3YyZLZAND28jpYFaXXcQFqdjoN/L9H0fLQKtI8xHs01q1U2bL25zdtNb/Xt6LtIC/skKSKRWtiFyRFpYY8nR6SFHaQckRb2p3JEIog0vkgLe2s5Ii3s3OWItHBXQI5I6DgIEAkdh/FF0ug4CBAJHQcBIqHjIEAkdBwEiEQQaXyR0HEQIBI6DgJEQsdBgEjoOAgQCR2H8UUy6DgIEAkdBwEioeMgQCR0HASIRBBpfJHQcRAgEjoOAkRCx+ESkfaXGq12oSBSPDabieZh15v8hjAU1CYpBX2sbWCd/5IU/YnpJEU3YzZJLXof00mKTsl0kqKvMp2k8I7iJN0XOrz96TOSouKVJmlU21vnFI3KSIqKd2hJf4tEqGEFiISqVIBIqDP7izTILs5HGMZY+3jwPVVwFxGp8maqEFIFqfJeqsAVI1XeTBXc10WqvJkquLuMVHkzVdDDQ6q8mSroDSJV3ksVhw4lUuXNVEGfFKnyZqqgW4tUeTNV0K1FqryZKoRUQaq8lyro1iJV3kwVdGuRKm+mCrq1SJU3UwXdWqTKm6mCbi1S5b1U8ejWIlXeTBV0a5Eqb6YKurVIlTdTBd1apMqbqUJIFaTKe6mCbi1S5c1UQbcWqfJmqqBbi1R5M1XQrUWqvJkq6NYiVd5LlYC+ClJlSxV3pIr3z6kCB4RU+RIm0HasCY6eUwUOCKnyZqrAASFV3kwVOCCkypupAgeEVHkvVSKeV0GqvJkqeF4FqfJmqqCvglR5M1XwvApS5c1UIaQKUuW9VEG39r1UMWZbxNrah62Y8qnCvEB2RJ9UgEjoUAoQCb1BASKhKze+SAn9MAEioRMlQCT0gASIhO6LAJEIIo0vEjoOAkRCx6GxSHfs6CF0wY6uQBfs8PlXYBfxRoFT6B8sLD76EguLj37HwuKjj7Kw+ATx1xUffZ+FxUc/aWHx0dVaWHz01hYWHx2+dcXX6PAtLD46fAuLjw7fwuKjw7ew+ATx1xUfHb6FxUeHb2Hx0eFbWHx0+BYWHx2+dcU36PAtLD46fAuLjw7fwuKjw7ew+ATx1xUfHb6FxUeHb2Hx4fNnFv/lli7OotqfWPzXK0Q6i2p/YfEJ4q8rPqr9hcVHtb+w+Lifv7D4uJ+/sPjw+euKT7ifv7D4uJ+/sPjo8L0nPtldfIq6IL7V+zKbVtMDv2wcgTbYOviHg0PmYE/0dextyn489K4mWnYzqUlQU5SauzD+YXrY1URTTZia28QZVOa3iS7Zm2rqdKhpCmo6pTcgTlF4VPNOHe2pHtTRF+pBHQ2ZDtQdOiE9qKMF0YM6vH8P6vDoPagTqHegDs/bgzq8aQ/q8KY9qMObXkCdUoo7dZf+52VXjVzautjkST1LBCM7ukQernd4iWCRh5cIfnp4iWC+h5eIINHoEsHWDy8RegDDS4SGwfASobswlkT2WSJ0F0aXKKC7MLxE6C4MLxG6C8NLhO7C8BKhoquQyBck0rQ/ha3JxtcSeUXbR3uV1OuD9e2I7ejb384/K4oCcDJFI+rF2RRFeTmboqhGZ1MUxetsihIUlaxoelYUN95mUxT36WZTFLf1ZlMUPaPZFEXPaC5FvVp5HlXxRNE7mpUnpAKala/sBTRTXSKjox1NUCU0+rjYaHOsmWZ1boU12leFIzpWq7Eqd6zVx9I25tuxv5nrqRrfQphP1ZoWwnyq5rEQ5lO1d4UwJzBvznyqFqkQ5lOZLyHMp3J1QphPZReFMIcPbc7cwIe+yVybnTkVmPfawdMbONyZ1IR3nklNuPKZ1CSoOZGa6CTMpCZ6FDOpie7HTGqirzKTmujYTKSmRS9oJjXRC5pJTfSCZlITvaCZ1CSoOZGa6AXNpCZ6QTOpiV7QTGqiFzSTmugFTaQmoRc0k5roBc2kJnpBM6mJXtBMahLUnEhN9IJmUhO9oJnURC9oIjUd/KYoNd2h5q8Fgv6oJmpaSWoG2o41wdGzmgQ1J1ITNe1MaqKmnUlN1LQzqYn7mzOpifubE6np4TdnUhP3N2dSE/c3Z1Jzrl5Q2j86PeqTVdPun0wPYeSX384eqil9QaSZICa7b9yofAli1H4LJBqVColLcV+YnKJ5+Lm5r9XD/VTtj64kp2o9dCU5le3vSnIqy92V5FR2tyfJMJXV7EpyKpvXleRUFqsryansTVeSBJJMJOFxciTvbOBaztnAh5yzWdhZHM/uReNM4erU7RHCsLBjkaFQXNgJCVFoYYclRKGFnZsQhRZ2hEIUIig0uEILO1ghCi3so4UotLCbF6IQegqjK4SewuAKJfQURlcIPYXRFUJPYXSF0FMYXSGCQoMrhJ7C6AqhpzC6QugpjK4QegqjK4SewtgKBYWewugKoacwukLoKYyuEHoKoytEUGhwhdBTGF0h+KHuCr1cLDRo1HK9FXq9hEfQqOVGVwi13OgKERQaXCHUcqMrhPtDoyuE+0OjKwQ/NLpCuD80uEIG94dGV2ioWu4e0lDFyz2kvrO1LeWxjntq6khxP5rMV/xRePxJdvxWCY9fC4/fCI/fCo+fhMfvhMfvhccvfP61wudfK3z+JeHzLwmff0n4/EvC59/Om23/PH7h8y8Jn39J+PxLzedfq+3Wd7E6qcJnG2v2Jz+IdKH9w7sIaqAEOKdw2m+3LAmOBpxzOAZwzuFYwDmHQ4BzDscBzjkcDzjncALgnMNBhfwCzjIV8u/h+mVq3vtwl6li78Odqy6V8XKNn6veFQKdAL099LnqcyHQ56r7hUCfy08IgT6XTxECfS7/IwN6mMuFCYE+lxcUAh2OtAN0ONIO0AnQ20OHI+0AHY60A3Q40g7Q4Ug7QIcjbQ89wpF2gA5H2gE6HGkH6HCkHaAToLeHDkfaATocaQfocKQdoMORdoAOR9oeekKdfgX018tQJ1QvF0AvrNOVUL10gI7qpQN0VC8doKN6aQ49KvTTO0BHP70DdNTpHaCjn94BOgF6e+jtHemtHbFBN9GUoB/vZN7OCyXorC8vR+UB5xxOAJxzOBFwzuEkwDmFoxXgnMPRgHMOxwDOORwLOOdwCHDO4aBCfgFnmQr5Ptxlat77cJepYu/DnasuFfEcQjRz1btCoM9VRwuBPld9LgT6XHW/EOgE6O2hz+VThECfy/8IgT6XCxMCfS4vKAQ6HGl76BaOtAN0ONIO0OFIO0CHI+0AnQC9PXQ40g7Q4Ug7QIcj7QAdjrQDdDjS9tAJjrQDdDjSDtDhSDtAhyPtAJ0AvT10ONIO0OFIO0BHnX4F9JfL+0SH6uUC6IU3WB2qlw7QCdDbQ0f10gE6qpcO0NFP7wAd/fQO0FGnt4fu0U/vAB399A7QOzjStB1s7cMqSb8++x6SGy8kP15IzSsgUnb7bFKu9Gt5dfR9AFH6ANLYA/hlwr+O9jHoh0/+HX77PZB5w9eywzeDh5/UNiH5ZMJT+FZ2+CQ7fCc7fC87/MFn3lL4g8+7pfBHn3Vfhx9Hn3UL4Y8+6xbClz3rRtmzbvv98HjDlz3rRtmzbpQ960bZs26UPesm2bNukj3rJtmzbpI96ybZs26SPeum4Wdd2ttUyT2HP/ys+zr84Wfd1+EPP+u+Cj+p4Wfd1+EPP+u+Dv/iaev+JXj46dfRzPdsrdkWVTbWuseD79Dx8FMH6Hj4qQN0PPx0BXRtd+jGP0GfbIMRIdDx8FMH6HgdpwN0vI7TAToBenvoeB2nA3Q40g7Q4Ug7QIcj7QAdjrQ9dIMtztv3Xgy2OO8AnQC9PXQH6O2v6R7Q20MPgN4eegT09tAToDeH3mFjFEDvsDEKoFs40g7Q4Ug7QCdAbw8djrQD9OZ1uol2G6pV2hY+2yUXNzBRH9vTJ5PjcvvhbmCUP8jY5OU2atrvLQGFPlOo/UYUUOhDhTQUGnsear/FBRT6UCELhQZXiKDQ4Ao5KDS4Qh4KDa5QgEKDK4SewugKoacwuEIOPYXRFUJPYXSFaCaFjqV1bQyqoJDWKm1Ra/Ogp86BJG025vRwrFIj9fDcVN5peTWn8lnLqzmVJ5tfzcK8OZV/W17Nqbze6mr6qXzh8mpO5SGXV3Oqe9jLqznV/e7l1SSoOZGa6AXNpCZ6QTOpiV7QRGqGqfxmiHFX8yHsEzVpf99DUzjQxJj7aLN3SK39dcTG0Q99A+11WzdMZU8h/mfiT+VmIf5n4k9lfiH+Z3M+Qfx1xZ/KWkP8z8SfyolD/M/En8q4Q/zPxJ/qmQ+I/5n4Uz0iAvE/Ej+iw7ew+OjwLSw+OnwLi48O38Liw+e/J76ODwvE+YL49tjJ1uqHvWnzt3+F3AmI6AogVd5MFfQQkCpvpgo6DkiV92qVhP4EUuXNVEE3A6nyZqqg94FUeTNV0ClBqryZKoRUQaq8lyp4zgqp8maqoFuLVHkzVdCtRaq8mSro1iJV3kwVdGuRKu+kSlAKfZX+qaL9kSoqFcSnkLajb38ekVjnvyRF/0OapFHvq/k+EjkkJUgqTVJjd0mtyUiKfsJ0ksL3Tycp/Pl0ksJHTycp/O5skmo8RSROUhV2SY3KSIqnfaaTFN2j6SRF92g6SQmSziYpukfTSYru0XSSons0m6RmcF8aTNw+OgRVkFR7s9130uFBJG2z3HXYE8CYUDjaHNyNsaHAXcRrcDf1B7ewUP9S9Qd3u1D/UvUHN8ZQ/2fqv35OyhDUX1j9we021L9U/cGdOdS/VP3BTTzUv1T9wZ8WgfqXqj/4gyVQ/0r1LXp9K6uPXt/K6qPXt7L66PWtrP7Cfl+p/d6qiqWjb/R29Ym0FPVf9/ntwn4f6tuF/T7Utwv7/RXUfz3v08J+H+rTwn4f6tPCfh/q08J+H+oTQf2F1V/42R6oT+j1raw+en0rq49e38rqo9e3sPpuKr9/G8+uvk8FPWPcyGiliuLP+CqPm8ruQ/zPxCeIv674U5l9iP/ZnD+V14f4n4k/ldWH+J+JP5XTh/ifiT+V0Yf4H4nvp3qmB+J/Jv5Uj/RA/M/ER4dvYfHR4VtYfIL464qPDt/C4i/s8/eDY7Al7Wd8d8cvbPNX1z4s7PKX135hkz+/9q/n+7Cwx19e+4Ut/vLaE7RfVvuFDf7y2i/8BM/y2i/8AM/y2qOvt6726Ostq31EX29d7dHXW1d7aq69U1v0xlEqfXZMe/zKTtJIjw7Q20P3gN4eegD09tf0COjtoSdAbw49KUBvD10DenvoBtDbQ7eA3h46AXp76HCkHaDDkXaADkfaHLpWWeiktt4BmSN0Tblv0DZtmyVp0gcWS9tXxOu/Il3+FVpd/xX6+q8w13+Fvf4r6PqvcJ99xf0kX3NSqDkp/5uy+3UhxMxJqeKk/BaQFLarLD2unZj010mm5iRbc1I2FZze5gxn7LeTcne8jpfAYjxSQcevb3CXf4O//BvC5d8QL/+GdPU35Pe+Yf0Gffk3mMu/wV7+DZf/puny3zRd/pt2+VyibQ1cR+H5cplf+NGF7ST/a7Z8OsnXfFP+kuO2add5ypyUv4pEs52UbOakVHFSfk2c0km65iRTc5KtOYlqTsr/FKLaT8ro5H3NSaHmpPj6JK9yY8pnREj7SfH5pPz7k15v9LxNmZN04Ztyv6f8G1uFH2H+VZ/SSTU/9/yDptq4bVDa+ByKVHVa/vG28mm67jRTd5qtO43qTnN1p/m600LdaSdZEsN+WjKZ01L5tEyZn1TdabruNFN3Wj5LrNouIbc/MxeefFu9fJqrO83XnRbqTot1p6Wa04xSdaed6OZ3uW2wmdPyJI8a71ZtmcxpJ0jS/nsj5TKnpfJpzz9To1XdabruNFN3mqs7LU+S9odBb15FZ05LVaeZPEnyaj/N+8xp9uS0Y2xBZU47GZvbU5liJidNqjrNqrrT8llCad+H49Zgz5xm6k6zdadR3Wnu5Ne96+ZM5mdqfd1poS7IWHdaqjqNVN1puuo6me9klE+zdadR3Wmh6spFdVcuqrtyOVVzms03pm9mf7f9x1z6dTvJ5i/JhXPS5+fkL8aFc3TFOabiHFtxDlWc4yrO8RXnVOSBObHte/srmudz0ufnWFVxjs4bfbcbfft8jqk4x1acQxXnuIpzfMU5oeKcWHFO+vwcUhXnVOQBVeQBVeRB/pJtAu3PKwRHz2flZ1ofj33R1PPvIb8NWPEsW3UWVZ2Vr8VC2g1a1P75LF91Vqg6K1adlWrOyreui2fpqrNM1Vm26iyqOqsqN3xVbviq3PBVueGrciNU5Ua+i33rZ+1rqSbKnGWqzso/zxh13G92+cNE2JR9N/R43zPaB9OdP5ri8SxFNA+f7fxXSH68kMJ4IcXxQkrDhXTytn7XkPR4IZnxQrLjhUTjhTTe1TtyXL3NfpM8kg6lo49lw28RHe2d/MO6t/buNiFS0CYzgCB9AFH6AJLwASQlfQBa+gCM9AFY6QMg6QNw0gcgfSZO0mfiJH0mTsJnYlLCZ2JSwmdiUsPPA8ntA3h4jOwYwOhXoYIjIzXUVege0lDXld8h6aGuFPeQ2v/2B3lL9gjDmOfbcaQNwOTBWIDJgyGAyYNxAJMH4wEmDyYATB5MBJg8mAQwWTBGAUweDCrfEzCofE/AoPI9AUMAkweDyvcEDCrfEzCofE/AoPI9AYPKNw/GovI9AYPK9wQMKt8TMKh8T8AQwOTBoPI9AYPK9wQMKt8TMKh8T8Cg8s2DoXXrGHeAeXjPYAez7Kz0+jViomVnpRKYZWelEphlZ6USmGVnpQIYt2w/pgRm2X5MCcyydUwJzLL9mBIYApg8mGzla5XaVi2z6mFNp/xQtfb7zjK3v00Jjbn932FTjiXwfu1New/KcwTljiULtX9YNb3Jg+/5tWNkDSHKH0ISP4T8Ej+yhqDlD8HIH4KVPwSSPwQnfwjyZ2c/2Ox8D2qw+fYe1GAz6O+gQo85UUaLP2igOUNjgOYMjQWaMzQENGdoHNCcofFAc4YmAM0Zmgg0Z2gS0JygiaiGT9GgGj5Fg2r4FA2q4VM0BDRnaFANn6JBNXyKBtXwKRpUw6doUA2foUmohk/RoBo+RYNq+BQNquFTNAQ0Z2hQDZ+iQTV8igbV8Akap1aua16+veXUwjPU68d7nVp4hiqhWXiGKqFZeIYqoVl4hiqhWbhfU0KzcL+mgEYvXNeU0CzcrymhWbhfU0JD66KxZnvu29iHF8t2NAuXfCU0C5d8JTQLl3x2f7HzRunZeeuFS74SmoVLvgIas3DJV0KzcMlXQrNwyVdCs3ADtISGgOYMzcrVcAHNytVwAQ2q4TM06y4sXnBQ6y4sXgKz7EJWJTDLLmRVusYQwOTBLLuEawnMsku4lsAsu4RrCcyyS7iWwCy7hGsBDK1b+RbArFv5FsCsW/kWwKDyPQHTvo75bNGxkLajb38e8W+LjrkOS8Z/uGqapm0AUafMAOLoAzB2H4A1mQEk4QPosFQ68wC09AEY6QOw0gdAow/g9eKTzjnpAxh9Ji4OYPiZuDSA4Wfi0gCGn4kLA/DDz8SlAQw/E5cGkP0NaLU/HatVTE8uIr+ebems/IKzt9uYW8GsdTDPZ+mqs0zVWbbqLMqfFf121jehtrOyl09NRm9nkcl8V6w6K9WclV8SrXiWrjrLVJ1lq87K6+VoV/mWdM9nuaqzfNVZoeqsWHVWqjkrv0BI8ax8bri0b3zi9fNLu/llJYpn2aqzqOosV3WWrzorVJ0VK87y+deltbX7WdaZ57N01Vmm6ixbdRZVneWqzvJVZ4Wqs2LVWanmLF2VG7oqN/RJbvi4nxX181m26iyqOstVneWrzgpVZ8Wqs2oqB29U1Vm66qyaysHn28i338LWlfdP74T5fN8w+S11U/DP5+iKc0zFObbiHKqo4n2+8VI8y1edFarOilVn1Xgan3ewxbN01Vmm6ixbdVZVbviq3PBVueGrcqPK7/q8c319tcj71mQ2954oc07FLz+/f0Dhe3zFOaHinFhxTvqcQay4MseKK3Pepaa45cG3W7nbObbiHKo4xxXGkzvHVzAIFefEinMq8iBV5EGqyINU8TtNFTN03o0WznEV53yYB7d/oF8H5mvls/bnrTtwO/X2j//fP/z7X/7hH//6z/9xO+nXf/2vv/3Tf/7lX//29Y//+f//2/Zf/vHf//LXv/7lX/7+3/79X//pn//Pf/37P//9X//1n379tz+p31//S26Kf3b2V0R6/1e364tVv/6VOf5V+LM1v/6V/Tr7fwcT1J+DSfrvfp/6v2+VpPvz7UJu/+73Qbf/7vztv3v/67/fvyi6P1NM6te/+H2GvTVXb/+TDh6/jtP+z0bfxnkb6/8D",
      "brillig_names": [
        "get_contract_instance_internal",
        "decompose_hint",
        "lte_hint",
        "discover_new_messages",
        "notify_created_nullifier_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "deposit_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "decompose_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "_compute_total_min_collateral_value",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7969124557626779129": {
            "error_kind": "string",
            "string": "Function _compute_total_min_collateral_value can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3bjiW3rYbfZa59oRNFya8SbBi24wQDDOzAdjawEeTdd3X31GF6UauqRbmX1PpvAjsudf38iiVSLC3qP5/+/stP//7nD59//cdvf3z6/m//+fTlt59//PPzb78u//af/3736affP3/58vmfPxz/70/m6X9sjM8D/vjXj78+/fsff/74+5+fvmdO/N2nX379+6fvk7W8/Il/fP7yy6fvrTH//Z/vPlk2VaOoZlSyVaOq7pWr7Mp198oVo5zxVaNSzShbdS/L0ijrHZmvw6z3ib4Z993t9ca59XIT3HZ1ZuHiEKP9enGIbLaLIwkXJzK06idnjxc/yXeujfyc18utze8ovxF9Shv9dELfEq8OYaP39+VnyqutOfrwWr6n1vKt+0b+002Cf4+biK/c4gt5G+WMjSc3CcmH1TXS4TUouAa7zTUSv2ZLstnu8Ka546tWUNTQWekKoxBuppjo68axrRwXC+N2cjb73Tzyz8OSqRtGVcNy3d1yKAxj2pmYdBwmvQvR79PdPgVYytLVKa4X5/0P+8U/ngXlvgR543sTlDoTZHsjZHsj5HojVMgTHifI294Exc4EBfP+gmgVtGQJ3wi6vZZzWHVwzvtfdikIV3tec61wyAKdlHE4Z9c/7NwhvxQvprDmohTS8dJnggEElQQzCOoIEnxQSxA+qCQY4YNaggkEdQTZgaCSIIOgjmCyIKgkGEFQRzBjVXeBYFprznT4GrESDCCoJIiMWkcwPKJGPBzBuF0bv730iaDDW6wliDWJkqDHW6wlCB9UEgzwQS1B+KCSIKE2oyWIdbGSYERtRkuQQFBHkFGb0RIMIKgkiNqMkmBCRv2a4DMWfD6SsGTkviIWJLQCFjLIEEQsSD1FLIjlEhaLAC1iQR1LwuIQoEUsCNASFo8ykogFAVrEggAtYcHvJkQshORfxAJvEbFgbpGwzLsHl3YsMb7GMu2WPA7rtY6p/uKFYZx2U95bGNqY1g4Tls3rjY3Rzvp6tmSId1nNcNrtoS0ZzlpQehNDzls3o2Rfx+U47RbRlgxn/fLYkGFAXNYznLUI1pIhchs1Q0JM0TNEbqNmGOGHeobIbdQMGbmNniFyGz1D5DZqhtNuvm3JEDFFzTAjpugZwg8vMMx+sy+H1wx52p2xLRk2ics27U2/A50wXL7er/Jjcrt8a6S/zVuLdOZdxlKdf5Zvw9Dy2+y/fJh8b8aWT4Um/vuM4EwOZ/K3t9zaQw//p5sIgmj7qsTR7MaKHf/Zp1UIB3dyYMEyd/HW8dgGk4+XP1lbqHJ3ZG3cpkvP9kZ+9w/rrvzC/rZh5I9NP45NPw5OPw8tn/0D5PMu35kbRak3Rcl1pyj2pijb7hT1xigZ052iICuyfs9xbTxT1O7oilQ4seZxggo/OXygoN4Iud4Iud4IedeboNiZoNLy7XGC6P0Ffah21amw3wcELxOkAIJKgvBBJcEIH9QShA8qCbIHQSVBBkEdweRAUEkwgqCOYLYgqCSIVZ3u+JKUkc3oCOZHlFw/GMEEgqpGt9kim9ESREatJOjgg1qC8EElQQ8f1BLEqk5JMBgQVBLEqk5LEKs6JUF8q1MTxKpOSTDiO4mWIDJqofNmZhSeRSzIfSUsCQmtiCUAi4QFqaeEJSOWi1gQoAUs1hgUsmQuCNEiF4sYLXNBKUnmgigtcnEI0zIXFHNELj6Ai8gF/iJyCZhfRC5x2vzl3lkw1vCs71G7w2CsmXavd7sTJKzJs76hTSHidVZDtGbWGNoU4qyFt3ZdMReTEVgaQJy1pNcSokN0bgAxAKIeIlIcPcRp9zE3hYgURw8xwBMbQESKo4dISHEaQAyAqIeIFEcPMSKwNICIwKKHyAgsDSDCE7Wnm1g77ZbiphCbROfaYz4o0+Fq8ZiPmPNK8fAiPf3lZ/1tdgo/TL8zdnD9eWz9hUOGnM92V2Sp6SRyr/Xuoij3pqi0ze+BilJvinx3jHx3jEJ3jAL3pohsd4pib4pK299C2hWRMWcx5687c8bRdraXOyRoL6dOLPrD4Prz2Pp5cP48OP80OP/SmmkU/dkNrp+H1u9La75h9Mex9dux8wdf+pneMPrHjl/ejR2/vBs7fvnSWnsY/YPHrzB2/uDD4PGLBs8fSgcOR7Prj77th5u7FQVfqig8UFHoTlHuTRF3x4i7Y5S6Y1RaPT9OUWk9/EBF3JmiUFqzJrt/50uB3lNR7E1RaV35QEXUmyLXHSPXHSPfHaNS444HKkq9KSp93XygIjmKeLtvCfI2+RNFYVmvrpcHz/u2J2Lh8uWCdXOGZ0+vc/9Q+Jr4UE3RdqipQ07cISem/jQVWsA+VlOHnHKHnHLoUFPuThMV2ko8VlPqT5PtkJPtLy8g119sIddfDCb/kDlz257rkzVHTbcXJ78Vf9My8NaAMLoBeXADwuhPIIz+BGj0J0BpcAPi6E8gDv4OxFKRa6lkbOUS5775iPk8LhRcb7l4M9y7eDOO5CL/4st5K7gQH35N9VVn6Ze3jg46T0E3KuvcXnv4oY2zhyO/vV/1c0f6nxWVztN5oKLYm6LUHaPUHaPcHaNM3SnKnSliE7pTlN5f0XhH0oc1UaBDlPn6K2K2Dgi1CBkIlQgdvFCNEF6oRejhhWqEEQiVCEvnqgPhdYQEhFqEGQiVCCkAoRYhFngXEG4/HqF0cwACRyQ1aoRIrbUIH1E5Hg5h3K6Nt0eHMSOp0SJMSK3VCOGFWoQZXqhGCC9UI8QCT4kwlQ5oA8LrCLHA0yLEFzw9QizwtAgdFnhqhPh2okXokVpLx44nj1K0zAVJsMglILOVuSBRELkQclCZC0K6yCUiTstcUNeSuSBOi1wYcVrmgrKSyCUhTstcEKdFLhlVHZkL1gESl2zgLzIXzC8iFzdt/kI7l3hztmMOs75Hbzkg887FLxBnXUy96ZTRuLUHt2xuNu5lmvUNbQkx4nVuAHHWGNoSIs9aeGt4BniediduU4izlvRaQkyIzg0gzrqYbwlx2kpRU4gILFqIzhikOA0gwhMbQESKo4dokeI0gIgURw9x2i3OTSEisDSAiMCih+gRWBpAhCdegJj31s453EKcdldxS4jUJDrbtF99OPFLhkiUV/0xuV2/NdLf5rg2yOBDU+2nQ3tf9Mex9ZeOvR1FP7vB9RcmEb+/Ns4fXrKC/r/uaGmfViEcnLt/8TKB8db51waTj5c/m1uqfPu8n7Ma7Pud2bco4t4UlU7HfaCi+P6KPlRLNGdL5U0gvI6QgFCJ0MIL1QjhhVqEDl6oRhiAUIswAaESofdAqEXIQKhEGBwQahFigadrlbv8HSQ1aoRIrdUIMxCqmlE5G5HUqBEitdYiZHihGiG8UIswwQvVCLHA0yIs/UgBCK8jxAJPidDhC54eIRZ4aoRY4GkR2gCEWoRIrYXGOM45lKJlLkiCRS4ema3MBYmCyCUgB5W5BHARuSBOi1wIdS2ZC+K0yCUiTstcUFYSuTDitMwFcVrmgqqOyCVhHSBzgb+IXDLmF4mLt9PmL/caNjvvZn2P2jVsfvqlKiAqO7w6H2Z9Q5tCxOush0izxtCmEGctvDXsUuOn3YnbFOKsJb2WEBnRuQHEWRfzTSEixdFDnHZbc1OISHH0EDM8sQFEpDhqiMEgxWkAESlOA4hIcfQQLQJLA4gILHqIDoGlAUR4orrXcJh2V3FTiE2ic23DXcp0uFpsuBtzXikeXqSnv/ysv81W4cfpJze2/mgG139lEnG56SRytztviLk3RZe2+b2vou4Ype4Ype4YXaqOva8i7kwRGdedovj+ij5WPz661KcZCO8iJCBUInTwQjVCeKEWoYcXqhEGINQiTECoRBg8EGoRMhAqEZIDQi1CLPCUfZopIqlRI0RqrUaYgVDXCY0YSY0aIVJrLcIEL1QjhBdqEWZ4oRohFnhKhPHSRmYgvIsQCzwtQnzB0yPEAk+NEAs8LcJLJ60C4V2ESK2lrkzRoxQtc0ESLHIJyGxlLkgURC6EHFTmEsBF5II4LXKJqGvJXBCnRS6MOC1zQVlJ5JIQp2UuiNMyF1R1RC4Z6wCZC/xF4sIG84vIxU2bv9ztFs5+1veoYbdwnnYXeMP2wkyzvqFNIeJ11kOMs8bQphBnLbw1bJHE0+7EbQpx1pJeS4gJ0bkBxFkX800hIsXRQ5x2W3NTiEhx1BCTgSc2gIgURw/RIsVpABEpTgOISHH0EB0CSwOICCx6iB6BpQFEeKK60XWadldxU4hNonNtt+eY3K5f7vbMcRXCvHe6WQr2L/rbbBV+nP7oxtbPZnD9hUkkpF0/GXOmf3vV7fL96Ju7CIpo+9jE0ezWRpIudrS+v8s/huPFL/rz2PpLWwiH0Z/G1p/d4Pp5aP3Zds8/mU1/sjf6S81fu9Hv45aFeRb0P2L+4V2/M/f1O5Oz23LOfGjn7nL6akIe3oTSnrORTODhTSA3vgnjP4U4/lOI4z+F0k/ERjKB+jYhcF6rKSF5wYBkRjcgjG5AGtyA3HlicW7A2E/AG9N5ODs3IA4eCbyxoy9yFhM6fw8umODGdyQ/cEQWCsm8mktpr1B7n78aO3D+9GZjw0xPNnT+ZC+8idT587piwvhRicaPSnH00ttiwvhPgcd/Cjz+U0ijl94WEzpPMk+XW7nzwtu5AWOX3RYDOv+edGaANWF0A0Z/AnbssttiwOhfMLx1wwczO37FxPZeMbliwvCrZdt7deOKCeM/hfFrFnb8moXtvWZxGpt7r1icG9B5cnFqQO+bI84NGHyVbNPoTyANvkq2afRdl97m8YNZ79sjzk1wvW+QuGLC8KtlZ8d/CuPXLNz4NQs3fs3CjbzL48WAwZML1/tPOk4N6P0HHecGDL5KdjT6E+j9pxynBsTRf0KwmDB+MOPhi46Ow/gmDL9adr3/mOOKCeM/hfFrFm78moUf/UcdvveKxakBdvACsLeDr9GWqtfoBgz/BAZfJftQSK+j2Q2Ih3ZgLTqYpVWSPUzsTx3MnhWVPtE/UBF1pyi/v6LOTyW7vZjC2gCRQjpe+oyw9AkfCK8jTECoRMjwQjVCeKEWYYIXqhEyECoRln52A4TXEUYg1CEMxgChFiEBoRYhFngXEG5FFkruBqFFUqNGiNRai7C0nQwIDxfH7dp4c9T8ghBJjRahR2qtRggv1CIM8EI1QnihFiFhgadGGIBQixALPC1CfMHTI8QCT4uQscBTI8S3Ey3ChNT6NcIXLihFi1wykmCZSwAXkQsSBYkLGeSgMheEdJGLRZyWuaCuJXJxiNMyF8RpmQvKSiIXjzgtc0GcFrkEVHVkLlgHiFwI/iJzwfwicuFp8xfaucR4wyXP+h5xWK91TPUXv0CcdTH1Fog2bke4WzY3G/eimfUNbQnR4nVuAHHWGNoSopu18PYmiJzXHyXYZOMtRAQWPUQ/a0mvKURE5wYQZ13Mt4Q4baWoKUQEFj1EQorTACI8UQ8xIsVpADEAoh4iUhw9xGm3ODeFiMCih5gQWBpARGDRQ5x2A/WbIGa/2ZeDABHRWQ2RTZPobFParg50ApEor/op0+FqI/3tmPNK8fAiPf3lF/08tn5LY+t3fnD9VyaRQ4ulv7w7L3vXnSLuTVHojlHojhF1x+hSdexdFV0qNb2vIupOUX5/RR+rHx9f6tMMhHcRJiBUIkzwQjVCeKEWYYYXqhEyEOoQJmOBUIswAqESoTVAqEVIQKhFiAWesk9zckhq1AiRWmsRPqJy/LE6oSWPpEaLMCC1ViOEF2oRErxQjRBeqEUYscBTIwxAqEWIBZ4WIb7g6RFigadFmLDAUyPEtxMtwozUWurKlDJK0RKXbJAEy1wCuIhckCiIXCxyUJkLQrrIxSFOy1xQ1xK5eMRpmQvitMwFZSWRS0CclrkgTotcCFUdmQvWASKXCH+RuWB+Eblc6tjwIbnc6xYejJn1PWrXLXyBOOtiql174WDsrG9oS4gOr3MDiLPG0JYQ/ayFt3YtkhaICCx6iGHWkl5TiIjODSDOuphvCXHaSlFTiAgseogRKU4DiPBEPURGitMAYgBEPUSkOHqI025xbgoRgUUPMSOwNICIwKKGaKfdQN2u0fUCEdFZD9E2ic6P6va86Oex9TsaW7/3g+u/MolEajqJ3OvOG+ylTtjvq4h7U0TdMaLuGMXuGF2qjr2rokulpvdVRN0pyu+v6EP14wv2Up9mILyLMAGhEmGGF6oRwguVCJ2BF6oRMhAqEVoLhFqEEQiVCJ0BQi1CAkItQizwdH2ag/NIatQIkVprET6icvyhOqEtCJHUaBESUms1QnihFmGEF6oRwgu1CBkLPDXCAIRahFjgaRHiC54eIRZ4WoQZCzw1Qnw7USL0Bqm10JVp4YJStMjFIgmWuQRwEbkgURC5OOSgMheEdJGLR5yWuaCuJXIJiNMyF8RpmQvKSiIXQpyWuSBOi1wiqjoyF6wDRC4Mf5G5YH4RuVzq2PAhudztFh7srO9Rw27hYdpd4A3bCwc36xvaEqLH69wA4qwxtCXEMGvhrWGLpDDtTtyWEGnWkl5TiIjODSDOuphvCXHaSlFTiAgseoiMFKcBRHiiHmJCitMAYgBEPUSkOHqI025xbgoRgUUNkQwCSwOICCx6iNNuoG7Y6Jqm3VXcEqJrEp1ruz3H5Hb9crdnjqsQ5r3TzVKw/6qfx9bvaWz9wQ+uvzCJsDebIj5sNSjo3151u3w/+uYugiLaPjZxNLu1T5RuL/ZpfX85OHf/4mUC463zrw0mHy9/NrdU+e7H3LhNmp7trf7uH9d9/dEPrn9w/jw4fx6cf+nosGH0xwfo512/MzeSsu1PEvUnKfcmKZrQn6T+KFnfn6TCmiNtu3aXfw7veKJDdLY7RbE3Rd68v6KP1Vc2+gCEWoQZCJUIA7xQjRBeqEVI8EI1wgSESoSl/YNAeB0hA6ESIVsg1CKMQKhEmLDAU543EBOSGjVCpNZahKVjDYHwcPHdjp4xI6lRImSD1FqNEF6oRWjhhWqE8EItQocFnhohAaESIb7g6REGINQixAJPizBggadGiG8nWoSE1FrqLsiEUrTIJSIJlrkgs5W5IFEQuTByUJkLQrrIJSFOy1xQ1xK5ZMRpmQvitMQlGZSVZC6I0zIXxGmRi0VVR+aCdYDIxcFfZC6YX0QuYdr85e6pFynO+h41PPUiTbsLvGGb/MSzvqEtISa8zg0gzhpDW0LMsxbeGrb6S9PuxG0IMZtZS3pNISI6N4A462K+JcRpK0VNISKw6CE6pDgNIMIT9RA9UpwGEJHiNICIFEcPcdotzk0hIrDoIRICSwOICCx6iNNuoG54YEOedldxS4jcJDrXnlpAy3SyXy2eWhBzXikeXqSnv/yiP42tP8Wx9ecwuP4rkwjlppPIve68ZIzvTlHqTZHtjpHtjpHrjtGl6ti7KrpUanpfRbE3RcG8v6IP1Y9vQRiAUIswA6ESIcEL1QjhhVqEEV6oRpiAUImQHRBqETIQKhEmC4RahBEIlQgzFni6Ps0LwgCEWoRIrZUI7SMqxx+qE9qCEEmNFqFFaq1GCC/UInTwQjVCeKEWoccCT42QgFCJEF/w9AgDEGoRYoGnRUhY4KkR4tuJFmFEai10ZVq4oBQtcmEkwTIXZLYyFyQKIpdLR5LOyAUhXeSSEadlLqhrSVycQZyWuSBOi1wsykoyF8RpmQvitMjFoaojc8E6QOTi4S8yF8wvIheaNn+51y2cHM/6HrXrFr5AnHUx1a69MC2AAFENMeN1bgBx1hjaEKI3sxbe2rVIWiAisOgh2llLek0hIjo3gDjrYr4lxGkrRU0hIrDoIXqkOA0gwhP1EANSnAYQkeI0gIgURw9x2i3OTSEisOghRgSWBhARWPQQp91A3a7R9QIR0VkPMTWJzrXdnmNyu3652zPHtUEG897pZinYf9Wfxtaf49D6gwmD6y9MItnlTVGmeKZ/e9Xt8v3om7sIimj72MTR7NZGki5e3tD14uDc/YuXCYy3zr92se14+bO5pcp3P+bmuJtrb/Q7M9XjcvEB5vJurjP3LXAmZ7dFxHxoNr18d34xwZvxTaDhTQjjP4Uw/lOg8Z9CqeX0SCakvk0IvMXAkLxgQPSjG8CDG1Bav49jQOeJxakBafQnkDoPZ+cG5OEjQe58Ir1iQufB7NwEMsM/BTLjPwU7/lOwnacVF0xwg4c16r1icWpA7/WKcwPC6AZ0nlicGhBGfwJh8BXyMg2JBnhjtp95eEPpaMDLOK4bFyvvFyvvV2g0dToumcpxlfcrJNjn41JpnN/HJfN6XCykkt7uH0G9Tf7EcYP329f74Hmv4hOLX27d+jnKs//m+8CLJu5PU6Gj+2M1xUdo2j48+mRPZp3kaVWS/OFb4mpA4dvUQAbQ6AbkRxiwfcNbvv3l+wZYs4So9W8b7+ONCYXsbSgTxn8KwY9vQhreBBr/KcRHmJD9uuXF50BnJiyBdzMher414RH5S87rHw/mLCosstO2LjF82MS3mlD4XPMXm7AtaBYT7JkJfHCkFOytCTS8CcmMb0IY34Q8vAl5+KfAJg5vgh1+UmU7/lNw4z8FN/5T8OM/BT98gsFh+ASDw/ih7SELz7YmPGThWTbhRRP3pym6/jTxA/LbYNJ6dbCny9WnH8esf3v5jHFTNOBHrDJam5CGNyH78U0Y/imkRl/PaP9yHehQExNNsLz/JvT4o7EQXzRZ6k+T8x1qSv1p8u4BmlJav3wu/8g3mhrlrW01tYlBtH/oD0T+RFNOdt0ft/zz4edz68aOFHKXsqhPWvR2Ws/jSl8tXNgCgXfJ3Y5LdeO48n5ceb8U68ZlWzmu7n7ZhMpx+cK4fLPtJttQOa7yfq7yfqVJ/HQc140Llfcr/N7vfByVxm2f6rx38WZcLN3PufvjqG4cV96v+N6ejEu+blx2NeOimbbFqXergzp/2Kr10jQkmsJ7Cy7wF5HLtOfbLJnWxsXFWy6z9uY/4RJm7UV7xmXW86hPuNCs5xaecZk2Tp9wwbwrcomYd2Uus3ZfPeHC8BeRS5q1ved9LvbS4TXHyvUc6yNrI7hIXBz8ReZCs3K5P794Ay4ilwAuIpcELhKXS/WXGblMG6fvcyHMuzIXzLsylwwuEpcIfxG5XDrXfT4urtQ5b/lyvXGJcbr1kSu145udi4W/yFx4Vi735xfnwEXkEsFF4lKqv0zPJYCLyGXaOH2fS8C8K3PBvCtyIQsuIhf4i8ildIbn7FzyFS4hzbY+8saAi8gF/iJzybNyuTu/eBvAReSSwEXicqn+MiOXCC4SFz9tnD7hgnlX5oJ5V+QSPLiIXOAvIhdicJG4pCtcDjeZZX2UHbiIXOAvEpdg7Kxc7s4vwURwkbhYAy4ilwAuIpcELhIXN22cPuGCeVfk4jHvylwIXCQuAf4ic8ngInGJhXk37E10HRlzwuWN57Km/VxWc3KYFLutqejyj697c8dQ6BfXj/5gVyEcnKCfOtfvt3NxRf2pd/4++V2/u3/x8k5vR7Utmky+Nbf318XHbR7xfPu4SmWiYfTnofWTCWPrt92/7if6u59u7+t3g/N3g/t/of/8MPpLbcp83vUHN107USq0JwcX+IvIpdSm7ONzubucJGZwkbiU2rdNz4XAReSSwUXikqeN0ydcMO9KXKLBvCtzieAicbHwF5FLqe4wOxe6wsVO1/4kEoGLxCXCX2QuYVYu9+eXmMFF4sIeXEQuDC4Sl0v1lxm5TBunT7hg3hW5ZMy7MpcELgIXNvAXkYt14CJxKbUpc5Q2Lu701OsPtz7iwOAicSH4i8wlzsrl/vwSLbiIXAhcRC4ZXCQupfrL9FymjdP3uSTMuzIXzLsil2zAReQCf5G4JBPAReJSalNm/X7MjY3TtT9JPoOLxCXAX2QuaVYu9+cX8uAicmFwkbiU6i/TcyFwEblMG6fvc2HMuzIXzLsil+TAReQCfxG55AguApdcaFNmM+9cjJnueI7sLbiIXOAvIpdCm7IJuNyfXwKBi8glg4vEpVB/ARcGF4lLnDZOn3DBvCtzwbwrcuEALiIX+IvIJSVwueXCRv7dBMet52sMr8cs0KQxeWOT+eY+1vmKMfz2MfI6+GSMHHtMWCFYk/LtqFwzqvB992xU1b2o6l5Uda9Yda9YdS+uel5cda9UZVdhtjkZVegNezYqVoxyheN/z0bRm2cLJx8cm9063+VwO0Y+1OPuW+zkt/j+fXyFNvkguZMx/PYx9PaZrHA4+v0xseI+craet07h34Swr2PkRuEnY2rucxadhDGpwt/kHZInY94e0bxxFWPS28dYXzGm4j6uwh73dr8uHJx6MubtfuAL0SiYtWmsDYdU0fv8Miz5umF8OsyZ22GF0HI6rOpuofDjymjXkrSNh1R0G1bocXQ6LJwOO2TJ+7BcNczX3S3V5Cwh1eQsofAb8SUf3BYv7F6PokKntrNRuWZU4dCus1GFNVyK+xLuhgYV8vTg7O7Dt/cqHBd7NoprRsmR/nQU1YyKVXZxlUKWM1MK21OmQ4fsdVRhp8TZqFwzKoeKUbGQO5+NoppRtupehfeL8la+iPYmC4qFo9HORnHNqMKa+2RU4avl2agqGoUdxyejqIph4auA99soT+52VKwZVTiw52xUqBqVakYVZoCzUVU0chX5XHMvNqZqVKgaVUO+1BXDx+1HPD7Z21GpZpSjmlGF4/jORsWaUcFWjco1o6gmLjPV5Bul3+CfjXrzvf67/Nv//vj75x9/+vLLH8uYp//4719//vPzb79+/dc//+9f63/56ffPX758/ucP//r9t59/+fu/f//lhy+//fz03z6Zr//zt+dZdJk/w6LnOS4u1VT33fI//PR/2OcrXP7OkrfLvZf7/z8=",
      "brillig_names": [
        "_compute_total_min_collateral_value"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "PriceFeed"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Lending"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "market_assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "market_assets_list",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "market_assets_list_len",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "scaled_deposited_assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "scaled_borrowed_assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "scaled_total_deposited_assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "scaled_total_borrowed_assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposit_accumulators",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "borrow_accumulators",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::repay_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::repay_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::withdraw_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::withdraw_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "precision",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "deposit_accumulator",
                    "type": {
                      "fields": [
                        {
                          "name": "value",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "last_updated_ts",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 64
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "accumulator::Accumulator"
                    }
                  },
                  {
                    "name": "borrow_accumulator",
                    "type": {
                      "fields": [
                        {
                          "name": "value",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "last_updated_ts",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 64
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "accumulator::Accumulator"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_compute_utilization_rate_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_compute_utilization_rate_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_withdraw_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_withdraw_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::borrow_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::borrow_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_compute_total_collateral_value_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_compute_total_collateral_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "asset",
                    "type": {
                      "fields": [
                        {
                          "name": "asset_address",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "loan_to_value",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "oracle",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "is_borrowable",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "optimal_utilization_rate",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "under_optimal_slope",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "over_optimal_slope",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "deposit_cap",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "asset::Asset"
                    }
                  },
                  {
                    "name": "utilization_rate",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "precision",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_compute_borrow_rate_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_compute_borrow_rate_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_deposit_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_deposit_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Lending::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "on_behalf_of",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::deposit_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::deposit_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "on_behalf_of",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::repay_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::repay_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_repay_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_repay_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_borrow_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_borrow_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::update_accumulators_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::update_accumulators_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::withdraw_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::withdraw_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::borrow_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::borrow_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_compute_total_min_collateral_value_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_compute_total_min_collateral_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "on_behalf_of",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::deposit_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::deposit_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "oracle",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "loan_to_value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "is_borrowable",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "optimal_utilization_rate",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "under_optimal_slope",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "over_optimal_slope",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "deposit_cap",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::add_asset_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::add_asset_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "deposit_accumulator",
                    "type": {
                      "fields": [
                        {
                          "name": "value",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "last_updated_ts",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 64
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "accumulator::Accumulator"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::compute_total_deposited_assets_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::compute_total_deposited_assets_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "102": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "103": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "104": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n"
    },
    "105": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "106": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "107": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "109": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "110": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "111": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "112": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "133": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "136": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "139": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "140": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "141": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "142": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "143": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "144": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "149": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "150": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "151": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "152": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "154": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "156": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "157": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "159": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "168": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "182": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "185": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "186": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "188": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "189": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "191": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "193": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "20": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "221": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "223": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "266": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "269": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "271": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "276": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, FromField, Hash, Serialize, ToField},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"
    },
    "283": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "284": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "298": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "300": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "301": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "310": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "321": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "335": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "339": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "340": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "356": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "359": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "365": {
      "path": "/home/jean/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "396": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "52": {
      "path": "/home/jean/work/noir/lending/contracts/src/helpers.nr",
      "source": "use dep::aztec::hash::pedersen_hash;\nuse std::ops::{Add, Sub};\n\n// Utility used to easily get a \"id\" for a private user that sits in the same\n// \"space\" as the public users.\n// It help us to have a single mapping for collateral that have both public and private users.\npub fn compute_identifier(secret: Field, on_behalf_of: Field, self: Field) -> Field {\n    // EITHER secret OR on_behalf_of MUST be set. But not both\n    assert(!((secret == 0) as bool & (on_behalf_of == 0) as bool));\n    if (secret != 0) {\n        pedersen_hash([self, secret], 0)\n    } else {\n        on_behalf_of\n    }\n}\n\npub fn covered_by_collateral(\n    collateral_price: u128,\n    borrow_price: u128,\n    loan_to_value: u128,\n    collateral: u128,\n    increase: u128,\n    decrease: u128,\n) -> u128 {\n    let price_precision = 1000000000 as u128;\n    let ltv_precision = 10000 as u128;\n\n    let collateral = (collateral + increase) - decrease;\n\n    let collateral_value = (collateral * collateral_price) / price_precision;\n    let debt_covered = (collateral_value * loan_to_value * price_precision) / (borrow_price * ltv_precision);\n\n    debt_covered\n}\n\npub struct DebtReturn {\n    debt_value: u128,\n    static_debt: u128,\n}\n\nfn div_up(a: u128, b: u128) -> u128 {\n    let div = a / b;\n    if div * b < a {\n        div + (1 as u128)\n    } else {\n        div\n    }\n}\n\npub fn debt_updates(\n    interest_accumulator: u128,\n    static_debt: u128,\n    increase: u128,\n    decrease: u128,\n) -> DebtReturn {\n    assert(interest_accumulator > (0 as u128));\n    let accumulator_precision = 1000000000 as u128;\n\n    let current_debt_value = (static_debt * interest_accumulator) / accumulator_precision;\n    let new_debt_value = current_debt_value.add(increase).sub(decrease);\n\n    // static_debt_increase = amount / accumulator\n    // rounding up new debt.\n    let static_debt_increase = div_up(increase * accumulator_precision, interest_accumulator);\n    // rounding down repayment.\n    let static_debt_decrease = (decrease * accumulator_precision) / interest_accumulator;\n\n    // We need to allow repaying of the entire debt as well etc. This is very prone to failing\n    // if you try to repay exact due to time diff between sim and execution.\n    let new_static_debt = static_debt.add(static_debt_increase).sub(static_debt_decrease);\n\n    DebtReturn { debt_value: new_debt_value, static_debt: new_static_debt }\n}\n\npub fn debt_value(static_debt: u128, interest_accumulator: u128) -> u128 {\n    let accumulator_precision = 1000000000 as u128;\n    div_up(static_debt * interest_accumulator, accumulator_precision)\n}\n"
    },
    "53": {
      "path": "/home/jean/work/noir/lending/contracts/src/main.nr",
      "source": "mod asset;\nmod position;\nmod helpers;\nmod accumulator;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Lending {\n    use dep::aztec::prelude::{AztecAddress, Map, PublicMutable};\n\n    use crate::asset::Asset;\n    use crate::helpers::{compute_identifier};\n    use crate::position::Position;\n    use dep::price_feed::PriceFeed;\n    use dep::token::Token;\n    use crate::accumulator::Accumulator;\n    use dep::aztec::macros::{\n        functions::{initializer, internal, private, public, view, utility},\n        storage::storage,\n    };\n    use dep::aztec::protocol_types::traits::{FromField, ToField};\n\n    #[storage]\n    struct Storage<Context> {\n        market_assets: Map<Field, Map<AztecAddress, PublicMutable<Asset, Context>, Context>, Context>,\n        market_assets_list: Map<Field, Map<u64, PublicMutable<AztecAddress, Context>, Context>, Context>,\n        market_assets_list_len: Map<Field, PublicMutable<u64, Context>, Context>,\n        scaled_deposited_assets: Map<Field, Map<AztecAddress, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, Context>,\n        scaled_borrowed_assets: Map<Field, Map<AztecAddress, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, Context>, // static debt\n        scaled_total_deposited_assets: Map<Field, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>,\n        scaled_total_borrowed_assets: Map<Field, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, // static debt\n        deposit_accumulators: Map<Field, Map<AztecAddress, PublicMutable<Accumulator, Context>, Context>, Context>,\n        borrow_accumulators: Map<Field, Map<AztecAddress, PublicMutable<Accumulator, Context>, Context>, Context>,\n    }\n\n    #[private]\n    #[initializer]\n    fn constructor() {}\n\n    #[private]\n    fn repay_private(\n        from: AztecAddress,\n        amount: u128,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        asset_address: AztecAddress,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        // docs:start:private_call\n        let _ = Token::at(asset_address).transfer_to_public(from, context.this_address(), amount, nonce).call(&mut context);\n        // docs:end:private_call\n        let _ = Lending::at(context.this_address())\n            ._repay(AztecAddress::from_field(on_behalf_of), amount, market_id, asset_address)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn repay_public(amount: u128, nonce: Field, owner: AztecAddress, market_id: Field, asset_address: AztecAddress) {\n        let _ = Token::at(asset_address).transfer_in_public(context.msg_sender(), context.this_address(), amount, nonce).call(&mut context);\n        let _ = Lending::at(context.this_address())._repay(owner, amount, market_id, asset_address).call(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _repay(owner: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == asset_address, \"Invalid asset or market id\");\n\n        Lending::at(context.this_address()).update_accumulators(market_id, asset_address).call(&mut context);\n\n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / borrow_accumulator.value;\n\n        assert(scaled_user_borrowed_amount >= scaled_amount, \"Insufficient balance\");\n        scaled_user_borrowed_amount_loc.write(scaled_user_borrowed_amount - scaled_amount);\n\n        let scaled_total_borrowed_asset_loc = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address);\n        let scaled_total_borrowed_asset: u128 = scaled_total_borrowed_asset_loc.read();\n        scaled_total_borrowed_asset_loc.write(scaled_total_borrowed_asset - scaled_amount);\n    }\n\n     #[private]\n    fn borrow_private(secret: Field, to: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let on_behalf_of = compute_identifier(secret, 0, context.msg_sender().to_field());\n        let _ = Lending::at(context.this_address())\n            ._borrow(AztecAddress::from_field(on_behalf_of), to, amount, market_id, asset_address)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn borrow_public(to: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let _ = Lending::at(context.this_address())._borrow(context.msg_sender(), to, amount, market_id, asset_address).call(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _borrow(owner: AztecAddress, to: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n\n        assert(asset.is_borrowable, \"Asset is not borrowable\");\n\n        let total_collateral_value: u128 = Lending::at(context.this_address())._compute_total_collateral_value(market_id, owner).call(&mut context);\n        \n        let total_min_collateral_value = Lending::at(context.this_address())._compute_total_min_collateral_value(market_id, owner).call(&mut context);\n\n        let borrow_price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n        let min_collateral_for_borrow = (amount * borrow_price * 10000 as u128) / (asset.loan_to_value * 1000000000 as u128);\n\n        assert(total_min_collateral_value + min_collateral_for_borrow <= total_collateral_value, \"Insufficient collateral\");\n        \n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / borrow_accumulator.value;\n        scaled_user_borrowed_amount_loc.write(scaled_user_borrowed_amount + scaled_amount);\n\n        let scaled_total_borrowed_asset_loc = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address);\n        let scaled_total_borrowed_asset: u128 = scaled_total_borrowed_asset_loc.read();\n        scaled_total_borrowed_asset_loc.write(scaled_total_borrowed_asset + scaled_amount);\n        \n        let _ = Token::at(asset_address)\n            .transfer_in_public(context.this_address(), to, amount, 0)\n            .call(&mut context);\n    }\n\n    #[private]\n    fn withdraw_private(secret: Field, to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let on_behalf_of = compute_identifier(secret, 0, context.msg_sender().to_field());\n        Lending::at(context.this_address())\n            ._withdraw(AztecAddress::from_field(on_behalf_of), to, amount, market_id, collateral_asset)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn withdraw_public(to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let _ = Lending::at(context.this_address())\n            ._withdraw(context.msg_sender(), to, amount, market_id, collateral_asset)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _withdraw(owner: AztecAddress, to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(collateral_asset);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == collateral_asset, \"Invalid asset or market id\");\n        \n        Lending::at(context.this_address()).update_accumulators(market_id, collateral_asset).call(&mut context);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(collateral_asset);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        let scaled_user_deposited_amount_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_asset).at(owner);\n        let scaled_user_deposited_amount: u128 = scaled_user_deposited_amount_loc.read();\n        let user_deposited_amount = (scaled_user_deposited_amount * deposit_accumulator.value) / 1000000000 as u128 ;\n        assert(user_deposited_amount >= amount, \"Insufficient balance\");\n\n        let total_collateral_value: u128 = Lending::at(context.this_address())._compute_total_collateral_value(market_id, owner).call(&mut context);\n\n        let total_min_collateral_value = Lending::at(context.this_address())._compute_total_min_collateral_value(market_id, owner).call(&mut context);\n\n        let collateral_price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n        let withdraw_amount_value = (amount * collateral_price) / 10000 as u128;\n\n        let total_collateral_value_after_withdraw = total_collateral_value - withdraw_amount_value;\n\n        assert(total_min_collateral_value <= total_collateral_value_after_withdraw, \"Insufficient collateral\");\n\n        let scaled_withdraw_amount = (amount * 1000000000 as u128) / deposit_accumulator.value;\n        scaled_user_deposited_amount_loc.write(scaled_user_deposited_amount - scaled_withdraw_amount);\n\n        let scaled_total_deposited_asset_loc = storage.scaled_total_deposited_assets.at(market_id).at(collateral_asset);\n        let scaled_total_deposited_asset: u128 = scaled_total_deposited_asset_loc.read();\n        scaled_total_deposited_asset_loc.write(scaled_total_deposited_asset - scaled_withdraw_amount);\n\n        let _ = Token::at(collateral_asset)\n            .transfer_in_public(context.this_address(), to, amount, 0)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_total_collateral_value(market_id: Field, owner: AztecAddress) -> u128 {\n        let mut total_collateral_value: u128 = 0 as u128;\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id);\n\n        for i in 0..market_assets_list_len {\n            let market_asset_loc = market_assets_list_loc.at(i);\n            let market_asset: AztecAddress = market_asset_loc.read();\n            let collateral_asset_loc = storage.market_assets.at(market_id).at(market_asset);\n            let collateral_asset: Asset = collateral_asset_loc.read();\n            let collateral_price = PriceFeed::at(collateral_asset.oracle).get_price(0).view(&mut context).price;\n            let scaled_collateral_amount_loc = storage.scaled_deposited_assets.at(market_id).at(market_asset).at(owner);\n            let scaled_collateral_amount: u128 = scaled_collateral_amount_loc.read();\n            let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(market_asset);\n            let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n            let collateral_amount = (scaled_collateral_amount * deposit_accumulator.value) / 1000000000 as u128;\n            total_collateral_value += (collateral_amount * collateral_price);\n        }\n        total_collateral_value / 1000000000 as u128\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_total_min_collateral_value(market_id: Field, owner: AztecAddress) -> u128 {\n        let mut min_collateral_value: u128 = 0 as u128;\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id);\n\n        for i in 0..market_assets_list_len {\n            let market_asset_loc = market_assets_list_loc.at(i);\n            let market_asset: AztecAddress = market_asset_loc.read();\n            let debt_asset_loc = storage.market_assets.at(market_id).at(market_asset);\n            let debt_asset: Asset = debt_asset_loc.read();\n            if(debt_asset.is_borrowable) {\n                let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(market_asset).at(owner);\n                let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n                let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(market_asset);\n                let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n                let user_borrowed_amount = (scaled_user_borrowed_amount * borrow_accumulator.value) / 1000000000 as u128;\n                \n                let borrow_price= PriceFeed::at(debt_asset.oracle).get_price(0).view(&mut context).price;\n\n                min_collateral_value += (user_borrowed_amount * borrow_price * 10000 as u128) / debt_asset.loan_to_value;\n            }\n        }\n        min_collateral_value / 1000000000 as u128\n    }\n\n    #[private]\n    fn deposit_private(\n        from: AztecAddress,\n        amount: u128,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        let _res = Token::at(collateral_asset)\n            .transfer_to_public(from, context.this_address(), amount, nonce)\n            .call(&mut context);\n        Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, market_id,collateral_asset)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn deposit_public(\n        amount: u128,\n        nonce: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        // docs:start:public_to_public_call\n        let _ = Token::at(collateral_asset)\n            .transfer_in_public(context.msg_sender(), context.this_address(), amount, nonce)\n            .call(&mut context);\n        // docs:end:public_to_public_call\n        let _ = Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, market_id, collateral_asset)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _deposit(owner: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(collateral_asset);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == collateral_asset, \"Invalid asset or market id\");\n        \n        Lending::at(context.this_address()).update_accumulators(market_id, collateral_asset).call(&mut context);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(collateral_asset);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        let total_deposited_assets = Lending::at(context.this_address()).compute_total_deposited_assets(market_id, collateral_asset, deposit_accumulator).call(&mut context);\n        assert((total_deposited_assets + amount) < asset.deposit_cap, \"Deposit cap exceeded\");\n\n        let scaled_user_deposited_asset_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_asset).at(owner);\n        let scaled_user_deposited_asset: u128 = scaled_user_deposited_asset_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / deposit_accumulator.value;\n        scaled_user_deposited_asset_loc.write(scaled_user_deposited_asset + scaled_amount);\n\n        let scaled_total_deposited_asset_loc = storage.scaled_total_deposited_assets.at(market_id).at(collateral_asset);\n        let scaled_total_deposited_asset: u128 = scaled_total_deposited_asset_loc.read();\n        scaled_total_deposited_asset_loc.write(scaled_total_deposited_asset + scaled_amount);\n    }\n\n    #[public]\n    fn compute_total_deposited_assets(market_id: Field, asset_address: AztecAddress, deposit_accumulator: Accumulator) -> u128 {\n        let scaled_total_deposited_asset_static = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let total_deposited_asset = scaled_total_deposited_asset_static * deposit_accumulator.value / 1000000000 as u128;\n        total_deposited_asset\n    }\n\n    #[public]\n    fn add_asset(market_id: Field, asset_address: AztecAddress, oracle: AztecAddress, loan_to_value: u128, is_borrowable: bool, optimal_utilization_rate: u128, under_optimal_slope: u128, over_optimal_slope: u128, deposit_cap: u128) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n\n        assert(loan_to_value <= (10000 as u128));\n\n        asset_loc.write(Asset {\n            asset_address,\n            oracle,\n            loan_to_value,\n            is_borrowable,\n            optimal_utilization_rate,\n            under_optimal_slope,\n            over_optimal_slope,\n            deposit_cap,\n        });\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id).at(market_assets_list_len);\n        market_assets_list_loc.write(asset_address);\n        market_assets_list_len_loc.write(market_assets_list_len + 1);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        assert(deposit_accumulator.last_updated_ts == 0);\n        assert(deposit_accumulator.value == 0 as u128);\n\n        deposit_accumulator_loc.write(Accumulator {\n            // 10**9\n            value: 1000000000 as u128,\n            last_updated_ts: context.timestamp(),\n        });\n\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n\n        assert(borrow_accumulator.last_updated_ts == 0);\n        assert(borrow_accumulator.value == 0 as u128);\n\n        borrow_accumulator_loc.write(Accumulator {\n            // 10**9\n            value: 1000000000 as u128,\n            last_updated_ts: context.timestamp(),\n        });\n    }\n\n\n    // Create a position.\n    #[public]\n    fn update_accumulators(market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let mut deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let mut borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n\n        let timestamp = context.timestamp();\n        let time_delta = timestamp - deposit_accumulator.last_updated_ts;\n\n        // Only update if time has passed.\n        if !(time_delta == 0) {\n            let precision = 1000000000 as u128; // 10**9\n            let utilization_rate = _compute_utilization_rate(market_id, asset_address, precision, deposit_accumulator, borrow_accumulator);\n            let borrow_rate_per_year = _compute_borrow_rate(asset, utilization_rate, precision);\n            // TODO: let supply_rate_per_year = borrow_rate_per_year * utilization_rate * (1 - reserve_factor);\n            let supply_rate_per_year = (borrow_rate_per_year * utilization_rate) / precision;\n\n            let new_borrow_accumulator = ((borrow_accumulator.value * borrow_rate_per_year * time_delta as u128) / 31536000 as u128) / precision;\n            let new_deposit_accumulator = ((deposit_accumulator.value * supply_rate_per_year * time_delta as u128) / 31536000 as u128) / precision;\n\n            borrow_accumulator.value += new_borrow_accumulator;\n            borrow_accumulator.last_updated_ts = timestamp;\n            borrow_accumulator_loc.write(borrow_accumulator);\n            deposit_accumulator.value += new_deposit_accumulator;\n            deposit_accumulator.last_updated_ts = timestamp;\n            deposit_accumulator_loc.write(deposit_accumulator);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_utilization_rate(market_id: Field, asset_address: AztecAddress, precision: u128, deposit_accumulator: Accumulator, borrow_accumulator: Accumulator) -> u128 {\n        \n        let scaled_total_deposited_asset = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let scaled_total_borrowed_asset = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address).read();\n\n        let total_deposited_assets = (scaled_total_deposited_asset * deposit_accumulator.value) / precision;\n        let total_borrowed_assets = (scaled_total_borrowed_asset * borrow_accumulator.value) / precision;\n        let mut utilization_rate = 0 as u128;\n        if (total_borrowed_assets != 0) {\n            utilization_rate = (total_borrowed_assets * precision) / total_deposited_assets;\n        } else {\n            utilization_rate = 0;\n        }\n\n        utilization_rate\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_borrow_rate(asset: Asset, utilization_rate: u128, precision: u128) -> u128 {\n        let mut rate = 0 as u128;\n        if utilization_rate < asset.optimal_utilization_rate {\n            // rate = base + utilization * slope1 / optimal No base for now\n            rate = (utilization_rate * asset.under_optimal_slope) / asset.optimal_utilization_rate;\n        } else {\n            // rate = base +slope1 + (utilization - optimal) * slope2 / (1 - optimal) No base for now\n            rate = asset.under_optimal_slope + (utilization_rate - asset.optimal_utilization_rate) * asset.over_optimal_slope / (precision - asset.optimal_utilization_rate);\n        }\n        rate\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_position(owner: AztecAddress, market_id: Field, asset_address: AztecAddress) -> pub Position {\n        let scaled_user_deposited_asset_loc = storage.scaled_deposited_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_deposited_asset: u128 = scaled_user_deposited_asset_loc.read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let collateral = (scaled_user_deposited_asset * deposit_accumulator.value) / 1000000000 as u128;\n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let debt = (scaled_user_borrowed_amount * borrow_accumulator.value) / 1000000000 as u128;\n        Position { collateral, scaled_debt:scaled_user_borrowed_amount, debt }\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_total_deposited_assets(market_id: Field, asset_address: AztecAddress) -> u128 {\n        let scaled_total_deposited_asset = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let total_deposited_assets = (scaled_total_deposited_asset * deposit_accumulator.value) / 1000000000 as u128;\n        total_deposited_assets\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_total_borrowed_assets(market_id: Field, asset_address: AztecAddress) -> u128 {\n        let scaled_total_borrowed_asset = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address).read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let total_borrowed_assets = (scaled_total_borrowed_asset * borrow_accumulator.value) / 1000000000 as u128;\n        total_borrowed_assets\n    }\n\n\n    #[utility]\n    #[view]\n    unconstrained fn get_accumulators(market_id: Field, asset_address: AztecAddress) -> (Accumulator, Accumulator) {\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        (deposit_accumulator, borrow_accumulator)\n    }\n}\n"
    },
    "56": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "57": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "64": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "65": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "66": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "67": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "71": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "88": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "92": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "93": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "96": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "97": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    }
  }
}
