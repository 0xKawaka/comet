{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "Lending",
  "functions": [
    {
      "name": "add_asset",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "oracle",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "loan_to_value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "is_borrowable",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "optimal_utilization_rate",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "under_optimal_slope",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "over_optimal_slope",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "deposit_cap",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "add_asset"
      ]
    },
    {
      "name": "_liquidate",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "debt_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "user",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "debt_to_liquidate_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1840251649407153602": {
            "error_kind": "string",
            "string": "Insufficient borrowed amount"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14434150440419769526": {
            "error_kind": "string",
            "string": "collateral >= debt"
          },
          "15333773746166717806": {
            "error_kind": "string",
            "string": "Insufficient collateral"
          },
          "16523063005220065570": {
            "error_kind": "string",
            "string": "Function _liquidate can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_liquidate"
      ]
    },
    {
      "name": "borrow_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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gAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAAB0UjAAAHtSQAgA0AAAdSIwAAB2suAIADgAUBAIAFAAKADi4CgAuADiMAAAewKACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAAewIwAACAkoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAACAkoAIANBAADAQCABYANgAwLAIADgAWADSQAgA0AAAhtAQCACoAIgA8uAIAKgBAuAIAMgBELAIAQgA+AEiQAgBIAAAhtLgGAEIAOLgKADoARAQCAEAACgBABAIARAAKAESMAAAg8AQCADIAIgAYmLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAACMUjAAAJNSQAgA0AAAjSIwAACOsuAIADgAUBAIAFAAKADi4CgAuADiMAAAkwKACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAAkwIwAACYkoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAACYkoAIANBAADAQCABYANgAwBAIAMgASADQMAgAgAAoAOAQCADYAOgA8BAIAKgA6AEA0AgBCACoAOJACADgAACekuAYAQgBEuAoARgA8DAIAQAAKAEAMAgA8AAoAPIwAACbguAIAMgAYmKgEAAQXFa8RaDhAAAjwBAQIm",
      "debug_symbols": "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",
      "brillig_names": [
        "borrow_public"
      ]
    },
    {
      "name": "update_accumulators",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "12348881442450494403": {
            "error_kind": "string",
            "string": "Function _compute_utilization_rate can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17134621154673181869": {
            "error_kind": "string",
            "string": "Function _compute_borrow_rate can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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ABy2IwAAHCgLKAAFgFcABiQCAAYAAByGIwAAHD0LKAAFgFkABiQCAAYAABxWJwINBAA8CQENCygADIBEAAUkAgAFAAAcayUAABESLQwBBy0MAggtDAMJLQwECi4IgFoACyMAAB42CygADIBEAAUkAgAFAAAcmyUAABESLQwBBy0MAggtDAMJLQwECi4IgFgACyMAAB42CygADIBEAAUkAgAFAAAcyyUAABESLQwBBy0MAggtDAMJLQwECi4IgFMACyMAAB42CygADIBEAAUkAgAFAAAc+yUAABESLQwBBy0MAggtDAMJLQwECi4IgFQACyMAAB42CygADIBEAAUkAgAFAAAdKyUAABESLQwBBy0MAggtDAMJLQwECi4IgFUACyMAAB42CygADIBEAAUkAgAFAAAdWyUAABESLQwBBy0MAggtDAMJLQwECi4IgFYACyMAAB42CygADIBEAAUkAgAFAAAdiyUAABESLQwBBy0MAggtDAMJLQwECi4IgFcACyMAAB42CygADIBEAAUkAgAFAAAduyUAABESLQwBBy0MAggtDAMJLQwECi4IgFkACyMAAB42CygADIBEAAUkAgAFAAAd6yUAABESLQwBBy0MAggtDAMJLQwECi4IgFsACyMAAB42CygADIBEAAUkAgAFAAAeGyUAABESLQwBBy0MAggtDAMJLQwECi4IgFwACyMAAB42LQwKBC0MBwEtDAgCLQwLBS0MCQMmJQAADogtCAELJwIMBAQAEAEMAScDCwQBACgLAgwtDAwNLgqARgANACgNAg0uCoBGAA0AKA0CDS4KgEYADS0IAQwnAg0EBQAQAQ0BJwMMBAEAKAwCDS0MDQ4uCoBGAA4AKA4CDi4KgEYADgAoDgIOLgqARgAOACgOAg4uCoBdAA4tCAENAAABAgEtDgsNLQgBCwAAAQIBLQ4MCy0IAQwAAAECAS4KgEUADC0IAQ4AAAECAS4KgEQADicCDwQQLQgAEC0MDREtDAsSLQwMEy0MDhQtDAQVABAADwAlAAAO1i0EAAAnAgQEDy0IAA8tDA0QLQwLES0MDBItDA4TLQwGFAAQAAQAJQAADtYtBAAALQ0OBAsoAASARAAGJAIABgAAH3YnAg8EADwJAQ8nAgQEDy0IAA8tDA0QLQwLES0MDBItDA4TABAABAAlAAAP/y0EAAAtDQ0ELQ0LBi0NDA8tDgQNLQ4GCy0ODwwuCoBHAA4BKAAGgEgACy0NCwQLKAAFgEwABgsoAASARgALJAIABgAAIeAjAAAf5AsoAAWAUwAGJAIABgAAIbYjAAAf+QsoAAWAVAAGJAIABgAAIYwjAAAgDgsoAAWAVQAGJAIABgAAIWIjAAAgIwsoAAWAVgAGJAIABgAAITgjAAAgOAsoAAWAWAAGJAIABgAAIQ4jAAAgTQsoAAWAWgAGJAIABgAAIOQjAAAgYgsoAAWAWwAGJAIABgAAILojAAAgdwsoAAWAXAAGJAIABgAAIJAnAgwEADwJAQwLKAALgEQABSQCAAUAACClJQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgoLKAALgEQABSQCAAUAACDPJQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgoLKAALgEQABSQCAAUAACD5JQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgoLKAALgEQABSQCAAUAACEjJQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgoLKAALgEQABSQCAAUAACFNJQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgoLKAALgEQABSQCAAUAACF3JQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgoLKAALgEQABSQCAAUAACGhJQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgoLKAALgEQABSQCAAUAACHLJQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgoLKAALgEQABSQCAAUAACH1JQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgotDAoELQwHAS0MCAItDAkDJioBAAEFZGGIqMbPlMs8AQECJioBAAEF7cpnKDUwRK08AQECJioBAAEFRafKcRlB5BU8AQECJi4BgAOABgsAgAYAAoAHJACABwAAImwjAAAidy4AgAOABSMAACLeLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAAIsouAYAKgAguAoAIgAsBAIAKAAKACgEAgAsAAoALIwAAIpkoAYAFBAABAwCABgACgAYjAAAi3iYqAQABBb4eP/8+pPb6PAEBAiYqAQABBcVrxFoOEAACPAEBAiY=",
      "debug_symbols": "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",
      "brillig_names": [
        "update_accumulators"
      ]
    },
    {
      "name": "deposit_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fromPublicBalance",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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669ddK+/dtG9/tpF9/prF+Xrr1G+/hrl669Rvv4a5etvk/39JeNXvv4a5euvUb7+GuXrr1G+/lrl669Vvv5a5euvVb7+NtnXWDJ+5euvVb7+WuXrr1W+/lrl669Tvv465euvU77+OuXrb5P9HCXjV77+OuXrr1O+/jrl669Tvv565euvV77+euXrr1e+/nrl669Xvv565euvV77+euXrr1e+/q7K199V+fq7Kl9/V+Xrb5M9ByXjV77+dr6TYDl+5etv5zsJluNXvv52vpNgOX7l62/vewMW41e+/va+f18xfuXrb+977BXjV77+9r4PXjF+5etv73vVFeNXvv72vp9cMX7l62/v+8kV41e+/va+n1wxfuXrb/f7yZXiV77+dr8/Wyl+5etv9/udleJXvv52v39YKX7l62/3+3GV4le+/na/v1UpfuXrb/f7RZXiV77+ZuXrb1a+/irf/8oq3//KKt//yirf/8oq3//KKt//yinf/8op3//KKd//yinf/8otutdf1/3+V6ftKxq2a82y2E8X38FMu9F1Ccy0O12XwEy71XUJzLR7XRfAdL95WTMwek8xucev97SRe/xeefx6q5p7/HqLj3v8emuEe/x6l/J7/HpX3N/xd7+rWCl+vac13ONXvv52v6tYKX7l62/3u4qV4le+/na/q1gpfuXrb/e7ihXi735XsVL8ytff7ncVK8WvfP3tflexUvzK19/udxUrxa98/e1+V7FS/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexUvzK19/udxUrxa98/e1+V7FS/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexUvzK19/udxUrxa98/e1+V7FS/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexUvzK19/udxUrxa98/e1+V7FS/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexUvzK19/udxUrxa98/e1+V7FS/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexUvzK19/udxUrxa98/e1+V7FS/LrXX9/9rmKl+HWvv777XcVK8etef/2ie/31incVu8eve/31ivfouseve/31ine8+h2/4o2p7vErX3+V73/lle9/5ZXvf+V73/8quLzFnxZX+OgfbSyXthnm/PnaO5fO1/VmXDqvF5px6bwOOY/L+w0afe8bjDUD0/vOZe3AdF6StQPTea3XDkznRWQ7ML5vMGn/aJ98CUwM7uPiGMN+rbcfU+28kJWcaue1qeRUOy8330z1Hn/nZWEx/s6rt1L8nW9Ptxq/bhebcGDPO9+erhx/3yVLOf6+K4ty/F55/H2v6uX4+16qy/H3vf6W4+97/S3H3/f6+xy/NfZr/J1vT1eOX8/6exy/nvX3OH496+9x/HrW3+P4O19/o4n7xSkfxN/5+luMv/P1txh/5+tvMf7O199S/J1vT1eOv/P1txh/5+tvMf7O199i/J2vv8X4la+/nW9PV45f+frb+fZ0a3LLdnEOqfDRPu+TfX6VKdmDa21ctuOMbbSPyjZ8cOl8XW/FpfPt9Npx6bwOEeJyn2vnNYvoXDuvb0Tn6ieaa+d1k+hcO6+xROfaeT32o7neWm7bxT4dzHWk2q0015HqscJcO98yUXauI9VNpbmOVDeV5jpS3VSaq59oriPVTaW5jlQ3reteN6WDuqnzbSZl5zpU3VSY61B10/u5dr7Vpexch6qbCnMdqm4qzHWouqkwVz/RXIeqmwpznahu6nx70Hdzvcevtxa6x6+3vvkdf+fbg5bj11uH3OPXW1vc4++7XgjLsgUSXDAH8Xvl8fe9rpfj73utLsff9/pbjr/v9bccf9/rbyn+tfPtQcvx973+luPve/0tx697/V0X3evv2vn2oOX4da+/a+fbg5bj173+rp1vD1qMv/PtQcvxK19/O98etBy/8vW38+1By/ErX38738azHL/y9bfzbTHL8StffzvfZLIcv/L1t/MtG8vxK19/O98AsRy/8vW3860Ky/ErX38733+wHL/y9bfz/QfL8Stffzvff7Acv/L1t/P9B8vxK19/O99/sBy/8vW38/0Hy/ErX38733+wHL/y9bfz/QfL8Stffzvff7Acv/L1t/P9B8vxK19/O99/sBy/8vW38/0Hy/ErX38733+wHL/y9bfz/QfL8Stffzvff7Acv/L1t/P9B8vxK19/O9/Prxy/8vW38730yvErX3873/OuHL/y9bfzvenK8StffzvfQ64cv/L1t/O93srxK19/O9+TrRy/8vW3873TyvErX3873+OsHL/y9bfzvcjK8StffzvfM6wcv/L1t/O9vcrxK19/O9+Dqxy/8vW3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inz6V5jl/K8w53+FPf8rDpN2Xbeu6ZqeKz37MSjWDEo1g45TZYn7rH79O/+lIskvHnMtMe8l7HJ7UPxlmKkbZuuGubphxzfL5fZA6THsaRP2bdhaNyzUDYtVw9wL3fJjO/olB/Nl2AuSOW3b0huzLF9IOl83bK0bFuvmluqGvfjDydk9Bbn+dZhf6oaZumG2bpirG+brhq11w47/cG6X5scw+5wlf/t5Th3vpyX9JemKL8l//iXvn0Xm4yeEsl9hzv8K+9OvuA9zdcN83bC6W+SL53PFYbFuWKoblquGhaVumKkbZuuG1S2koW4hffGoI677jTXG55+pHv212LjsbxhFa798RT79K1486hD9CnP+V9jzv8Kd/xX+/K9Yz/+KcP5XxPO/4vy/7nj+X3c6/687nf/Xnc7/607n/3Wn8/+60/l/3en8v+50/l93+vFf931YrhqWl7phpm6YrRvm6ob5umFr3bBQNyzWDavLklyTJeuyLHXDTN0wWzfM1Q3zdcPWumGhblisG5bqhtVlianLElOXJaYuS0xdlpi6LDF1WWLqssTUZYmpyxJTlyW2LktsXZbYuiyxdVli67LE1mWJrcsSW5clti5LbF2WuLoscXVZ4uqyxNVliavLEleXJa4uS1xdlri6LHF1WeLrssTXZYmvyxJflyW+Lkt8XZb4uizxdVni67LE12XJWpcla12WrHVZstZlyVqXJWtdlqx1WbLWZclalyVrXZaEuiwJdVkS6rIk1GVJqMuSUJcloS5LQl2WhLosCXVZEuuyJNZlSazLkliXJbEuS2JdlsS6LIl1WRLrsiTWZUmqy5JUlyWpLktSXZakuixJdVmS6rIk1WVJqsuSVJcluS5Lcl2W5LosyXVZkuuyJNdlSa7LklyXJbkuS+p6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdqXvRe8/6GocneHAx7kSX7ln4mZ/tp2NFWvkIHhdzCiX2Fk/oKJ3cVzqvedqtwTF/h2L7CcX2F4/sKZ+0rnL7uyqmvu3Lq666c+ror577uyrmvu3Lu666c+7or56vvym/PuLrFs3YWT+gsnthZPKmzeHJX8djjJ7j2Vrp+DLPWrIV4bg592cMP8a+7F9y+xFzxJfaKL3EiX+LC40uCe/qSg1/kJbdtDOSW532fluPtVJd9z7XFPX57n+1H/L7z+Nedf1id+xr/qjz+oDz+qDz+pDz+rDt+syiP3yiP3yqPv/f1txS/8vXXKF9/jfL11yhff43y9dcoX3+t8vXXKl9/rfL11ypff63y9dcqX3+t8vXXKl9/rfL11ypff53y9dcpX3+d8vXXKV9/nfL11ylff53y9dcpX3+d8vXXKV9/vfL11ytff73y9dcrX3+98vXXK19/vfL11ytff73y9dcrX39X5evvqnz9XZWvv6vy9XdVvv6uytffVfn6uypff1fl6++qfP0NytffoHz9DcrX36B8/Q3K19+gfP0NytffoHz9DcrX36B8/Y3K19+ofP2NytffqHz9jcrX36h8/Y3K19+ofP2NytffqHz9TcrX36R8/U3K19+kfP1NytffpHz9TcrX36R8/U3K19+kfP3NytffrHz9zcrX36x8/c3K19+sfP3NytffrHz9zcrX36x7/XWL7vXXLbrXX7foXn9d9/tfleLXvf465ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftf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",
      "brillig_names": [
        "discover_new_messages",
        "decompose_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkAAAAA//////////8AG20B1yzdCJRh9T8Z\necbYL8GbJ2QKMy8thEFEG9U1o7UU2EB0CfuyKOugXyPLSQ2k8/YOgraKn6cfSG+1PkfXAhmAXn/d\nW2W9qKlTTeKHY3UiMAap1cAEGqEmdMViUwuxFpbcz57aJiwkqMjuTAIZJgbmRz5zpvE+gFMW7IZz\nKcMqrEsJV6FKE89hsg+uXsmm9REHr0cThohOnn3KIsX70BzVI2fYF476kFfFXHAiBD6nkPq6ysAS\neMUcvQ1DVi8pHUW6pK0XSu+Ic39ZdeknVLPTt0cKcIJUNX4zYle4ivQB/uwaAhvReVLzX18QOeRd\naJdFpseFSoehKV7moAxZ+gKDDvZT86dsKUYYiytsO8uqd/rUiHFVaErS0/933ecdDYi9OWWsEb3U\nx3Ko3olVkxyPlpisaC9uLiOkZt82FwITqFZaqxIp+sKOfA0/LPhGxmLsdZB1PPtlEYL48LIHjSey\n/HRYNoRJ3wUlH3Foy6VCOFCO6qMhFCac/Ld+Zk8aIuSmLVifXcWOAD4X0sKeZqqcjXq3WBuYEO2n\nPlPhfd8OP4PTyf+mJHwLpRXOLm9SrLCVbfb6d5ltuCSwof5icAWAOdGTIloJDBxD6rJm2uBK2eUa\nTtY3AGgmVXq4Em0rBT5bIVQbAIXof+fe3dWp52EULvP6uuwTnmbsSVeRCscawYwU2j0RMmb0gffD\nur8XLg2I7iMPGv+k0PCwM8mdwg11m7Q4yOgb1Djpo6Iu2CTJ9U2anZEyU38b0dDqBdOfJPWYxxmB\nfpIrQeoQXbpbSpICOEwUXm1lkPwYOvAEY/ISDcBcWRAkGl2Q0/FLzh/enw+yODaiLjUTyGJGK/u0\n7xxQB88rrhfp0vxeXOODJDgDisdO9pvUO73UKqpQJKv+BlgGiTOf86hGeVae2tgwKINa6VLDSfY6\nzW4e+dRuXDAWxIgHS55cyh8EGMymBFNaecHqbdZuoykSDDTOw1NTnhJQCX48lOpUQ4quUqk0jDC5\nvwo5b1dP3q2xIYEOQucFIwJoK/GW8QH0+V1GfBqMKxn3sJtkEv6f0nMKgkFH+sYTRYTqYp6HeAWb\nM9tiOJwPnIyAHSNIAsHsymX7oAxvngxRx8bohz8ug/hzmC8pQuwVdOPPVVKl1IC0H1uSpEpfGTkN\ncrCW6vpe97hH7swc3+c6MwYAtorj5RY7erxzCCwLDaomc36PpJkWrhIRthQVSIcWUzOiB2u6EAEA\nH9zb7Q/IQy+OcXkWBK3m/BK37sI7rRBcjBSo4Nv/wY4lCeqVGMuAGxl4lymWE3GqkdmbTYVX9uyZ\n3nmm9kabO52+n2Yc1KjhKCdbgzhjfhxsOGj0VfRqAbI5Ws9myIKdtLKduQRb024z7/JH1+gZ4f54\n/yQGaaY/trb5I5OVWyMKurQvFTX2Hp5tFupdTVmqS/h5X/NA9wRlQTdQePr+ryVXDFoLtFDFuKJO\n8Qu4TRfyNz/v81nX9NdFnBmGoPtqBBTIiy1lpnyLV0/rlk4i8FyAE9EZ+HfavzsGzJkFkXWHfC6H\nIxRHsgDjzhNfd0bCgCz9ymEcbPIn1fKQ7oc5CJzYFRkIJ87NAfuuPrnTEG7KMplKZmQPS6ciS2aj\n09nbbZcfQAxKypkVQJB7J1XMxJhvJCXd8CdlYMudJXx3UuIeprvjGg1kVdXMMTR9I7InFCzCFC/j\no8BrgGFdEgn3dm1h7CAZ/U5O1iEoMK9wZjdVdMvs0boO5giT6d2Ix2zDyqX84iXErd3KybfG2AaG\nehas0/puKp6HPqYiOAe/itYrNEVTAN0K0i+rMpepxMCSAik6N88kl+rnjBUfQjoY9g/tUc8TFdGy\nYBCCLR9QPk/nA38CKbM6TC3j+oLi3Ib1n/FRVCTWvHWd/IyUcPmmHlCqR1Gc+Wlcp8yPYCr7/6iW\nKoxoFrrWO/J20yopZbBGS4Dg+XBj6s+1vuEvoTj1TED/XgsF+d37hYhDIQ+I3KPgKkXzd0fli04q\n3pCfVR6ykxCzmCGxPS1MgeUKgMU302ghQxecbQNrEFnEE0rNRgN5dQ5GFsp+JZndkmQspDVI1R+c\nnjdbR1FZXbc42Iv5BABlXYMpH/2Vm8T6LK0gU+xDvqefhWipXhrCZPJbmhQZIwSMyw7WXkKxGe9B\nZzEuX3hU5Wfta0fJKZOa4pIPLxgyKlSwAvnkq7aZzHvUUQk6+5Otfh5qJJR1B4gKxHentAPG7qEA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAACJcpD1TpYy67th5UPXwZ+hPrxQImoezBakL1GugaY8+gJZ4cf9vuYLYMty8Q+LkrCSHSp\nMJ4FCWiy1L2Y0yfMDwDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMk\ngqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJiS18GKk8\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "_borrow",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1602191554767750373": {
            "error_kind": "string",
            "string": "Function _borrow can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14687457983715723088": {
            "error_kind": "string",
            "string": "Asset is not borrowable"
          },
          "15333773746166717806": {
            "error_kind": "string",
            "string": "Insufficient collateral"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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CygABoBFAAUkAgAFAAAfuSUAABkhLQwBBy0MAggtDAMJLQwECiMAACBMCygABoBFAAUkAgAFAAAf4yUAABkhLQwBBy0MAggtDAMJLQwECiMAACBMCygABoBFAAUkAgAFAAAgDSUAABkhLQwBBy0MAggtDAMJLQwECiMAACBMCygABoBFAAUkAgAFAAAgNyUAABkhLQwBBy0MAggtDAMJLQwECiMAACBMLQwKBC0MBwEtDAgCLQwJAyYuAYADgAYLAIAGAAKAByQAgAcAACB4IwAAIIMuAIADgAUjAAAg6i4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAACDWLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAACClKAGABQQAAQMAgAYAAoAGIwAAIOomKgEAAQXFa8RaDhAAAjwBAQImLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAAIUwjAAAhvCQAgA0AACFZIwAAIXIuAIADgAUBAIAFAAKADi4CgAuADiMAACG3KACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAACG3IwAAIhAoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAAIhAoAIANBAADAQCABYANgAwLAIADgAWADSQAgA0AACJ0AQCACoAIgA8uAIAKgBAuAIAMgBELAIAQgA+AEiQAgBIAACJ0LgGAEIAOLgKADoARAQCAEAACgBABAIARAAKAESMAACJDAQCADIAIgAYm",
      "debug_symbols": "7Z3bjiQ3jobfpa/7QkdK8qsMFobt8QwaaNgD27PAwvC7b1RlxaGdVLJSUmRJqd8XRld3sEh9wSAl6vTnp3/+/ON///39l1/+9evvn777x5+fvv760w9/fPn1l+WnP//6/OnH3758/frl398f//qTevmfMfpV4Pf//PDLy8+///HDb398+i6EaD5/+vmXf376Lmptll/xry9ff/70nVbqr//5vEj5EimriqSoRMoV6XJF7fJFDH2RLipqF5XpSpyUtgumNzFtbVTfyH2+fl6ZVYtWbteSAvOwSyq8PeySpu1h8szD0bm42u/IHR9+MT+4NuantD6udXqg+Y3o+7jRjwJ97cNqviZrb5ufvHVvD6dF7u/mx9DafG2+Mf9FSfLnK7GK/eQWX0h2lTJKa0GJV1G9Pb78MQqu4fXagOit+htbq/hmL1aE3SIbBIsaOqvV72Fk099DjNW+TM7YQrnIyfmwv5uo9sZ5y3oL2T0g7B+J9on9pOjtYaN2z7JGM8+GtLltSGl/2kTHPG39Glbd4eUZxT1rdNKrGUYl4Wlv1oh39L2XZ18QWgOEtQgDEFYidPDCaoTwwlqEHl5YjZCAsBIhwQurESIW1iIMFghrEWJ0UoswOiCUEaZ14E/aXyOEF9YiTIiF1QjhhZUInYIXViOEF9Yi1BidVCOEF9YiNIiF1QgTEFYitA4IKxHyCzuA8B6EHggrEfJLfqZG+IoFnsVhIcQsFguyIYsFvX0OC+YXeCyYueKwRCRoFgtm2zksCTUqFgu8hcHiFWILi2XSTGTiOiFt7MGOFcus9W8JC7yFw2ImjS0SlkkLCxKWSUvyAhY76VBRwoKQy2FxCLkslkk7/wKWWSv/EhYkaA7LrJV/CYsDFg7LpJV/AUvACJrFggTNYYkIuSwWhFwWC0bQHJYEb2GxTJqgg97MCH/bdHXf0wtEUpOm87sgaqIVh6YQryDqSbNcW4j4nOshzrqyvi3ESUuz90EMYWthSFfZmWY9magtxElHlU0hzrpJoS1EB4j1ENHFqYc46zFPbSGii1MPcdajntpCRBenHmJAF6cBRAeI9RDRxamHGJFYGkBEYqmHmJBYGkCEJ74DYlLb1Q7JXEEMCtm5AcQG2VnH7X4G47wA0fu0/erkD08r7nfTdrtHOIB5+c0vxmsa2HjjBja+RS3/44yXSx06PmHgaHeOa3jHonwgFBASEFYi9PDCaoTwwlqEBC+sRuiBsBJhgBdWI0QsrEX4jjolEAoIMTqpRfiO8/2B8OYJmiHBCysRRoVYWI0QXliLUMMLqxHCC2sRGoxOqhHCC2sRWsTCaoQRCCsROoxOqhEmIKxE6B0QViJ8x+lBsyF8xQLPYrEgZnFYArIhiwW9fQ4L5hd4LJi54rAkJGgWC2bbGSxJoUbFYoG3cFg0YguLZdJMdPtksjRr/VvCMmlskbBMOlQUsNhJh4oSlkmHigKWWbcoSFgQcjksftLunIQF3sJiQYLmsMxa+ZewTDpnLmAJk9ZyJSwYQXNYIhI0iwUhl8WCkMthmXVjhIQF3sJg0WrWHQwt71NYKE6a0FuewK6VnjTRtaVo8EW3oDhpxbUtRTtpgbblSXILRWSXBhTdpKPLxhSRo1tQnHQ00paiR0+nBUVklwYUZz0hqjFF+GIDigE9nRYUHSg2oIieTgOKs+6JaUwR2aUBxVl33DSmiOxST3GZeAHF2vsBForI0Q0otjiFq/S8fIrG7U+z5+UHWjf1hEOlXlO8WG/U0NbHka1vUd//OOszi/Ajmc36QJL12zeudVDf6GDsiXa1PkSvt6fJcw+7/Z4Ir9Tx4Yv1fmTrM0vaR7F+aPY0NHsam30a2fowNPs4tN9nagCDWJ+GzrWZA6fHsN5kVkqOYn0c2Xpth7Z+5GxlMpfYDWK9HTlbGTtyT8EMPTI0buSegvFDZys/NHsa2u9j39Z7Q5v1JlxZn/rOtaS3WhrpK+utenw/x+zWE922Xi/1970GnuzhuNwU3xoQB2+AHv0N6DB4A4wevQE0eAPs6G/Ajv4G3Ohv4AOmVRo3IPXcABfS2gty0cZr870b2/yuuxGi+WTGNr/rLoRofhibfug6eYnmf8D0UNvIH0cfwqSu/V9ugFODu5BTw2bf66d92I3ez4K2Nr01ddh+0t1N1fO8Vd31W33HF2i6flfvacDob8AOXkhzdvBCmnOj9wPc6G/Aj/4G/OhvgAYvpDnqupAmjQZd6LorL5vvxjZ/6DLa8pdjmz82/b7LCLL5g88BeTV46vJq9DegB69D+b4rFu9pwOCjYD96HcKPXofwdvQ3YAefj/B91yGkjoTvuwohmu+77kbI5g89/vU09PjXj1198DT0Ih4fBi+h+77rD+9oQN8ViPc0YPACrk+jj4JHr0PQ6HUIGr0OQXr0N6AHXw1MfdchpI4E9V2FkM0fupBOdujxL/W9DkI0f+zqA7mhVwOTH7yETn3XH97TgMELuESDj8GIBh8F0+h1CBq9DkGj1yFo9DoE9V2HEPNw31UIyfzQ944Q2Xw3tvlDj37DuPs2LuYPPfoNmetI4ya2lHj90fxXqdyxXYIU21knpdZDV0gZfRuVSyqs7UlaaHx0bj11OTpyx4df7clcOZi2O5lJeeHVkV01kN+PVU/0psCfrMCf3QJ/egvSyQrIna3g7BaEs1uQ6X+3U5DpHzdUEE5WkFlt21DByS2ImXmihgr82QpO/tCidmcrqP/QzDLZ8fawobAfUabf7rmIxj5AxwPaYR/QDhvO1+HMA3Q8oB3+Ae3InCvZVAfpB+jw5+sI6gE6HtGOdL6Os/sfMZ7cg4pn9z9iOrkFSZmzFZzdAn12C/TJfcBkzm6BoZMVWHW2AtdAAW0P0+EqslWFs+eriKer8OZ8FXS6CtLnqzi/FUGdr0L+LkK6rWIZIa6XEEYVDoW+8KYinq7iHR2BahWhXoWNfqtbHm5rXFRcP2yVXyuiVsX9Yf6A67TZrg93JJpLgTa9o5fR2HanN9v9N9Xciz2hJ3uMUrYve7TqzB7flz1Gd2ZPZ/5sH84nbbHKBLodq7Ra5sLentbKWHdtPg1tvlNjm++HNt+PTZ8enYosrcMma6ORzA92u29aBc+Y/+hI6LZrQKxzQTI/KtrMj1ZdmR8eHTjddjHJYn6UzF8m3zfzk4/X5vuhzY9qbPPd2Oanoc1PQ9PXioY2Xw8dOLUem74Zm74Zm74dm74dutOg3dCdBu3GTlsuDm0+9RN5Xu0J/TjzxZ5+YsPFnkf3Ub1xqz1eHF5qm9axtNbO2CvzHz5CaGx+HNr8ZMc2f2j6S3Gi3ny/Fc+ij3Q0/1WFNueroNNVGHW+Cne+inS6Cnt+K2w8XYVr4bTbPqPok7tWEU5X4fX5KvzpKkidr+IBrUinq+C3ppN26+wAabK3VTTc8bXYE3l77LYDTadw255by8eMieZsBeFkBfxO6rsUCOtxFx3+dB2W35PcWIc792VYfstLQwXanq3g7BaYs1tgzm6BPbsF9uSoZ93ZLXAnRz3r9dkKfAMFt5ZoGkvufBXpdBXBnq8inK6iST9AUHF+K5I+X4X4XSwD3dsqXk5hW0sKRPvDblWRzlbh5I5AvYpYreKD1hUbJ/cyWtt+c92j07Eve4zryx6rO7OH+rLHmc7s6cyf/cP5tFxbmblWcxjzSY9tPg1tfhibfnx0Kmq6rjhzqeOJ5jddV5y51PFM81suk8hc6jiK+ZkrHccx3w9tvlZjmz82fROGNt8OHTi9HZu+G5u+G5u+H5u+H7vTQGN3GmjstEVpaPNjP5Hn1Z7UjzNf7OknNrzYQ+rRfdSmayvp4SOExuanoc3Xbmzzx6ZvGlSGbi/RJGvPVxFOV+H0+Sr86Sq8Ol/FA1qRTldBLZz25irQzA1LTVUEc74KOl1F1OerOL8VSZ2vgk+lS2RZVVgl3CQRtF8TRnB6Ty9vC1MCf9ZXWxXxdBX8Vpe2Kuh0Ffy+9bYqzm8Ff3ZpWxXv+C6EJf3aWbtOKC5/DkbopS3f59pLi9Hf7qXdXiYUbHq89dtOhKUhV+O94Fx3FnXHyHfHyMfeLCLbnUXdMQrdMcqsE/5Ai6LpziLqzaKku7OoN0ZRqe4s6i2LZK4b+kiLMksMTrUorb07p6TenVY2rpceauX8VQ0uGjV6A9zoDUiDN8CO/gbcwzsVy0Bx20Gtk5YaICyxjP7h+XUp529vwHhxiauwyDJ6//gGbFe2Lg0QV4kKs8bRp8EbQG70BsTBG/D4wVbrBoz+BpIavQGDh9GkBn8DSY3+BvTob0AP/wYG70qkx4/IWjdg8ESWrBm8Ab6nKHSxqCenvljUU5x4tejxUyrL0+vI2FlxGCotSEsfMIZo24BgRm9AGLwBcfQ30GSuxpu0NcA7f2zARQmdrsSqJoMJUYl7hJL4ACXaPkLJI1pizCOUNHFh5XYlXlh9rWOgrZAdwyEuLGHnYlSTUnxzo2KHRjnbo1E9kvI8qSUvbUYlezTqIhVLpKhIFxXpyiweFqQy64ElqSJdmSW1klSSpNy3TvQilbnESpLSukiqSJcp0mWKaGTiqNPbh+gO03CrVCamSFKxRMoX6fJFujLH/whSIfe+9C7lr6UyusJ2PLU/HFm4SmW+SkmqSFfmq5Skkih12Nz4JmWUK5HKrDAXpDIrQSQpvtxK25iElv+ElLWE/W1IctiCpn3invbrVLJRO+al0cyzIW17FkJKh9wWHbeqwK8xwR0ONV/eAfOsWWbtVzPMIYDwT+99SX+Y/DaXM6tt5sIFMLyHYSZig+E9DOGH1Qwd/LCeIfywmmGmfwiG9zCEH1YzJMTDaob81ZJgeBdDjFOqGWZG2WD4DcPt7F/SnmEIP6xmmBAP6xnCD2sZ5u4zA8N7GMIP6xlinFLNUMMPqxkaxMN6hgSGtQwtxin1DAMY1jLMnMEOhvcwjGD4N4avXDx8i+eCuMVyIeREngv6/SwXzDlkuDhwYbkgT7NcIubheS6oWbFcEvyF54L4wnHJXXP+9FxMXKeqjT3YsXOZNL5IXDT8hecyaXyRuJhJ6wwil0nr9BIXO+m4UeSCuMtzQdxlubhJxwEiF/gLy2XW+QCRy6TzARKXWecDRC6TzgeIXDCeZrkE5GmeC+Iuy2XWPRQiF4ynWS4J/sJzmTRPB72ZEf62R+u+py8UJ83qd1HUROuxp5pCvKLo1aS5ri3FWVfgt6U46xr8xhQdKMoUw3Y0lA7JMBSRXRpQtJOOMBtTRI5uQNFNOhppTBE9nRYUkV0aUPTo6bSgCF9sQJHQ02lBET2dBhQDejotKKKn04IisksDirPuxGlMEdmlAcVZd/ncRzGp7QqeZK4pkkKObkGxQY7WcbtUzBzuSuIpLqOltfru0+EKCK24301pNT8cyLz85lfrtR3ZeqOHtj6NbP07VuRH9YTRo+GJsPSO1ftgKDB8x0p/MJQYwg+rGXr4YT1D+GE1QzJgWM0QfljNMCAe1jNMYFjLMDowrGX4jhsDwPD2SZyU4If1DBEPaxkGBT+sZwg/rGao4Yf1DDFOqWZo4If1DBEPqxlaD4a1DB3GKfUMCQxrGXoNhtUMAxgyJ9YGgm/xXBC3WC4BOZHn4sCF5YK+PMslYj6L54I8zXJJmIfnuaBmxXGJCv7Cc0F8YbnoSfORcLJZnLUmLnExk8YXkcuk40aJi5103ChyceDCckHcZbk4xF2ey6T9OomLh7/wXJCnWS6zzgeIXCadTxe5TFrflbjMul9B5II8zXKJiLs8F8RdlsuseyhELvAXnsukebrpDQ1JTZrVm57nnvSkua4xRXzRDSjOul6/McVJq7VNz6FLFtmlBcVJR5htKTrk6BYUJx2NNKaInk4DirOeKNWYIno6DSgSfLEFRfR0GlAM6Om0oIieTguK6Ok0oDjr3prGFJFdGlBMyC4tKMIXq+8WcEohR7eg2CBHf9Q5+07pMLL1xo9sfYv6/gdaL1c+Ujxa/yr1jvP0OalQIvWOc1I4KV8klUqkqIgGFekKRbpC0VuORbpi0VtORW85Fb3lVEJeZ1aJBL8mOApJS9/5lg21DntQ0BS53Bnt+p2H6PdfTZ57mLbTeQNRvP3wYkfaE743dHz80tjUd2O13hqrw5X1uvNXJVgfR7beDM3eDM3eDs0+M8U/iPWZqfUzrTe79XQdwjNn9H2cQV71ZpDrzaDUmUHUGyGKnRkU+J2Y0a6VDIpknrD60u7miIUhgWEtw8xOIzC8hyH8sJphgh/WM4Qf1jI0SoFhNUP4YTVDjXhYzzCAYS1Dg3FKPcMIhnUn9jtj4Yf1DBEPqxk6+GE9Q/hhNUMPP6xniHFKNUOCH9YzRDysZphZ3wSG9zDEOKWaYeZGeDC8h2ECw1qGmRWOMzO8cIFvcVysQtziuSAnslw0+v08F/TlWS4G81k8F+RplovFPDzPBTUrlouDv/BcEF9YLn7SfHT7ZOiFy6TxReJC8Beey6TxReQyaZ1B4jJrnV7kMum4UeIy6/4EkQviLsslTToOELnAX3guyNMcF6ccuLBcJp0PkLjMOh8gcsF4muVikKd5Loi7PBfEXZaLxXia5wJ/YbnMun+h5c1/C8VJs3rLe8Kc85PmurYUZ12B35jipPXXthTDpNXaluebLxSRXRpQjJOOMBtTRI5uQXHS0Uhbigk9nRYUkV3qKXqFnk4LivDFBhQ1ejotKDpQbEARPZ0GFGc9dasxRWSXBhRn3YnTmCKySwOKs+7yaXpnnXfI0Q0otjiB68Pub/OkhrY+jmx9i/r+x1n/jhX5gZ4wejQ8Eda/Y/U+GAoM37HSHwwlhvDDWoak4If1DOGH9QwTGNYy1PDDaoYG8bCeIYFhLUOLcUo9wwCGlSdxkoMf1jNEPKxm6OGH9Qzhh9UMCX5YzxDjlGqGAX5YzxDxsJphNGBYzRDjlGqGyYJhNcMIhpUMg3JgyJxYGxR8i+WiEbd4LsiJLBeDfj/PBX15lovFfBbPBXma54J5eJaLQ82K5wJ/Ybl4xBeWC02aj4STzcKsNXGRy6TxReISJh03ilwmHTdKXGbd9yByQdzluSDuslySAxeWC/yF4xIV8jTPZdL5AImLnnQ+XeQyaX1X4jLrfgWRC/I0zwVxl+ViEXd5LhhPs1wc/IXnMmmebnpDQ/STZvWm57lHP2mua0uR8EU3oDjrev3GFCet1jY9hy5GZJcWFB0oNqCIHN2AYpp0NNKYIno69RTTrCdKNaaInk4Dihq+2IKiA8UGFNHTaUDRoKfTgiJ6Og0ozrq3pjFFZJcWFJFdGlB08MX6uwWSR45uQbFBji49Z5+icfvT7Dn7gdaNPuFQqdcUL9aTG9n6YEa2vkV9/wOt5ysfya6fCyUSrd++ca2D+kYHY0+0q/Uher09TZ41fjtzNBDF2w8vdqQ9jHlDx8dfG5t03411Zm9suLaepnlVXinz8MaavbFEgv1LLtvzSbKHo2lSfGsADd4ArUdvwOhvwIz+BszobyBTcxioAa7nBriQ1j68izYy5qehzXd2bPPD0Ob7rrsQsvlj06euk5dsfmZctN93p8w35r9KBVUkVaQrFunKrAASpDLnfaYUNynvrqVYXUGrbZijD4PdNynN7+EUpYp08V1ESYrvlwVFbpNSWnBtp9ZhuXYmCK4drV5fz1JWSEKvYL+nQ3t3KNDZ9GY+Pdp8E81mvnK3zY8qrh991FbqAWnaXtXyZ2f/Po7U/E6joNNWljTW/fV81dF2N7ssDAkMaxnyN7uA4V0M4YfVDD38sJ4h/LCaIX8yHRjexRB+WM0wIB7WMwxgWMswYpxSzzCCYd2NGl4n+GE9Q8TDWoZGwQ/rGcIPqxlq+GE9Q4xTqhka+GE9Q8TDaobWgmE1Q4xTqhnye0fA8C6GCQxrGXoPhtc3zyxc4FssF0Lc4rkgJ7JcAvr9PBf05VkuEfNZPBfkaZZLwjw8zwU1K46LVfAXngviC8tFT5qPbp/cvnCZNL5IXAz8hecyaXwRuUxaZ5C4zFqnF7lMOm6UuMy6P0HkgrjLcvGTjgNELvAXngvyNMtl1vkAkcuk8wESl1nnA0QuGE+zXCLyNM8FcZfngrjLckkYT/Nc4C8cFzfr/oWWN3MuFCfN6i3v8fNOT5rr2lKcdQV+Y4qT1l/bUrSTVmtb3j+wUER2aUDRTTrCbEwROboFxUlHI20pevR0WlBEdmlAkdDTaUERvtiAYkBPpwVFB4oNKKKn04DirKduNaaI7NKA4qw7cRpTRHapp+hn3eXT8k7JhSJydAOKLU7gKr1f0Sd/eJq9X5H2mzMOZF5+86v1Rg1tfRzZ+hb1/Y+z/h0r8l08Wn+RohKpd6zm5qRckVQskSJTJFVEIxTpCkW6YtFbjkW6UtFbTkVvOZW8ZVKmSIqnYfWaOoN1SfrOB7kYlTLpsJvG6u26YdLh2vrOX9Vt6zObU0exfmj2dmj2dmj2mSn+Uax3D7c+exPhxaDUmUHe9mZQ6MwgMr0Z1BuhoHsziN+JafdRlzvcjrj2JTP7ZSSpIl2ZPQWSFN+ztrQFQZuiAPrjbp8Mmes9TzT/426fDJr1pmX4tor5GBpfgntP4lzGF+vD3oRr613X1i9ZYh9XMdanvq135pb1pnP2Lce0S5G478be7F8Gvm8/ivX8HfXDWB9Htt53/pEL1nceYG9bT0Ozp6H9ni+wD2J95Ec6WpmtL6jo+qT4yI9HZDH2K1vmgrcdQtpd7xCKMRSJJV8ilvj1ArKY48Vo71XHaySJPwtP2+2kfn0cQuxiqUiMP0lNFgtFYvysnyxW1jZfZiRfDVm6dmof+gVGLBaJZT4cSYwfyctiVCSWdJlYiTZSme9tKQ5sYjExYrFITNsiMaPLxKhIzJYhsa5MrIyky3xv+xIYa+K1GL8hRxajIjH+am5ZzJWJxSKxUIYklL2AWKYtlr2AVPYCUtkLSJkX4Nwm5q9DkM7kbklM6zIxKhIzpkwsFIlZXyZWkrtJO1smForEfJk2vvca9tqXoyshw2e3fb1i8pERciVCsUCIX4EhCVGBkCkBwfeOJaFUMDihzG2AslgsEnNl2lyZNl+mzZdpozJtVPbeQpm2TPaUxKIuE6OC2MHnzqTWMJUMJ1TwyWRO8L+tyRpVIuRKhGKBkC0IbZkjtQUhV6KJX9yatnLBMlS8FvK6RKhEE0nhmhUq8T2+BCUJFSQ7G22JUCoQSq5EqECTU7ZEqMDLndYlQgUekTltQC89sDXG0uGDf5uNJ5cZtIliURQ7rKzfxDJpRxQr0uYzQw23d8fdsTtO9Cbmi8T4yC6LuTKxWCSW6a+JYiHzAtLuJfsLcG9SmVKmJEUlUlSkK1NbX/x7kyJ1JRVtiVQqaddSMSqSSiVSukiXLtJlinSZWCLFd2pEqaL3xa+UFaV8kVSJ95J3JVKZmqAkFUqkMqU9SSqWSMUiGrFIVypqVy5u3JQKmrVwMWEdOx0WwhljL0LGlgjdryksM7Z8HvLqkIj8vp5uSUqvcpkpBVmOyuQykwph35QbDsczXuAvUrFEKpP4BCl+dCNK8QEnxm3aaZlAvpLK1CgkKf5dx32qJIZrqcwkuyRFJVKxSFcs0pWKdGWm5W9LGb4bYPS2vGEpZe6hwzp1EeM/TlGM/za/FYuMGBWJ2SJtmetLn+3mTWZn8rZe01+fs71gccDCYUnAwmDR8BYWC7yFw5IZ6k2PJQILg8XCW1gsiC0clkzhZHYsHr1cFgtNimVbpEPaX2OhWb1FwDJrbLmNJcBbWCzwFg5LhLewWBywMFgSvIXFgtjCYHFKAwuHBb1cDgu/ahtYArAwWIydAculqVN4wGtT7RQx4NLUKbLAa1PdFL3GS1On6AlemjpFxfu1qX6eZOOnmPV6bSpNMca/NHWetxrm+VbD80RgE9eJIWOVuW7qE9XjxKY+z7cqNTU9T3dfbOrzdPeFpvonWsIpNnWasJS5K+spm6qfpwshNnWet2qmSTb+iSqGUlPt88wxiU19ntqS2NRpRjbezZNs3Dxhyc8Tlp5o0abUVJrnrT7R4sq7bru99fQFzPOkpvuuASbadhFTiNdgwvNE97Zg4qSfkgjmiVYTNgbjJgVz+9r7BcyswVcAQ+p5RhGNwcyalSQw+nn6so3BzJquRTAIvjyYJ9pA3xgMPIYHY5GuM2CQrnkwDuk6AwbpOgMGwZcH80SreRuDQfDlwdCsHpP2q4mSYcCEWbOSCCZzTWOMq5hx/hswr2KZ3fii2N3arpvkl3Ls29MUD4cZa8Xd7hn22+APBcyXuz1fDAqZLa5CO0KmJiGJZYYZkljmJCtJLHPXmySWWZcuisUisVT0AmJms6kkZoqQRKfKxIq+rUi2TKzoBcSy1x2jLhMre91J9RU3Yop9GZTuD2QnG2RNZwa5znwoud58KLjODIq9+VBncSgq3ddnH5Xpy4ei6iwOReX7+uyjot58qLM4FLXq7LPXqjMf0r3FIe06++y1782HeotDOvb22afOfMj0FocyV258oEG2Mx8yXcWhv5Yf//eH37788OPXn39fRF7+9b+//PTHl19/efvxj//7z/ovP/725evXL//+/j+//frTz//8728/f//1159e/u2TevvfPzTZ9PllkeDSVPf6M7nPOui0/PxS+9DW+8/aqZef9auApvBZ62Be/uKlgqCdXf7C2bTYttj3/w==",
      "brillig_names": [
        "_borrow"
      ]
    },
    {
      "name": "get_position",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "position::Position",
            "fields": [
              {
                "name": "collateral",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "scaled_debt",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "debt",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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lLKSMk0pKynTlLJGZJ1RVlKmKWUlZZpSVlKmKWUlZZpSVlKmGWWNpExTykrKNKWspExTykrKNKWsEVlnlJWUaUpZSZmmlJWUaUpZSZmmlJWUaUZZEynTlLKSMk0pKynTlLKSMk0pa0TWGWUlZZpSVlKmKWUlZZpSVlKmKWUlZZpR1kzKNKWspExTykrKpERWH9OGsJ7JGtsma1qW9l1WUqYpZY3IOqOspExTykrKNKWspExTykrKNKWspEwzylpImaaUlZRpSllJmaaUlZRpSlkjss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLJWUqYpZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrKNKOsjZRpSllJmaaUlZRpSllJmaaUNSLrjLKSMk0pKynTlLKSMk0pKynTlLKSMk0o6+1/Q9YZZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrKNKOsjpRpSllJmaaUlZRpSllJmaaUNSLrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oqydlmlJWUqYpZSVlmlJWUqYpZY3IOqOspExTykrKNKWspExTykrKNKWspEwzyhpImaaUlZRpSllJmaaUlZRpSlkjss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLJGUqYpZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrKNKOsiZRpSllJmaaUlZRpSllJmaaUNSLrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oayZlmlJWUqYpZSVlmlJWUqYpZY3IOqOspExTykrKNKWspExTykrKNKWspEwzylpImaaUlZRpSllJmaaUlZRpSlkjss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLJWUqYpZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrK9HNZ8+I2WcvzxHdlvX2k26A8y/qiCOqyFkFx7exov7T1aO/Lb0f/krWRMk0pKynTlLKSMk0pKynTlLJGZJ1RVlKmKWUlZZpSVlKmKWUlZZpSVlKmCWXNCynTlLKSMk0pKynTlLKSMg0pawxhPTrWs1uEOfqvg3N+lEDIe6tsj5uPy9M09g/Objs6+7ScHO2Ky1tVlb/uTx5/ett45+aearfu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9hr7stfYl73Gvuw19mWvsS97jX3Za+zLXuOL7LVtvzB0LbqdYS+qZNvSzz2/IubXsO8/Y6zL+qxsDY/HRG/3jXeObXV9Q0xrvx97n07QNZ2oazpJ13SyrukUXdOpuqbTVE3n1b0Dqek4XdPRdVYOus7KQddZOeg6KwddZ+Wg66wcdJ2Vg66zcvz0WTlvu6wsz29X3ubjlM3HK5tPUDafqGw+Sdl89jdQd3XdZ8R7l07m43JZtunn8m33grh/v/fqL6mf+JJ2yZeE/PiSHJ6+ZOeJvBrWjYHC8rzv07K/neqy7bm2hMez9+2+s1Lcv6mtaP5p459TCN/n7wafvx98/mHw+cfB558Gn38efP5l8PnXweev/fp7Mv88+PU3D379zYNff/Pg1988+PU3D379zYNff/Pg1988+PU3D379LYNff8vg198y+PW3DH79LYNff8vg198y+PW3DH79LYNff8vg1986+PW3Dn79rYNff+vg1986+PW3Dn79rYNff+vg1986+PW3Dn79bYNff9vg1982+PW3DX79bYNff9vg1982+PW3DX79bYNff9vY19+0jH39TcvY19+0jH39TcvY19+0jH39TcvY19+0jH39TcvY19+0jH39Tcvg1183+PXXDX79dYNff93g1183+PXXDX79dYNff93g1183+PXXDX799YNff/3g118/+PXXD3799YNff/3g118/+PXXD3799YNff/3g198w+PU3DH79DYNff8Pg198w+PU3DH79DYNff8Pg198w+PU3DH79jYNff+Pg1984+PU3Dn79jYNff+Pg1984+PU3Dn79jYNff9Xvf3Uy/8H3v0qD73+VBt//Kg2+/1UafP+rNPj+V2nw/a/S4PtfpcH3v0qD73+VBt//Kg2+/1UafP+rNPj+V2nw/a/S4PtfpcH3v0qD73+VBt//Kg2+/1UafP+rNPj+V2nw/a/S4PtfpcH3v0qD73+VBt//Kg2+/1UafP+rNPj+V2nw/a/S4PtfpcH3v0qD73+VBt//Kg2+/1UafP+rNPj+V2nw/a/S4PtfpcH3v0qD73+VBt//Kg2+/1UafP+rNPj+V2nw/a/S4PtfpcH3v0qD73+VB9//Kg++/1UefP+rPPj+V3kZ+/qbB9//Kg++/1UefP+rPPj+V3nw/a/y4Ptf5cH3v8qD73+VB9//Kg++/1UefP+r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",
      "brillig_names": [
        "get_position"
      ]
    },
    {
      "name": "_compute_total_collateral_value",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "4270187767586857285": {
            "error_kind": "string",
            "string": "Function _compute_total_collateral_value can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_compute_total_collateral_value"
      ]
    },
    {
      "name": "compute_total_deposited_assets",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "deposit_accumulator",
            "type": {
              "kind": "struct",
              "path": "accumulator::Accumulator",
              "fields": [
                {
                  "name": "value",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "last_updated_ts",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "compute_total_deposited_assets"
      ]
    },
    {
      "name": "_repay",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5235018679007078561": {
            "error_kind": "string",
            "string": "Invalid asset or market id"
          },
          "6787403583199288031": {
            "error_kind": "string",
            "string": "Insufficient balance"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13135008234568508716": {
            "error_kind": "string",
            "string": "Function _repay can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_repay"
      ]
    },
    {
      "name": "get_total_borrowed_assets",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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6HGzYuhxs2LocbNS6ANuVgw9blYMPW5WDD1uVgy9nxm98xt6l2Lt6JhX8u62sPoE3txRTu1O26Kc2m22RTm1e2yLcmo32Bbl1O6uKco4tVtri3Jq99UW5dRuqi3Kqd1RW5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKhNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKjNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKgttphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxHKvOB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFsuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mEsiy4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4nZaoTS4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4na+i9K7xX4c7V2In1DujMSnFYkJ5mkkeW/ccckfB0f79Mk5/BbJ4qM6EAmH1oFIeL8ORMJVdiCSRyT9IuGEOxAJj92BSLj3DkQiF+hAJBIH/SI5EocORCJx6EAkEocORJo7ccjr0c7b8Ono33A8cI7hzO2wK3DmdrYVOHM7ygqcuZ1cBc7cDuocjp/buVTgzO0YKnDm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",
      "brillig_names": [
        "get_total_borrowed_assets"
      ]
    },
    {
      "name": "borrow_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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j19vbXGPv+96ISzLFkhwwRzE75XH3/e6Xo6/77W6HH/f6285/r7X33L8fa+/pfjXzrcHLcff9/pbjr/v9bccv+71d110r79r59uDluPXvf6unW8PWo5f9/q7dr49aDH+zrcHLcevfP3tfHvQcvzK19/Otwctx698/e18G89y/MrX3863xSzHr3z97XyTyXL8ytffzrdsLMevfP3tfAPEcvzK19/Otyosx698/e18/8Fy/MrX3873HyzHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18/8Fy/MrX3873HyzHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18/8Fy/MrX3873HyzHr3z97Xz/wXL8ytffzvcfLMevfP3tfD+/cvzK19/O99Irx698/e18z7ty/MrX3873pivHr3z97XwPuXL8ytffzvd6K8evfP3tfE+2cvzK19/O904rx698/e18j7Ny/MrX3873IivHr3z97XzPsHL8ytffzvf2KsevfP3tfA+ucvzK19/O98oqx698/e18/6ty/MrX3873vyrHr3z97Xz/q3L8ytdf5ftfrcr3v1qV73+1Kt//alW+/9WqfP+roHz/q6B8/6ugfP+roHz/q7DoXn+D8v2vgvL9r4Ly/a+C8v2vgvL9r4Ly/a+C8v2vgvL9r4Ly/a9C7/tf+bQNDquxB/F3vv66uPO/XVh46bT4j8HJPc4Kt8kdjM1pe+GcP4+9c+l8XW/GpfN6oRmXzuuQZlw6r29acel937JmXDqvx5px6bzOa8al8/qxGRcPl0Mu1LvHXKh3j7lQ7x5zod495kK9e8il930Cm3GZtt4N21izLPYAzLQFbwnMtBVvCYwHzDGYaWveEphpi94SmM6rmDXlDcztCUzhpc2aF7dNd83G7ePDfba97+H3Zrb3+DtfEYrx933jjjFug2N8quGOX9rGsH6MtjG655e+T7bvm7HwZPu+wQpPtu9WgfBk+/b/wpPtezmUnWznOxoKT7Zv+y082b7rnJ9ONtttsumpqtgn23dRJDxZP9NkR6qgnF224thZG79OdqQKqjjZkSqo4mRHqqCKkx2pgrpNdnk32c73RPzhZL3ZRjtvl6+THWmdLU52pHW2ONmh1tnSZIdaZ11O+2TN8v6l1xy3W/ea88HdbKhF+SdkwrLf58NyUIh2vvfkNTlzTGao5d67vbbxq/m9T1Pn+2VeQ+YwZzrfifOnZPZHd87n9HWyY5WIhcmOVSIWJutnmuxYJeJjsuvTU/F9skOViKXJDlX1lSY7VCFXmuxQtZl7BLKa+P6lTUhbPW+if/oxrF/uaDrfjPSHaOL+018Xs/u9srXzbU5PJFMygZ1voHpNzhyT8UOR2V/a/emh1MGNZsn7F86MWw5uNEPVTcn6HU0uvLRftqC9/XwHPsD4aEmYW/tuH+12jENVZO0wDlXrtcM4VBXZDuNQ9WkzjJ1vTKwG41CWoB3GofzDjzC6zT745xnuYIayD5JgOv/RkuxPUHrfxll4tp3/qF54tp3/VF54tjP9dCz2vv208Gw7/7G68Gz1/iywZrZ6f0RYM1s/1mydf8x2tU+zPR5tn0aHL2wGq7xE2QxWp4myGayq+wEbb3b/6+3TY8iNzGAVoCCZwapFOTK9b6zekMxgVaggmcEqVkEyg1W3gmQ8ZF6QmbcOLpGZtwoukaEGfkWGGvgVmdFq4Fcu8eC10/6NzOiefnT04rVz2iZ5w/h0GMuN/x8ke99UXxHJ0WpsGZJ3NqNV2ZJsRquz33a8XmyabvadGJ21uTBbk5Zt0x6TzDObfDjb5THbJTzP9h5RvD4i+4jo62YI8cVG4S0jyr1F9GJz7JYRme4istdH5MPjzlL4yrf1+y3Oeu+/hu90h+91h7/qDj/oDj/qDj/pDj+rDt8vnYdv0yP8rwWZN7rD733VLYTf+aq7rlvNY9fwez9EjL7zJfoncy38tDD6ztfz1bh9rrGwL0raTxhO/inmj+9BR9/52i851c7rBMmpdl5TSE618/pDcKpr57WK5FR7X1l/MtV1CyPF8GmqBy9s3KNz/rTl1a/tJL4Ofvyafvk09I6w9wVbAcKR6oBGCEeqLxohHKluaYRwpHqoDcI4UvHxE4TL47gA8/RI7BBhSlsQ2RR/1Hx77/3xX4rx6Zy0nD6Yd97dGZJ55y2pIZnPWu23ZO5hfjnzWf1ES+azGpCWzGd1LC2Zz2pxWjIfqfeshHnCh17PHB96PXN86PXM8aHXM/cwv5w5PvR65vjQ65njQ69njg+9njk+9HLmGR96PXN86PXM8aHXM8eHXs/cw/xy5vjQ65njQ69njg+9njk+9Hrm+NCrmacFH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZG3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ27xodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZy5w4dezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5r0fcDskc3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZD3V4uRbm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzMP+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17OPOJDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfOED72eOT70eub40OuZ40OvZ+5hfjlzfOj1zPGh1zPHh17PHB96PXN86OXMMz70eub40OuZ40OvZ44PvZ65h/nlzPGh1zPHh17PHB96PXN86PXM8aFXM88LPvR65vjQ65njQ69njg+9nrmH+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczN/jQ65njQ69njg+9njk+9HrmHuaXM8eHXs8cH3o9c3zo9czxodczx4deztziQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxodczx4dezxwfejlzhw+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzD0+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzNf8aHXM8eHXs8cH3o9c3zo9cw9zC9njg+9njk+9Hrm+NDrmeNDr2eOD72cecCHXs8cH3o9c3zo9czxodcz9zC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYRH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZJ3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ57xodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZi5WxZ86PXM8aHXM8eHXs8cH3o9cw/zy5njQ69njg+9njk+9Hrm+NDrmeNDL2du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6rLE1WWJq8sSV5clvi5LfF2W+Los8XVZ4uuyxNdlia/LEl+XJb4uS3xdlqx1WbLWZclalyVrXZasdVmy1mXJWpcla12WrHVZstZlSajLklCXJaEuS0JdloS6LAl1WRLqsiTUZUmoy5JQlyWxLktiXZbEuiyJdVkS67Ik1mVJrMuSWJclsS5LYl2WpLosSXVZkuqyJNVlSarLklSXJakuS1JdlqS6LEl1WZLrsiTXZUmuy5JclyW5LktyXZbkuizJdVmS67Kkrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r+ZF7zXv3zA02ZuDy15kyb6ln8nZfrrsaCtfoYNCbuHEvsJJfYWTuwrnVW+7VTimr3BsX+G4vsLxfYWz9hVOX3fl1NddOfV1V0593ZVzX3fl3NddOfd1V8593ZXz1Xflt2dc3eJZO4sndBZP7Cye1Fk8uat47PETXHsrXT8us9ashXhuDn3Zww/xz7sX3N7EXPEm9oo3cSJv4sLjTYJ7epODX+Qlt20M5JbnfZ+W4+1Ul33PtcU9fnuf7Uf8vvP4151/WJ37Gv+qPP6gPP6oPP6kPP6sO36zKI/fKI/fKo+/9/W3FL/y9dcoX3+N8vXXKF9/jfL11yhff63y9dcqX3+t8vXXKl9/rfL11ypff63y9dcqX3+t8vXXKl9/nfL11ylff53y9dcpX3+d8vXXKV9/nfL11ylff53y9dcpX3+98vXXK19/vfL11ytff73y9dcrX3+98vXXK19/vfL11ytff1fl6++qfP1dla+/q/L1d1W+/q7K199V+fq7Kl9/V+Xr76p8/Q3K19+gfP0NytffoHz9DcrX36B8/Q3K19+gfP0NytffoHz9jcrX36h8/Y3K19+ofP2NytffqHz9jcrX36h8/Y3K19+ofP1NytffpHz9TcrX36R8/U3K19+kfP1NytffpHz9TcrX36R8/c3K19+sfP3NytffrHz9zcrX36x8/c3K19+sfP3NytffrHv9dYvu9dctutdft+hef133+1+V4te9/jrl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfOeX7Xznl+1855ftfeeX7X3nl+1955ftfeeX7X/lF9/rrle9/5bvf/+rx0iFm8xz/0eAt6pDC44XT+jHX3tdqybn2vq5LzrX3GkBwrt3v1yU5195rC8m5dl6HrHlNj7na93P1MW9x+OTSPtjmdBi2iXvUzu+jncsfbDqvcZqy8bB5yabz2iyu3n6MjmEJ79k4t411/inoo6FrWLeQ17g8Df5V/32NOef9lZclfRp9x9h5iagFY+fVpxaMnRe2WjB2XjMrwdj79n1aMHZe6WvB2LmJ0IKxc7+hBaMHowRGXIwIRlyMCEZcjAhGXIwIRlyMBMbeN0HVghEXI4IRFyOCERcjgtGDUQIjLkYEIy5GBCMuRgQjLkYEIy5GAmPvW0lrwYiLEcGIixHBiIsRwejBKIERFyOCERcjghEXI4IRFyOCERcjgbH3Dfm1YMTFiGDExYhgxMWIYPRglMCIixHBiIsRwYiLEcGIixHBiIuRwNj7sSZaMOJiRDDiYkQw4mJEMHowSmDExYhgxMWIYMTFiGDExYhgxMVIYOz9cCgtGHExIhhxMSIYcTEiGD0YJTDiYkQw4mJEMOJiRDDiYkQw4mIkMPZ+xJ4WjLgYEYy4GBGMuBgRjB6MEhhxMSIYcTEiGHExIhhxMSIYcTESGHs/qFQLRlyMCEZcjAhGXIwIRg9GCYy4GBGMuBgRjLgYEYy4GBGMuBgBjGvvxz1rwYiLEcGIixHBiIsRwejBKIERFyOCERcjghEXI4IRFyOCERcjgbH3Q+i1YMTFiGDExYhgxMWIYPRglMCIixHBiIsRwYiLEcGIixHBiIuRwGhxMSIYcTEiGHExIhhxMSIYPRglMOJiRDDiYkQw4mJEMOJiRDDiYiQwOlyMCEZcjAhGXIwIRlyMCEYPRgmMuBgRjLgYEYy4GBGMuBgRjLgYCYweFyOCERcjghEXI4IRFyOC0YNRAiMuRgQjLkYEIy5GBCMuRgQjLkYC44qLEcGIixHBiIsRwYiLEcHowSiBERcjghEXI4IRFyOCERcjghEXI4Ex4GJEMOJiRDDiYkQw4mJEMHowSmDExYhgxMWIYMTFiGDExYhgxMVIYIy4GBGMuBgRjJ27mDWvacOYTC5gjGkb7NJT2H5ZjsL2dgvE+PhQKKWjlzZp2V7a5MdgG46idovdsRv/wO7MUSDJBP8xOtknkWzyB6N9XNzHaB9/pcj22mv4kLRzR4WkP5fUI+loknbuNJH055J27nqR9OeSdu7AkfTnknbeDUDSn0vaeWcCSX8saeq8S4KkP5e0844Nkv5cUrpHw0lK92g4ST2SjiYp3aPhJKV7NJykdI++J6k3eXtpn2xB0nUx+xPQxcfHHDfqNHhaUKcH04B6pk3SgjqdjBbUaTa0oE4/oAV1D/UG1HHVLahjfFtQx5u2oI43bUG9K2/6K6SwdGXc7iF15WruIXVV8t9D6qoevofk+wupq0rqHlJXZcY9pK7W4HtIXS1Q95D6u3ub/u7epr+7t+nv7m36u3ub/u7efZ1xfw+pv7t3X2ev30Pq7+7d15ngf4TU1/na95D6u3v3de7zPaT+7t59nUd8D6m/u3df5+TeQ+rv7t3X+a33kPq7e/d1rug9pP7u3n2dd3kPqb+7d1/nMN5D6u/u3df5gPeQ+rt793Vu3T2k/u7efZ2ndg+pv7t3X+d83UPq7+7d1/lT95D6u3v3dS7SPaT+7t59nddzD6m/u3df58jcQ+rv7t3X+Sb3kPq7e/d17sY9pP7u3n2dB3EPqb+7d1/nFNxD6u/u3df++feQ+rt797Wv+z2k/u7efe03fg+pv7t3X/tg30Pq7+7d1/7M95D6u3v3tW/wPaT+7t597Wd7D6m/u3df+4neQ+rv7t3Xfo73kPq7e/e1n949pP7u3n3tZ3YPqb+7d1/7Sd1D6u/u3dd+PveQ+rt797Wfyj2k/u7efW2WcQ+pv7t3X9ss3EPq7+7d1w/07yH1d/fu66fd95D6u3v39aPge0j93b37+jnpPaTu7t6xv99axv5+axn7+61l7O+3lnHp7u4d+/utZezvt5axv99axv5+axn7+61l7O+3lrG/31rG/n5rGfv7rWXs77eWsb/fWsb+fmsZ+/utZezvt5axv99aRqEfEC3xEZKJTyH98SY//7HL/TJXd5mvu2ytuyzUXRbrLkt1l+Wqy37+Y4D7Zabusros8XVZ4uuyxNdlia/LEl+XJb4uS3xdlqx1WbLWZclalyVrXZasdVmy1mXJWpcla12WrHVZstZlSajLklCXJaEuS0JdloS6LAl1WRLqsiTUZUmoy5JQlyWxLktiXZbEuiyJdVkS67Ik1mVJrMuSWJclsS5LYl2WpLosSXVZkuqyJNVlSarLklSXJakuS1JdlqS6LEl1WZLrsiTXZUmuy5JclyW5LktyXZbkuizJdVmS67IkV2VJWpa6y0zdZbbuMld32WGW+LBf9ulYnMdl6/Fl5nGZXf7rfU/g9t4fg5N7bFN7a0ccjM1pa2jk/HnsPZzQVzixr3BSX+HkrsI5fjjRLhzTVzi2r3BcX+H4vsLp665s+rorm77uyqavu7K5+q68H9NnlsV+jccuncVjOovHdhaP6ywe31k8P7433y8LdZfFqsuEdsF7+6gvCe1rV3gTd8Wb+CveZL3iTcIVbyLzDQBvHm+y5qc3+dmT8HtIqb+QcnchCe349oOQvMnbuTTefs0kof3eBAOyvQV0+Te3Sgvg9Vu9FSNau4sodBdR7C6i1F1EubeIrt/krRiR6S4i211E3d2z1+7u2Q32d1uXZXvt1efSa+d1f+mczNME/McEQucTSNltoxf3eQIHDtma3SLbtTT69kxy+6rp7VmcLYx2q90KHBMeY5ejsdbkB78lfxp9xx7B3gJ7AnsL7BnsDbA32J0R7DfsBuwtsFuwt8DuwN4Cuwd7C+y9+71BseNSm2DHpTbBjkttgh2X2gJ7xKU2wY5LbYIdl9oEOy61CXYP9hbYcalNsONSm2DHpTbBjks9A7tNeYvaPX/jZMeOS22BPeFSm2DHpTbBjkttgh2X2gS7B3sL7LjUJthxqU2w41KbYMelNsGOS22BPeNSm2DHpTbBjkttgh2X2gS7B3sL7LjUJthxqU2w41KbYMelNsGOS22APS+41CbYcalNsONSm2DHpTbB7sHeAjsutQl2XGoT7LjUJthxqWdgj2YDYqNbDrDjUltgN7jUJthxqU2w41KbYMelNsHuwd4COy61CXZcahPsuNQW2I9PWjoVe3LbZN1iXOG117xuJ2WkJT9G3yjd41+Vxx+Uxx/7jj+s+7FGYXUH8Sfl8Wfd8btFefxGefxWefxOefydr7/F+Dtff4vxd77+FuNXvv465euvU77+euXrr1e+/nrl669Xvv5ef7ChcPzK11+vfP31ytdfr3z99crX31X5+rsqX39X5evv2vn6+9Q/DCkexN/5+luMX0//+Th+Pf3n4/g7X3+L8Xe+/hbj73z9LcUfOl9/i/F3vv4W4+98/S3G3/n6G1e/PS2OYQnP8R88WXbbWOefgj4auob9qOQ1Lk+Df9UoX2O+PdXeY17Sp9F3jJ3fRvrA6Ja8fefcfeJxODruEcd9pP/gHTu/7Q3Hu/Pb9HC8O19WhuPNMngtbw/vS3l3bvOH4915W2I43p23UYbj3XnbZzje+MtLeSf85bW88ZfX8sZfXssbf3ktbw/vS3njL6/ljb+8ljf+8lre+MtLeefe60Gbwh790/m0h7zNjdwWRwxPP4x2h0/Il+130atfPo29k+m9cmtHxkPmBZneq6F2ZHqvW9qR6b3CaEem91qgHZneu8KNyIRl6b1/245M753WdmQmroHDttvPzXoVxnq7bhj9Hxv8PJmOO8d5V7K0D37+ru3xWOvsNth6r2ZDJpMfMj7B+9iQ6ab+vKs16i/LvBUJ6i9m3qoL9Rczb2WJ+ouZt3pG/cXM2yVH/aXBBtuo34/68z7tQP3FzPtEB/UXQ69vZvXp9c2sPr2+idW39PpmVp9e38zq0+ubWX16fTOr71F/YvXp9c2sPr2+mdWn1zez+vT6ZlafXt/A6tu0/YzUusV+Vb/3Qw5R/1T16fXNrD69vpnVp9c3s/oe9SdWn17fzOrT65tZfXp9M6tPr29m9en1Tax+7weqo/6p6tPrm1l9en0zq0+vb2b1PepPrD69vpnVp9c3s/r0+mZWn17fzOrT65tY/ZVe38zq0+ubWX16fTOrT69vZvU96k+sPr2+mdWn1zez+vT6ZlafXt/M6tPrG1j9aDZ4Nrrlq/qBXt/M6tPrm1l9en0zq0+vb2b1PepPrD69vpnVp9c3s/r0+mZWn17fzOrP2+vLdptjXtfC2HWJ+8HnZnnOlY+zzOO8XTNZjvP2n2Q5ztvJkeU4cU8kuW3wsoTS8mjCvjxaF7Usj6XtbKNH/pnln7grgvxLnLgtgvxLnLgvgvxLnLgxgvxLnPhbUMi/pIm/BoX8S5r4e1DIv6SJvwiF/Eui6ze1/B75Z5afrt/U8tP1m1p+un5Ty0/Xb2r56frNLH+m6ze1/HT9ppafrt/U8tP1m1p+j/wzy0/Xb2T5S5veZLp+U8tP129q+en6TS0/Xb+J5b9NHPlnlp+u39Ty0/WbWn66flPL75F/Zvnp+k0tP12/qeWn6ze1/HT9ppafrt/M8hu6flPLT9dvavnp+k0tP12/qeX3yD+z/HT9ppafrt/U8tP1m1p+un5Ty0/Xb2b5LV2/qeWn6ze1/HT9ppafrt/U8nvkn1l+un4jy1846s5Yun5Ty0/Xb2r56fpNLT9dv5nld3T9ppafrt/U8tP1m1p+un5Ty++Rf2b5h/L9wfpd/lhUNC/baJtXVxjtl2XLFr/459S6n4Vu/FDL6I9IumUxeyCpyN3Z/ZPkvdHySSrskGn8UOso+v9Y/6EWUvT/sf5DPT9D/x/rP9QDNPT/sf7zVtLo/0v/oR6hof+P9R/qGRr6/1T/daiHaOj/Y/2HeoqG/j/Wn/7f3PrT/5tbf4/+U+tP/29u/en/za0//b+59af/N7f+9P+m1j/Q/5tbf/p/c+tP/29u/en/za2/R/+R9S/tnxHo/82tP/2/ufWn/ze3/vT/5taf/t/U+kf6f3PrT/9vbv3p/82tP/2/ufX36D+1/vT/5taf/t/c+tP/m1t/+n9z60//b2r9E/2/ufWn/ze3/vT/5taf/t/c+nv0n1p/+n9z60//b2796f/NrT/9v7n1p/83tf6Z/t/c+tP/m1t/+n9z60//b279PfqPrH/pJK1M/29u/en/za0//b+59af/N7f+9P9m1t8u9P/m1p/+39z60/+bW3/6f3Pr7+fV3yxpC8SssTDax7wF4pNfnka7D5ITd9KESU7ckxImOXF3R5jkxH0SE3eS1pZIWhP2ddK6qGWdLOyTe/v/0H9m/c3EfRL0v+k/cZ8E/W/6T9wnQf+b/hP3SdD/pr9H/6n1n7m7g/63WaH/1PrP3ElD/5vQ6D+1/vT/ptbf0v+bW3/6f3PrT/9vbv3p/82tv0f/qfWn/ze3/vT/5taf/t/c+tP/m1t/+n9T6+/o/w2tf2GfHOvo/82tP/2/ufWn/ze3/h79p9af/t/c+tP/m1t/+n9z60//b2796f9Nrb+n/ze3/vT/5taf/t/c+tP/m1t/j/5T60//b2796f/NrT/9v7n1p/83t/70/6bWf6X/N7f+9P/m1p/+39z60/+bW3+P/lPrT/9vbv3p/82tP/2/ufWn/ze3/vT/ptY/0P8bWv/SOXmB/t/c+tP/m1t/+n9z6+/Rf2r96f/NrT/9v7n1p/83t/70/+bWn/7f1PrHzv3/mtdNpJhMQX8X065oegrbL8tR2M7FLerb8H10SgeDvdv09OmJx7p8YOzcRmvB6MEogbFzU6cFY+feSAvGzi2GFoydV+q9YFzXbYZrOMLYecGrBGPq/LlxNxjjsmGM+QBj549ftWDExXwPY96WmLC4A4y4GBGMHow/xGjMAUZcjAhGXMy3MIa4AQlpOcCIixHBiIv5Hsa0BR2yP8CIi5HAmHEx38J4e/KyhWHSAUZcjAhGXMxPMdpwgBEXI4LRg1ECIy7mexjzFnRajlZqXIwIRlzMtzCm/UOdDldqXIwIRlzM9zA6t2H09gtGt+BiRDDiYn6KcV0OMOJiRDDiYr6FMZttbD4ov93iwSiBERfzPYxuA5K9OcCIixHBiIv5Hsb9Ozw5HH2ocTEiGHExP8UYv7YmnMHFiGDExXwLo1nW7Stlt0APCnCDjxECObGT8XYLxPinH6QdgnQmbSCdyY/BNhxFfaslH3N8+k7k7T56GPayfUnIxaeS6tfou0gekfoXaWIXpkekiT2eHpEmdpB6RJrYn+oRaWL3q0YkO7G31iPSxM5dj0gTdwX0iETHQYFIHpH6F4mOgwKR6DgoEImOgwKR6DgoEImOQ/8iOToOCkSi46BAJDoOCkSi46BAJI9I/YtEx0GBSHQcFIhEx0GBSHQcFIhEx6F/kTwdBwUi0XFQIBIdh1NEsnYf7VNBpGTC4wCZ5TH6+EgYH5ftx+Q+msfeBm4NH5LSnxhOUo+ko0lK72M4SemUDCcpfZXRJF3xjuok3Tc6vP0ZDiSl4tUmaVq2X5372/ADST2SNpe0l4NNTX6o/nQu7HawqVuppUmWbycLVTrJ8u1kof4nWb6dLDzfJVm+nSw8ZyZZvpssgZ4FyfLtZOG5O8ny7WTh+T/J8u1koc9Ksnw7WTzJQrJ8N1no4JIs304WOrgky7eThQ4uyfLtZKGDS7J8O1no4JIs302WSAeXZPl2stDBJVm+nSx0cEmWbycLHVyS5dvJ4kkWkuW7yUIHl2T5drLQwSVZNmWse6ju7UGy0MElWb6dLHRwSZbvJkuiz0KyfDtZPMlCsnwoE80mo41uOUgW3BDJ8u1kwQ2RLN9OFtwQyfLtZMENkSzfTha+z0KyfDdZMt9nIVm+nSz0WUiWbycL32chWb6dLHyfhWT5drJ4kuVbyWLttjmfcykVkkXNlw4yPdmp5afLOrX89E2nlp9O6NTy09ucWP4bGOSfWX76j1PLT0dxavnpEU4tv0f+meWn6ze1/HT9ppafrt/U8tP1m1p+un4zy2/o+k0tP12/qeWn6ze1/HT9ppbfI//M8tP1m1p+un4jy29T3nR0iz2Qn67f1PLT9Ztafrp+M8tv6fpNLT9dv6nlp+s3tfx0/aaW3yP/zPLT9Ztafrp+U8tP129q+en6TS0/Xb+Z5Xd0/aaWn67f1PLT9Ztafrp+U8vvkX9m+en6TS0/Xb+p5afrN7X8dP2mlp+u38zye7p+U8tP129q+en6TS0/Xb+p5ffIP7P8dP2mlp+u38jyF45y8p6u39Ty0/WbWn66fjPLv9L1m1p+un5Ty0/Xb2r56fpNLb9H/pnlp+s3tfx0/b4nv3e7/D6ZgvzOLPto45/4HeKLfoNtYngaHA8G36z6x9iwuuehdzVp4o2kJj05XWruwoSnBWJXkxabMjWXDcfy9bMZ6Jh9U02TH2ragprrspcr6+Ljs5p36jSqWlCnP9SCOm2ZFtQ91BtQpwnRgjrevwV1PHoL6njpFtTxvA2oR7xpC+p40xbU8aYnUPc5p536mv/rbVft1tncutg3+7R8lQgj271EHol6lwiL3L1E+OnuJcJ8dy8RTr17ibD1vUuU6AF0LxENg+4lorvQl0Tuq0R0F7qXyCNR7xLRXeheIroL3UtEd6F3iTIVXYVEoSCR8fu3sI136b1EYfHbS4clL+8Hm9uIbfTt7zV8VZQCcDRFPYoOpijl5WiKUo2OpijF62iK8iRNtaL5q6I8eBtL0XXhOd1oivJYbzRF6RmNpig9o8EUtTOvo0t6oegdzcwLUgHNzHf2ApqhbpFp9TuauJTQmGXb+sWYp0k6czTam307Nu8fYw9f+cSN3kx+CLPkT6Pvenr0HErPoVrq6GmHaqijpx2qnY6edqhmOnraoVrp6OmGagCgpxuqa4GebqhWC3o6+kNj6enRcyg96Q+NpSf9obH0pD80lp70h8bSk/7QUHp6+kNj6Ul/aCw96Q+NpSf9obH09Og5lJ70h1TpadP2BWjrFnugJ/2hsfSkPzSWnvSHxtKT/tBQeq70h8bSk/7QWHrSHxpLT/pDY+np0XMoPekPjaUn/aGx9KQ/NJae9IfG0pP+0FB6BvpDY+lJf2gsPekPjaUn/aGx9PToOZSe9IfG0pP+0Fh60h8aS0/6Q2PpSX9oKD0j/aGx9KQ/NJae9IfG0pP+0Fh6evQcSk/6Q6r0jGYjbaNbDvSkPzSWnvSHxtKT/tBYetIfGkrPRH9oLD3pD42lJ/2hsfSkPzSWnh49h9JzrP5Q3l86W1/Q0+2v7J/COD6A9XCo8fkD4lBNmey2D4VfQglismYbnexqCqnbcKOtNFSjZVCNhmqeDKrRUA2RMTXKQzU5BtVoqMbFoBoN1YwYVKOhGgyDauTRqHuNhmoEDKoRfYb+NaLP0L9G9Bn614g+Q+8ahYU+Q/8a0WfoXyP6DP1rRJ+hf408GnWvEX2G/jWiz9C/RvQZ+teIPkNzjQo/kAwLfYbuNTL0GfrXiD5D/xrRZ+hfI/oM/Wvk0ah7jegz9K8RfYb+NaLP0L9G9Bn614g+Q/caWfoM/WtEn6F/jegz9K8RfYb+NfJo1L1G9Bn614g+Q/8a0WfoXyP6DP1rRJ+he40cfYb+NaLP0L9G9Bn614g+Q/8aeTTqXiP6DP1rRJ+hf43oM/SvEX2G5hoVNg4Ojj5D9xp5+gz9a0SfoX+N6DP0rxF9hv418mjUvUb0GfrXiD5D/xrRZ+heo7Wruu4eUldlzD2ktqu2K2WySXtymuTTIzntR/yr8viD8vij8viT8viz7vjDojx+ozx+qzx+pzx+5etvUL7+BuXrb1C+/gbl629Qvv5G5etvVL7+RuXrb1S+/kbl62+8fP11xm0nJTuTl8JrW2e32VrvS+0iNZt/xgD2Ftgj2FtgT2BvgT2DvQH2tIC9BXYD9hbYLdhbYHdgb4Hdg70FdlxqE+y41CbYcalNsONSm2DHpbbAnnGpTbDjUptgx6U2wY5LbYLdg70FdlxqE+y41CbYcalnYC9tf5FxqU2w41IbYI8LLrUJdlxqE+y41CbYcalNsHuwt8COS22CHZfaBDsutQl2XGoT7LjUFtgNLrUJdlxqE+y41CbYcalNsHuwt8COS22CHZfaBDsutQl2XGoT7LjUFtgtLrUJdlxqE+y41CbYcalNsHuwt8COS22CHZfaBDsu9QzshY3oo8WlNsGOS22B3eFSm2DHpTbBjkttgh2X2gS7B3sL7LjUJthxqU2wX+9SrXUbdptsCbsJO3brohbshZ8Dx+uPZQf7L+wZ7A2wX394Oth/YTdgb4Hdgr0Fdgf2Ftg92FtgX8HeAnsAewvsuNQm2HGpTbDjUltgX3GpTbDjUptgx6U2wY5LbYLdg70FdlxqE+y41CbYcalNsONSm2DHpZ6BvfSzgoBLbYIdl9oEOy61CXZcahPsHuwtsONSm2DHpTbBjkttgh2X2gQ7LrUF9ohLbYIdl9oEOy61CXZcahPsHuwtsONSm2DHpTbBjkttgh2X2gQ7LrUF9oRLbYIdl9oEOy61CXZcahPsHuwtsONSm2DHpTbBjkttgh2X2gQ7LvUM7KUt2jIutQl2XGoT7LjUJthxqU2we7C3wI5LbYIdl9oEOy61CXZcahPsDVxq3gY797Q1+K/X/hVSWmx/Ibn+QvJXh+QXt722X9bS5+Xd6PsEVu0TCH1PIKR1uweFFM3TK9/Dj7rDT7rDz52Hn5dtSQrZxj+Hbxbd4Rvd4Vvd4Tvd4Xe+8pbC73zdLYXf+6pbCL/3VbcQfu+rbiF83auu1b3qWt2rrtW96lrdq+71p9DLhq971bW6V12re9W1ulddq3vVdbpXXad71XW6V13X/arr9zZVXr+G3/2q+z787lfd9+F3v+q+D7/7Vfd9+N2vum/DP/sYyfubXH57s7cP9cdgtxhXeO01r+ljdLy5/330r4esXwa7mLbBLj2F7ZflKGy/H3FsfHw8iE3p6KVNejo9+empbTh8+LdYu4/2aR/tzNLzs2a3bM/TrTPm0+h7sniShWT5brKsJAvJ8t1kCSQLyfKhTOGHOen64xFJFr3JkkgWkuW7yZJJFpLlm8ly/QGaJIveZDEkC8ny3WSxJAvJ8t1koYNLsnw7WTzJQrJ8N1no4JIs304WOrgky7eThT5L+2Qx4ZEsSyrI72Pewr79+YjErR9fJAh0Q7RJmva7hX8m8pCUnoU6SfcdEXxy9kBSOgvDSYr/H05Sj6SjSYqXHk5SHO9wkvLNInWSLnGX1C4HkvL9n+EkpXs0mqSR7tFwktI9Gk5SukfDSUr3aDhJPZIOJunxcQW3Ge5XPcI32Xxc5GsuWmsuOuyErGZLuNW6TxcdZdBjc+aUnnbLTR/vEE9/h3T6O+ST3yEvy+nvYE5/B3v6O7jT38Gf/g7r6e8QTn+HePo7nP2Zzsc7oa77vg6rj19ul/l4B8w17ptB+OXgolTzTse3nH39XYP/etHxJoVr2pa/NbuDi0zNRbbmIldzka+5aK25KNRcdPxR2OuTNR/plGouyhUXueX9RWE5mNPxtlVrzPtF6eCiw4wIZqMXXD64yBXe6ejzdLwxUuFDeLwdUemimo/78eYvxq7bpIwNByi8qbvM1l3m6i7zdZetdZeFusti3WWp7rJcddn6IktS3C97+mLn4zJTviwcXGbrLnN1l/m6y46z5Gbftsvc0Y3n+OvL5cti3WWp7rJcddnxVzPLl5m6y2zdZS90C7vcLh6sMseP98yjxjOrP/gExBdI8v5588t6cJkpX3bwMY227jJXd5mvuyxWXZaOST43Ypw5uMzUXXZM0odlvywc3BSOj2m/jX3MLR4swvnF3Pavwt8aQQc5mU3dZbbusuMs8dnvn4DlaG6+7rK17rJQd1l88enedVvtwcc0p7rLckWQcVmWustM3WW27jJXcZ+8XebrLlvrLgt1l+WKO1dcTM2d63aZqbvMVl0Wj/2a3aa2fj0TLi7H9+TSRabmIltzkau5yNdctNZcFGouijUXpZqLajLieCVb81ZchadHK4+LTM1FtuYiV3ORr7lorbko1FwUay5KNRfln19klqXmIlNzka256Pie/ngId3u2eHDZi3t68bLje/rNqWyXPT/ye1xm6y5zdZf5usuO12ITdiQmHSF5YVHzw4/lo3fLVZfZpe4yU3eZrbvM1V3m6y57UUPZ5VEMxYPLQt1lse6yVHdZrrrsuA9dvszUXXacJevDNK4pH1zm6i7zdZetdZeFusti3WWp7rJcdZl/1bfaL3P24PPmbd1lru4yX3fZWndZqLss1l2W6i7LVZetS91ldVmy1mXJix642x/f3j7IB7egFz3w4mVr3WWh7rJYd1mquyxXXRbqCoxQV2CEugIj1BUYL3619P7k+Nt/PRYgPHqpIR69W6667EXHvXiZqbvsWIAYt99/mZjtwWWu7jJfd9lad1mouyzWXZbqLstVl714mlC8zNRdVpclqS5LUl2WpLosSXVZkuqy5LiTZfJjWcz26LJcddlxj8kms32vyabwuOEdf1U4ub3zmtzTM6Pj0YVv6N5Ccv2F5PsLae0vpNBfSLG/kFJ/IeXeQrLHPdW2IZn+Quru7m0Xibu33b/jmbyJpdE/3H1tPz/H37pnBxPw2iewap9A0D6BqH0CSfsEsvIJmEX7BIz2CVjtE9C+EhvtK7HRvhIb7Sux0b4SG+0rse1+HXi7G/NtAr3fhUqOzF5/F+pl83STHxs1LF+fb1sbQPMKTQTNKzQJNK/QZNC8QOMW0LxCY0DzCo0FzSs0DjSv0HjQvEJDNfwSDdXwSzRUwy/RUA2/REM1/AqNpxp+iYZq+CUaquGXaKiGX6LxoHmFhmr4JRqq4ZdoqIZfopm3Gr618XY03h6gmbcaLqFZ562Gi2jmrWuKaOZdoQo/yLPrvCtUEc28K1QRzbwrVAlNmHeFKqKZt19TRDNvv6aIZt66pojGg+YVmnn7NUU0h9WwW/YfQLvlaU+v48kaE8z+62wTbAmOtftuaLdq/bH1l7v9fQ8qSgS1PvatNeHp6AzlvZLjXTOAc4eTgfMSzvEOKMC5wzHAeQ3HAuc1HAec13A8cF7DWYHzGk4Azms4VMhv4FAhv4FDhfwaTqJCfgOHCvkNHCrkN3CokN/A8cB5DYcK+Q0cKuQ3cKiQ38ChQn4DZ+YK+Tb7DY5bDr49lWeukItwZq6Qi3BmrpCLcGaukItwPHBew5m5Qi7CmblCLsKZuUIuwpm5Qi7CoUJ+CcctVMhv4FAhv4FDhfwGDhXyGzgeOK/hUCG/gUOF/AYOFfIbOFTIb+BQIb+GY6iQ38ChQn4Dhwr5DRwq5DdwPHBew6FCfgOHCvkNHCrkN3CokN/AmblCLvwq19mZK+QinJkr5CKcmSvkIpyZK+QiHA+c13BmrpCLcGaukItwZq6Qi3BmrpBLcCY++sjtxyPaW0P0AM28m4cV0cy7eVgRzcSbohbc+MRHHxXRzLt5WBHNvFvpFtHMu5VuEc3Em72X0Ey82XsBzcRHHxXRzFsNF9HMWw0X0VANv0RzfV3zs8PrY97Q3P58THc7vN41OGrmZxNIeybc/swHE0i9T8C6fQLOHkwgK59Ag8NVhCdgtE/Aap+A0z4B3/sElrhPwC4HE1i1T6D3lbg4ge5X4tIEul+JSxPofiUuTCB0vxKXJtD9SlyYwPGOQNFvEUUfvpqI4/1OHqYmr+ngIldzka+5aK25KNRcFGsuSjUXHepklv24CbOE9ctl/vgX2+XLTN1ltu4yV3eZr7tsrbss1F0W6y5LdZfVZYmpy5Ljn6y8v3f4459y5P02le3RRRW3AX/8Be7SO6Wai3LFRcdfhC1dZCpAWFtzkau56FinsGVEjgdpdPwFtNJFoeai0u368KJUAyJXXHT8rZjSRTUZ4WoywtVkhKv55Lq15qJQc1GsueinGXH7l/k18vj3NmnZy7+nj/yvQvDL0OC32i+s7nnoLa7j253Ui6ffffG07UwZUvrzi+fffvFlW3KWP0d+fJsVefHbP+yvgf4wXdf9sN41Pr2Fd7+iOm7Dv78k/vyS9PNL8g8vuf3L/ZHbhxf6uHEO1j9daG4X3v75//7jv//tH//p7//yH7dLfv3X//Ov//yff/u3f/3453/+f/97+y//9O9/+/vf//a//uF///u//fO//M//8+//8g9//7d//vXf/rJ8/M9/v6lj/xqX1f2PPz5t//1mzuJfbwZn/R9/RHj77zdTFhebfv33Xxf4GNJffYx/XPDHFUvItxHRPD6wv8ZZ/1ebd7F/vdTtjbzdXmY1f13DA8MfV5i/2tv/9V+3Sf7/",
      "brillig_names": [
        "discover_new_messages",
        "decompose_hint",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "_withdraw",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5235018679007078561": {
            "error_kind": "string",
            "string": "Invalid asset or market id"
          },
          "6787403583199288031": {
            "error_kind": "string",
            "string": "Insufficient balance"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10435052277855889085": {
            "error_kind": "string",
            "string": "Function _withdraw can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15333773746166717806": {
            "error_kind": "string",
            "string": "Insufficient collateral"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_withdraw"
      ]
    },
    {
      "name": "get_accumulators",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "tuple",
            "fields": [
              {
                "kind": "struct",
                "path": "accumulator::Accumulator",
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "last_updated_ts",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ]
              },
              {
                "kind": "struct",
                "path": "accumulator::Accumulator",
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "last_updated_ts",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ]
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7f3druw8dqUJ34uPfSD+k30rjQ+F+nEXDBh2wVX1AY2C771jv7GkiJ1LIa7NZMScJJ8Te2emGEE+Yy5pjiEF9X/+4b/903/53//9P/3zv/4///Y//+H/+r//zz/8y7/91//8v/753/719p/+z3/84z/8l3//53/5l3/+7//p+b/+h+3X/zEu/DXgf/6P//yvv/7z//xf//nf/9c//F9m88b94z/807/+t7/+neztQ/6ff/6Xf/r1n7b/+Mdvx6ccv47Omz+Ojenk0GDD16EhbI+P9fY//n//eJtO7DGd7NI+nVCup+Nd+TrUx/x9OqnLdLLfp1Py9XTittOJNn6fTu4xnWLt19HFhcp08vZ1aNpOxCqn03F52/HfDomxMh1bNvN1uNt+O/r+LX77yLeYj3yL/ci3uI98i//It4SPfEv8yLekj3xL/si3fORvP3zkbz985G8/fORvP3zkbz985G8/fORvP3zkbz985G8/fORvP3zkbz9+5G8/fuRvP37kbz9+5G8/fuRvP37kbz9+5G8/fuRvP37kbz9+5G8/feRvP33kbz995G8/feRvP33kbz995G8/feRvP33kbz995G8/feRvP3/kbz9/5G8/f+RvP3/kbz9/5G8/f+RvP3/kbz9/5G8/f+RvP3/kb7985G+/fORvv3zkb7985G+/fORvv3zkb7985G+/fORvv3zkb7984m/fbttHvqXL377bQjy+paSno8P9W+xHvsV95Fv8R74lfORb4ke+pcvfvrvdy9u/xdry27d8P/oWY+5zumVaz7cAy9ldz7zfMAzuaR7h628kC8w/H3c+b715rsw/xHTcRY7ZHUeHeF9AGXwBZht9AWb0BdjRF+BGX4AffQFh9AXE0ReQRl/A6Fdio/9KnPzeOIUU/PMCTtxFOJ60siGZ64Nz2KeR09MK/altMccja7fzxuODvT07OD8szm+H/iJu9bcOsxHX3+vMRlx/czYbcf3d5GzEPcQ/TFx/vz4bcf0GYzbi+h3RbMT1W7jZiOM5P0zc4Tk/TRzP+WnieM5PE8dzfpq4h/iHieM5P00cz/lp4njOTxPHc36aOJ7zw8Q9nvPTxPGcnyaO5/w0cTznp4l7iH+YOJ7z08TxnJ8mPoLnNA/i+RqiyccvTkyxrvLRxpd9UzsTnraD+3om04/gDqXYjODjhNiEERyXFJsRvJEUmxFcjBSbEfyGFBsPm5dsRujhpdiM0G1LsaEvfs2Gvvg1G/ril2wiffFrNvTFr9nQF79mQ1/8mo2HzUs29MWv2dAXv2ZDX/yaDX3xazb0xS/ZJPri12zoi1+zoS9+zYa++DUbD5uXbOiLX7OhL37Nhr74NRv64tds6Itfssn0xa/Z0Be/ZkNf/JoNffFrNh42L9nQF79mQ1/8mg198Ws29MWv2dAXv2RT6Itfs6Evfs2Gvvg1G/ri12w8bF6yoS9+zYa++DUb+uLXbOiLX7OhL37Fxm30xa/Z0Be/ZkNf/JoNffFrNh42L9nQF79mQ1/8ms3KffHNMe1sbhfsrUoy+YOkefrsfDaTuOWvg6N9wpfDHfvKLbcg9pW7eTnsA7w1dkrsK3sQQewr2xtB7Cs7J0HsHuwS2Ff2e4LYV7aSgthxqSLYcaki2HGpEtiHeEH5hNhXdqm3+z3pwF5qEzEm2ePDTdmePt3Yd8u0sqsdSKaVXfBAMnlkGkGmlV32QDKt7MoHkmllFz+QTCu7/oFkWjklGEemIV5Bj0xDvLcemYZ42T0yOVKIIWTyyDSCTKQQP5bJbmGfibG3FVdksjdZvw63Jj9Byfns6LQdRyf7eJb6/ii1I4UYQiZSiCFkIoUYQiZSiBFk8qQQQ8hECjGETKQQQ8hECjGETB6ZRpCJFGIImUghhpCJFGIImUghhpCJFOLnMrmcD5m8r93IsPGYi40xPI4u7hSh3T/cmfB8tDk72qVj5q64347+JWsgtZhSVlKOKWUlFZlSVlKUKWX1yDqjrKQ0U8pKqjOlrKRAU8pKajSlrKRMM8oaSZmmlJWUaUpZSZmmlJWUaUpZPbLOKCsp05SykjJNKSsp05SykjJNKSsp04yyJlKmKWUlZZpSVlKmKWUlZZpSVo+sM8pKyjSlrKRMU8pKyjSlrKRMU8pKyjSjrJmUaUpZSZmmlJWUaUpZSZmmlNUj64yykjJNKSsp05SykjJNKSsp05SykjLNKGshZZpSVlKmKWUlZZpSVlKmKWX1yDqjrKRMU8pKyjSlrKRMU8pKyjSlrKRME8rqN1KmKWUlZZpSVlKmKWUlZZpSVo+sM8pKyjSlrKRMU8pKyjSlrKRMU8pKyjSjrIaUaUpZSZmmlJWUaUpZSZmmlNUj64yykjJNKSsp05SykjJNKSsp05SykjLNKKslZZpSVlKmKWUlZZpSVlKmKWX1yDqjrKRMU8pKyjSlrKRMU8pKyjSlrKRMM8rqSJmmlJWUaUpZSZmmlJWUaUpZPbLOKCsp05SykjJNKSsp05SykjJNKSsp04yyelKmKWUlZZpSVlKmKWUlZZpSVo+sM8pKyjSlrKRMU8pKyjSlrKRMU8pKyjSjrIGUaUpZSZmmlJWUSYms1ocDYa7J6ssha9i28l1WUqYpZfXIOqOspExTykrKNKWspExTykrKNKWspEwzyhpJmaaUlZRpSllJmaaUlZRpSlk9ss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLImUqYpZSVlmlJWUqYpZSVlmlJWj6wzykrKNKWspExTykrKNKWspExTykrKNKOsmZRpSllJmaaUlZRpSllJmaaU1SPrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oayFlmlJWUqYpZSVlmlJWUqYpZfXIOqOspExTykrKNKWspExTykrKNKWspEwTynr775B1RllJmaaUlZRpSllJmaaU1SPrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oqyFlmlJWUqYpZSVlmlJWUqYpZfXIOqOspExTykrKNKWspExTykrKNKWspEwzympJmaaUlZRpSllJmaaUlZRpSlk9ss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLI6UqYpZSVlmlJWUqYpZSVlmlJWj6wzykrKNKWspExTykrKNKWspExTykrKNKOsnpRpSllJmaaUlZRpSllJmaaU1SPrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oayBlmlJWUqYpZSVlmlJWUqYpZfXIOqOspExTykrKNKWspExTykrKNKWspEwzyhpJmaaUlZRpSllJmaaUlZRpSlk9ss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLImUqYpZSVlmlJWUqYpZSVlmlJWj6wzykrKNKWspExTykrKNKWspExTykrK9HNZ42YOWdPzxE9lvX2kOaA8y/qiCPK2F0EypXa03cp+tLXpt6N/yZpJmaaUlZRpSllJmaaUlZRpSlk9ss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLIWUqYpZSVlmlJWUqYpZSVlGlJW79x+tM+1W4TR26+DY3yUgItnqyyPm4/b0zTOD47mODrasFWONsnEo6rSX/cnrz+9HLxjMU+1m08O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leUn9VtaflK/peUn9VtaflK/meWvbXrjSP1Wlt+T+i0tP6nf0vKT+i0tP6nf0vJ75F9ZflK/peUn9VtaflK/peUn9VtaflK/leUPpH5Ly0/qt7T8pH5Ly0/qt7T8HvlXlp/Ub2n5Sf2Wlp/U7x9Wlp/Ub2n5Sf1Wlj+S+i0tP6nf0vKT+i0tP6nf0vJ75F9ZflK/peUn9VtaflK/peUn9ZtZ/tqr7iKp38ryJ1K/peUn9VtaflK/peUn9Vtafo/8K8tP6re0/KR+S8tP6rey/Hkq3x+tP+RPVUXLth9tS3CVo/227dXiN/9cWl/vQs9TXUb/iKTbNnNMJFe5O3v8JXlvRvlLqu2Qmae6jqL/H+s/1YUU/f9Y/6nun6H/H+s/1Q009P9T/cu6nTT6/9J/qlto6P/H+k91Dw39/1j/qW6iof8f6+/Rf2n9yf/W1p/8b239yf/W1p/8b239yf9W1j9t5H9r60/+t7b+5H9r60/+t7b+Hv2X1p/8b239yf/W1p/8b2r9K/tnpI38b239yf+W1t+Q/62tP/nf2vqT/62tP/nf2vp79F9af/K/tfUn/1tbf/K/tfUn/1tbf/K/pfW35H9r60/+t7b+5H9r60/+t7b+Hv2X1p/8b239yf/W1p/8b239yf/W1p/8b2n9Hfnf2vqT/62tP/nf2vqT/62tv0f/pfUn/1tbf/K/tfUn/5ta/8qbtJIj/1tbf/K/pfX35H9r60/+t7b+5H9r60/+t7b+Hv2X1p/8b239yf/W1n/h/M9seZ+ICalytE9ln4jPfns62n2RXDhJ60xy4UyqL8mwcLrTmeTCOYlJB0lraySticd10ro0ynWytk9uWDgnQf+b/gvnJOh/09+j/9L6L5yToP9N/4VzEvS/6b9yToL+Kayc7qB/CitnUuif4spJGvqnSP63tv7kf2vrT/63tv4e/ZfWn/xvbf3J/9bWn/xvbf3J/9bWn/xvaf0T+d/a+pP/ra0/+d/a+pP/Ta1/bZ+c5NF/af3J/9bWn/xvbf3J/9bWn/xvbf3J/5bWP5P/ra0/+d/a+pP/ra0/+d/a+nv0X1p/8r+19Sf/W1t/8r+19Sf/W1t/8r+l9S/kf2vrT/63tv7kf2vrT/63tv4e/ZfWn/xvbf3J/9bWn/xvbf3J/9bWn/xvZf3zRv63tv7kf2vrT/63tv7kf1PrX3lPXt48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",
      "brillig_names": [
        "get_accumulators"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7f3drvM4l6WJ3kse54FITvGnb6WxUciqyi58QCKzkJW1gUYh770d4SXZ77dkcb0K2nOSfE4CKyIkm3zGtDTHoE39n3/47//8X//3//gvf/vX/+ff/tc//F//9//5h3/5t//2T//xt3/719u//Z///Md/+K///rd/+Ze//Y//8vyf/2H54x/OpT9P+F//85/+9Y9//1//8U///h//8H+5RVz4x3/453/973/+nfztRf6fv/3LP//xb8t//uO341OOX0fnRfZjYzo4dPXr16HrujxeVvx//v/+8Tac3GI4OaRtOGs5H46E8nWoxPx9OKXJcLJswyn5fDhx2ehEH78Nxy8thlO8/zq6hLUynLx8HZqW72J5dzickJcNvwslxspwfFnc1+Fh+eXor3fxH3mX8JF3kY+8y/qRd4kfeZf0kXfJH3mX8ol3CctH3uUjn/3wkc9++MhnP3zksx8+8tkPH/nsh4989sNHPvvhI599+chnXz7y2ZePfPblI599+chnXz7y2ZePfPblI599+chnXz7y2V8/8tlfP/LZXz/y2V8/8tlfP/LZXz/y2V8/8tlfP/LZXz/y2V8/8tmPH/nsx4989uNHPvvxI5/9+JHPfvzIZz9+5LMfP/LZjx/57MePfPbTRz776SOf/fSRz376yGc/feSznz7y2U8f+eynj3z200c+++kjn/38kc9+/shnP3/ks5+bfPbDssb9XUp6Onq9v4t85F3Wj7xL/Mi7pI+8S/7IuzT57IfbWt72Lt6XX97l+9E3a7aN6danPy8BlqNVz7wtGK7haRzr/TNSFoXx533l83a9yZXxrzHtq8gxh/3oNd4n4HqfgO99AqH3CUjvE1h7n0DsfQKp9wnk3idQ+p6AXzq/E/vF/p04ydY4rWmV5wkcuIt1/6aVX5M7Pziv2zByepqhHNoWt39lzd/WWPajxR8dnB8W55dD/yRuv3UYjbj9Xmc04gLxDxO3302ORtx++zsacfv9+mjE7RuM0Yjbd0SDEXf2LdxoxPGcnyaO5/w0cTznp4kLxD9MHM/5aeJ4zk8Tx3N+mjie89PE8ZwfJu7xnJ8mjuf8NHE856eJ4zk/TVwg/mHieM5PE8dzfpo4nvPTxPGcnybeg+d0D+L5HKLL+y9OXPGh8tJOyrapnVuftoP7+k5m6MEdarHpwcdpsenBcWmx6cEbabER2Lxk04Pf0GLTgzPQYtNDD6/FpoduW4sNffFLNkJf/JoNffFrNvTFr9nQF79mI7B5yYa++DUb+uLXbOiLX7OhL37Nhr74JZuVvvg1G/ri12zoi1+zoS9+zUZg85INffFrNvTFr9nQF79mQ1/8mg198Us2kb74NRv64tds6Itfs6Evfs1GYPOSDX3xazb0xa/Z0Be/ZkNf/JoNffFLNom++DUb+uLXbOiLX7OhL37NRmDzkg198Ws29MWv2dAXv2ZDX/yaDX3xSzaZvvg1G/ri12zoi1+zoS9+zUZg85INffFrNvTFr9nQF79mQ1/8ms3MfbEvcWMTFrdUSSbZSbqn185HI4lL/jo4+id8+c8nsfoOnmQ6JPaZu3lF7DMbBUXsM3sQRewCdg3sMzsnRewzmzJF7DP7PUXsM1tJRey4VAXsoYOnfA+JHZeqgh2XqoJ9Zpd6m33asZfaQJxLfn9xV5anV3f+3TIJMvUg08wuuCOZZnbNHck0s8vuSKaZXXlHMs3s4vuRqYsHwyNTF0+TR6YuHkGPTF08tx6ZunjYPTI5UoguZCKF6EImUogfy+SXdRuJ87cZV2TyN1m/DvcuP0HJ+ejotOxHJ//4LnW8y0QK0YVMpBA9yORJIbqQiRSiC5lIIbqQiRSiC5kEmXqQiRSiC5lIIbqQiRSiC5lIIbqQiRSiB5kCKUQXMpFC/FymkPMuk0htIcPHfSw+xvVxdAmHCP324rdFwOej3dHRIe0jDyX8cvSfspJaDCkrKceQsgqyjigrKcqQspK6DCkrKc2QspLqDCkrKdCIsgqp0ZCykjINKSsp05CykjINKasg64iykjINKSsp05CykjINKSsp05CykjKNKOtKyjSkrKRMQ8pKyjSkrKRMQ8oqyDqirKRMQ8pKyjSkrKRMQ8pKyjSkrKRMI8oaSZmGlJWUaUhZSZmGlJWUaUhZBVlHlJWUaUhZSZmGlJWUaUhZSZmGlJWUaURZEynTkLKSMg0pKynTkLKSMg0pqyDriLKSMg0pKynTkLKSMg0pKynTkLKSMo0oayZlGlJWUqYhZSVlGlJWUqYhZRVkHVFWUqYhZSVlGlJWUqYhZSVlGlJWUqYRZS2kTEPKSso0pKykTEPKSso0pKyCrCPKSso0pKykTEPKSso0pKykTEPKSso0oKyykDINKSsp05CykjINKSsp05CyCrKOKCsp05CykjINKSsp05CykjINKSsp04iyOlKmIWUlZRpSVlKmIWUlZRpSVkHWEWUlZRpSVlKmIWUlZRpSVlKmIWUlZRpRVk/KNKSspExDykrKNKSspExDyirIOqKspExDykrKNKSspExDykrKNKSspEwjyhpImYaUlZRpSFlJmYaUlZRpSFkFWW3I6mXdEeaarFJ2WddlKd9lJWUaUlZSpiFlJWUaUlZSpiFlJWUaUVYhZRpSVlKmIWUlZRpSVlKmIWUVZB1RVlKmIWUlZRpSVlKmIWUlZRpSVlKmEWVdSZmGlJWUaUhZSZmGlJWUaUhZBVlHlJWUaUhZSZmGlJWUaUhZSZmGlJWUaURZIynTkLKSMg0pKynTkLKSMg0pqyDriLKSMg0pKynTkLKSMg0pKynTkLKSMo0oayJlGlJWUqYhZSVlGlJWUqYhZRVkHVFWUqYhZSVlGlJWUqYhZSVlGlJWUqYRZc2kTEPKSso0pKykTEPKSso0pKyCrCPKSso0pKykTEPKSso0pKykTEPKSso0oqyFlGlIWUmZhpSVlGlIWUmZhpRVkHVEWUmZhpSVlGlIWUmZhpSVlGlIWUmZBpT19t+QdURZSZmGlJWUaUhZSZmGlFWQdURZSZmGlJWUaUhZSZmGlJWUaUhZSZlGlNWRMg0pKynTkLKSMg0pKynTkLIKso4oKynTkLKSMg0pKynTkLKSMg0pKynTiLJ6UqYhZSVlGlJWUqYhZSVlGlJWQdYRZSVlGlJWUqYhZSVlGlJWUqYhZSVlGlHWQMo0pKykTEPKSso0pKykTEPKKsg6oqykTEPKSso0pKykTEPKSso0pKykTCPKKqRMQ8pKyjSkrKRMQ8pKyjSkrIKsI8pKyjSkrKRMQ8pKyjSkrKRMQ8pKyjSirCsp05CykjINKSsp05CykjINKasg64iykjINKSsp05CykjINKSsp05CykjKNKGskZRpSVlKmn8saF7fLmp4Hfijr7SXdDuVZ1hdFkJetCJIrtaP9UrajvU+/HP2nrKRMQ8pKyjSkrIKsI8pKyjSkrKRMQ8pKyjSkrKRMQ8pKyjSirImUaUhZSZmGlJWUaUhZSZmGlFWQdURZSZm6lFVC2I6WXFsijOK/Do7xUQIhHs2yPBYfl6dhHB8c3X509OtSOdolF/eqSn+uT56/etl5x+KeajcfHJxvS6VfB2cf/fPBf9Y5sRt1PkOdk0NS5zPUOcEsdT5DnZNUU+cT1HkmuqfOZ6hz1jKo8xnqnMUd6nyGOme1izqfoc6FOqfOJ6hz1kOp8xnqnPVQ6nyGOmc9lDqfoc5ZD6XOZ6hz1kOp8wnqvLAeSp3PUOesh1LnM9Q566HU+Qx1znoodT5DnQt1Tp1PUOesh1LnM9Q566HU+Qx1znoodX69zv2a9jrPtZd2Oe6j/uNv+eX4P6uRVUuq0U41srZINVqpxriwAkg12qlG1umoRjvVyGoa1WinGlnzohrtVKNQjVSjmWpk/YhqtFONrPJQjXaqkbUYqtFONbIWQzXaqUbWYqhGM9XoWIuhGu1UI2sxRqox7d+1uv3569F/CsUyRSdCkeB3IpQgVB9Ckft2IhSRaCdCkRZ2IhRBWidCkTH1IZQnfulEKJKJToQimehEKJKJToQShOpDKJKJHwsVQvI7FFl9Bb27DWZfunA5PX4IHQ+FWvwulPdPx/4pE7lEFzKRSnQhE5nEj2WSJe3jFiepIlNcHls/PAHM6x08GYMO+EBmoASeDEAJPJ5eCTweXQm8AF4HPB5aCTyuWAk8PlcJPM5VCTzOVQe84FyVwONclcDjXH8OPkrZwcfqj1p8SBt5H8rTalguvx0iCz63C5kEmXqQCQ/dhUw47i5kwp93IRNuvguZ8P49yLSSFHQhE7lCFzKRQnQhEylEFzIJMvUgEylEFzKRQrxNJnH7llIiyy8y/YmeZEENPWmBGnoSAC30EVevhh6nroYe962GHkethl5Ar4Ue56uGHjerhh43q4YeN6uGHjerhT7hZtXQ42bV0ONm1dDjZtXQC+i10ONm1dDjZtXQ42bV0ONm1dDjZrXQZ9ysGnrcrBp63KwaetysGnoBvRZ63KwaetysGnrcrBp63KwaetysFvqCm1VDj5tVQ4+bVUOPm1VDL6DXQo+bVUOPm1VDj5tVQ4+bVUOPm1VCnxbcrBp63KwaetysGnrcrBp6Ab0WetysGnrcrBp63KwaetysGnrcrBZ6h5tVQ4+bVUOPm1VDj5tVQy+g10KPm1VDj5tVQ4+bVUOPm1VDj5vVQu9xs2rocbNq6HGzauhxs2roBfRa6HGzauhxs2rocbNq6HGzauhxs1roA25WDT1uVg09blYNPW5WDb2AXgs9blYNPW5WDT1uVg09blYNPW5WC73gZtXQ42bV0ONm1dDjZtXQC+i10ONm1dDjZtXQ42bV0ONm1dDjZrXQr1O72SA7+pBi7eiYN/LhFrY/gXd3lFO707Yop3abbVFO7R7bohRQtkI5tbtri3Jqt9YW5dTuqy3Kqd1UW5RTu6OmKCNupxlK3E4zlLidZihxO81QCihbocTtNEOJ22mGErfTDCVupxlK3E4rlAm30wwlbqcZStxOM5S4nWYoBZStUOJ2mqHE7TRDidtphhK30wwlbqcVyozbaYYSt9MMJW6nGUrcTjOUAspWKHE7zVDidpqhxO00Q4nbaYYSt9MKZcHtNEOJ22mGErfTDCVupxlKAWUrlLidZihxO81Q4naaocTtNEOJ22mEMi+4nWYocTvNUOJ2mqHE7TRDKaBshRK30wwlbqcZStxOM5S4nWYocTutUDrcTjOUuJ1mKHE7zVDidpqhFFC2QonbaYYSt9MMJW6nGUrcTjOUuJ1WKD1upxlK3E4zlLidZihxO81QCihbocTtNEOJ22mGErfTDCVupxlK3E4rlAG30wwlbqcZStxOM5S4nWYoBZStUOJ2mqHE7TRDidtphhK30wwlbqcVSsHtNEOJ22mGErfTDCVupxlKAWUrlLidZihxO81Q4naaocTtNEOJ22mFcsXtNEOJ22mGErfTDCVupxlKAWUrlLidZihxO81Q4naaocTtNEOJ22mFMuJ2mqHE7TRDidtphhK30wylgLIVStxOM5S4nWYocTvNUOJ2mqHE7bRCmXA7zVDidpqhxO00Q4nbaYZSQNkKJW6nGUrcTjOUuJ1mKHE7zVDidlqhzLidZihxO81Q4naaocTtNEMpoGyFErfTDCVupxlK3E4zlLidZihxO61QFtxOM5S4nWYocTvNUOJ2mqEUULZCidtphhK30wwlbqcZStxOM5S4nUYoy4LbaYYSt9MMJW6nGUrcTjOUAspWKHE7zVDidpqhxO00Q4nbaYYSt9MKpcPtNEOJ22mGErfTDCVupxlKAWUrlLidn6KUsPivoyWs8ReUByORtCFxq3saST4ad1zy18HRP71yXu8i4aM6EAmH1oFIeL8ORMJV2hfJ41c7EAkn3IFIeOwORMK9dyCSIJJ9kUgcOhCJxKEDkUgcOhCJxKEDkeZOHPJ2dBC//nL0H3DC3E6/Amduh12BM7ezrcCZ21FW4AhwXsOZ20FV4MztXCpw5nYMFThzd+oVOHTIr+EIHfIJHDrkEzh0yCdw6JBP4AhwXsOhQz6BQ4d8AocO+QQOHfIJHDrk13BWOuQTOHTIJ3DokE/g0CGfwBHgvIZDh3wChw75BA4d8gkcOuQTOHTIr+FEOuQTOHTIJ3DokE/g0CGfwBHgvIZDh3wChw75BA4d8gkcOuQTOHTIr+FM/mT7Chw65BM4dMgncOiQT+AIcF7DoUM+gUOHfAKHDvkEDh3yCRw65NdwJn8aegUOHfIJHDrkEzh0yCdwBDiv4dAhn8ChQz6BQ4d8AmfqDlnCA051Tw2Xtn0v/PJ4ZZ/DwbF555FDqRxbdoVK+fXYPwWaukvvQKC5nyTeg0BTu5UeBJraMfUg0NSurQeBBIFsCzS1e+1BoKkddA8CTe3iexCIJMG4QCQJpgW68Z47Ssj7BrdZXE0hn/cta0OQx9HuEMnqdvXXvPxy9J383BmBJvm5zb8m+bldvSZ5gbwS+bl9uCb5uQ22Jvm5nbMm+bktsSb5ub2uInmHh9Uij4fVIo+H1SKPh9UiL5BXIo+H1SKPh9Uij4fVIo+H1SKPh1Ui7/GwWuTxsFrk8bBa5PGwWuQF8krk8bBa5PGwWuTxsFrk8bBa5PGwSuQDHlaLPB5WizweVos8HlaLvEBeiTweVos8HlaLPB5WizweVos8HlaJvOBhtcjjYbXI42G1yONhtcgL5JXI42G1yONhtcjjYbXI42G1yONhlciveFgt8nhYLfJ4WC3yeFgt8gJ5JfJ4WC3yeFgt8nhYLfJ4WC3yeFgl8hEPq0UeD6tFHg+rRR4Pq0VeIK9EHg+rRR4Pq0UeD6tFHg+rRR4Pq0Q+4WG1yONhtcjjYbXI42G1yAvklcjjYbXI42G1yONhtcjjYbXI42GVyGc8rBZ5PKwWeTysFnk8rBZ5gbwSeTysFnk8rBZ5PKwWeTysFnk8rBL5gofVIo+H1SKPh9Uij4fVIi+QVyKPh9Uij4fVIo+H1SKPh9Uij4fVIX8DCXkl8nhYLfJ4WC3yeFgt8gJ5JfJ4WC3yeFgt8nhYLfJ4WC3yeFgl8g4Pq0UeD6tFHg+rRR4Pq0VeIK9EHg+rRR4Pq0UeD6tFHg+rRR4Pq0Te42G1yONhtcjjYbXI42G1yAvklcjjYbXI42G1yONhtcjjYbXI42GVyAc8rBZ5PKwWeTysFnk8rBZ5gbwSeTysFnk8rBZ5PKwWeTysFnk8rBJ5wcNqkcfDapHHw2qRx8NqkRfIK5HHw2qRx8NqkcfDapHHw2qRx8MqkV/xsFrk8bBa5PGwWuTxsFrkBfJK5PGwWuTxsFrk8bBa5PGwWuTxsErkIx5WizweVos8HlaLPB5Wi7xAXok8HlaLPB5WizweVos8HlaLPB5WiXzCw2qRx8NqkcfDapHHw2qRF8grkcfDapHHw2qRx8NqkcfDapHHwyqRz3hYLfJ4WC3yeFgt8nhYLfICeSXyeFgt8nhYLfJ4WC3yeFgt8nhYJfIFD6tFHg+rRR4Pq0UeD6tFXiCvRB4Pq0UeD6tFHg+rRR4Pq0UeD6tD3i94WC3yeFgt8nhYLfJ4WC3yAnkl8nhYLfJ4WC3yeFgt8nhYLfJ4WCXyDg+rRR4Pq0UeD6tFHg+rRV4gr0QeD6tFHg+rRR4Pq0UeD6tFHg+rRN7jYbXI42G1yONhtcjjYbXIC+SVyONhtcjjYbXI42G1yONhtcjjYZXIBzysFnk8rBZ5PKwWeTysFnmBvBJ5PKwWeTysFnk8rBZ5PKwWeTysEnnBw2qRx8NqkcfDapHHw2qRF8grkcfDapHHw2qRx8NqkcfDapHHwyqRX/GwWuTxsFrk8bBa5PGwWuQF8krk8bBa5PGwWuTxsFrk8bBa5PGwSuQjHlaLPB5WizweVos8HlaLvED+LeTFp/J1tITVV452kvbXXt3TuPPRLOOSvw6O/kmavH5pijseT1N893ia4ujH05SsYDxNSSGG0zSRb4ynKcnJeJqSyYynKWnPeJoKmg6nKTnSeJqSI42nKTnSeJqSI/1Y07APxMUlVFTyflm+jvYSftX0Tp60R4l8JpPRIk9yokWefEOLPCmEFnmBvBJ5HL0WeXy3FnncsRZ5PKwWeTysEvmCh9Uij4fVIo+H1SKPh9UiL5BXIo+H1SKPh9Uij4fVIo+H1SKPh9UhHxY8rBZ5PKwWeTysFnk8rBZ5gbwSeTysFnk8rBZ5PKwWeTysFnk8rBJ5h4fVIo+H1SKPh9Uij4fVIi+QVyKPh9Uij4fVIo+H1SKPh9Uij4dVIu/xsFrk8bBa5PGwWuTxsFrkBfJK5PGwWuTxsFrk8bBa5PGwWuTxsErkAx5WizweVos8HlaLPB5Wi7xAXok8HlaLPB5WizweVos8HlaLPB5WibzgYbXI42G1yONhtcjjYbXIC+SVyONhtcjjYbXI42G1yONhtcjjYZXIr3hYLfJ4WC3yeFgt8nhYLfICeSXyeFgt8nhYLfJ4WC3yeFgt8nhYJfIRD6tFHg+rRR4Pq0UeD6tFXiCvRB4Pq0UeD6tFHg+rRR4Pq0V+ag+b1518WeSXo/+kk6b2mVU6U3vBKp2p/VqVztSeqkpHoHNCZ2pvUqUztX+o0pm6x6/SmboPr9KhVz6hk+mVz+jQK5/RoVc+o0OvfEZHoHNCh175jA698hkdeuUzOvTKZ3TolU/oFHrlMzr0ymd06JXP6NArn9ER6JzQoVc+o0OvfEaHXvmMDr3yGR165dd0ZKFXPqNDr3xGh175jA698hkdgc4JHXrlMzr0ymd06JXP6NArn9GhVz6h4+iVz+jQK5/RoVc+o0OvfEZHoHNCh175jA698hkdeuUzOvTKZ3TolU/oeHrlMzr0ymd06JXP6NArn9ER6JzQoVc+o0OvfEaHXvmMDr3yGR165RM6cz+7vUqHXvmMDr3yGR165TM6Ap0TOvTKZ3Tolc/o0Cuf0aFXPqNDr3xCZ+5nRFfp0Cuf0aFXPqNDr3xGR2amU9y604m1o13KXwf7px1UfQ4Hx+adRw6lcmzJ25BL+fXYu0JT9+tdKDS1Z+hCoal9S0nbsMXJUjnap+A3iVJ5PjodaXRju4nkXfzl6Dv5qT2RKvmp/ZYm+bmflaxKfmqfqEp+ag+qSn5qf6tKXiCvRH5uT6xJfm6vq0keD6tFHg+rRR4Pq0R+7mclq5LHw2qRx8NqkcfDapEXyCuRx8NqkcfDapHHw2qRx8NqkcfDKpGf+znMquTxsFrk8bBa5PGwWuQF8krk8bBa5PGwWuTxsFrk8bBa5PGwSuTnfj66Knk8rBZ5PKwWeTysFnmBvBJ5PKwWeTysFnk8rBZ5PKwWeTysEvmCh9Uij4fVIo+H1SKPh9UiL5BXIo+H1SKPh9Uij4fVIo+H1SKPh9Uhvy54WC3yeFgt8nhYLfJ4WC3yAnkl8nhYLfJ4WC3yeFgt8nhYLfJ4WCXyDg+rRR4Pq0UeD6tFHg+rRV4gr0QeD6tFHg+rRR4Pq0UeD6tFHg+rRN7jYbXI42G1yONhtcjjYbXIC+SVyONhtcjjYbXI42G1yONhtcjjYZXIBzysFnk8rBZ5PKwWeTysFnmBvBJ5PKwWeTysFnk8rBZ5PKwWeTysEnnBw2qRx8NqkcfDapHHw2qRF8grkcfDapHHw2qRx8NqkcfDapHHwyqRX/GwWuTxsFrk8bBa5PGwWuQF8krk8bBa5PGwWuTxsFrk8bBa5PGwSuQjHlaLPB5WizweVos8HlaLvEBeiTweVos8HlaLPB5WizweVos8HlaJfMLDapHHw2qRx8NqkcfDapEXyCuRx8NqkcfDapHHw2qRx8NqkcfDKpHPeFgt8nhYLfJ4WC3yeFgt8gJ5JfJ4WC3yeFgt8nhYLfJ4WC3yeFgl8gUPq0UeD6tFHg+rRR4Pq0VeIK9EHg+rRR4Pq0UeD6tFHg+rRR4Pq0M+LnhYLfJ4WC3yeFgt8nhYLfICeSXyeFgt8nhYLfJ4WC3yeFgt8nhYJfIOD6tFHg+rRR4Pq0UeD6tFXiCvRB4Pq0UeD6tFHg+rRR4Pq0UeD6tE3uNhtcjjYbXI42G1yONhtcgL5JXI42G1yONhtcjjYbXI42G1yONhlcgHPKwWeTysFnk8rBZ5PKwWeYG8Enk8rBZ5PKwWeTysFnk8rBZ5PKwSecHDapHHw2qRx8NqkcfDapEXyCuRx8NqkcfDapHHw2qRx8NqkcfDKpFf8bBa5PGwWuTxsFrk8bBa5AXySuTxsFrk8bBa5PGwWuTxsFrk8bBK5CMeVos8HlaLPB5WizweVou8QF6JPB5WizweVos8HlaLPB5WizweVol8wsNqkcfDapHHw2qRx8NqkRfIK5HHw2qRx8NqkcfDapHHw2qRx8Mqkc94WC3yeFgt8nhYLfJ4WC3yAnkl8nhYLfJ4WC3yeFgt8nhYLfJ4WCXyBQ+rRR4Pq0UeD6tFHg+rRV4gr0QeD6tFHg+rRR4Pq0UeD6tFHg+rQz4teFgt8nhYLfJ4WC3yeFgt8gJ5JfJ4WC3yeFgt8nhYLfJ4WC3yeFgl8g4Pq0UeD6tFHg+rRR4Pq0VeIK9EHg+rRR4Pq0UeD6tFHg+rRR4Pq0Te42G1yONhtcjjYbXI42G1yAvklcjjYbXI42G1yONhtcjjYbXI42GVyAc8rBZ5PKwWeTysFnk8rBZ5gbwSeTysFnk8rBZ5PKwWeTysFnk8rBJ5mdnDituPFlfiL0ff6czsM+t0ZvaCdToz+7U6HYHOCZ2ZfU+dzszepE5nZv9QpzNzj1+nM3MfXqWz0iuf0aFXPqNDr3xGh175jI5A54QOvfIZHXrlMzr0ymd06JXP6NArn9CJ9MpndOiVz+jQK5/RoVc+oyPQOaFDr3xGh175jA698hkdeuUzOvTKJ3QSvfIZHXrlMzr0ymd06JXP6Ah0TujQK5/RoVc+o0OvfEaHXvmMDr3yCZ1Mr3xGh175jA698hkdeuUzOgKdEzr0ymd06JXP6NArn9GhVz6jQ698QqfQK5/RoVc+o0OvfEaHXvmMjkDnhA698hkdeuUzOvTKZ3Tolc/o0Cu/ppOnfi58nc7UvbK4sNFJbjmgM3WvXKUzda9cpSPQOaEzda9cpTN1r1ylM3WvXKUzda9cpTN1r1yjM/Xzp+t06JXP6NArn9GhVz6jI9A5oUOvfEaHXvmMDr3yGR165TM69MondKZ+zm2dDr3yGR165TM69MpndAQ6J3Tolc/o0Cuf0aFXPqNDr3xGh175hM7Uz9Os06FXPqNDr3xGh175jI5A54QOvfIZHXrlMzr0ymd06JXP6NArn9CZ+7l9VTr0ymd06JXP6NArn9ER6JzQoVc+o0OvfEaHXvmMDr3yGR165RM6cz+3r0qHXvmMDr3yazqlg9Q9pu3oNebwTOc+gw66/eWh7xK/z6BNV+XDVhghpFyZQYhl2Y7Oy/Nrp69BJYuDyhYHVQwOqlG61HhQzuKgvMVBBYuDEouDWi0OyuIVXSxe0cXiFV0sXtFXi1f01eIVfbV4RV8tXtFXi1f01eIVfbV4RV8tXtFXi1f01eIVPVq8okeLV/Ro8YoeLV7Ro8UrerR4RY8Wr+jR4hU9WryiR4tX9GTxip4sXtGTxSt6snhFTxav6MniFT1ZvKIni1f0ZPGKnixe0bPFK3q2eEXPFq/o2eIVPVu8omeLV/Rs8YqeLV7Rs8Ureta4oue0H10W931QZbE4KGdxUN7ioILFQYnFQa0WBxUtDiopD8r5g0FpXNHz/nWxUPzyy6C+H533r0zl8PjGlP/jO1rfjr3dyr+OLeXXY++TLdNM1i/LMtNk3UyT9TNNNsw0WZlpsutMk40zTTbNNNl5OqjbZGfqoNxMHZSbqYNyY3VQcTv2Nk5/MNuxWqjabGWq2Y7VRNVmO1YXVZvtWG1UbbYafVTxaZ/tmiqzPf+N4G0GpfcZ+KX7GbjuZ+C7n0HofgbS/QzW7mcQu59B6n4G3d+TQ/d3tGD/jna688BtBvavRbUZ2L8WJf+YgU/fZ2D/WlSbgf1rUW0G9v1BZQZi/2pam0EHV1OJ+wxWeZ7B94O97APxIvJ9uvbNRNPp2nceTacrc023gz6i5XQ7aDpaTreDDqXldDtoZ1pOt4Pe57em6/Njut8Nw9pBo9RyuqN1VZXpDtZVrevWM/s1hvOD47JsP8eIt7XW72wGa8F+h81aUjllI4Ox2dcK/Zrc+cF52V44y9PGl7J8oRmst2uJZrA+sCWawXrGlmgG6y9bohmsF22IJo7W2fwOmnVbh8kp/oLm4IVd2Mbs3fp4YfFHB+ethQjLL4fekY/WMHWAXED+aeQz93dKyGfuG5WQz9yPKiGfuc9VQj5z/6yDPA2WJ/eAfLBMuwfkuM+PI8d9fhy5gPzTyHGfn0aeqfKfIV+K35E/ffX4EHnO2yB+2czp8IXd7b23V779nZ5+clfyl0Z8LOxrRIpjXyNiH/sakRPZ14hgybxGhSTKvkZEV/Y1IuuyrxHhmH2NBI3Ma0TOYF8jcgb7GpEz2NeInMG+RuQM1jVyCzmDfY3IGexrRM5gXyNyBvsaCRqZ14icwb5G5Az2NSJnsK8ROYN9jcgZzGvkyBnsa0TOYF8jcgb7GpEz2NdI0Mi8RuQM9jUiZ7CvETmDfY3IGexrRM5gXqMOHq2HRuQM9jUiZ7CvETmDfY0EjcxrRM5gXyNyBvsakTPY14icwb5G5AzmNerggcdoRM5gXyNyBvsakTPY10jQyLxG5Az2NSJnsK8ROYN9jcgZ7GtEzmBeIyFnsK8ROYN9jcgZ7GtEzmBfI0Ej8xqRM5jXaB35c5TPD05xOzalX6jfyYxcvX+NzMjZ1F8j00Mi5B5kKpM9e+n7fHtIV1rOt4ekouF8Yw+uv+V8e3DQLefbgxttOd8enN3P5ytLKF8Hy1JK5aWD7M1gkPw07PXr7hUFOid0eugH9ej00BPq0RmrL2xNZ6wusjWdsXrOxnTSWB1qazpj9bOt6YzV/bamQ698RkemoXOf7zzd732+8/Sz9/nO06He5ztPz3mf7zxd5J/zzYP1hW5f0JDgpPLSeZGvg3N4sPE5HBxb8vbCpfx67J3jYB2kGsfBek01joN1pWocBY5NOA7WF6txHKzfVuM4WB+vxnEwf6DGcTDfocWx4GfacMTPtOGIn2nDET/ThuNo/aPb1h/E+YN8q4tnw7ec72j9WG2+o/VN5/P1XTz/u+V8R+tDavMdrV+ozXe0+3ptvjLZfEfL/Wrznau/8l08E7flfOfqr3wXz2ptON8unnvacr6T9VddPI+z5Xwn66+6eE5ky/lO1l918fzClvOdrL/q4rl6Lec7WX/VxfPeWs53sv6qi+eQtZzvZP1VF8/HajnfyfqrLp7b1HK+k/VXXTxPqOV8J+uvunjOTcv5TtZfdfH8lZbznay/6uK5IC3nO1l/1cXzKlrOd7L+qovnKLSc72T9VRf7+7ec72T9VRf7zrec72T9VRf7obec72T9lUzWX8lk/ZVM1l/JZP3VOll/tU7WX62T9VfrZP1VF8/JaDnfyfqrLp5p0XK+k/VXgz2poj7fyfqrwZ5UUZ/vZP3VYE+qqM93sv5qtGdPVOc7WX812vMhqvOdrL8a7RkO1flO1l+N9pyF6nwn669GexZCdb6T9VejPa+gOt/J+qvRnldQne9k/dVozyuozney/mq45xXU5jtZfzXc/v+1+U7WXw23n35tvpP1V8PtT1+b72T91XD7vdfmO1l/Ndz+6bX5TtZfDbcfeW2+k/VXRSab72T91WT7t/vJ9m/3k+3f7ifbvz1Mtn97mGz/9jDZ/u1hsv3bwyKTzXeu/ipMtn97GG7/9rc9Vylux94Q+F8OvoPkQYiNQPIkxDYgh9vKXg0kz0JsBJKHITYCKdOAvM93nqeH3+c7z1O+7/Odpwu9z3eeZvE+33l6uj/nO9wu97X5ztMh3ec7TyNzn+88T1++z1cmm+9k/dVwu9zX5jtZfzXcLve1+U7WXw23y31tvpP1V8Ptcl+b72T91XC73NfmO1l/Ndwu97X5TtZfDbfLfW2+k/VXw+1yX5vvZP3VcLvc1+Y7WX813C73tflO1l8Nt8t9bb6T9VfD7XJfm+9k/dVwu9zX5jtZfzXcLve1+U7WXw23y31tvpP1V8Ptcl+b72T91XC73NfmO1l/Ndwu97X5TtZfDbfLfW2+k/VXw+1yX5vvZP3VcLvc1+Y7WX813C73tflO1l8Nt8t9bb6T9VfD7XJfm+9k/dVwu9zX5jtZfzXcLve1+U7WXw23y31tvpP1V8Ptcl+b72T91XC73NfmO1l/Ndwu97X5TtZfDbfLfW2+k/VXw+1yX5vvZP3VcLvc1+Y7WX813C73tflO1l8Nt8t9bb6T9VfD7XJfm+9k/dVwu9zX5jtXfyXD7XJfm+9c/ZUMt8t9bb5z9VeyyGTznau/kuF2ua/Nd67+SibajP4+38n6q4m2dr/Pd7L+aqKN0u/znay/mmz/dpls/3aZbP92GW3/9hjKNt+8hMpL/9aDHfI2w1J+PfbOcbC+TY3jYP2gFsfR9rF/H8fzB7bIaBvk64EcrDPWAzlYy60HUgDZBuRgJkEP5GDuI+8vLVlqIFMMXwen9Jii+C80gxmVlmgG8x4t0QxmJ07Q/Dnf0R6vUJ3vYN15db5jNdGrk3U72MWDeGqwxyvU5yuTzXeszrE+37EavPp8x+ra6vMdqxWrz3es/qo638Eer1Cf71j91fN8vfMH8x23vzqe77j91fF8ZbL5jttfHc933P7qeL6D9VfJpf3gXA7mO1h/VZ3vYP1Vbb6DPV6hPt/B+qvqfAfrr6rzHay/qs5XJpvvYP1Vdb6D9VfV+U7WXw32eIX6fCfrrwZ7vMKaw7IdXGKuvLSUHc7zV6GzPzjWp8V/HeyTfziv+MVxsL5NjeNg/aAax8H6zEYc72wENi/ZDNa/NmUzWK/blM1gfXFTNoP10E3ZDNZv/xabW4S/HSz5O5vBHs3Rls3M/XaNzcw9dI3NzH1xjY3A5iWbmfviGpuZ++Iam5n74hqbmfvidd374nzQFw/2mJSmbAZ7pEpbNlP3xRU2U/fFFTZT98UVNgKbl2ym7osrbKbuiytspu6LK2zoi1+zmacv/nO+gz3epj7fefrX+3zn6Unv852nz7zPVyab71j9YFyWbSAxRHcw37F6vPp8x+rb6vMdqxerz3es/qo233Wwx9vU5ztWf1Wf71j9VX2+Y/VX9fnKZPOdq79aB3u8TX2+c/VX62CPt6nPd7L+arDH29TnO1l/Ndjjberznay/GuzxNvX5TtZfDfZ4m/p8J+uvBnsMTX2+k/VXgz3WpT7fyfqrwR6SUp/vZP3VYI8cqc93sv5qsAd41Oc7WX812KM26vOdrL8a7PkZ9flO1l8N9vyM+nwn668Ge35Gfb6T9VeDPT+jPt/J+qvBnp9Rn+9k/dVgz8+oz3ey/mqw52fU5ztZfzXY8zPq852svxrs+Rn1+U7WXw32/Iz6fCfrrwZ7fkZ9vpP1V4M9P6M+38n6q8Gen1Gf72T91WDPz6jPd7L+arDnZ9TnO1l/NdjzM+rznay/Gux5FPX5TtZfDfYsiPp8J+uvBntmQ32+k/VXgz1boT7fyfqrwZ6BUJ/vZP3VYM8qqM93sv5qsGcK1Oc7WX812N7/9flO1l8Ntkd/fb6T9VeD7aVfn+9k/dVge97X5ztZfzXY3vT1+U7WXw22h3x9vpP1V4Pt9V6f72T91WD7t9fnO1l/Ndj+7fX5TtZfDbZ/e32+k/VXk+3fvk62f/s62f7t62T7t8fJ9m+Pk+3fHifbvz1Otn97XGSy+c7VX8XJ9m+Pk+3fHifbvz1Otn97nGz/9jjZ/u1xsv3b42T7t8fJ9m+Pk+3fHkfbv13ydnBcnT+Y72D9VUi7vrcTKy+dF/k6OIeyH+tzODi25O2FS/n12DvHwfo2NY6D9YNaHEfbx16N42D9qxrHwfpiNY6D9dtqHAWOTTgO5g/UOA7mO9Q44mfacMTPtOGIn2nCcbTnRqhxxM+04YifacMRP/NDjnE79obAH4AUQLYBiaNpBBJL0wgknqYRSExNG5CjPXVjzWUDeVvhr7y0W8sStmmuxYX9+PhFZ7Bb8Qmd+3wHu2NW5zvWjS2ltB2c0lOPfvzSPsX162ifUnh+6TucsW5WjeGMdQNqDGesqKwtnMGeO9EYzljtSGM4YyVVjeGMFT81hiNTwyl+g5OfusAdzlhNb2M4c3fIFTgzd8jBL5u5Ct6n73Bm7pCrcGbukGtwBntySGM4M3fINzjLKRyZGY647eggfvkOZ+Y+pwpn5j6nCmfqPqcGZ+o+J5S8w3HL+UuvJW23trWUg6v31E3R75CMy34fjMuBMRns2SCfqcljklO3WxL2XlRW99c+3YM9z+QzJI9rcuaoM8j+VYkgJX+HI8B5DWduC1CBM7cFqMCZ2wI84KxP36La4UxtAWpwpu7qK3AGe8hMYzhT997hMZDVpfOXdrdC2pAkedocRpYvlFO3jGnfOiekEv6ajRnssTJvJFkLKQZ7YM1navKY5NSd6+Olw98t0h9cKJeyf+HbheXgQjl1n5u97ChL5aVlJyL+1zvOAfZHJOducfp+dNixT91B62GfujdXwz7Yo4+6wT61n9DDPnXwr4d9asunh13A/kPsYbOH8jzDHeTU9rAlyMF+dN72J76jPQarMZ3BNr1qSieN9oitxnTYWuCMzmDbTjWmM9hmUo3pCHRO6MyzicUVOoPt5fS7dII86Kz+ic7x0f7p6PiN5eSddVOWk/fhTVlO3rX/Bktxe54j/ulrFl8kR3vImyLJyd1AQ5KTO4eGJCd3GQ1JCiQbkZzcvTQkidNpRRKf04okLqcVSTxOI5KjPWBQkeTsHudVKnHw2nn/xUIKTz/SfvHaJW+TvGF/etjvTa87+dk9kR752T1UG/J3lgLLZixn91GnCXGjh8K5/UkEwftSoePysm1S6rJ7ZlkO6SwPOkt8pnOfQbE/A/+YwffNylKjB6FpzsB1PwPf/QxC9zMQ+zOQ+LhSV35i5mW/ZXgR+T7dda7pxrmmm+aabgd9RMvpdtB0NJyudNChtJxuB+1My+l20Pv81nR9fkz3u2GQDhqlltOVuaY7WFe1rlvP7Nf41zbaSDJYC/Y7bCpbZyQZrF9bXdjZpMo+k3nZXjjL05i/fjeWZLDeriWawfrAhmjWwXrGlmgG6y9bohmsF22JZrTO5nfQrNswcoq/oDl4YRceK5VPWyz/sR3e94Mfu28tvxx6Rz5aw9QB8pn7MCXkM/d3Sshn7ht1kMeZ+1Ed5GnmZu53kC+Px0u6p684HCLPeRtEcdVNim7vvX/9I9/02I/3JX9pNFgaOqRGgkbmNcKd2dcIO2dfI/yffY0wjPY1wmGa1yhjSe1rNPNaTS8akTPY14icwb5GgkbmNSJnsK8ROYN9jcgZ7GtEzmBfI3IG8xoVcgb7GpEz2NeInMG+RuQM9jUSNDKvETmDfY3IGexrRM5gXyNyBvsakTNY1ygv5Az2NSJnsK8ROYN9jcgZ7GskaGReI3IG+xqRM9jXiJzBvkbkDPY1Imcwr5EjZ7CvETmDfY3IGexrRM5gXyNBI/MakTPY14icwb5G5Az2NSJnsK8ROYN5jTw5g32NyBnsa0TOYF8jcgb7GgkamdeInMG+RuQM9jUiZ7CvETmDfY3IGcxr1MMD4KfXiJzBvkbkDPY1Imewr5GgkXmNyBnsa0TOYF8jcgb7GpEz2NeInMG8RkLOYF8jcgb7GpEz2NeInMG+RoJG5jUiZ7CvETmDfY3IGexrRM5gXyNyBvMareQM9jUiZ7CvETmDfY3IGexrJGhkXiNyBvsakTPY14icwb5G5Az2NSJnMK9RJGewrxE5g32NyBnsa0TOYF8jQSPzGpEz2NeInMG+RuQM9jUiZ7CvETmDeY0SOYN9jcgZ7GtEzmBfI3IG+xoJGpnXiJzBvkbkDPY1ImewrxE5g32NyBnMa5TJGexrRM5gXyNyBvsakTPY10jQyLxG5Az2NSJnsK8ROYN9jcgZ7GtEzmBeo0LOYF8jcgb7GpEz2NeInMG+RoJG5jUiZ7CvETmDfY3IGexrRM5gXyNyBusalYWcwb5G5Az2NSJnsK8ROYN9jQSNzGtEzmBfI3IG+xqRM9jXiJzBvkbkDOY1cuQM9jUiZ7CvETmDfY3IGexrJGhkXiNyBvsakTPY14icwb5G5Az2NSJnMK+RJ2ewrxE5g32NyBnsa0TOYF8jQSPzGpEz2NeInMG+RuQM9jUiZ7CvETmDeY0COYN9jcgZ7GtEzmBfI3IG+xoJGpnXiJzBvkbkDPY1ImewrxE5g32NyBnMayTkDPY1ImewrxE5g32NyBnsayRoZF4jcgb7GpEz2NeInMG+RuQM9jUiZzCv0UrOYF8jcgb7GpEz2NeInMG+RoJG5jUiZ7CvETmDfY3IGexrRM5gXyNyBvMaRXIG+xqRM9jXiJzBvkbkDPY1EjQyrxE5g32NyBnsa0TOYF8jcgb7GpEzmNcokTPY14icwb5G5Az2NSJnsK+RoJF5jcgZ7GtEzmBfI3IG+xqRM9jXiJzBvEaZnMG+RuQM9jUiZ7CvETmDfY0EjcxrRM5gXyNyBvsakTPY14icwb5G5AzmNSrkDPY1ImewrxE5g32NyBnsayRoZF4jcgb7GpEz2NeInMG+RuQM9jUiZzCuUVgWcgb7GpEz2NeInMG+RuQM9jUSNDKvETmDfY3IGexrRM5gXyNyBvsakTOY18iRM9jXiJzBvkbkDPY1Imewr5GgkXmNyBnsa0TOYF8jcgb7GpEz2NeInMG8Rp6cwb5G5Az2NSJnsK8ROYN9jQSNzGtEzmBfI3IG+xqRM9jXiJzBvkbkDOY1CuQM9jUiZ7CvETmDfY3IGexrJGhkXiNyBvsakTPY14icwb5G5Az2NSJnMK+RkDPY14icwb5G5Az2NSJnsK+RoJF5jcgZ7GtEzmBfI3IG+xqRM9jXiJzBvEYrOYN9jcgZ7GtEzmBfI3IG+xoJGpnXiJzBvkbkDPY1ImewrxE5g32NyBnMaxTJGexrRM5gXyNyBvsakTPY10jQyLxG5Az2NSJnsK8ROYN9jcgZ7GtEzmBeo0TOYF8jcgb7GpEz2NeInMG+RoJG5jUiZ7CvETmDfY3IGexrRM5gXyNyBvMaZXIG+xqRM9jXiJzBvkbkDPY1EjQyrxE5g32NyBnsa0TOYF8jcgb7GpEzmNeokDPY14icwb5G5Az2NSJnsK+RoJF5jcgZ7GtEzmBfI3IG+xqRM9jXiJzBukY35GhkXiNyBvsakTPY14icwb5GgkbmNSJnsK8ROYN9jcgZ7GtEzmBfI3IG8xo5cgb7GpEz2NeInMG+RuQM9jUSNDKvETmDfY3IGexrRM5gXyNyBvsakTOY18iTM9jXiJzBvkbkDPY1Imewr5GgkXmNyBnsa0TOYF8jcgb7GpEz2NeInMG8RjKyh83nB6e4HZvSL9TvZEZ2jn+NzMh+7a+RkQ7IuAeZymTPXvo+3x4cR8v59tC9t5xvD51wy/n20FW2nG8PHVrD+a49rKr8znzX7Tbnig+Vl76pXbaj16de8PbSdzg9tIJqcHroBtXg9NAQvguOz2lvH3MplaPDzXltk7xdf/ejN5ICyUYkR2tN9UiO1vS+kWSIZSeZ0xPJ78eK26mLd+kb9dFa7z6oj2YAfo/6Pktf3FI5Ou9zzOExRZ/DwbElb8Mo5ddj79RHsyFdUI8zmyE96jO7LD3qM9s3Pepz+0It6gJ1Bepz+00t6nN7Uy3qc3tTLep4Uw3qeFMF6glvqkEdb6pBHW/6FupxO/YGzB9gx5yqYBewa2DHnqpgx5+qYMegqmCf2qGWxyr0UsXuJO0sV/f02vloJHHZFq2jf8KX1y/uU3tUPe55apeqyH1qn6rIfWqnqsh9aquqyH3q7v2d3GU7OK7ugDv9zJu47z8HjjF/597Fw9qNcF/dPuw1yC/c7yzpUdqxpO9ox5Jeoh1LgeWP71P7QG4s18p96vb2WR5DKd++p9/FI8LHJE9PrEV+6lBblTy5thb5mZ1gWELayZfaQM5/2ea7eEB2HyRndnZtSc7s636PpHNx3aG4+LT9nHNH28Sd/6bbd/EI6THJC+SVyM/sGd9Mvtkv8H0XD3xGpZm96O+qlPz+4rclllBRyae0f30rPW1HuZGf2YvqkseLKpHv4qHLfZJv+X0J38WDl9HJd/HwZXTyXTyAGZ18Fw9hRiffxYOY0cl38RDZKXQ6/Z6m7+IBmFPodPq9Tt/FQzA71anyHTHfxcMtR2UvsFdjT6+lx541lPfdl1t+v8l38ahJlPpDKTxJL0qxTtOJUoF1nV6Uwun/WCm/rDv629KlVJTyN2W/Dr8FX09Qcj46Oi370cn7bzrh9PvQiVSgD50EnRR0urMnQdBjT4Kgx55MQI89Ll+PPb5djb3gxN/G3u9fdrgtxC4H7PHWeuzxy3rs6e/12NPnvI39KsvGfl2P2NPnqLFf6XPasL/TpHNpSZNepCVNEvaf0/Su7DT983Xzyu/sV4G8Enk6ai3y5OVvI99u14KVZL0HlfCmF1WK7qAPwm02pBnxjy1p4h9/TjPkvNMUqe6oEf2eAMbwdHQJX+xxm59hnw7Y400/wl78AXuB/dvY72PxMa6/sD8aS1z2scQnhMUdzjPtgU/OoXJ09ts0s7hfjr3XAD6ZGsCxUwPkAdQAaQM1QEYyfQ0kkh1qgDyKGiAXm6AG1u3r8HlNBzVAPjdBDch+HXgC+KgBoQZmqoEYDmqAfKDHGvBr2KD4dfUHuuL5+9T18ZSA6NYDXfHxQ+qa8eZj6orfHlNXPPSYuuKLx9RV0HVIXfE5XWYY5fHF2XKUUWd8zpC6FnzOmLric8bUFZ8zpq74nDF1FXQdUNew0DcZ0dXLuiPMa0XXEHPYjo65HOhK3zSmrvRNY+pK3zSmroKuHeoqYX8sqIQcDnTld5Bd6lr23F9Kzge68tvGznVdl+XoOsz3EcfUlXW6MXVlnW5IXR1505i6kjeNqSt505i6kjeNqaug65C6kjeNqSt505i6kjeNqSt505i6kjcNqasnbxpTV/KmMXUlbxpTV/KmMXUVdB1SV/KmMXUlbxpTV/KmMXUlbxpTV/KmIXUN+Bwjurr9aVa3xdPq7zjCrmsIR98LD4KuvetaDn7HEfA5Y+qKzxlTV3zOmLric8bUFZ8zpK7CuvqYurKuPqaurKuPqSt505i6CroOqSt505i6kjeNqSt505i6kjeNqSt505C6ruRNY+pK3jSmruRNY+pK3jSmroKuQ+pK3jSmruRNY+pK3jSkrhGf8xFdk6/omuK2YX9KD9ziv2TCtnQhEy6kC5kEmd4lU0rb4T4voSJTCXlDWGRJj6Pz4b0sl8e97OngdDSOkt0+y8WfH+zcknZx3C9Q8lfFYFc0KubOHkvxNvbZl539uhywZ9nqfeyj7OyfEW7sE3epn7Nfwz5uvyZXYV/S9hQlt7inm8Nt4Hf0XO5/jj4ubkefngd+iP72kvuN2T+73RddX96eKnp77VI72rn9VuIkVY7OZYNS3MGlL3HboQZIvagBvpE1fg2UEvaGYMm/FMH3g2PZZxmLq7jWfGsFvw7OPvpvzjLRYVNe7yuvzPfTKK83lhfLR5TXG8uLZS/K643lxXId5fXG8hLKi/J6X3kRUlNebywv8u+py+teBATgFEEmAacIMjn1+EXgFr/sVSBLpd1wJe5feCllmO/6FUKnCSr9Fv481PTfr3eFbIgqCEWogsmqoBxUAUkLVXBTmCqgCgqJCFUQCpEI3eGtMqiC6atAFr5iRxXIwjfhqAJZyA6pAlnIDqkCWYQqoAoWskOq4LbeSRVQBQupUZdV4Jd9lxTvf62Cu67kQEPq6kh2xtSVrGZMXUlfxtSVPGVMXQVdu9RV1l3XtBzoSuYxpq58A2pMXfGvQ+rq6Yf71HX/PYsPfzeSu670w13qGtb98/rLwzh2XQVdh9SVfnhMXemHx9SV1doxdWX9dUxd8a9D6hpYfx1TV9Zfu9RVwvb9Ji85VI6Osj1jJcbH2k+IR7PM64Yk5/LLsfd6IceiXn6nXsjHqJffqRehXqiXp2PL40luiyuVg9dbcWzauCyVo2MMyz6O4A6KkbCQYjRTjCScFKOZYiSWpRjNFCNZMsVophgJwClGK8UopPYUo5liZKmBYjRTjKxjUIxmipFFEorRTDEKxUgxWilGVmAoRjPFyAoMxWimGFmBoRjNFCMrMBSjmWJkBYZitFKMKyswFKOZYmQFhmL8UDGmsFdJuhE5KEZWYChGM8XICgzFaKYYyRkpxo8VY173YnzC/ShGoh2K8VPFKH6/Mt7G/70YIwaGYjRTjEIxUowfKsa8bkBSjkfFyBclKMbrxSj79vCruOWgvLAklNcby4svM1BebywvPCzldb280h6RrHk5WFaLfOGA8npfeSW+QkB5/YXyisteXr7mM11Y/K5OWP7OaR4Bf0h/+zu62vHrujN0a1wObtYJJ0u52y33fZZ/lHttNE7yug9ecjpYX8lCuVPunyp35/cXD249uPpmrr6Uo6FyJHekHA2VIzkl5WioHMk1Kce/UI7P2qSD8iLXpLzeV16FXJPyemN58V1ByuuN5cXPlyivN5YXP0iivN5YXkJ5UV7vKy9yMsrrenmV/Rlha8nrQXmRe1Febywvci/K623ltS7kXpTX5fKKy/510ehcOigvci/K643lRe5Feb2xvMi9KK83lpdQXpTX+8qLb89SXm8sL74NS3m9sbxI7Smv95WXE8qL8rpcXk7SXl4HOyCtjt6L8npjedF7UV5vLC96L8rrjeXFNyYorzeWF9+YoLzeV16eb0xQXn+hvPajo/+7n9F+Pzp72aok++gfg85ftcjXK6hFK7XIdzGoRSu1yBc3qEUrtSjUIrVopBZZlqAWrdQiaxjU4odq0cV1f8DN7e+nanzEOqx5UI6GypE1EsrRUDmypkI52inHwBoM5fi5ckzuUY75qByJGynHj5VjzLKXY1oOvtschHKkHD9Vjsk/btZJ4kE5EjpSjobKkdyRcjRUjuSOlKOhciR3pBwNlSO5I+VopxyF3JFyNFSOfP2bcvxcOeb4KMcn4I9y5BvglKOhcmRVhnI0VI5COVKOnyrHvCx7OWbnDsqRVRnK0VA5sipDORoqR1ZlKMfP9Y5PXzDLzteO9w/pb39HVzt+XfMeJK1rKQflzqoP5T5RubOqRLnPU+4rq1aU+0TlzqoY5T5RubPqRrlPVO6s6lHuE5W7UO6U+zzlzqok5T5Que/LTGtcloNyZ9WTcrdb7vss/yj32mic5IdA8vev/2e5R5IZyn2ccl/zo9zTwTf+IskM5T5RuZPMUO4TlbtQ7pT7POXONyIp98+V+/r0a5p4VI58Y5FyNFSOfKOQcrRTjolv/FGOhsqR3JdyNFSO5LKUo6FyJDelHA2Vo1COlKOdcuQbYZTjx8ox77xvf68Hz1ZIfGOLcjRUjqzKUI6GypFVGcrRUDmyKkM52inHTAxOOX6sHMvjxyqxRDkoR2JwytFQORL0UI6fK8f4uFmXVL6XY+ErFJTjp8oxebc/0/X293pQjiwSUo6fK8c1PMoxH/xwuQjlSDleLke/pr0cc/oLR9+Lkc6RYjRTjCwQUowfKkaX4+NnXre/D1x1YYGQcjRUjiwQUo6GypEFQsrRTDnGhcyRcjRUjqxXU46GypH1asrRUDmyIkM5GipHoRwpRzvlyJoM5fixckzuIXxa3UE5sipDORoqR1ZlKEdD5ciqDOVoqBxZlaEc7ZSjY1WGcjRUjqzKUI6GypFVGcrRUDmyKkM5GipHckfK8WPlmJf98ao5u+WgHHHWlOPHyrE8XR1LOLg6epy1kXJMIns5yq9H35XCdPaiFH6sF6WwKr0oJSjViVJ87agXpXDGVpRKDyuS3IFSfFmlF6X4HkcvShHEdKJUIKPoRSkyil6UEpQyolR5dOklHihF72dEqSxbUu/zGg6UovfrRSl6vzZK/UlT6M9a0qSHakmTtZiWNFkvaUlToNmQJusOP6dZ/P41JV9KqvRTcXlsXf0EMK9f5FlH0CKPN9Qij9fTIo93UyK/4vO0yNN3v438/iWJ+PTrgQd5epu3kY+PL0nnA/L0Nj8mH0LyOxRZfYW8uw1m3zzK5fT4mUI8XKFYthf3yfunY+860Qn1oRN9Uxc6RbosDZ3u7Mne9diT1Ouxx1/osRfYq7FnzUCPPc76jez33zY7VxZ32o8Wl7aRF/f0m+JNJ3x4Hzrhw7vQKeEx+tBJ0MmGTn7PS4r3+ZtO9HB96ES/14dO9HttdLrTpCtrSZM1jIY0MysNLWnS17ekyWpAS5rk+z+nuboHzfUpt3zQFGg2pIl/a0kTl9WSJl6oJU28UEuaeKGGNAteqCVNvFBLmnihljTxQi1pCjQb0sQL/Zzm7Z69Q0nuV5oHr+7L9hOrENzjcdlfqx4F36RFHo+lRR4/9jbyt+N38r98t+T7seJ2lcS7b99DKfg8+yqlBf94USX/vQ9KC/7xN2jm8kQzHtDEP/6cZgruQXN1f+kOmxa8phZ5gbwSeTzs28g37Ffwuz2ohDe+qFJ0B30Qfvd3usr8RNMf0MSX/pimLGkftzj5a7tB3Xwt5JXI40u1yONhtcjjYbXIC+SVyNN3v4386X6LieeRv4/86X6LieeL/wb5EPYVDAl/99Sm78f7lLZXv/3597+4TDwvXI08vY0WeYH8m8i7FMM+zxTlO3sSej325O567Onq9diTvaux56m8b2SfHrsc3v4u39gL7N/HPuUH+xy/safP+Tl7ebCU1csv7O806Vxa0qQXaUmT7qIlTVb2G9Lk6chNadLLtqRJ8tySJmlyS5oCzR/TjLL/BkRiDr/Q/N3j7/TxTpr08Vqa9PFm76J/A7EN3Ifl6RsLuXyxx8npscf3qbHn2cqK7PGUH2Hv/AF7HKgee/yqHnuB/bvYhz1a8KGsv7A/OPr0abxpxQf3oROOuQ+d8NYaOt3Z46312OOt1dhHvLUee7y1Hnu8tR57vPXb2K+yTdOvz/u87OwF9mrs8ct67PHAeuzp79XYJ/qcd7G/rZf5/dWfj97Z0+fosZeZ2QfZ2d8uv5WjS9zmeIPwCCX9Desd5dRtS1uUU3chbVFOHZb/FsqnXdD/+OHf06XVfbGcOvxuzHLqZrcty7kfwt6Y5dRhc2OWU5uqxiynNkmNWQosm7HE9bRjie1pxxLf044lvqcdS3xPM5ZzP3C9MUt8TzuW+J52LPE97VgKLJuxxPe0Y4nvaccS39OOJb6nHUt8TyuWee4Hhf8WS1nctreuOJEDlviedizxPe1Y4nt+zNKlsrMsyy8sD1779NHTeRG4q3DHT+lwx3u9iXuzR3jnuR/h3YlGeMUfa+TD3vv4p8d6HWskuWyvLcX7ytFr2l56LU/48pdImFD7Is39aPJeRMI2dyASfrwDkTD6bxKprA+RYvkescz9bHRV8pj9d5Ev+7Vm8QexosPuv42838lLPiCPiX8b+X3YyxoPyGPNtcjjt5XIe0z0j8mHfbdRCX/H8veOvpPHGWuRx+5qkcfDvoe8k7Rv77C65/1bjsYdl22FIvqnV87rl0qCSh2ohDfuQSV8dA8q4bl7UAl/3oFKAV9jQiXZDo6rO1BJUMmCSnF76RjzgUr0eG9SaXX7JNcgv6h0J0/fpkWeXkyLPP2VFnnWP951N96HfSO/Vu7Gt8FmeQy8fPvyrrBa0odOeJA+dGIlpg+dWLfpQyeZWqe8HR3Er78cfacztbPI+3ctQ1nkO5115t5G3H60uBIP6Mx8BbxdpPbvHCW3HNCZ+bpTpzNzilenM3PSJunxbb68LJWj8z7HW2KwH/vHIzy+H1v2m2Epvx57pz7zvVCP+swJmx71mdM1NepTPwlbj/rMyZce9ZlzLD3qU3syNeoCdQXqU3tINep4Uw3qeFMN6nhTDep4UwXqCW/6FurnzxjOCXOqgh13qoIde6qCXcCugR2DqoJ9aq9U+9ZGmtrTVOlM7T1qdPLUHsHvsxQv+YDO1K18lc7UHXeVztSNcZWOQOeEztRtZpXO1OsVYd2GLfLUKx8fHeO+i0F+NOzef+1UNfVj4duSnLoHb0py6n795HvEB7Z533fdufL00usXyqmfCN8Y5dS/4av9qmbux5JX6Qh0TuhMvftL2fdMuE2ydrRL253TL49jjyPVhuvIcz+QvAuFpv7NZxcKTb3rjA2FKotMcz+TvQeJytyPeu9Doqk3pelDoqm9bB8STW2o+5BIppZo3/9VnNTCNZ/CtluQT8+PoV7SoUjrFtzdWMovR9/Jz50YaJKfOwnQJD+3w38jebdvIZ69iwfk53bumuTnNuSK5Od+6Lwq+bntsyb5uV2xJvm5za4meYG8Enk8rBZ5PKwWeTysFnk8rBZ5PKwS+bmf+a5KHg+rRR4Pq0UeD6tFXiCvRB4Pq0UeD6tFHg+rRR4Pq0UeD/sm8nGfZE7Zfycf8LBa5PGwWuTxsG8if6O2kS/ZHZDHw2qRF8grkcfDapHHw2qRx8NqkcfDapHHwyqRFzysFnk8rBZ5PKwWeTysFnmB/FvIl8UvX0eXJawH5PGwWuTxsFrk8bBa5PGwWuTxsErkVzysFnk8rBZ5PKwWeTzsu8inspH/8/W+kRfIK5HHw2qRx8NqkcfDapHHw2qRx8MqkY94WC3yeFgt8nhYLfJ42J+SD49n9AafY4W8S4+RpCjPw76DF8DrgMfBKoHHwCqBx78qgce+KoHHveqAT5hXJfB41zeBL2U72i9LZdhxWbYlw7i4A5XwuQZUWstuio9VwhO/S6X9GbN+Cf582LLTFv/083NZDq+OxT0uj8U/hu1L/hJVEHU8UfHyA4pKTjCgqGQQA4pKvjGgqGQn44mayWUGFJXMZ0BRiYgGFJVEaUBRBVHHE5VEaUBRSZQGFJVEaUBRSZQGFJVEaTxRC4nSgKKSKA0oKonSgKKSKA0oqiDqeKKSKA0oKonSgKKSKA0oKonSgKKSKI0mqiwLidKAopIoDSgqidKAopIoDSiqIOp4opIoDSgqidKAopIoDSgqidKAopIojSeqI1EaUFQSpQFFJVEaUFQSpQFFFUQdT1QSpQFFJVEaUFQSpQFFJVEaUFQSpfFE9SRKA4pKojSgqCRKA4pKojSgqIKo44lKojSgqCRKA4pKojSgqCRKA4pKojSeqIFEaUBRSZQGFJVEaUBRSZQsiBq2xyZKyr+IehdJEMm+SCQ+7xHJu32S3j2N5P64yht4Uhkl8CQnSuBJN5TAk0C8C3wIO/hSGrbAoeRtiuLcfnTYbttC/jCcpKQPw0lK9jCcpCQPw0kqSDqapKQaw0lKXjKcpCQxFiQ9D4iF1Ma+SOvUcUDIO3bx6y9H3+lM7ayrdKY2qVU6U/s9CQ86KVaOdmm73d9WJfdjfQ4Hx+adRw6lcmzZJSrl12PvCgkKGVdoajfWhUJTmysbCsXt2BtcfyDR1GapD4mmtkp9SDT1UngXEsWpvWwfEk1tqPuQaGpXfyLRnQ6u/oyOQOeEztxuNm+zDFlc7eLn836VCkEeR7tDJLcAbicv8Zej7+Tndqma5Oc2n5rk5/aUbyS/7j8yC2teDsjPbRUVyae5HaAm+bmNnSb5uf2aJvm5vaAmeYG8Enk8rBZ5PKwWeTysFnk8rBZ5PKwS+YyH1SKPh9Uij4fVIo+H1SIvkFcij4fVIo+H1SKPh9Uij4fVIo+HVSJf8LBvIl/C/jP6peQD8nhYLfJ4WC3yeNj3kBf/IO9Xf0BeIK9EHg+rRR4Pq0UeD6tFHg+rRR4Pq0P+BhLySuTxsFrk8bDvIp/KRj78HfnfO/quE463D50EnbrQCTdtQScn+6aZbnVP485Hs4zLtkFC9E/S5PVLU3z6eJqSAIynKdnCeJqSWgynqSMPGU9TfGSHmsp2cFzdgab0vR1qGv2macwHmtL3mtB0dTuS9fm1c/zSiV62D53oT7vQydNz/nMXOrFiZ0In2Sd502mt9By3qT2GUnxJ+/GbqqwGjqgqnm9EVQVVB1SVdckRVSWh+bGq4UE+Pm2D/0Knk6Pv5MlRtMiTjGiRJ+t4D3nvl+3Rql7CwbeKAumFFnnyCC3yZAZa5PH1WuQF8krk8cda5PGwWuTxsFrk8bBa5PGwSuQFD6tFHg+rRR4Pq0UeD6tFXiCvRB4Pq0UeD6tFHg+rRR4P+ybyq9+O9uvRHgOCh30TeQllJx+XytF555fDA5/P4eDYkrcplvLrsX8quuKNR1MUzz2aonj50RQlIxhNUUHRwRQl0xhNUbKS0RQlgxlNUbKd0RQlMxpM0UhmNJqiZEajKUpmNJqiZEbdKRr331Aviz+QVJB0NElJjYaTlNhoOEnJjYaTlOBoNEkTrvRNkq4x7ZKW+s6JZQnbi6/laR/gr72A0jw9z32+8zQE9/kOdrcsYS/nIlJ5aZ/iNhCfUnh+6Tucwe47beEMlv03hZMHi9Hbwhns3t8WzmDhbls4g+WkbeEIcF7DGayP/U04ZXt8h89OvsMZrOltC2fuDrkCZ+YOOfilPIadvsOZuUOuwSkzd8hVODN3yFU4M3fI4fED2mM4M/c5t6B0e+kgfvkOZ+Y+pwpn5j6nCmfqPqcGZ+o+J5S8w3HL+UuvZX+sw1rKt6v37doOyZ+RjMt+H4zLd2Pil6k7qIs1eUxy6nbrsUAe5Olpttc+3TOnl1dJHtekTE0yxZ1kyd/hzG0BKnDmtgAVOHNbgAqcuS3AA8769H2uHc7UFqACx03d1dfgTN2o1+BM3XsHv39LcnWp8tIxb37QJXn62qMsXyhlZpQp7wlOKuGv2Rg3dX/5OyRrIYWbuhm9WJPHJKfuXB8vHf5ukf7gpZeyv7QLy8GFcuo+N/t92LlUXlp2IuJ/veMcDOMRyblbnL4fHXbsU3fQatj91L25Hvapu3497FP7CT3sUwf/etgF7BrYp/aHv4U9bPZQUv7eifup7WFLkPx+/Auk6R8b36CiUw86BTYJ7EMnNlkwolOQh05PD9+JL472T0fHb6qy/d+IqrIF4IiqCqp2p+ofX/ff7fDTwvOmKdsAjqcp+wCOpykbAY6nKUnOeJqS+gynqZAQjacpadJ4mpIljacpSdJ4mgqaDqcpOdJ4mpIjWdH0VS5/8No57L/Ccs/iHL922Wd5K4CnWd4q514D5E7UADnVWDVwV5WkakBVV7Iq66redcLX/lgnn/eWNgSpkBe//7hSwlrVSdKjXX76zpnLhz+Ble3g+LTpz23uX5oKmvanadr4xZuO3zXF146nKb52PE3xqeNpiu/sUVO3axoPNMV1DqdpxHOOpynfj+hQ07hlDjHmA035fsR4mpIjjaepoOlwmpIjjacpOdJ4mpIjjacpOdJwmqap/WmQXdOQYuVoCYt/qPT8nQH311U6XxFNUztOOyqd5+xpag/ZjUqCSh2oNLXP60alqZ2bIZVO1yDS1F6sG5WmdlfdqDT1ursdlc5dbZ56Jb0blcgeelCJ7KEHlcgeelBJUKkDlcgeelCJ7KEHlab2S0vYVVpKbSBOomzLgLe/8/MvKf3B8X7N264Ttz+foNz+/pN9mdoFKbOf2tsos5/asSizn9qHKLMX2Kuxn9ozvJd92rfiui3eLwfsp3YCyuynXltUZj/1iqEye3ytFvtbmAH7d7GPZRv47c9wwJ4+523sc94Ov0U36wF7+px3sb9dUx6v7ssBe/ocPfb0OXrs6XPexz75/dXzr/fa3zv6T6UcaX8vSrE2YEOpmNf9Z1f5acfm+KUTPqMPnVhz6EMnQScbOpUdSiw+fdMJj9+HTuQBfehEdtCHTuQMfehEJtGFTp5Eog+dyCOs6PTYBqas33Uij+hDJ/KIPnQSdOpCJ/KIPnQij+hDJ/IIDZ3+ZB/wRO9iX/3uWsDn6LHHu+ixx4+8jf0v31WWA/YCezX2+AY99ngBPfb09+9j7x/sQ82HBV+2X43emk/5ex8WWG/sQyfWG7vQSfDWRnQKsew65ef86XeOvWuKZx9PU7KA8TQlY+hPU3H7/VS8+66poOlwmpKJjKcpWYuGpnf2ZC3vYx/Tzj7lA/bkJ+9jn/c1pVTKAXsykY/U/RH7lZxDjz15hB57gf272Od1m+btzyP2+AY99vT3euzp7/XY09+/j734U/aRPud97Cv7/EXWR/TYs46hx15gr8aeHlOPPVnaz9mHsOzsb1Qq7F1Ka9iOv/39wPK1dpLI0vTY02PqsafHfCP7lB/sn54ivrGnx9RjL7BXY0+GrMee/l6PPRmyHnsyZD32+Fo19hlfq8ee/v7n7Je0j1ucpAr7+NjYZnVPSdr6RV4g/y7y+9Exrwfk6e21yNPZa5Gnr9ciT1f/PvJuJx8PyNPTK5EvdPRa5Fmnehv5uH0NLcZ8QJ5VKi3yeFgt8gJ5JfJ4WC3yeFgt8nhYLfJ4WC3yeFgd8rLQz/+YfAj7VvIuyOor5J3LeV/FcmV5fvrq96OLS9vIi/u2m5MsdP996CToZEMn7zYoxfvvOuEs+tAJH9KHTriWPnTC41jRKbhdp1C+6YQj6kInxxpgHzqxYtiHTuQRfehEHtGHToJORnRa/KMvz990Io/oQyfyiD50Io/oQyfyiD50Io/oQidPHtGHTuQRfehEHtGHTuQRfeiEf/qxTr74fVdDX8pf+yW2eBzR28if/jZSPB5HizyuRYl8wIdokcdZvI/82a9SJeAVtMjT/WuRF8i/i/z5LzcCK4Za5PGwWuTxsFrk8bBa5PGwSuQFD6tFHg+rRV4g/2PycXE7+fQ88EPyt5d0O5S4Vo72qTyec/93O+DelaL/N6JU9tvymM8hHyiFX+hFKfxFL0rhR6wotRP32aUDpfAvnSi14nd6UQp/1ItSrAn2ohRriL0oJSjViVJkFL0oRUbRi1JkFL0oRUZhRan9Bw+3Pw/SpJWMohOlIhlFL0qRUfSiFBmFFaX2kd+UKgdKkVH0opSgVCdKkVFYUUryrtQaDpQio+hFKTKKXpQio+hFKTKKTpRKZBS9KEVG0YtSZBS9KIWfMqJU3Ldtur12qR0tIWxHSw6Vo6M8fkXyWPkK8WiWJW8F45anYRwfHP26AYw+1176j52p9h+/5OyWX46/lyOmkXL8XDnKQ/jnq+OjHHHGlKOhcsT+U46GypGMg3LUKcfov5djJsihHD9YjvIox7TWXr3svGN5/vZhPjg4+/21s3+q9NvB90InB6PQ/3WGQidGpNCnKHS+KUahT1HoQqFT6DMUOutqFPoUhc6KHYU+RaGzFkihT1HorDJS6B8r9OJ3gLe/4y/H/1mOhbSbcvzcdbc8vqFWloNvqBWhHCnHj10d3UP4EtxBOdKVUo6Gro70jpSjTu8YjsqRb6hRjmbKcV34hhrlaKgccdaUo6Fy5NtelOPnyjE8AvYiclCOfCeLcjRUjkI5Uo52ypHvN1GOhsqRbyFRjobKkVUZytFQObIqQzl+rhwra9brwqoM5WinHB2rMpSjoXJkVYZyNFSOrMpQjobKkVUZytFQOQrlSDnaKUdWZShHQ+XIqgzlaKgcyR0px+vl6Pajb5W51Mox+bC/eLpN4Xs5enJHytFQOZI7Uo6fK8cYHuWYykE5kjtSjobKkdyRcjRUjkI5Uo52ypHckXL8WDmGZVcn3QrloBzJHSlHQ+XIt8EpR0PlyLfBKcfPlaM8leO6HpQjqzKUo51yDKzKUI6GypFVGcrRUDmyKkM5GipHVmUoR0PlKJQj5WinHFmVoRw/V47huRzjQTmyKkM5GipHVmUoR0PlyKoM5fi5ctzn+Mff5aAcWZWhHO2Uo7AqQzkaKkdWZShHQ+XIqgzlaKgcWZWhHA2Vo1COlKOdcmRVhnL8XDmmp3IsB0/dElZlKEdD5ciqDOVoqBxZlaEcP1aO4vYHeSTxB3v0CKsylKOdclxZlaEcDZUjqzKUo6FyZFWGcjRUjqzKUI6GylEoR8rRTjmyKkM5fq4cl+dyPHhi68qqDOVoqBxZlaEcDZUjqzKU48fK0efH7rcS1trxEtx+vBxuwLeyikP52i3fsD7Kd3XV4/O6D15yyt/LPbJKRLnbLfdVHuUeD5KByKoS5dvH1fqwfFmFonw7Ll9WrSjfjstXKF/Kt9/yZVWM8rVbvik+yrf4BkkFq26Uu91yL4+r9W2J5KB8WaWjfLu4Wh+XL6t6lG/H5cuqHuXbb/kmVuko347Ll1U6ytds+YpLj/IN4a8nFYlVPcrdbrmHp6u1HDyZJLGqR/n2cbU+LF+hfCnffsuXVT3Kt+PyZZWO8u24fFmlo3xNlO+9HFl1oxwNlSOraJSjnXLMrIpRjp8rx/VRjj4fbEecWeWiHA2VI6tQlKOhcmRViXI0VI5COVKOdsqRVR/K0VA5sopDORoqR1ZlKEdD5ciqDOVopxwLuSPl+KlyjCXuVRVLKgflSO5IOX7s6rg8hL/9HQ/KkdyRcjRUjkI5Uo52ypHckXL8XO9Ylqdy9AflSO5IORoqR3JHytFQOZI7Uo6GypFvg1OOZsoxLnwbnHI0VI6sylCOhsqRVRnK0VA5sipDORoqR3JHyvFyOa634ti0cVkqRyeJ22vf/iwHxUjqSDGaKUYyR4rRTDGSOFKMnyrG6DbdU/TpezE68kaK0UwxkjZSjGaKkayRYjRTjCSNFKOZYiRnpBg/VYxr3qokreUg9Ha4aYrxU8WYyjbolIP7XoweN00xmilG3DTFaKYYcdMUo5lixE1TjGaKUShGivFDxZhXtxdjDAfFyC+pKUYzxUjOSDGaKUa+z0gxmilGvs9IMZopRlZgKEYrxRhYgaEYzRQjKzAUo5liZAWGYjRTjOSMFOOnivH5+4xHKzCBnJFiNFOM5IwUo5liJGekGM0UIzkjxfixYoz7t3Ziyt+LUYRipBg/VIxp55eSk4NixE1TjGaKETdNMZopRtw0xfixnrGkRzGuB8WIm6YYzRQjbppitFKMK2vTFOPHesb9UdS3Pw96xpVfB1KMHyvGp18HulA52kle96FIPsolV6F4Kd4PFW92cS/eoxWblVySYtS4kh4WI7kkxWimGMklKUYzxUguSTGaKUZySYrRSjFGfk1IMZopRnLJLovRy4bQ+7T8cvRdV0HXHnUNfnttHyQc6Er6NaauBElj6kom0+f9NT90/buR3HUl3hhTV5KCIXVNmO4xdWU3nDF15ct7Y+pK3jSmroKuQ+pK3jSmrvjXn+u6rA9dbzOusl/yns37p2w+5y/2eEw19hkfqMcer/Y+9rIvTvs1/ML+YCy+bEqF8PQL5/ilE96rD53wUkZ0CrHsOuX0pNPvHHvXVNB0OE3xUONpynp9f5qK2++n4t13TVmrH09Tco7xNCU/eZum4fG90pCWiqZr2gpgLU8Av+x+IWrpQiZSmS5kIpTpQiYymS5kEmR6l0zyWHqU51c/lOnWJWxH3+5E6Vmo7wdnLxvv7KP/ripBy4iqErWMqCphy4iqEreMqCqBy3iqpoV8ZkRViXNGVFVQ9V2qrn5fxlj9+ouqd/Z0qu9jL/uXmtf1+1cGk+Me9T72++F+jfmAPXcSPfak/XrsifA1rvdX7g6CUp0oRTJvQ6mY1w1hzOmxIVz80omsvQ+d8CR96EQebkSnskOJxadvOpFwd6GTJw/oQyeygz50ImfoQycyiT50EnTqQifyCCs67QufsazfdSKP6EMn8og+dCKP6EMn8ogudArkEX3oRB6hodOdvcD+p+zdrePdXtyVpfaUKSdpg+JW9/wT/KORx8dHZHVPx65fOuGJjOiUduua1wOd8ER96IQn6kMnPFEfOuGJrOi0/7Ahx+86CZ6oD53wRH3oxBqtEZ3i45m++UAn1mj70EnQqQudyCP60Ik8og+dyCP60Ik8og+dyCO60Gmd2T/58th2eXFLTaeW60nrzH7ordzPc9JV4K7CfWa/osl9Zv+hyX1mP/Fe7qd58DqzP9DkPnO/r8g9zrye+Fbu574pzrw+qMkdv6rDHb+qw13grsIdv6rDHb+qwx2/qsI9HXNP+8Pin5YDfA4Hb5B35DmUyrElb1RK+fXY+2CypcEUQ4PJi6XBOEuD8ZYGEywNRiwNZrU0mGhpMJauwNnSFTh/9goc97vqsvjvoymLqdE4U6PxpkYTTI1GTI3m+Gojpewt5erPe9u8bJ/aLE8ttixf75Df/g7lze+QXzx9p+U7uLe/g3/7O4S//g7r5sByir+8w4FLWspmZbxbHkfL0ZeUct6eG1Kcr73wzVluLyzLYzE17BOVWSa6zjLROMtE69f79MtE72flS2eVK2e58O7rlJO3v8P69neIb3+H9PZ3yG9/hzLJx9ovs0zUzTJRP8tEw5W7hJdLZ61Xzjreayf4slm2ENxj46XtpHjlpHTlpMPLaAiPNYSQn/fY+sffOPb+BuXNb3C8CUHLN3B/9Q3E7RqId9/fwL/7DcKb32A91MDfFoS2T+9tOebbSe7KSf7KSS+uEr+z9HU74uvg9Xkt8GvpK7/4Kn7Tt1jf/xbx/W+Rmr6FLAdvkd//FuXtb/Hiy5BN38L99beIy3ZhiD4evIV//1uE97+FvP8t1ve/RXz/W6T3v0V+/1uUt79FWt7/Fu//dKf3f7rT+z/d6f2f7vT+T3d6/6c7vf/TnVt8Lk5/rZpzi4o6/SJUfvFtidXtXxFbg/zyFvfT1munxWunpWunvbj+7l9ou522VvC54vNOu/jyzVC8WK1v+yYvFuEbv4n7xJv4T7zJ+vaPZmlxDTv9LWMu6f1vkd//FuXdb1GW5f1v4d7/Fv79b9HifnL6w7iyyPvfYn3/W8R333jLkt7/Fvn9b1He/hZuef9buPe/hX//W4T3v4W8/y0Oi3Zdt9R0zc+dnv86qVw46XgxsXbScaksaZ/VH3+Xv+tIyotlriWVvYVdbovd304L106Ta6et1047vlguOYTHaU8P4dhOS9dOy9dOK5dOCy90K4/HkSwlum+nvSBZ8vZYEueW5RvJF09RqJ6Wrp1WLs3txVba1dNefHBKCU+DXL+d5q+dFq6dJtdOW6+dFq+dlq6ddvzBuR1aHqf55yr5x9+vqRf7z7V9k+M1vNZv4v76m5yvRZYXm8A1fYvw/reQ332L+2nrtdPitdOuXSJfrM9VTyuXTovLtdPctdP8tdPCtdPk2mnXbqTx2o30xVJHWvcLa0rPP1M9+rT4tOzfMEref3sL9/638O9/i/D+t5D3v8X6/reI73+L9P63yO9/i/L2t8jv/3Tn93+68/s/3fn9n+78/k93fv+nO7//053f/+nO7/905/d/ustvf7rvp7lrp/lrp4Vrp8m109Zrp8Vrp6Vrp+Vrp5ULp63Lslw7zV07zV87LVw7Ta6dtl47LV47LV07LV877VqVuGtV4q5VibtWJe5albhrVeKuVYm7ViXuWpW4a1XirlWJv1Yl/lqV+GtV4q9Vib9WJf5alfhrVeKvVYm/ViX+WpWEa1USrlVJuFYl4VqVhGtVEq5VSbhWJeFalYRrVRKuVYlcqxK5ViVyrUrkWpXItSqRa1Ui16pErlWJXKsSuVYl67UqWa9VyXqtStZrVbJeq5L1WpWs16pkvVYl67UqWa9VSbxWJfFalcRrVRKvVUm8ViXxWpXEa1USr1VJvFYl8VqVpGtVkq5VSbpWJelalaRrVZKuVUm6ViXpWpWka1WSrlVJvlYl+VqV5GtVkq9VSb5WJflaleRrVZKvVUm+ViX5WpWUa1VSrlVJuVYl5VqVlGtVUq5VSblWJeValZRrVXIte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV/ciey37NwxdEXdw2osq2bf0c6X4X0472sq30YNCbsMppobzKivWGo6zNRxvazjB1nDE1nBWW8OJtoaTbA3H1lU527oqF1tX5WLrqlxsXZWLratysXVVLrauyuXTV+XTZ1zdxpOMjScbG08xNR6/LMbG44yN53gD9Vtj/3Wa926tjOeWBzyepBzT3+9ecHuT8Ik3kU+8ydrkTUJ8vEkMT29y8Iu8HLaNgcLyvO/Tcryd6rLvubaEx2/vi/8afzQ+/nXnH9cQvo8/dT7+3Pn4S9/jP/7iQ0fjd52P33c+/tD5+KXz8Vu//9bG3/n913V+/3Wd339d5/df3/n913d+//Wd33995/df3/n913d+//Wd33995/df3/n913d+/w2d339D5/ff0Pn9N3R+/w2d339D5/ff0Pn9N3R+/w2d339D5/df6fz+K53ff6Xz+690fv+Vzu+/0vn9Vzq//0rn91/p/P4rnd9/187vv2vn99+18/vv2vn9d+38/rt2fv9dO7//rp3ff9fO779r5/ff2Pn9N3Z+/42d339j5/ff2Pn9N3Z+/42d339j5/ff2Pn9N3Z+/02d339T5/ff1Pn9N3V+/02d339T5/ff1Pn9N3V+/02d339T5/ff3Pn9N3d+/82d339z5/ff3Pn9N3d+/82d339z5/ff3Pn9N3d+/y2d339L5/ff0vn9t3R+/y2d339L5/ff0vn9t3R+/y2d339L3/ffsPR9/w1L3/ffsPR9/w1L3/ffsPR9/w3m97+qjb/v+2/ofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1Xo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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "_compute_utilization_rate",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "precision",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "deposit_accumulator",
            "type": {
              "kind": "struct",
              "path": "accumulator::Accumulator",
              "fields": [
                {
                  "name": "value",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "last_updated_ts",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "borrow_accumulator",
            "type": {
              "kind": "struct",
              "path": "accumulator::Accumulator",
              "fields": [
                {
                  "name": "value",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "last_updated_ts",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "12348881442450494403": {
            "error_kind": "string",
            "string": "Function _compute_utilization_rate can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_compute_utilization_rate"
      ]
    },
    {
      "name": "_deposit",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "951653053333916160": {
            "error_kind": "string",
            "string": "Deposit cap exceeded"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5235018679007078561": {
            "error_kind": "string",
            "string": "Invalid asset or market id"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16022896159229267359": {
            "error_kind": "string",
            "string": "Function _deposit can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AgAMAAAccSMAABwsJwILAGoKOAULDCQCAAwAABxHJwINBAA8CQENCygABoBFAAUkAgAFAAAcXCUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BCygABoBFAAUkAgAFAAAchiUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BCygABoBFAAUkAgAFAAAcsCUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BCygABoBFAAUkAgAFAAAc2iUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BCygABoBFAAUkAgAFAAAdBCUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BCygABoBFAAUkAgAFAAAdLiUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BCygABoBFAAUkAgAFAAAdWCUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BCygABoBFAAUkAgAFAAAdgiUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BCygABoBFAAUkAgAFAAAdrCUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BLQwKBC0MBwEtDAgCLQwJAyYqAQABBWRhiKjGz5TLPAEBAiYuAYADgAYLAIAGAAKAByQAgAcAAB3/IwAAHgouAIADgAUjAAAecS4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAB5dLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAB4sKAGABQQAAQMAgAYAAoAGIwAAHnEmKgEAAQXFa8RaDhAAAjwBAQImLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAAHtMjAAAfQyQAgA0AAB7gIwAAHvkuAIADgAUBAIAFAAKADi4CgAuADiMAAB8+KACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAB8+IwAAH5coAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAAH5coAIANBAADAQCABYANgAwLAIADgAWADSQAgA0AAB/7AQCACoAIgA8uAIAKgBAuAIAMgBELAIAQgA+AEiQAgBIAAB/7LgGAEIAOLgKADoARAQCAEAACgBABAIARAAKAESMAAB/KAQCADIAIgAYm",
      "debug_symbols": "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",
      "brillig_names": [
        "_deposit"
      ]
    },
    {
      "name": "_compute_borrow_rate",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "asset",
            "type": {
              "kind": "struct",
              "path": "asset::Asset",
              "fields": [
                {
                  "name": "asset_address",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "loan_to_value",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "oracle",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "is_borrowable",
                  "type": {
                    "kind": "boolean"
                  }
                },
                {
                  "name": "optimal_utilization_rate",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "under_optimal_slope",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "over_optimal_slope",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "deposit_cap",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "utilization_rate",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "precision",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17134621154673181869": {
            "error_kind": "string",
            "string": "Function _compute_borrow_rate can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBPJwAABAMnAgsECicCDAQAHxgADAALgEQdAIBFgEUGHQCAR4BHAR0AgEiASAYdAIBJgEkGHQCASoBKBh0AgEuASwYdAIBMgEwGHQCATYBNBi4IgEQAAS4IgEUAAi4IgEYAAy4IgEcABC4IgEgABS4IgEkABi4IgEoABy4IgEsACC4IgEwACS4IgE0ACiUAAAC5JQAAALouBAABgE4oAgACBIBOJwIDBAE7DQACAAMmJQAAAeUeAgALAB4CAAwAMzgACwAMAA0nAgsBASQCAA0AAADjJQAAAg4eAgALAR4CAAwACjgLDA0kAgANAAAA/yUAAAIgLQgBCwAAAQIBJwIMBgAtDgwLDDgJBQwkAgAMAAABpCMAAAEjAjgJBQEOOAUJAiQCAAIAAAE6JQAAAjIEOAEHAicCBAYACjgEBwMkAgADAAABaAY4AgcJCjgJAQgkAgAIAAABaCUAAAJEAjgKBQEOOAUKAyQCAAMAAAF/JQAAAjIGOAIBAwA4BgMBDjgGAQIkAgACAAABmyUAAAJWLQ4BCyMAAAHgBDgJBgEnAgMGAAo4AwYCJAIAAgAAAdIGOAEGBwo4BwkEJAIABAAAAdIlAAACRAY4AQUCLQ4CCyMAAAHgLQ0LASYoAIAEBHgADQAAAIAEgAMkAIADAAACDSoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEF7cpnKDUwRK08AQECJioBAAEFKIaSsEfc/UM8AQECJioBAAEFZGGIqMbPlMs8AQECJioBAAEFRafKcRlB5BU8AQECJg==",
      "debug_symbols": "vZfbbqMwEIbfhWsuPAcfpq+yWlUkIRUSIhFJVlpFffe1txzSAKUdRbmJ7Oj/+H8PNjDXbFduLm+vVbM/nLKXX9esPmyLc3Vo4uz6nmebtqrr6u319u/MpB8Q+A+cjkWT5qdz0Z6zFyBkm2dls0tjCiZeZF/VZZyZOJ7qDWIvN4yDWvyMmMX4TswCbhA7OyMOzKETB3Z8K/6dx/juMfFFejmAPC0+mgdV34ah+mGl+mB9Hx8c0dfxxRJ3YoncJL48Oj7gp/jJBPgJJojPMPGzJiBCPRV3BKyYWBNMJ4/DsLL/LPQLCJbM/Q2k+WXHFH5MRH4l0SNPBH2nRiSfEiWOUcdZo+TsHIdkDHRcHMNYcEsfmKgwxzpM5+ZpAUMaMY/32PyrBIkhDBg7P8GcBiMDOkxUGPAS5kdM7AQTFYY6N9S5zR+5VWz+xK1jOrel87aCObOADS98JMswwawK8zo3H1RYoPWSWMYJtuBGQb7ChHSYyo2NU2EAKgwX7hv48TmJYCeYVWGkcyOdG5MOCyrM6twc6DC3hJkRY7nHPKiwYH6+ud7j7E/RVsWmLrtmbH9ptje92fnvsbxr047tYVvuLm2ZGrabXi35B5cLpM4nrUFCHr9Hokk0+gc=",
      "brillig_names": [
        "_compute_borrow_rate"
      ]
    },
    {
      "name": "withdraw_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AAiAAygAgAQEAAElAAAHQS4IgAUACi4IgAYACy0OAgstDgkGLQ4KAQEoAAWARgACLQwCBSMAAAapLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAAB5AjAAAIACQAgA0AAAedIwAAB7YuAIADgAUBAIAFAAKADi4CgAuADiMAAAf7KACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAAf7IwAACFQoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAACFQoAIANBAADAQCABYANgAwLAIADgAWADSQAgA0AAAi4AQCACoAIgA8uAIAKgBAuAIAMgBELAIAQgA+AEiQAgBIAAAi4LgGAEIAOLgKADoARAQCAEAACgBABAIARAAKAESMAAAiHAQCADIAIgAYmLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAACRAjAAAJgCQAgA0AAAkdIwAACTYuAIADgAUBAIAFAAKADi4CgAuADiMAAAl7KACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAAl7IwAACdQoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAACdQoAIANBAADAQCABYANgAwBAIAMgASADQMAgAgAAoAOAQCADYAOgA8BAIAKgA6AEA0AgBCACoAOJACADgAACjQuAYAQgBEuAoARgA8DAIAQAAKAEAMAgA8AAoAPIwAACgMuAIAMgAYmKgEAAQXFa8RaDhAAAjwBAQIm",
      "debug_symbols": "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",
      "brillig_names": [
        "withdraw_public"
      ]
    },
    {
      "name": "get_total_deposited_assets",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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6HGzYuhxs2LocbNS6ANuVgw9blYMPW5WDD1uVgy9nxm98xt6l2Lt6JhX8u62sPoE3txRTu1O26Kc2m22RTm1e2yLcmo32Bbl1O6uKco4tVtri3Jq99UW5dRuqi3Kqd1RW5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKhNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKjNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKgttphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxHKvOB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFsuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mEsiy4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4nZaoTS4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4na+i9K7xX4c7V2In1DujMSnFYkJ5mkkeW/ccckfB0f79Mk5/BbJ4qM6EAmH1oFIeL8ORMJVdiCSRyT9IuGEOxAJj92BSLj3DkQiF+hAJBIH/SI5EocORCJx6EAkEocORJo7ccjr0c7b8Ono33A8cI7hzO2wK3DmdrYVOHM7ygqcuZ1cBc7cDuocjp/buVTgzO0YKnDm7tQrcOiQT+B44BzDoUM+gUOHfAKHDvkEDh3yCRw65GM4gQ75BA4d8gkcOuQTOHTIJ3A8cI7h0CGfwKFDPoFDh3wChw75BA4d8jGcSId8AocO+QQOHfIJHDrkEzgeOMdw6JBP4NAhn8ChQz6BQ4d8AocO+RhOokM+gUOHfAKHDvkEDh3yCRwPnGM4dMgncOiQT+DQIZ/AoUM+gUOHfAxn8re4V+DQIZ/AoUM+gUOHfALHA+cYDh3yCRw65BM4dMgncOiQT+DQIR/DmfzN3xU4dMgncKbukL17wKnuqWHSuu+FXR6fbLPbOTZvPLIrlWPLplApn4/9LdDUXXoPAnkE0i3Q1G6lB4Gmdkw9CDS1a+tBoKmdYw8CTe1e9Qt04z21he5Coal9fBcKESZoV4g0QbtCfmqF8rbJbfamppDN27a1zvnH0WYXSTCb+iEvn46+k587J5AkP3cAIEl+bmcvSX5uyy5Jfm4vLkjezO2xJcnP7Z0lyc/tiSXJz+11Jcl7yAuRx8NKkcfDSpHHw0qRx8NKkcfDCpG3eFgp8nhYKfJ4WCnyeFgp8h7yQuTxsFLk8bBS5PGwUuTxsFLk8bBC5B0eVoo8HlaKPB5WijweVoq8h7wQeTysFHk8rBR5PKwUeTysFHk8rBB5j4eVIo+HlSKPh5Uij4eVIu8hL0QeDytFHg8rRR4PK0UeDytFHg8rRD7gYaXI42GlyONhpcjjYaXIe8gLkcfDSpHHw0qRx8NKkcfDSpHHwwqRj3hYKfJ4WCnyeFgp8nhYKfIe8kLk8bBS5PGwUuTxsFLk8bBS5PGwQuQTHlaKPB5WijweVoo8HlaKvIe8EHk8rBR5PKwUeTysFHk8rBR5PKwQ+YyHlSKPh5Uij4eVIo+HlSLvIS9EHg8rRR4PK0UeDytFHg8rRR4PK0S+4GGlyONhpcjjYaXI42GlyHvIC5HHw0qRx8NKkcfDSpHHw0qRx8PKkL+BhLwQeTysFHk8rBR5PKwUeQ95IfJ4WCnyeFgp8nhYKfJ4WCnyeFgh8gYPK0UeDytFHg8rRR4PK0XeQ16IPB5WijweVoo8HlaKPB5WijweVoi8xcNKkcfDSpHHw0qRx8NKkfeQFyKPh5Uij4eVIo+HlSKPh5Uij4cVIu/wsFLk8bBS5PGwUuTxsFLkPeSFyONhpcjjYaXI42GlyONhpcjjYYXIezysFHk8rBR5PKwUeTysFHkPeSHyeFgp8nhYKfJ4WCnyeFgp8nhYIfIBDytFHg8rRR4PK0UeDytF3kNeiDweVoo8HlaKPB5WijweVoo8HlaIfMTDSpHHw0qRx8NKkcfDSpH3kBcij4eVIo+HlSKPh5Uij4eVIo+HFSKf8LBS5PGwUuTxsFLk8bBS5D3khcjjYaXI42GlyONhpcjjYaXI42GFyGc8rBR5PKwUeTysFHk8rBR5D3kh8nhYKfJ4WCnyeFgp8nhYKfJ4WCHyBQ8rRR4PK0UeDytFHg8rRd5DXog8HlaKPB5WijweVoo8HlaKPB5Whrxd8LBS5PGwUuTxsFLk8bBS5D3khcjjYaXI42GlyONhpcjjYaXI42GFyBs8rBR5PKwUeTysFHk8rBR5D3kh8nhYKfJ4WCnyeFgp8nhYKfJ4WCHyFg8rRR4PK0UeDytFHg8rRd5DXog8HlaKPB5WijweVoo8HlaKPB5WiLzDw0qRx8NKkcfDSpHHw0qR95AXIo+HlSKPh5Uij4eVIo+HlSKPhxUi7/GwUuTxsFLk8bBS5PGwUuQ95IXI42GlyONhpcjjYaXI42GlyONhhcgHPKwUeTysFHk8rBR5PKwUeQ95IfJ4WCnyeFgp8nhYKfJ4WCnyeFgh8hEPK0UeDytFHg8rRR4PK0XeQ16IPB5WijweVoo8HlaKPB72NeS9TeXjaO+CrRxtfNo+O5incee9WcYlfxwc7ZM0OXxoijseTtOE7x5PUxz9eJqSFYynKSnEeJp6NB1OU5KT8TQlkxlPU9Ke8TQlRxpPU3Kk4TTN5EjjaUqONJ6m5Ejf1tRtAzFxcRWVrF2Wj6Otd581vZMn7ZEi7yEvRJ7kRIo8+YYUeVIIKfJkBVLkcfRC5Au+W4o87liKPB5WijweVoq8h7wQeTysFHk8rBR5PKwUeTysFHk8rAx5t+BhpcjjYaXI42GlyONhpch7yAuRx8NKkcfDSpHHw0qRx8NKkcfDCpE3eFgp8nhYKfJ4WCnyeFgp8h7yQuTxsFLk8bBS5PGwUuTxsFLk8bBC5C0eVoo8HlaKPB5WijweVoq8h7wQeTysFHk8rBR5PKwUeTysFHk8rBB5h4eVIo+HlSKPh5Uij4eVIu8hL0QeDytFHg8rRR4PK0UeDytFHg8rRN7jYaXI42GlyONhpcjjYaXIe8gLkcfDSpHHw0qRx8NKkcfDSpHHwwqRD3hYKfJ4WCnyeFgp8nhYKfIe8kLk8bBS5PGwUuTxsFLk8bBS5PGwQuQjHlaKPB5WijweVoo8HlaKvIe8EHk8rBR5PKwUeTysFHk8rBR5PKwQ+YSHlSKPh5Uij4eVIj+1h81hI18W/+noOx0PnRM6U3vBKp2p/VqVztSeqkpnat9TpTO1N6nRyVP7hyqdqXv8Kp2p+/AqHXrlMzoeOid06JXP6NArn9GhVz6jQ698Rode+YROoVc+o0OvfEaHXvmMDr3yGR0PnRM69MpndOiVz+jQK5/RoVc+o0OvfEzHL/TKZ3Tolc/o0Cuf0aFXPqPjoXNCh175jA698hkdeuUzOvTKZ3TolU/oGHrlMzr0ymd06JXP6NArn9Hx0DmhQ698Rode+YwOvfIZHXrlMzr0yid0LL3yGR165TM69MpndOiVz+h46JzQoVc+o0OvfEaHXvmMDr3yGR165RM6jl75jA698hkdeuUzOvTKZ3Q8dE7o0Cuf0aFXPqNDr3xGh175jA698gmdud/JXaVDr3xGh175jA698hkdD50TOvTKZ3Tolc/o0Cuf0Zm6Vy4mbHRi7WiT8sfB9mkHVZvdzrF545FdqRxb8jrkUj4fe1do6n69B4XmfgdyFwpN7VtKWoftjV8qR9vk7CpRKs9Hpz2NbtenVSRr4qej7+Sn9kSi5Kf2W6LkPeSFyE/tE0XJT+1BRclP7W9Fyc/tnSXJz+2JBcnP/a5kUfJ4WCnyeFgp8nhYKfIe8kLk8bBS5PGwUuTxsFLk8bBS5PGwQuTnfleyKHk8rBR5PKwUeTysFHkPeSHyeFgp8nhYKfJ4WCnyeFgp8nhYIfJzv69blDweVoo8HlaKPB5WiryHvBB5PKwUeTysFHk8rBR5PKwUeTysEPmCh5Uij4eVIo+HlSKPh5Ui7yEvRB4PK0UeDytFHg8rRR4PK0UeDytDPix4WCnyeFgp8nhYKfJ4WCnyHvJC5PGwUuTxsFLk8bBS5PGwUuTxsELkDR5WijweVoo8HlaKPB5WiryHvBB5PKwUeTysFHk8rBR5PKwUeTysEHmLh5Uij4eVIo+HlSKPh5Ui7yEvRB4PK0UeDytFHg8rRR4PK0UeDytE3uFhpcjjYaXI42GlyONhpch7yAuRx8NKkcfDSpHHw0qRx8NKkcfDCpH3eFgp8nhYKfJ4WCnyeFgp8h7yQuTxsFLk8bBS5PGwUuTxsFLk8bBC5AMeVoo8HlaKPB5WijweVoq8h7wQeTysFHk8rBR5PKwUeTysFHk8rBD5iIeVIo+HlSKPh5Uij4eVIu8hL0QeDytFHg8rRR4PK0UeDytFHg8rRD7hYaXI42GlyONhpcjjYaXIe8gLkcfDSpHHw0qRx8NKkcfDSpHHwwqRz3hYKfJ4WCnyeFgp8nhYKfIe8kLk8bBS5PGwUuTxsFLk8bBS5PGwQuQLHlaKPB5WijweVoo8HlaKvIe8EHk8rBR5PKwUeTysFHk8rBR5PKwM+bjgYaXI42GlyONhpcjjYaXIe8gLkcfDSpHHw0qRx8NKkcfDSpHHwwqRN3hYKfJ4WCnyeFgp8nhYKfIe8kLk8bBS5PGwUuTxsFLk8bBS5PGwQuQtHlaKPB5WijweVoo8HlaKvIe8EHk8rBR5PKwUeTysFHk8rBR5PKwQeYeHlSKPh5Uij4eVIo+HlSLvIS9EHg8rRR4PK0UeDytFHg8rRR4PK0Te42GlyONhpcjjYaXI42GlyHvIC5HHw0qRx8NKkcfDSpHHw0qRx8MKkQ94WCnyeFgp8nhYKfJ4WCnyHvJC5PGwUuTxsFLk8bBS5PGwUuTxsELkIx5WijweVoo8HlaKPB5WiryHvBB5PKwUeTysFHk8rBR5PKwUeTysEPmEh5Uij4eVIo+HlSKPh5Ui7yEvRB4PK0UeDytFHg8rRR4PK0UeDytEPuNhpcjjYaXI42GlyONhpch7yAuRx8NKkcfDSpHHw0qRx8NKkcfDCpEveFgp8nhYKfJ4WCnyeFgp8h7yQuTxsFLk8bBS5PGwUuTxsFLk8bAy5NOCh5Uij4eVIo+HlSKPh5Ui7yEvRB4PK0UeDytFHg8rRR4PK0UeDytE3uBhpcjjYaXI42GlyONhpch7yAuRx8NKkcfDSpHHw0qRx8NKkcfDCpG3eFgp8nhYKfJ4WCnyeFgp8h7yQuTxsFLk8bBS5PGwUuTxsFLk8bBC5B0eVoo8HlaKPB5WijweVoq8h7wQeTysFHk8rBR5PKwUeTysFHk8rBB5j4eVIo+HlSKPh5Uij4eVIu8nJu/NdrQ3JX46+k5nZp9ZpzOzF6zTmdmv1enM7KnqdGb2PVU6YWZvUqczs3+o05m5x6/TmbkPr9Px0DmhQ698Rode+YwOvfIZHXrlMzr0yid0Ir3yGR165TM69MpndOiVz+h46JzQoVc+o0OvfEaHXvmMDr3yGR165RM6iV75jA698hkdeuUzOvTKZ3Q8dE7o0Cuf0aFXPqNDr3xGh175jA698gmdTK98Rode+YwOvfIZHXrlMzoeOid06JXP6NArn9GhVz6jQ698Rode+YROoVc+o0OvfEaHXvmMDr3yGR0PnRM69MpndOiVz+jQK5/RoVc+o0OvfEwnL/TKZ3Tolc/o0Cuf0aFXPqPjoXNCZ+pe2Ru30klm2aEzda9cpTN1r1ylM3WvXKUzda9cozP1+77rdKbulat0pu6Vq3Sm7pWrdDx0TujQK5/RoVc+o0OvfEaHXvmMDr3yCZ2p3ytcp0OvfEaHXvmMDr3yGR0PnRM69MpndOiVz+jQK5/RoVc+o0OvfEJn6veX1unQK5/RoVc+o0OvfEbHQ+eEDr3yGR165TM69MpndOiVz+jQK5/Qmfo9iXU69MpndOiVz+jQK5/R8dA5oUOvfEaHXvmMDr3yGR165TM69MondOZ+b1+VDr3yGR165TM69MpndDx0TujQK5/RoVc+plM6SN1jWo8OMbtnOvcZdNDtLw99l/hlBo0SSOvWwnAu5coMXCzLenRenj87fQzKaByU1Tgop3FQXuOggsZBRY2DShoHlTUOqigcVNB4RQ8ar+hB4xU9aLyiB41X9KDxih40XtGDxit60HhFDxqv6FHjFT1qvKJHjVf0qPGKHjVe0aPGK3rUeEWPGq/oUeMVPWq8oieNV/Sk8YqeNF7Rk8YretJ4RU8ar+hJ4xU9abyiJ41X9KTxip41XtGzxit61nhFzxqv6FnjFT1rvKJnjVf0rPGKnjVe0bPGK3rReEUvGq/oReMVvUhc0XPaji6L2RmU1ziooHFQUeOgksZBZY2DKuoGZZdl0TgoIzwoY3cGJXFFz9vjYq7Y5dOgvh6dt0emsns8MWV/PaP15dhbe/hx7K0uPx17n6ybabJ+psmGmSYbZ5psmmmyeabJlokma5aZJmtmmuxMHZSZqYNq9P6CTiY7Uwdlxuqg4nrsbZx2Z7ZjtVC12Y7VQ9VmO1YTVZmtHauLqs12rDaqNluJPqrYtM02pMpsz38jeJuB634GvvsZhO5nELufQep+Brn7GZTeZ+CW7mdgup9B9/fkRntFS85A/x3tdOeB2wx2r6a2pLyeZku2jxXTsNc+miWujakx5mlHirC3GcLjReX2qdd0v77ky7Gp+FWAVMpzZ+r30AT7cbA3j6naZe9Ya8o2Q7uUT0ffyRTI7JPZ360CMrf/ZyBzQMZC5oCMg8wBGQ+ZAzIBMgdkImQOyCTIHJChBz4iQw98QCbQAx+RoQc+IkMPfESGHviIjIfMARl64CMy9MBHZOiBj8jQAx+RoQc+IBPpgY/ITNsD21zWYbjnJ4k2MtP2wFUy0/bAVTIeMgdkpu2Bq2Sm7YGrZKbtgatkpu2Bq2Sm7YFrZNK0PXCVDD3wERl64CMy9MBHZDxkDsjQAx+RoQc+IkMPfESGHviIDD3wAZlMD3xEhh74iMy0PXAy2zCSW3bITNsDV8l4yByQmbYHrpKZtgeukpm2B66SmbYHrpKZtgeukSnT9sBVMtP2wFUyTXpgk/NKxvpQIRPCtmF7KOHp6GXvs2NZm/j0NNtfn3wfv+t8/L7z8YfOx/+d3syFAa8MtefHSoLMAZkMmQMyBTK7ZMyyQOaAjIHMARkLmQMyDjIHZDxkDsgEyByQoQc+IkMPfESGHviIDD3wARlDD3xEhh74iAw98BEZeuAjMh4yB2TogY/I0AMfkaEHPiIzbQ9cebLOmGl74BoZO20PXCUzbQ9cJTNtD1wlM20PXCXjIXNAZtoeuEpm2h64SmbaHrhKhh74iAw98AEZRw98RIYe+IgMPfARGXrgIzIeMgdk6IGPyNADH5GhBz4iM20PXPl1iXHT9sA1Mn7aHrhKZtoeuEpm2h64SmbaHrhKxkPmgMy0PXCVzLQ9cJXMtD1wlUyTHvjq70Bjtv5x9O7vQFNcB5KeX28c88f4S9/jD0vn4zedj/87vVmojT8mv44/lvLpW3b+Jm//9frZJj+Ojnvv4DbFbyZ2Men84GS2y0h8mmvYO9Zv5jiY5dOxdy5uVi5m+5G6SztcPFx2uQS47HKJcNnlkuCyyyXDZZdLGYnL8uBSKlyc3bod58yj23Fu13UsafMoy9OY3W4nlc065ux85di46RNd/HTsb32+9T4v9JHTx6DPt/TZ7MJNqmWH41B+QZDjUP5CkKOHYxOOQ/kXQY5D+R1BjkP5I0GOEn4qbBx/p/IPNPchFXVDSou+IRl9Q7L6huT0DcnrG9LBzT2XtA2p2FwZ0og/hT56zRNkjl7zBJmj1zxB5ug1T5A5es0TZI5e8wSZo9c8QeboNU+QOXrNE2QyPfARGXrgIzL0wEdk6IGPyNADH5Ap9MBHZOiBj8jQAx+RoQc+IuMhc0CGHviIDD3wEZlpe+Daz+fLtD1wlcy0PXCFjF2m7YGrZKbtgatkpu2Bq2Sm7YGrZDxkDshM2wNXyUzbA1fJ0AMfkaEHPiJDD3xAxtADH5GhBz4iQw98RIYe+IiMh8wBGXrgIzL0wEdk6IGPyEzbA1c217Jm2h64RsZO2wNXyUzbA1fJTNsDV8lM2wNXyXjIHJCZtgeukpm2B66SmbYHrpJp0gNf3QYzlKff0+5vgxnL2sSnp9maj5/JW1v6Hr9bOh+/6Xz83+nNvB3wylB5fsw6B5kDMh4yB2QCZA7IRMgckEmQOSCTIXNApkBmn4xfIHNAxkDmgAw98BEZeuAjMh4yB2TogY/I0AMfkaEHPiJDD3xEhh74gEygBz4iQw98RIYe+IgMPfARGT8rmdqTdWHaHrhKZtoeuEpm2h64SmbaHrhKZtoeuEYmTtsDV8lM2wNXyUzbA1fJTNsDV8l4yByQoQc+IkMPfESGHviIDD3wERl64AMyiR74iAw98BEZeuAjMvTAR2T8rGRqvy5J0/bAVTLT9sBVMtP2wFUy0/bAVTLT9sA1MnnaHrhKZtoeuEpm2h64SmbaHrhKxrcgc/V3oDFb/zh693egaXvfdkqPn6P+ei3vffyh8/HHzsefOh//bm/mlmVZ/25u/3a+Mn4tr703j9feP81197X3fjPHwSyfjr1zKbNyMduP1F36ymX/nVpw2X+jFlz236cFl/23acFl/11acNl/k1avXJYHl1Lh4uzW7ThnHhN0btd1LGnzKMvTmN1uJ5XNOub8hG7/2LjpE138dOxdn4g+qvVJAvqETZ/f7vRcn2LXyd7+7R4m4OYlPqaQ+59C6X0Kbln6n4Lpfwq2/ym4/qfgdU/Bp7IOxGeXdyYQep9A7H0Cyu/L9QkovyvXJ6D8nlydgFF+R65P4Oh+nB4TMO5Thnw/z148z108z188L1w8L148L108L1887+gvKIXHecF/Oc8uF8/b1c+4vKxrDsaV+LRp6LLsGje3Tcs9Lw0sYe/oYtcPdyU8BRTLXsmHtKyrDrd/PkYS4scMvP4Z2McMbPo6g9D9DGL3M0jdzyB3P4OifwY+bjN4vprGvRu73wZivfdfpru/7fW40zVzTdfONd0O+oiW0/VzTbeDDqXldDtoZ1pOt4Pe50fTtfkx3a+GwXXQKLWc7mhd1fl0/WBdVQjbBlwhuvOD4y2n+jg4LubrH7ofrAX7CZtQUjllM1i/Fozb2CRzfnDe0s3sn+JKv3ygGay3a4nGg+YIzWA9Y0s0g/WXLdEM1os2RBNG62x+giasyxg5xU9o9hbU3PZ7CRMeH/zrlxNfD85rC3FbH3k+9I58tIapA+Qz92FCyGfu74SQe5C/G/nM/agQ8pn7XCHkM/fPQsgHy5N7QD5Ypt0B8oj7fDty3OfbkeM+344c9/lu5Ikq/x7ypdgN+dOjx7vIc14HUYytfLC5fff6ybd/p6dtitYH+RN/Fvo18mikXiNiH/0akRPp14hgSb9GJFH6NSK6Uq9RJuvSrxHhmH6NyBn0a0TOoF8jj0bqNSJn0K8ROYN+jcgZ9GtEzqBfI3IG9RoVcgb9GpEz6NeInEG/RuQM+jXyaKReI3IG/RqRM+jXiJxBv0bkDPo1ImfQrpFfyBn0a0TOoF8jcgb9GpEz6NfIo5F6jcgZ9GtEzqBfI3IG/RqRM+jXiJxBvUaGnEG/RuQM+jUiZ9CvETmDfo08GqnXiJxBv0bkDPo1ImfQrxE5g36NyBnUa2TJGfRrRM6gXyNyBv0akTPo18ijkXqNyBn0a0TOoF8jcgb9GpEz6NeInEG9Ro6cQb9G5Az6NSJn0K8ROYN6jfzIf0f5/OAU12NT+kT9Tmbk6v1zZDxkDsj0kAiZB5nKZM8++j7fHtKVlvPtIaloOd8eXH/L+fbgoBvON/TgRlvOtwdn9/35+sWVj4P9Ukrlo53fmkHn89Oww8fdK/TQC8rR6aEflKPjoXNCZ6y+sDWdsbrI1nTG6jlb0xmrQ21NZ6x+tjGdLt4/L0eHXvmMzjy98n2+83S/9/n6yeY7T4d6n+88Ped9vvN0kff5DtYXmm1BwzvjKx+dF/9xcHYPNja7nWNLXj+4lM/H3jkO1kFKcUyD9ZpiHAfrSsU4Dta/inEcrC8W4+jh2ITjYH28GMfB/IEYx8F8hxhH/EwbjviZJhwzfqYNR/xMG45+MI5mXX/wxu7kW128G77lfEfrx2rzHa1vqs13tP6mNt/R+pDKfLt4L3XL+Y52X6/Nd7Q8sTbf0XK/2nz9ZPOdrL/q4v2yLec7WX/VxXtPW853rv4qdPE+zpbznau/Cl28J7LlfOfqr8LiJ5vvXP1V6OK9ei3nO1d/Fbp431vL+U7WX3XxHrKW852sv+ri/Vgt5ztZf9XFe5tazney/qqL9wm1nO9k/VUX77lpOd/J+qsu3r/Scr6T9VddvBek5Xwn66+6eF9Fy/lO1l918R6FlvOdrL/qYn//lvOdrL/qYt/5lvOdrL/qYj/0lvOdrL9yfrL5TtZfucn6KzdZf+Um66/cZP2Vn6y/8pP1V128J6PlfCfrr7p4p0XL+U7WXw32por6fCfrrwZ7U0V9vpP1V4O9qaI+38n6q9HePVGd72T91Wjvh6jOd7L+arR3OFTnO1l/Ndp7Fqrznay/Gu1dCNX5TtZfjfa+gup8J+uvRntfQXW+k/VXo72voDrfyfqr4d5XUJvvZP3VcPv/1+Y7WX813H76tflO1l8Ntz99bb6T9VfD7fdem+9k/dVw+6fX5jtZfzXcfuS1+U7WX+XJ+qs8WX812f7tYbL928Nk+7eHyfZvD5Pt3x4m2789TLZ/e5hs//Yw2f7tYbL928Nk+7eH4fZvf9l7leJ67A2B/XTwHSQvQmwEkjchNgLJqxAbgeRdiE1AxuE23xcDOc9bye/zneft4ff5+snmO08Xep/vPM3ifb7z9HT3+c7Tet3nO0+H9Hu+w+1yX5vvPG9fvs93sv5quF3ua/P1k813sv5quF3ua/OdrL8abpf72nwn66+G2+W+Nt/J+qvhdrmvzXey/mq4Xe5r852svxpul/vafCfrr4bb5b4238n6q+F2ua/Nd7L+arhd7mvznay/Gm6X+9p8J+uvhtvlvjbfyfqr4Xa5r813sv5quF3ua/OdrL8abpf72nwn66+G2+W+Nt/J+qvhdrmvzXey/mq4Xe5r852svxpul/vafCfrr4bb5b4238n6q+F2ua/Nd7L+arhd7mvznay/Gm6X+9p8J+uvhtvlvjbfyfqr4Xa5r813sv5quF3ua/OdrL8abpf72nwn66+G2+W+Nt/J+qvhdrmvzXey/mq4Xe5r852svxpul/vafCfrr4bb5b4238n6q+F2ua/Nd7L+arhd7mvznay/Gm6X+9p8J+uvhtvlvjbfyfqr4Xa5r813sv5quF3ua/OdrL8abpf72nwn66+G2+W+Nt/J+qvhdrmvzXey/mqizejv852sv5poa/f7fOfqr9JEG6Xf5ztXf5Um2789TbZ/e1r8ZPMdrL+KrqzzzYurfPSPXuyQ1xmW8vnYO8fB+jYxjoP1g2IcB+szX8fx/IUtabQN8sVAjrbzvhzIwVpuOZCD9fJyIAczCXIg/Vgg8/bRPvsayBTdx8EpPabo7QeawYxKSzSDeY+WaAazEydo7vMdrO2vznew7rw238FerxCMD+vBJu7EU4O9XqE+37Fa0vp8x+oc6/P1k813rK6tPt+xWrH6fMfqr+rzHau/qs93rP7qeb7W2K/zHez1CvX5jttf7c933P5qf77j9lf78/WTzXew/uoW2GwH57Iz38H6q+p8B+uvqvMdrL+qznew/qo238Fer1Cf72D9VXW+g/VX1fkO1l9V5+snm+9k/dVgr1eoz3ey/mqw1yuE7Jb14BJz5aN92eA8Pwqd7c6xv570/zj416rMdnT84DhY3ybFcbDXQchxHKzPbMTxzmawnrQpm8H616ZsPGwO2QzWFzdlM1gP3ZTNYP32j9jcIvz1YJ932Mzcm9fYzNxvV9gM9sqPtmxm7otrbGbui2tsZu6La2w8bA7ZzNwX19jM3BeHsPXFeacvHuw1KW3ZTN0XV9hM3RefsxnsVS1t2UzdF1fYTN0XV9hM3RdX2HjYHLKZui+usKEvPmYzT198n+88ve59vvP0r7/nO9jrberznafPvM93nt7xPt+x+sG4LOtAootmZ75+svmO1bfV5ztWL1af71j9VX2+Y/VX9fmO1V9V5zvY623q8x2rv6rPd6z+qj7fyfqrwV5vU5/vZP3VYK+3qc93sv5qsNfb1Oc7V3+VB3u9TX2+c/VXebDX29TnO1d/lRc/2Xzn6q/yYK+hqc93rv4qD/Zal/p8J+uvBntJSn2+k/VXg71ypD7fyfqrwV7gUZ/vZP3VYK/aqM93sv5qsPdn1Oc7WX812Psz6vOdrL8a7P0Z9flO1l8N9v6M+nwn668Ge39Gfb6T9VeDvT+jPt/J+qvB3p9Rn+9k/dVg78+oz3ey/mqw92fU5ztZfzXY+zPq852svxrs/Rn1+U7WXw32/oz6fCfrrwZ7f0Z9vpP1V4O9P6M+38n6q8Hen1Gf72T91WDvz6jPd7L+arD3UdTnO1l/Ndi7IOrznay/GuydDfX5TtZfDfZuhfp8J+uvBnsHQn2+k/VXg72roD7fyfqrwd4pUJ/vZP3VYHv/1+c7WX812B799flO1l8Ntpd+fb6T9VeD7Xlfn+9k/dVge9PX5ztZfzXYHvL1+U7WXw2213t9vpP1V4Pt316f72T91WD7t9fnO1l/Ndj+7fX5TtZfTbZ/e55s//Y82f7tebL92/Nk+7fnyfZvz5Pt354n2789T7Z/e55s//Y82f7tebL92/Nk+7fnyfZvz5Pt354n27+9TLZ/e5ls//Yy2f7tZbL928vix5qvz+vBMRi7M9/B+iuXNn1vJ1Y+Oi/+4+DsynaszW7n2JLXDy7l87F3joP1bWIcB+sHxTgO1meKcRysf5XiONq++2IcB+u3xTgO1seLcRzMH4hx9HBswhE/04YjfqYNR/xMG474mTYc8TNNOI72ngsxjviZb3KM67E3BHYHJIamEUgcTSOQHpBtQOJpGoHE1DQCOVgXGXJZQUZTA2nCbVV8nWa4JWDb8fFOZ7R3OJzQuc93sDtmdb5j3dhSSuvBKT316PsfbVMMH0fblNzzR9/hjHWzagxnrBtQYzhjRWWN4YyVfzWGM1Y70hbOYG+0aAxnrPipMZyx+tifwil2hZOfusANzlhNb2M4HjjHcGbukJ1dVnPlrE1f4czcIVfhzNwhV+HM3CFX4czcId/gLGdwBntnxQ/heLMe7bxdvsKZuc+pwvHAOYYzdZ9TgzN1n+NK3uCY5fyjQ0nrrS2UsnP1nrop+gnJuGz3wbjsGJPB3g3ynprcJzl1u+Xd1ov6YP7cX/dg7zN5D8ndmhzsTSk/Jbk9KuF8yV/hzG0BKnDmtgAVOB44x3DmtgAPOOHpKaoNztQWoAZn6q6+BmfqRr0GZ+re2z0GEkw6/2gT8+oHTfJPm8P45Y5ysJe//BBl2rbOcam4P2djBnutzAtJ1kKKwV5Y856a3Cfppya5fbT7wyL9zoVyKdsD38YtOxfKqfvcbP2GslQ+2m9EvP18x9nB/ojkzC1O3452G/apO2g57FP35nLYp+765bBP7SfEsA/2IqhusE9t+eSwT+0Pf4TdrfbQP89wAzm1PWwJcrAfnbf9ie9or8FqTGewTa8a0xlsK6vGdNha4ITOaK/vakxnsM2kGtOZZ1uKK3Tm2cTiCh0/Nx3nH3SCfaKzf7R9Ojp+YTl5Z92U5eR9eFOWk3ftP2DpzZbnePv0mMVKcvIOvyHJyd1AK5JuGe3FdIIkJ3cZDUlO7kgakpzcvTQk6SHZiCQ+pxVJXE4rknicViTxOK1Izu5xjlKJnc/O2y8Wknv6kfbBZ98WIj+OvmF/etnvTa/f5Ed7KWFH5Gf3UG3I31nO7qJaspzdR50kxDc6bfpQs72JwFlbKnRMXtZNSk02zyzLLp3lQWeJz3TuM0j6Z2AfM/iyWdltBrn7GZTeZ9Do5V+SMzDdz8Dqn4GPjyt15Sdm1m+3DOu9/zpdN9d0/VzTDXNNt4M+ouV0O2g6Wk63gw6l5XQ7aGcaTtd10Pv8aLo2P6b71TC4DhqlltMdrauqTHewriqEtWe2If6pjTZubPy8bM63zrixGaxfC8ZtbFJln8m8rB+c/dOY778bu6EZrLdriWawPrAlmsF6xpZoBusvG6Lxg/WiLdGM1tn8BE1Yh5FT/IRm54ONe6xUPm2x/Gs7vK8HP3bfWj4dekfuQf5u5DP3YULIZ+7vhJDP3DcKIZ+5H5VBHmdu5n6CfHm8XtI8PeKwizzndRDFVDcpun339vhHTulxvC35Q6PB0tAhNRoswh1SI9yZfo08GqnXCP+nXyMMo36NcJj6NcKS6tdo5rWaTjRK5Az6NSJn0K8ROYN+jcgZ9Gvk0Ui9RuQM+jUiZ9CvETmDfo3IGfRrRM6gXqNMzqBfI3IG/RqRM+jXiJxBv0YejdRrRM6gXyNyBv0akTPo14icQb9G5AzqNSrkDPo1ImfQrxE5g36NyBn0a+TRSL1G5Az6NSJn0K8ROYN+jcgZ9GtEzqBdI7OQM+jXiJxBv0bkDPo1ImfQr5FHI/UakTPo14icQb9G5Az6NSJn0K8ROYN6jQw5g36NyBn0a0TOoF8jcgb9Gnk0Uq8ROYN+jcgZ9GtEzqBfI3IG/RqRM6jXyJIz6NeInEG/RuQM+jUiZ9CvkUcj9RqRM+jXiJxBv0bkDPo1ImfQrxE5g3qNHDmDfo3IGfRrRM6gXyNyBv0aeTRSrxE5g36NyBn0a0TOoF8jcgb9GpEzqNfIkzPo14icQb9G5Az6NSJn0K+RRyP1GpEz6NeInEG/RuQM+jUiZ9CvETmDeo0COYN+jcgZ9GtEzqBfI3IG/Rp5NFKvETmDfo3IGfRrRM6gXyNyBv0akTOo1yiSM+jXiJxBv0bkDPo1ImfQr5FHI/UakTPo14icQb9G5Az6NSJn0K8ROYN6jRI5g36NyBn0a0TOoF8jcgb9Gnk0Uq8ROYN+jcgZ9GtEzqBfI3IG/RqRM6jXKJMz6NeInEG/RuQM+jUiZ9CvkUcj9RqRM+jXiJxBv0bkDPo1ImfQrxE5g3qNCjmDfo3IGfRrRM6gXyNyBv0aeTRSrxE5g36NyBn0a0TOoF8jcgb9GpEzaNfILuQM+jUiZ9CvETmDfo3IGfRr5NFIvUbkDPo1ImfQrxE5g36NyBn0a0TOoF4jQ86gXyNyBv0akTPo14icQb9GHo3Ua0TOoF8jcgb9GpEz6NeInEG/RuQM6jWy5Az6NSJn0K8ROYN+jcgZ9Gvk0Ui9RuQM+jUiZ9CvETmDfo3IGfRrRM6gXiNHzqBfI3IG/RqRM+jXiJxBv0YejdRrRM6gXyNyBv0akTPo14icQb9G5AzqNfLkDPo1ImfQrxE5g36NyBn0a+TRSL1G5Az6NSJn0K8ROYN+jcgZ9GtEzqBeo0DOoF8jcgb9GpEz6NeInEG/Rh6N1GtEzqBfI3IG/RqRM+jXiJxBv0bkDOo1iuQM+jUiZ9CvETmDfo3IGfRr5NFIvUbkDPo1ImfQrxE5g36NyBn0a0TOoF6jRM6gXyNyBv0akTPo14icQb9GHo3Ua0TOoF8jcgb9GpEz6NeInEG/RuQM6jXK5Az6NSJn0K8ROYN+jcgZ9Gvk0Ui9RuQM+jUiZ9CvETmDfo3IGfRrRM6gXqNCzqBfI3IG/RqRM+jXiJxBv0YejdRrRM6gXyNyBv0akTPo14icQb9G5AzaNXILOYN+jcgZ9GtEzqBfI3IG/Rp5NFKvETmDfo3IGfRrRM6gXyNyBv0akTOo18iQM+jXiJxBv0bkDPo1ImfQr5FHI/UakTPo14icQb9G5Az6NSJn0K8ROYN6jSw5g36NyBn0a0TOoF8jcgb9Gnk0Uq8ROYN+jcgZ9GtEzqBfI3IG/RqRM6jXyJEz6NeInEG/RuQM+jUiZ9CvkUcj9RqRM+jXiJxBv0bkDPo1ImfQrxE5g3qNPDmDfo3IGfRrRM6gXyNyBv0aeTRSrxE5g36NyBn0a0TOoF8jcgb9GpEzqNcokDPo14icQb9G5Az6NSJn0K+RRyP1GpEz6NeInEG/RuQM+jUiZ9CvETmDeo0iOYN+jcgZ9GtEzqBfI3IG/Rp5NFKvETmDfo3IGfRrRM6gXyNyBv0akTOo1yiRM+jXiJxBv0bkDPo1ImfQr5FHI/UakTPo14icQb9G5Az6NSJn0K8ROYN6jTI5g36NyBn0a0TOoF8jcgb9Gnk0Uq8ROYN+jcgZ9GtEzqBfI3IG/RqRM6jXqJAz6NeInEG/RuQM+jUiZ9CvkUcj9RqRM+jXiJxBv0bkDPo1ImfQrxE5g3aN/ELOoF8jcgb9GpEz6NeInEG/Rh6N1GtEzqBfI3IG/RqRM+jXiJxBv0bkDOo1MuQM+jUiZ9CvETmDfo3IGfRr5NFIvUbkDPo1ImfQrxE5g3qN7MgeNp8fnOJ6bEqfqP8m40Z2jn+OzMh+7c+R6cElmQeZymTPPvo+3x4cR8v5+snm20Mn3HK+PXSVLefbQ4fWcr49rKr8ZL5hvc2ZYl3lo40vZT06PPWCt4++w+mhFZSC43voBsXg9NAQvgqOzWlrH3MplaPdzXmtk3Tm0ZmuJEdrIOVIjtaaypH0kPwuSRfLRjKnJ5Jfj/Vmo+6tSV+oj9Z690F9NAPwM+rbLG0xS+XovM0xu8cUbXY7x5a8DqOUz8feqY9mQ/qgPrMZkqM+s8sSox5mtm9y1Of2hVLU5/aQUtTn9ptS1D3UBajP7U2lqONNJajjTSWo400lqONNBahHvOlLqMf12Bswu4MdcyqCHXcqgh17KoLdg10COwZVBPvUDrU8VqGXKnbj08YymKfPznsjicu6aB3tE74cPrhP7VEFuU/tUgW5T+1T5binqZ2qIPepraogdw/313D368ExmB3u9DMv4r79HDjGvMOdfubb3IPZhh2c/8T9zpIepRnLLl5+3gtLeol2LKfOsn94n9oGcmMZKvep29dn/xhK+fKcfhevCB+TvIe8EPmpQ21R8uTaUuRndoJucWkjX2oDqfyyrYsXZPdBcmZn15RkFy+b1kHSmBg2KCY+bT9nzN42cZXfdHfxCukxyc/sGWXJz+wZX0y+3S/wu3jhMyrN7EV/qlKy24ebsriKSjal7fGt9LQd5Up+Zi8qSx4vKkUe7/oq8k2fl+jixcvoFLp4+TI6hS5ewIxOoYuXMKNT6OJFzOgUuniJ7BQ6nT6nGbp4AeYUOp0+1xm6eAlmpzpVnhELXbzcclT29GVy7Om15Nh72L/svtzy+abQxasmUeqXUniSXpRinaYXpVjX6UUpnP63lbJL2NDb24wrStmbsh+HW5OfoOS8d3RatqOTtX/UyeL0+9CJVKAPnUgQJHS6sydBkGPvYS/GnkxAjj0uX449vl2OPU78Zezt9rCDvf17hz3eWoy9wy/Lsae/l2NPn/My9sEvK/sQ9tjT58ixp89pw/5Ok86lIU1PL9KSJgn792laUzaa9vm6eeF39sGTmUuRp6OWIu8h/yryzXYtCJ5kvQeV8KYXVYpmpw/CbbakiX9sSRP/+H2aLueNpvfVHTWi3RLA6J6OLvd3dd3SEdi/hX3aYY83fQt7b3fY405fx34bi40xfGK/N5a4bGOJTwiL2Z1n2gKfnF3l6GzXaWZvPh17rwF8MjXgqYHpa4A8gBogbaAGyEioAZIdaoA8avoaiORiE9RAWB+HzyHt1AD53AQ14LfrwBPARw2QE05VA9Ht1AD5QI81YINbodhb3r+jK56/T10fbwmIJuzoio8fU1e8+Zi64reH1DXhocfUFV88pq543TF1xed0mWGUx4OzZS+jTvicMXXF54ypKz5nSF0zPmdMXfE5Y+qKzxlTV/omJbpaHzaEOVR0dTG79eiYy46u9E1D6lrom8bUlb5pTF3pm3rU1bvttaDe5Z3nmwq/g+xS17Ll/r7knWcXi0fXvnUNy7J3HeZ5xDF1ZZ1uTF1ZpxtTV/KmMXUlbxpR17iQN42pK3nTmLqSN42pK3nTmLp6dB1SV/KmMXUlbxpTV/KmMXUlbxpTV/KmIXU15E1j6kreNKau5E1j6kreNKauHl2H1JW8aUxdyZvG1JW8aUhdLT5Hia5me5uVM6H6Ow636ercznPh0eJzute1uB1d8Tlj6urRdUhd8Tlj6orPGVNXfM6YurKuPqaurKsPqatjXX1MXcmbxtSVvGlMXcmbxtTVo+uQupI3jakredOYupI3jakredOYupI3DamrJ28aU1fypjF1JW8aU1fypjF19eg6pK7kTWPqis95i67JVnRNcd2wP6UHbm/vMgVsSxcy4UK6kAlT8TKZUloPt3lxFZmKyyvC4pf0ODrv3styedzLng5Oe+Mo2WyzXOz5wcYsaRPHfIKSPyoGuyJRMXf2HvavYp9t2diHZYc9y1avYx/9xv4Z4co+cpf6PvvgtnHbkEyFfUnrW5TMYp5uDreB39Fzuf8++riYDX16Hvgu+ttHbjdm++x2D7q+vL5V9PbZpXa0MdutxPhUOTqXFUoxO5e+yG2HGiD1ogZ4Imv8GijFbQ3Bkj8VwdeDY9lmGYupuNZ8awU/Ds422i/OMtJhU14vLC+eT6O8XlheLB9RXq8rr8SyF+X1wvJiuY7yemF5EeBSXi8sL0JqyuuF5eUpr5nL614EBOAUQSIBpwgSOfX4RWAWu2xV4JdKu2FK3B54KWWYZ/0yodMEle6ye6hpv17vMtkQVRAzEc5sVVB2qoCkhSqI2VMFVEEmEaEKYiYSoTuMmUyEKoiZR+yogph5Eo4quC3AUgVUQSE7pApiITukCmIhO6QKYiE1ogpiITXqsgrssu2SYu3nKrjrSg40pq4kO2PqSlYzoq5pIX0ZU1fylDF1JSHpU1cfNl3TsqMrmceYunp0HVJX/OuQuhr64T513X7PYt0fRnLXlX64S11d2P5eP72MY9OVfnhMXemHx9TVo+uQurJaO6aurL+OqSv+dUxdWX8dU1fWX7vU1bv1+Sbrs6scHf36jpUYH2s/t8X3nWNzWJHkXD4d+7teLDkW9fKTeiEfo15+Ui/kbtTL87Hl8Sa3xZTKweFWHKs2JvvK0TG6ZRuHMzvFSFhIMaopRk8xUoxaipFYlmJUU4xkyRSjmmIkAKcY1RQjqT3FqKYYWWqgGLUUo2Mdg2JUU4wsklCMaoqRFRiKUU0xsgJDMaopRk8xUoxaipEVGIpRTTGyAkMxqilGVmAoRjXFyAoMxaimGFmBoRjfVIy3FZa1Sm6RYvxajJ4VGIpRTTGyAkMxqilGTzFSjO8qxhy2YnzC/ShGoh2K8V3F6O12ZbyNf6cYMTAUo5ZiDDwoQTG+qxhzWIGkHPeKkQclKMbrxei37eGDN8tOeXnKi/J6XXnxMAPl9cLywsNSXtfLK20RScjLzrJa4IEDyuuF5cUjBJTXnyivuGzlZWs+07jFbuq45Q9Ocw/4Q/rbv6OpHR/CxtCEuOzcrCNOlnLXW+7bLH+Ve200xuewDd7ntLO+kkgRKfe3lbux24c7E3auvomrL+WoqBw95Ug56ilHckrKUVE5kmtSjn+iHJ+1STvlRa5Jeb2wvMg1Ka8XlhfPClJeryuvzM+XKK8Xlhc/SKK8XlherDpQXi8sL3Iyyut6eZXtHWGh5LBTXuRelNcLy4vci/J6YXmRe1Fel8srLtvjotGYvd6L3Ivyel15FXIvyuuF5UXuRXm9sLzIvSivF5YXT89SXi8sL095UV6vKy9Se8rrZeWVF3ovyut6eRmftvLa2QEpL/RelNcLy8tTXpTX68qL3ovyemF58cQE5fXC8uKJCcrrheXFExOU158or+3oaP/wM9qvR2fr1yrJNtrHoPNHLfJ4BbWopBYNz2JQi1pqkQc3qEUttchKA7WopRZZlqAWtdSipxapxffUoolhe8HN7d9P1bjFOoY1D8pRUTmyRkI5KipH1lQoR0XlyBoM5fi+ckzmUY55pxwtcSPl+LZyjNlv5ZiWnWebLYkj5fi2ckz2cbNOPu6UI6Ej5aioHD3lSDnqKUdyR8pRUTmSO1KOisqR3JFyVFSO5I6Uo6Jy5PFvyvF95ZjjoxyfgG/l6HgCnHJUVI6sylCOisqRVRnK8W3lmJdlK8dszE45sipDOSoqR085Uo56ypFVGcrxfb3j0wNm2dja8fYh/e3f0dSODyFvQVIIpeyUO6s+lPtE5c6qEuU+UbmzakW5T1TurIpR7vOUu2fVjXKfqNxZ1aPcJyp3Vg0p94nKnVVJyn2gct+WmUJclp1y95Q75a623LdZ/ir32miMzw+B/B8//17uJDOU+zjlHvKj3NPOE3+BZIZyn6jcSWYo94nKnWSGcp+o3HkiknJ/X7mHp1/TxL1y5IlFylFROfJEIeWoqBx54o9yVFSO5L6Uo55yjOSylKOiciQ3pRwVlSO5JuWoqBx5IoxyfFs55o337d9h590K0VOOlKOecmRVhnJUVI6sylCOisqRVRnKUVE5EoNTjm8rx/L4sUos0X8tx0QMTjkqKkeCHsrxfeUYHzfrkspOOfIIBeX4rnJM1mzvdL39O3wtx8wiIeX4vnIM7lGOeeeHy5lFQsrxejnakLZyzOlPHH0vRjpHilFNMXqKkWJ8TzGaHB8/87r9e8dVZxYIKUdF5cgCIeWoqBxZIKQcFZUjmSPlqKgcWa+mHPWUY2G9mnJUVI6syFCOisqRFRnKUVE5siZDOb6tHJN5CJ/Czvtci6ccKUc95ciqDOWoqBxZlaEcFZUjqzKUo6JyZFWGclRUjqzKUI5qyrEsrMpQjorKkVUZylFROXrKkXJ8VznmZXu9as5m2SlHnDXl+LZyLE9Xx+L2ro44ayXlmLzfytF/PvquFKazE6UMfqwXpbAqvSjFs1W9KMVjR70o5VFKiVLpYUWS2VGKh1V6UYrnOHpRiiCmF6XIKHpRioyiE6UsfkqLUuXRpZe4oxS9nxKlsl+TepuD21GK3q8Xpej92ih1p0l/1pImPVRDmo61mJY0WS9pSZMevCVN1h2+T/N2l9lolpIq/VRcHltXPwHM4YO8h7wQebyhFHm8nhR5vJsUeXyeEHlP3/0y8ttDEvHp1wMP8h7yryIfHw9J5x3y9DbfJu9cshsUH2yFvLkNZts8yuT0+JlC3F2hWNYPt8nap2PvOtEJ9aETfVMfOtFlSeh0Z0/2LsY+kNTLscdfyLFnFUCOPWsGcuw97F/HfvttszFlMaf9aDFpHXkxT78pXnXCh/ehEz68D53wGF3oFOnLlOhkt7ykWJu/6EQP14dOHp260Il+r41Od5p0ZS1psobRkiYrDS1p0tc3pJlYDWhJk3z/+zSDedAMT7nlgybOsCVN/FtLmh6aDWnihVrSxAu1pIkXakkTL9SSJl6oIc2MF2pJEy/UkiZeqCVNvND3acayrXm4ZD7T3Pl0W9afWDlnHq/L/lj1yB7yQuTxWFLk8WMvI387fiP/6dmSr8d6s6nkrfnyHErG5/WgEv7xokp2rw/CP/6AZi5PNONXmgX/+H2ayZkHzWD+3B224DWlyONLpcjjYV9Gvl2/UjwqdaAS3viiSnFnz/OC3/1JV5mfaO48U1Twpd+m6Ze0jdsb/yd3gyp4TSny+FIR8n5Z8LBS5PGwUuTxsFLk6btfRv5sv8UbeXqbl5E/22/xRp7e5vvkndtWMLz7w1ubvh5vU1o//fbPP/zi0i+8L1yMPL2NFHl6m1eRNym6bZ4p+q/sSejl2HvYi7Gnq5djT/Yux57O/nXs02OXw9u/yx/Z857dV7JP+cE+xy/s6XO+z94/WPpg/Sf2d5oemg1p0ou0pEl30ZImK/staZJot6RJL9uQJm9HbkqTNLklTZzT92lGv/0GxMfsPtH86fF3+ngnSfoe+oL08Wavon8DsQ7cuuXpiYVcPtjj5OTY4/vk2OMS5djjKd/C3tiv7D0OVI49flWOPe72ZezdFi1YV8In9jtHn72N96YTPrgPnTw6daET3lpCpzt7vLUce7y1HHu8tRx7vLUY+4C3lmOPt34Z++DXadrwvM/Lxh5vLccevyzH3sNejD39vRj7SJ/zKva39TK7ffrz0Rt7+hw59lP3Oc5v7F2KlaNLXOd4g/AIJe0N6x3l1G1LW5QelK1QTh2W/wjl0y7oLrknQ27MB8upw+/GLKdudhuznDqcbsxy6rC5Lcu5X8DemOXUJqkxS0xPO5a4nnYsPSybscT3tGOJ72nHEt/TjiW+px1LfE8zlnO/bL0xS3xPO5b4nnYs8T3tWHpYNmOJ72nHEt/TjiW+px1LfM93Wf7aqf7jaG+832GJ72nGcu6XhDdmie/5NkuTysayLJ9Y7nz22aunb9zxSDLc8VMy3D3cX8O91Su8bxrh6fRrhFf8tkbWbb2PfXqt175GPpf1s32xtnJ0SOtHh/KEL3+IhAntQCTcbQciYZvVi2TmfuF5LyJh9F8kUgkPkWL5ErGYud+NLkoes/8q8mW71izW75D3kH8VebuR93mHPCb+ZeS3YS8h7pDHmkuRx29LkcdEf5u823Yb9e4PLH929J08zliIvMHuSpHHw76GvPFp294hmOf9W/bGHZd1hSLap0/O4UMl/G4PKuGNe1DJo1IHKuG5e1AJf96DSvgaFSr59eAYzFeVLD2eCpXi+tEx5h2V6PFepFIw2ySD859UupP3kBciTy8mRZ7+Soo86x+vuhtvw76RD5W78W2w2T8GXv748K6xrJb0oRMepAudHCsxfejEuk0fOs3t6vN6tPM2fDr6TmdqZ5G3Zy1dWfwOnZl7G2+2o70p8Sudqd9ffrtIbc8cJbPs0Jn5ulOnM3OKV6fjZ6aTHk/z5WWpHJ23OWb3mOKvV3h8PbZsN8NSPh97pz7zvVCO+swJmxz1mdM1OepT95Ni1GdOvsSoT/32aznqU3syMepTez0x6lN7SDHqHuoC1PGmEtTxphLU8aYS1PGmL6F+/o5hEzCnEtgj7lQEO/ZUBDv+VAQ7BlUE+9ReqfbURpza01TpTO09qnSm9gh2m6W3Pu/QmbqVr9GZ+oX2dTpTN8ZVOlP3r1U6U7eZVTp+ZjourMP2/qlX3j86xm0Xg/xo2K392Klq6tfCtyU5dQ/elOTU/frJc8Q7tnnbd92Y8vTRYUU5dXPfFOXcLzGv/apm7teSV+lM/Xu1Kp2pd38p254Jt0nWjr5d0D8Otsvj2P1IteE68twvJO9Coal/89mFQlPvOqNDocoi09zvZO9Doql3pulDoqk3pelCorlfTN+HRFMb6j4kmtrVl23/V298LVyzya27Bdn0/BrqJe2KFNbg7sbSfzr6Tn7uxECSvIe8EPm5Hf4LyZttC/FsTdwhP7dzlyQ/tyGXJD+3z5YkP7d9liNv5349vCj5uc2uJHk8rBR5PKwUeQ95IfJ4WCnyeFgp8nhYKfJ4WCnyeFgh8nO/812UPB5WijweVoo8HlaKvIe8EHk8rBR5PKwUeTzsi8jHbZI5ZbtDHg8rRR4PK0Te4mFfRP5GbSVfstkhj4eVIo+HlSKPh5Ui7yEvRB4PK0UeDytFHg8rRR4PK0UeDytE3uFhpcjjYaXI42FfQ74sdvk4uiwu7JDHw0qR95AXIo+HlSKPh5Uij4eVIo+HlSKPhxUi7/GwUuTxsK8in8pK/vfnfSGPh5Uij4eVIu8hL0QeDytFHg8rRR4PK0UeDytFHg8rRD7gYaXI42G/S9493tHrbI4V8iY9RpKifx72HTwWVgg8DlYIvAe8DHj8qxB47KsQeNyrEHjMqxB4vOuLwJeyHm2XpTLsuCzrkmFczFeVIj5XgUqhbKZ4XyU88atU2t4xaxdnz4ftN9rePv383C+7V8diHpfHYh/DtiV/iIrfHlBUvPyAonpEHU9UMogBRSXfGFBUspMBRSWXGVBUMp/xRE1ERAOKSqI0oKgkSgOKSqI0oKgeUccTlURpQFFJlAYUlURpQFFJlAYUlURpPFEzidKAopIoDSgqidKAopIoDSiqR9TxRCVRGlBUEqUBRSVRGlBUEqUBRSVRGk/UQqI0oKgkSgOKSqI0oKgkSgOK6hF1PFFJlAYUlURpQFFJlAYUlURpQFFJlIYT1S0kSgOKSqI0oKgkSgOKSqI0oKgeUccTlURpQFFJlAYUlURpQFFJlAYUlURpPFENidKAopIoDSgqidKAopIoDSiqR9TxRCVRGlBUEqUBRSVRGlBUEqUBRSVRGk9US6I0oKgkShpEdetrE33Kn0S9i0RC1IFIJD6vEcmabZLWPI3k43WVznrAy4AnORECT7ohBJ4E4lXgndvAl9KwBXYlr1P0xmxHu+22Tf4wnKSkD6NJ6sgehpOU5GE4SckphpOUVGM4ST2SjiYpSYwGSc8DYkdq04FIU8cBLm/YvQ2fjr7TmdpZ1+j4qU1qlc7Ufs+7B50UK0ebtN7ub6uS27E2u51j88Yju1I5tmwSlfL52LtCU9u3LhSa2o11oZBHIWmF4nrsDa7dkWhqs9SHRFNbpT4kmnopvA+JpvayfUg0taHuQqIwtas/kehOB1d/RgdHfUZnbjeb11m67E3t4mfzdpW6LeA9jja7SG4B3Ebex09H38l7yAuRn9t8SpKf21O+kHzYfmTmQl52yM9tFSXJz+0AJcnPbewEyce5/Zok+bm9oCT5uX2mJHk8rBR5D3kh8nhYKfJ4WCnyeFgp8nhYKfJ4WCHyCQ8rRR4PK0UeDytFHg8rRd5DXog8HlaKPB5WijweVoo8HvZF5Ivbfka/lLxDHg8rRD7jYaXI42FfQ97bB3kb7A55PKwUeTysFHkPeSHyeFgp8nhYKfJ4WCnyeFgp8nhYIfIFD/sq8qms5N0fyP/s6LtOON4+dMIf96ETblqDTsZvm2aaYJ7GnfdmGZd1g4Ron6TJ4UNTj6bDaUoCMJ6mZAvjaUpqMZ6m5CGjaeoXfGSHmvr14BjMjqYeTfvTNNpV05h3NKXvVaFpMBuS8PzZOX7oRC/bh070p33oRM/Zh06s2OnoObZJ3nQKlZ7jNrXHUIotaTv+Q1XDauCIquL5RlSVlcYRVWVdckRVPap+V1X3IB+ftsE/0Onk6Dt5chQp8iQjUuTJOl5D3tplfbWq9c7ukCe9kCJPHiFE3pIZSJHH10uRx3tLkccfS5H3kBcij4eVIo+HlSKPh5Uij4eVIo+HFSLv8LBS5PGwUuTxsFLk8bBS5D3khcjjYaXI42FfRD7Y9Wgbwh55POyLyHtXNvJxqRydN37ZPfDZ7HaOLXmdYimfj70rijceTVE892CKerz8aIqSEYymKNnDaIqSaYymqEfRwRQlgxlNUbKd0RQlMxpNUTKj0RQlMxpM0UBmNJqiZEbdKRq331Avi92RlNBoOElJjYaT1CPpaJKSGw0nKcHRcJLiSl8kaYhpk7TUd04si1s/PJSnfYA/9gKK8/Q89/n6yeY72N2yuK2ci/eVj7YprgOxKbnnj77DGey+0xbOYNl/WziDxeht4Qx2728KJw0W7raFM1hO2hbOYIljWziD9bE/hFPW13fYbPxXOB44x3Dm7pArcGbukJ1dymPY6SucmTvkKpyZO+QqnJk75BqcPHOH7B4/oN2HM3OfcwtK14923i5f4XjgHMOZuc+pwpm6z6nBmbrPcSVvcMxy/tGhbK91CKXsXL2nbop+QjIu230wLjvGJE/dQV2syV2SZep267FA7vzT22wv/XWXmdPLqyT3a3LmqNPdUpeNZMlf4cxtASpwPHCO4cxtASpw5rYADzjh6XmuDc7UFqAGZ+quvgZn6kb9HE5Ypu69nd2ekgwmVT465tUPmuSfHnv0ywfKqVvGlLcEJxX3p2xMWKbuL39CshJShMVD8sc1uU9y6s718dHuD4v0Ox+9lO2jjVt2LpRT97nZbsPOpfLRfiPi7ec7zs4wHpGcucXp29Fuwz51By2HfereXA771F2/GHYztZ+Qwz518C+HfWrLJ4d9an/4I+xutYc+5a+duPGAbAOS349/gFT9Y+NbyIdOXejEJoF96MQmC0p0cv6h09PLd+LB0fbp6PhHVS3b/42oKlsAjqgquwD2p6o3m8P19mnhedWUbQDH09Sj6XCashHgeJqS5IynKanPeJqSEI2nKWnScJo6sqTxNCVJGk9TcqTxNCVHGk9Tj6ZKND3K5Xc+O7vtV1jmWZz9zy7bLG8F8DTLW+Xca4DciRogpxqrBu6qklSNqCpZlXZVf+vk8bXf1snmraV1zlfIe7v9uNK7UNXJp0e7/PTMmcm7P4H168HxadOf29w/NMXXdqhpWvnFm45fNcXXjqepR9PhNMWnjqcpvrNHTc2madzRFNc5nqZ4zvE05fmIDjWNa+YQY/6qaeD5iPE0JUcaT1NypPE0JUcaT1OPpsNpSo40nqbkSONpOrU/dX7T1KVYOdq7xT5Uen5mwPx5lc5XROPUjlOPSuc5e5zaQ3aj0tSusBuVpvZ53ajkUUmFSqdrEHFqL9aNSlO7q25UmnrdXY9K5642Tr2S3o1KZA8dqJTIHnpQieyhB5XIHnpQieyhB5U8KnWg0tR+aXGbSkupDcT46NdlwNu/8/MvKe3O8TbkddeJ2z+foNz+fWc/tQsSZj+1t5Fln6d2LMLsp/YhwuyndhfC7Kf2DK9ln7atuGz69fa5L+w97MXYT722KMx+6hVDYfb4WjH2hf7+ZexjWQd++6fbYU+f8zL2Oa+H27KEHfYe9i9ifwtIH59ud/r7Qp8jx54+R449fc7r2Ce7fXr+fK/92dF3pUj7e1GKtQEdSsUctp9d5acdm+97i8YFn9GHTqw59KET6xNKdCoblFhs+qITHr8PnTw6daET2UEfOpEz9KETmUQfOpFI9KETeYQWnR7bwJTwRSdDHtGHTuQRfehEHtGHTuQRfejk0akLncgjJHS6s8cTvYp97dm1aPA5Yuwt3kWOPX7kZew/Pavsd9jjMeTY4xvk2HvYi7Gnv38de/tg72o+zNmy/mrUOeP/6MMs64196MR6Yx864a2V6ORi2XTKz/nTT469a4pnH05TRxYwnqZkDP1p6s12P/XWfNWU7GI8TclExtPUo6mApnf2ZC2vYx/Txj7lHfbkJ69jn7c1pVTKDnsykbfU/S57cg459uQRYuw9fuRl7HNYp3n75x57fIMcew97Mfb093Ls6e9fx97bc/b0Oa9jf77PXwysj8ixZx1Djj39vRx7D3sx9mRp32fv3LKxv1GpsDcpBbcef/v3A8vH2kkgS5NjT48pxj7SY76QfcoP9k9vEV/Z02PKsafHlGNPhizH3sNejD0Zshx7MmQ59vhaOfb4WjH2if7+++yXtI3bG58q7ONjY5tgnpK08EGe7v5l5LejYw475Ontpch7yAuRp6+XIk9X/zryZiMfd8jT00uRp6OXIs861cvIx/UxtJtj/Uo+s0olRR4PK0UeDytFHg8rRd5DXog8HlaKPB5WijweVoh8oZ//Nnnntq3kjfPBVsgbk/O2imXK8vz21a9HF5PWkRfzdTenQvffh054BSU6WbNCKfbrG9YKzqIPnTw6daETrqUPnfA4WnRyZtPJlS864Yj60Ik1wD50YsWwB53SQh7Rh07kEX3oRB6hRafFPvry/EUn8og+dPLo1IVO5BF96EQe0YdO5BF96EQe0YdO5BFd6GTII/rQiTyiD508On1XJ1vstquhLeXP/RI7GRzRy8if/jYyGTyOFHlcixR5fIgUeZzF68if/So1WbyCFHm6fynyrC++jPzpLzeSZcVQiryHvBB5PKwUeTysFHk8rBR5PKwUeTysEHlHP/998nExG/n0PPBd8rePNBuUGCpH21Qe77n/ww64d6Xo/5Uole26PGazyztKeZTqRCn8RS9K4Ue0KLURt9mkHaXwL70ohd/pRSn8USdKedYEe1GKNcRelCKj6EUpMopelPIo1YlSZBS9KEVGoUWp7QcPt3/upEmejKIXpcgoelGKjKITpQIZhRaltpHflCo7SpFR9KIUGUUvSpFRaFHK502p4HaU8ijViVJkFL0oRUbRi1JkFL0oRUbRi1JkFJ0oFckoelEKP6VEqbht23T77FI72ju3Hu2zqxwd/eNXJI+VLxf3ZlnyWjBmeRrG/sHRhhVgtLn20b92ptp+/JKzWT4dfy9HTzlSjm8rR/8Q/vnq+ChHnDHlqKgcsf+Uo6JyJOOgHGXKMdqdciTIoRzfWI7+UY4p1D69bLxjeX76MO8cnO322dk+Vfrt4Huhk4NR6DMUeiJGpNCnKHSeFKPQpyh0HrSj0KcodNbVKPQpCt1T6BT6DIXOWiCFPkWhs8pIob+t0IvdAN7+HT8dfy9H0m7K8X3X3fJ4Qq0sO0+oZRIMyvF9V0fzEL44s1OOdKWUo6KrI70j5SjTO7q9cuQJNcpRUTnyhBrlqKgccdaUo55yLDztRTm+rxzdI2Av3u+UI89kUY6KypHckXJUVI4830Q5KipHTzlSjnrKkVUZylFRObIqQzm+rxxra9aFVRnKUVE5sipDOSoqR1ZlKEc15ZgXVmUoR0XlyKoM5aioHFmVoRwVlSOrMpSjonL0lCPlqKccyR0px+vlaLajb5W51MoxWbd9eLpNYaccyR0pR0XlSO5IOb6vHKN7lGMqX8vRkDtSjorKkdyRclRUjuSOlKOiciR3pBzfVo5u2dRJt0LZKUdPOVKOesqRp8EpR0XlyNPglOP7ytE/lWMIO+XIqgzlqKgcWZWhHBWVI6sylKOecrSsylCOisqRVRnKUVE5sipDOSoqR1ZlKMf3laN7Lse4U46ecqQc9ZQjqzKUo6JyZFWGcnxfOW5z/PXvslOOrMpQjorKkVUZylFRObIqQznqKUfHqgzlqKgcWZWhHBWVI6sylKOicmRVhnJ8Xzmmp3Isy045esqRctRTjqzKUI6KypFVGcrxbeXozfYij+Ttzh49jlUZylFRObIqQzkqKkdWZShHPeXoWZWhHBWVI6sylKOicmRVhnJUVI6sylCO7yvH5bkc/U45esqRctRTjqzKUI6KypFVGcrxbeVo82P3W+9C7XjvzHa8392Az7OKQ/nqLV8XHuUbTPX4HLbB+5zyTrmzSkS56y334B/lHveSAVaVKN8+rtZ75RtYhaJ8Oy5fVq0o347Ll1Uuyrfj8mVVjPLVW74pPsq32D+fVARPuVPuasu9PK7WtyWSnfJllY7y7eJqvV++rOpRvh2XL6t6lG/H5csqHeXbcfmySkf5qi1fb9KjfJ3780lFZFWPctdb7u7pau133kwSWdWjfPu4Wu+WL6t6lG/H5cuqHuXbcfl6ypfy7bd8WaWjfFWU770cWXWjHBWVI6tolKOicmRVjHJ8XzmGRznavLMdcWSVi3LUU46JVSjKUVE5sqpEOSoqR1aJKEdF5ciqD+WoqBw95Ug56ilHVmUoR0XlyKoM5aioHMkdKcd3lWMscauqWFL5Wo6Z3JFyfNvVcXkIf/t33ClHckfKUVE5kjtSjorKkdyRcnxf71iWp3K0O+XoKUfKUU85kjtSjorKkdyRclRUjjwNTjkqKkeeBqccFZUjqzKUo55yLKzKUI6KypFVGcpRUTl6ypFyvFqO4VYcqzYm+8rRycf1s2//3HmAopA6UoxqipHMkWJUU4wkjhTju4oxmlX3FG3aKUbyRopRTTGSNlKMSoqxLGSNFKOaYiRppBjVFKOnGCnGNxVjyGuVpFDsTjHipinGdxVjKuugU3Zmpxhx0xSjmmLETVOMWorR4KYpRjXFiJumGNUUI7+lphjfVYw5mK0Yo9spRn5JTTGqKUZPMVKMWoqR5xkpRjXFyPOMFKOaYmQFhmJUU4yswFCMaoqRFRiKUUsxWlZgKEY1xUjOSDG+qxifn2fcW4GxnmKkGLUUIzkjxaimGMkZKUY1xUjOSDG+rRjj9tROTPlrMTqe2qEY31WMaeOXkvE7xYibphjVFKOnGClGLcWIm6YY39YzlvQoxrBTjLhpilFNMeKmKUYtxehZm6YY39Yzbq+ivv1zp2f0/DqQYnxbMT79OtC4ytHG57ANxee9XNKTS1K87yrebOJWvHsrNp5ckmKUuJLuFqOnGClGLcVILkkxqilGckmKUU0xkktSjGqKkV8TUoxaijGQS3ZZjNavCK1Ny6ej77oS2XWpq7PrZ1vn3Y6upF9j6urRdUhdyWT6vL/mh65/GMldV+KNMXUlKRhTV0z3mLqyG86QukYe3htTV/KmMXUlbxpTV/KmMXXFv35f1yU8dL3NuMp+yVs2b5+y+Zw/2OMx5djjA+XY49Vex95vi9M2uE/sd8Ziy6qUc0+/cI53nRLeqw+d8FJKdHKxbDrl9KTTT469a4qPGk9TPNR4mno07U5Tb7b7qbfmq6as1Y+nKTnHeJqSn7xMU/d4rtSlpaJpSGsBhPIE8MPuJ6KWLmQilelBpkwo04VMZDJdyETM8jKZ/GPp0T9/+q5MsWxrprE8tXpm7+Bs/co722i/qkrQMqKqHlUHVJWwZURViVtGVJXAZURVyWdGVJU4Z0BVC371ZaoGuy1jBBs+qXpnT6f6OvZ+e6g5hJ1HBgv3qNex3w63IeYd9txJhNiHZSHtl2NPhC9xvf/x3eGmFF1RL0qRzOtQKuawIow5PTaEix86eXTqQic8SR86kYcr0alsUGKx6YtOJNx96EQe0IdOZAdd6GTIGfrQiUyiD51IJPrQiTxCi07bwmcs4atOHp260Ik8og+dyCP60Ik8og+dyCP60Ik8QkKn3+wtnujb7E2y24ebstTeMmV8WqGYYJ5/gr838vj4Ewnm6djwoROeSIlOabOuOezo5NGpC53wRH3ohCfqQyc8kRadth825LijE56oD53wRF3o5FijVaJTfLzTN+/oxBptHzqRR/ShE3lEHzp5dOpCJ/KIPnQij+hDJ/KILnTyM/snWx7bLi9mqenUcj3Jz+yHXsr9PCf1M/sbSe4z+xVJ7h7uItxn9hOv5X6aB/uZ/YEk95n7fUnuM68nvpR7xTfNvD4oyD3gV2W441dluONXZbjjV2W4e7iLcMevinCP+9zT9rL4p+UAm93OF+QNeXalcmzJK5VSPh97H0zUNJikaTBZ02CKosGkRdNgjKbBWE2DcZoG4zUNRtMVOGm6Aqf3XoHjdlddFrszmqxqNEXTaPKiajRG1WisqtHsX218KVtLGex5b5uX9a82+6cW2y8f3xBf/g3p5d+QX/4N5dXfUJaXf4P5898QVgeWU/z0DTsuaSmrlbFmeRzt9x5Synl9b0gxtvbBN2e5frBfHoupbpuonWWibpaJ+lkmWr/ep08TvZ8VL52VLpxlFvPi65RZ7Mu/wb38G/zLvyG8/Bviy78hzfFnbZY8y0TLJBM1yywTNVfuEsZeOstdOmv3KhLselJwj4jeLv7jpHzlpHLhJLtcOclcOcleOcldOclfOSlcOSleOelKRexvtRDKuqAVTdg5qVw4af9H6LWTzJWT7JWT3JWT/JWTwpWT4pWT0pWTrlSEu1IR/kpFHDxDuVi7RUpx77R87bT9O/utmNfTbp/89bSDB7Cqp5lrp9lrp+3fd8y2FmtM3kESDh4eLk9r4Hvflq6dlq+dVi6dFpdrp5lrp9lrp+3rFuwmd/Bp5zR/7bRw7bR47bR07bR87bRy6bSD1dwQHw1bLjunmWun2WunuWun+WunhWunxWunpWunHVwUlu00Z3f+3g7WjaqnmWun2WunuWun+WunhWunxWunpWun5WunXauScq1KDpYn3PbD2Fu7uHMJOnqbe+00d+00f+20cO20eO20dO20aw1GudRg2GW5dpq5dtquADaZLfxIO57QHkSgMW63xZj2vi1dOy1fO61cOu0gwUppDY9udwm7c5q5dpq9dpq7dpq/dlq4dlq8dlq6dlq+dlq5dJq9ViX2WpXYa1Vir1WJvVYl9lqVHGyNWx63xWL3TkuXTjvY8Cua7ToZ7SNGdq58nOavnRaqpzm/c1q8dlq6dNp+FOFsWR/tcc48TosfJ5krJ9krJ+0q5tzjWXOXn9/F8NcfHHv/Av/qLwiv/oL4Z7/Am00Df7sAf/mC9OovyC/+gnjQ6KS0NTpPzcB6UrxyUrpy0sFC6E9+InE7Ys3xn38z8vETCXsQZbT8ioPYo+lXmNd/hW36FX7Z+Qr3+q/wr/+K8PqviH/+K+KyXhie79GPr0iv/4r8+q8oL/+KvLz+K8zrv8K+/ivc67/Cv/4rwuu/4vV/3fn1f9359X/d+fV/3eX1f93l9X/d5fV/3aXF38Xproa2tKio0x/M2oN08rYuun3Fk1f89RW/TnMH6WT1NHPtNHvttIPr7/bD59tpoYLvlh5k/0gSyh8NhVv8O74kvONL4ju+JL3hS8zy6j9NZ1pcw073vHPGvv4r3Ou/wr/+K8LrvyK+/ivS67+ixf3kdAM1Z8rLv8Iur/8K8+obr7P29V/hXv8V/vVfEV7/FfH1X5Fe/xX59V9RXv4VB0/XhjU1Dfm507MfJ/krJ4UrJ+2XypIez0Le/l3+2JEcLMksqWwt7JJN/HJavnZauXTaweb11dP2L5ZLdu5x2tPLmtfT7LXT3LXT/LXTDnQrj9dWLyWaP5528FTvUvLjQdtl+ULy4Kne6mn22mn+2tzCtdMO/nBKcU+DDF9OS9dOy9dOK5dOi8u108y10+y10w4e4l4eK+Vmsc9V8tef19TBo8ONvyS840vin/+S87VId/AIc9OvyK//ivLTr/h92sEaYfU0c+20a5fIg/W56mn+2mnh2mnx2mnp2mn52mnl0mn52o00X7uRHix1pPB4cik9b2e499dyW/zefomanp48Wr8ivv4r0uu/Ir/+K8rLv+JgqaPpV5jXf4V9/Ve413+Ff/1XvP6vu7z+r7u8/q+7vP6vu7z8r9svy+u/wrz+K+zrv8K9/iv867/ix3/d99PitdPStdPytdPKpdPMcu00c+00e+00d+00f+20a1VirlWJuVYl5lqVmGtVYq9Vib1WJfZaldhrVWKvVYm9ViX2WpXYa1Vir1WJvVYl7lqVuGtV4q5VibtWJe5albhrVeKuVYm7ViXuWpW4a1Xir1WJv1Yl/lqV+GtV4q9Vib9WJf5alfhrVeKvVYm/ViXhWpWEa1USrlVJuFYl4VqVhGtVEq5VSbhWJeFalYRrVRKvVUm8ViXxWpXEa1USr1VJvFYl8VqVxGtVEq9VSbxWJelalaRrVZKuVUm6ViXpWpWka1WSrlVJulYl6VqVpGtVkq9VSb5WJflaleRrVZKvVUm+ViX5WpXka1WSr1VJvlYl5VqVlGtVUq5VSblWJeValZRrVVKuVUm5ViXlWpWUS1USluXaaebaafbaae7aaf7aaeHaafHaaenaafnaadeq5Fr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hIHst2xOGpnizc9rRPqrbxprlaWfTX6ftvfKt1Qulw1GmKzWcoGs4Uddwkq7hZF3DKZqGE48yfqnhGF3DsbqGo+qqHBdVV+W4qLoqx0XVVTkuqq7KcVF1VY6Lrquy0XVVNu++Ksdtl5VlsTvjscrG45SNxysbT1A2nqhsPPsbqJu87jNi7dNrH/fHY2JaHm89SF92L4j7672tv6S84Uv215J//CUuPr4kuqcv2flFXnbrxkBued73adnfTnXZ9lxb3OO398V+jN8oH3/Y+MfbaufX8dvOx+86H7/vfPyh8/HHzsefOh9/7nz8pe/xO+3339r4O7//us7vv67z+6/r/P7rOr//us7vv67z+6/r/P7rOr//+s7vv77z+6/v/P7rO7//+s7vv77z+6/v/P7rO7//+s7vv77z+2/o/P4bOr//hs7vv6Hz+2/o/P4bOr//hs7vv6Hz+2/o/P4bOr//xs7vv7Hz+2/s/P4bO7//xs7vv7Hz+2/s/P4bO7//xs7vv7Hz+2/q/P6bOr//ps7vv6nz+2/q/P6bOr//ps7vv6nz+2/q/P6bOr//5s7vv7nz+2/u/P6bO7//5s7vv7nz+2/u/P6bO7//5s7vv7nz+2/p/P5bOr//ls7vv6Xz+2/p/P5bOr//ls7vv6Xz+2/p/P5b+r7/pqXv+29a+r7/pqXv+29a+r7/pqXv+29a+r7/pqXv+29a+r7/pqXv+29aOr//ms7vv6bz+6/p/P5rOr//ms7vv6bz+6/p/P5rOr//ms7vv6bz+6/6/a9q4+/8/tv5/lep8/2vUuf7X6XO979Kne9/lTrf/yp1vv9V6nz/q9T5/lep8/2vUuf7X6XO979Kne9/lTrf/yp1vv9V6nz/q9T5/lep8/2vUuf7X6XO979Kne9/lTrf/yp1vv9V6nz/q9T5/lep8/2vUuf7X6XO979Kne9/lTrf/yp1vv9V6nz/q9T5/lep8/2vUuf7X6XO979Kne9/lTrf/yp1vv9V6nz/q9T5/lep8/2vUuf7X6XO979Kne9/lTrf/yp1vv9V6nz/q9T5/lep8/2vUuf7X6XO979Kne9/lTrf/yp1vv9V6nz/q9T5/lep8/2vUuf7X6XO979Kne9/lTrf/yp1vv9V6nz/q9T5/lep8/2vUuf7X6XO979Kne9/lTrf/yp1vv9V6nz/q9T5/lep8/2vUuf7X6XO979Kne9/lTrf/yp3vv9V7nz/q9z5/le58/2v8tL3/Td3vv9V7nz/q9z5/le58/2vcuf7X+XO97/Kne9/lTvf/yp3vv9V7nz/q9z5/le58/2vcuf7X+XO97/Kne9/lTvf/yp3vv9V7nz/q6x+/6vHR8fbYsXz+PcOXkcdc3x8cA4fc9V+r245V+339ZZz1d4DtJyr9n6h5Vy19xYt56q8Dwkl5Mdc7flcTSm2rAMpxT0Gbku+z1f7vmHN56u8z2k+X+V9UfP5Ku+jms/XTzZf5f1U8/kq76lS8Pbj6BSXeD5f59ZjnX8a9N6hIYZ1yL9ezvI4+Jd3+jrmG8htzEv+dPQdo/J2rReMyjvBXjAqbzI7wah9z71eMCpviXvBqLzT7gWj8ga+F4wejC0wKrcbvWDExTTBiItpghEX0wQjLqYFRu07l/aCERfTBCMupglGXEwTjB6MLTDiYppgxMU0wYiLaYIRF9MEIy6mBUbt+z/3ghEX0wQjLqYJRlxME4wejC0w4mKaYMTFNMGIi2mCERfTBCMupgVG7bvo94IRF9MEIy6mCUZcTBOMHowtMOJimmDExTTBiItpghEX0wQjLqYFRu3vIukFIy6mCUZcTBOMuJgmGD0YW2DExTTBiItpghEX0wQjLqYJRlxMC4za3+jUC0ZcTBOMuJgmGHExTTB6MLbAiItpghEX0wQjLqYJRlxME4y4mAYYi/b34vWCERfTBCMupglGXEwTjB6MLTDiYppgxMU0wYiLaYIRF9MEIy6mBUbtbxftBSMupglGXEwTjLiYJhg9GFtgxMU0wYiLaYIRF9MEIy6mCUZcTAuM2t/R3AtGXEwTjLiYJhhxMU0wejC2wIiLaYIRF9MEIy6mCUZcTBOMuJgWGLW/sb0XjLiYJhhxMU0w4mKaYPRgbIERF9MEIy6mCUZcTBOMuJgmGHExLTB6XEwTjLiYJhhxMU0w4mKaYPRgbIERF9MEIy6mCUZcTBOMuJgmGHExLTAGXEwTjLiYJhhxMU0w4mKaYPRgbIERF9MEIy6mCUZcTBOMuJgmGHExLTBGXEwTjLiYJhhxMU0w4mKaYPRgbIERF9MEIy6mCUZcTBOMuJgmGHExLTAmXEwTjLiYJhhxMU0w4mKaYPRgbIERF9MEIy6mCUZcTBOMuJgmGHExLTBmXEwTjLiYJhhxMU0w4mKaYPRgbIERF9MEIy6mCUZcTBOMuJgmGHExLTAWXEwTjLiYJhhxMU0wKncxvx6rXjFmUyoYU14Pdvlp2H5Z9obt7ToQ49NDoZz3PtrkZf1oUx4H27g3arfYDbvxD+zO7A0km+g/js72SSSb/c7RPi3u42iffpXI+tkhfkjqkXQ0SZW7OyT9uaTKnSaS/lxS5a4XSX8uqXIHjqQ/l1R5GoCkP5Q0LovyZAJJfy6p8pQESX8uqfLEBkl/Linp0XCSeiQdTVLSo+EkJT0aTlLSo+EkJT36nqTelPWjfbYVScNithXQxafHHFfqBDwC1A0ZjAR1YhIJ6iQZEtQJGySoe6gLUMeyS1DHVUtQx/hKUMebSlDHmwpQt6q86X1IqozbfUiqXM19SKpa/vuQvL4hqWoW70NS1Undh6SqzbgPSdU9+D4kVTeo30Ny+q7eTt/V2+m7ejt9V2+n7+rt9F29db3j/j4kfVdvXe9evw9J39Vb1zvB70PSd/XW9a7q+5D0Xb11vUP5PiR9V29d7/a9D0nf1VvXO2fvQ9J39db1LtT7kPRdvXW9o/M+JH1Xb13vjrwPSd/VW9c7De9D0nf11vWuvfuQ9F29db0D7j4kfVdvXe8muw9J39Vb1zuz7kPSd/XW9S6n+5D0Xb11vWPoPiR9V29d7765D0nf1VvXO1nuQ9J39db1rpD7kPRdvXW9w+I+JH1Xb13vVrgPSd/VW9ee//ch6bt669qL/j4kfVdvXXuk34ek7+qta+/u+5D0Xb117Sl9H5K+q7euvY7vQ9J39da1B+99SPqu3rr2Y70PSd/VW9d+mPch6bt669qP8D4kdVdvo2s/uPuQ1F29ja79uO5DUnf1Nou6q7fRtZ/PfUjqrt5G134q9yGpu3obXZtl/B6Srp0k7kPSd/XWtQfBfUj6rt66fr1+H5K+q7eu3z3fh6Tv6q3rF7P3Iem7euv7raXR91tLo++3lkbfby2Nvt9aGn2/tTT6fmtp9P3W0uj7raXR91tLo++3lkbfby2Nvt9aGn2/tTT6fmtp9P3W0uj7raXR91tLo++3lkbfby2Nvt9amka/aVrSY0gmPQ3p95f8/Pc399PctdP8tdPCtdPitdPStdPytdPKpdN+/vuE+2nm2mnXqiReq5J4rUritSqJ16okXquSeK1K4rUqSdeqJF2rknStStK1KknXqiRdq5J0rUrStSpJ16okXauSfK1K8rUqydeqJF+rknytSvK1KsnXqiRfq5J8rUrytSop16qkXKuScq1KyrUqKdeqpFyrknKtSsq1KinXqqRcqhK7LNdOM9dOs9dOc9dO89dOC9dOi9dOS9dOy9dOu1Yl5lqVmGtVYq5ViblWJeZalZhrVWKuVYm5ViXmWpWYa1Vir1WJvVYl9lqV2GtVsr8+4+N22qfX4jxOC/unmcdpdvmv80wgL9uLetxjm9pbHLFzbMlroFHK52Pvw4m6hpN0DSfrGk5RNZz99RK54Rhdw7G6huN0DcfrGo6uq7LTdVV2uq7KTtdV2b37qry9ps8si/06Hr8oG49RNh6rbDxO2Xi8svH8+Np8Py1eOy1dOq3RxnynS3220VZ7lS9x7/gS/44vCe/4kviOL2nzUII3jy8J5elLfrYSfh9S1jekom5IjTah+8GQ/C0uXq9U9mslNdqCruGArLYBvf1hstoN8P27z1VHFNSNKKobUVI3oqxuREXbiN6/71x1REbdiKy6Eam7Zid112yBLefCsqyfHXypfXYJ20eXbJ4m4D8mEJVPIBe3Hr24zxPYcci3ZcbVIt/cY+XoVPz6qGkqxVaOdsGuDY6Jj2OXvWNvS3sPfkv5dPQdewK7BPYMdgnsBewC2AU2jAT7DbsBuwR2C3YJ7A7sEtg92CWwa/d7g2LHpYpgx6WKYMelimDHpUpgL7hUEey4VBHsuFQR7LhUEewe7BLYcaki2HGpIthxqSLYcamvwH6zoeuo3fMTJxt2XKoAdrfgUkWw41JFsONSRbDjUkWwe7BLYMelimDHpYpgx6WKYMelimDHpUpgN7hUEey4VBHsuFQR7LhUEewe7BLYcaki2HGpIthxqSLYcaki2HGpEtgtLlUEOy5VBDsuVQQ7LlUEuwe7BHZcqgh2XKoIdlyqCHZc6iuwJ7MCscktO9hxqRLYHS5VBDsuVQQ7LlUEOy5VBLsHuwR2XKoIdlyqCHZcqgR2//5re3brZN1iXOWzQwnrmzLyUh5H3yjdxx86H3/sfPxJ9/hj2F5rFIPbGX/ufPyl7/GHpfPxm87Hbzsfv+t8/Mrvv9XxK7//Vsev/P5bHX/n99/Q+f03dH7/jZ3ff2Pn99/Y+f03dn7/ff+LDRuPv/P7b+z8/hs7v//Gzu+/sfP7b+r8/ps6v/+mzu+/Sfn99yk/jOkp2v71z68DuYXf60NVt3+7x8BtyR/zVX6/bj7ffvLtNvPtJw+vz9enso7DZ5d3Zqu8e2g8W+W9RuPZKu9M2s42K+9jGs9WedfTeLbKe6TGs+2oo8rpa0co8K67tuPvqOPZHX9HHczu+DvqSXbH31GXsTv+jvqGvfGXjjqB3fF3dG/fHX9Hd+vd8Su//6bg1+fvUvx1xFm34dx6rPNPg947NMSwDjmk5engX6nP1zHfrPQ25iV/OvqOUfllRAdGt5Q1kHCfeOwenbYRp+1If+ftF+WXveF4K79MD8db+W1lON7cBt/L28P7rbyV2/zheCuPJYbjrTxGGY638thnON74y7fyNvjL9/LGX76XN/7yvbzxl+/l7eH9Vt74y/fyxl++lzf+8r288Zdv5W2194M2x230SznnbW7k1nGk+LTVjNtdIV/WnWaCXz4deyejvXOTI+Mhc0BGezckR0Z73yJHRnuHIUdGey8gR0Z7KixGxmnPb+XIaE9a5chM3APHdf/EUHLl2Ft3s2L0v7dMfDIdd47z3snydvDzs7b7x1pn14Ot991scWnKQ8YneOsWl97Ne7dGfe/m7UhQ3/t5uy7Uv80E9SdWf97uGfW9nzclR32vfVt71H+p+vOudqC+1/5KBdR/qfpkfTOrT9Y3s/pkfROrr/1VMqj/UvXJ+mZWn6xvZvXJ+mZW36P+xOqT9c2sPlnfzOqT9c2sPlnfzOqT9Q2svs3rz0itW+xX9bW/thL1X6o+Wd/M6pP1zaw+Wd/M6nvUn1h9sr6Z1Sfrm1l9sr6Z1Sfrm1l9sr6J1U9kfTOrT9Y3s/pkfTOrT9Y3s/oe9SdWn6xvZvXJ+mZWn6xvZvXJ+mZWn6xvYvUzWd/M6pP1zaw+Wd/M6pP1zay+R/2J1Sfrm1l9sr6Z1Sfrm1l9sr6Z1SfrG1j9ZFZ4Nrnlq/qFrG9m9cn6ZlafrG9m9cn6Zlbfo/7E6pP1zaw+Wd/M6pP1zaw+Wd/M6s+b9RW7zrGEUDk2LGl78blZnmvl/i7zsMybmrXlOG/+1JbjvElOW44TZyLZrQcvS6zdHk3cbo/WpV5uj5XtbMPikX9m+SdORZA/LBPHIsh/6w2Qf2b5Jw5GkD8sEz8Fhfw3N4j8M8s/8XNQyB/MxA9CIX8wpH5Ty++Rf2b5Sf2mlp/Ub2r5Sf2mlp/Ub2r5Sf1mlt+S+k0tP6nf1PKT+k0tP6nf1PJ75J9ZflK/keWvbHoTLKnf1PKT+k0tP6nf1PKT+s0svyP1m1p+Ur+p5Sf1m1p+Ur+p5ffIP7P8pH5Ty0/qN7X8pH5Ty0/qN7X8pH4zy+9J/aaWn9RvavlJ/aaWn9Rvavk98s8sP6nf1PKT+k0tP6nf1PKT+k0tP6nfzPIHUr+p5Sf1m1p+Ur+p5Sf1m1p+j/wzy0/qN7L8lVfdhUDqN7X8pH5Ty0/qN7X8pH4zyx9J/aaWn9RvavlJ/aaWn9Rvavk98s8s/1C+P1q/yZ+qipZlPdqW4CpH+2VZq8Uv/rm0Pt6Fnoa6jf6IpFsWsw0kV7k7u/0leW96+Uuq7ZCZhrqPov+P9R/qRor+P9Z/qPUz9P+x/kMtoKH/j/Wft5NG/1/6D7WEhv4/1n+oNTT0/6n+eahFNPT/sf5DraKh/4/1J/+bW3/yv7n19+g/tf7kf3PrT/43t/7kf3PrT/43t/7kf1PrX8j/5taf/G9u/cn/5taf/G9u/T36j6x/bf+MQv43t/7kf3PrT/43t/7kf3PrT/43s/5xIf+bW3/yv7n1J/+bW3/yv7n19+g/tf7kf3PrT/43t/7kf3PrT/43t/7kf1Prb8j/5taf/G9u/cn/5taf/G9u/T36T60/+d/c+pP/za0/+d/c+pP/za0/+d/U+lvyv7n1J/+bW3/yv7n1J/+bW3+P/iPrX3mTVrTkf3PrT/43t/7kf3PrT/43t/7kf1Pr78j/5taf/G9u/cn/5taf/G9u/f28+pslrwMxIVWO9qmsA/HZL09Huw+SEydpjUlOnEk1JjlxutOY5MQ5iUkbSWtrJK2J233SutTLfbKyT250E+ck6B+jnzgnQf+b/hPnJOh/03/inAT9b/pPnJOg/01/j/5T6z9zuoP+0c+cSaF/9DMnaegfPfnf3PqT/02tfyD/m1t/8r+59Sf/m1t/8r+59ffoP7X+5H9z60/+N7f+5H9z60/+N7f+5H9T6x/J/4bWv7ZPTiT/m1t/8r+59Sf/m1t/j/5T60/+N7f+5H9z60/+N7f+5H9z60/+N7X+ifxvbv3J/+bWn/xvbv3J/+bW36P/1PqT/82tP/nf3PqT/82tP/nf3PqT/02tfyb/m1t/8r+59Sf/m1t/8r+59ffoP7X+5H9z60/+N7f+5H9z60/+N7f+5H9T61/I/4bWv/aevEL+N7f+5H9z60/+N7f+Hv2n1p/8b279yf/m1p/8b279yf/m1p/8b2b906Lc/4cSVpFSNhX9Xcqbovlp2H5Z9obtXFpHfTt8OzrnnYO9W/X0+YlHWD4wKrfRvWD0YGyBUbmp6wWjcm/UC0blFqMXjMo7dS0YQ1hnGOIeRuUNbycYjfJ1YzUY07JiTGUHo/Ll114w4mK+h7Gst5i4uB2MuJgmGD0Yf4jRmB2MuJgmGHEx38J4I7VizMsORlxME4y4mO9hzOugY/E7GHExLTBaXMy3MN5c8zoMk3cw4mKaYMTF/BSjjTsYcTFNMHowtsCIi/kexrIOOi97d2pcTBOMuJhvYczbH3XevVPjYppgxMV8D6NzK0Zvv2J0uJgmGHExP8UYdhIeh4tpghEX8y2MxazHlr3223kwtsCIi/keRrcCKX5nLcbhYppgxMV8D+P2DE+Je3/UuJgmGHExP8WYdqIJj4tpghEX8y2MZgnrI2W3ge404B4f0wjkxE7G23Ugxj/9IG0XpDN5BelMeRxs496o3RIfc3x6JtKZZXfYy/qQkEtPLdWvo+8ieUTSL9LELqwfkSb2eP2INLGD7Eekif1pPyJN7H67ESlM7K37EWli596PSBOnAv2IROLQgUgekfSLROLQgUgkDh2IROLQgUgkDh2IROKgX6RI4tCBSCQOHYhE4tCBSCQOHYjkEUm/SCQOHYhE4tCBSCQOHYhE4tCBSCQO+kVKJA4diETi0IFIJA4vEcna7WifKyJlEx8vkFkeR++/EsanZf0xuU/msbeBC/FDUvKJ4ST1SDqapGQfw0lKUjKcpOQqo0ma8Y7dSbptdHj7Z9yRlI63N0nzsv7q3N8O35HUI6m4pFpebGrKQ/Wn98JuLzbN9NIUy7eLhS6dYvl2sdD/UyzfLhbWdymWbxcL68wUy3eLpZBZUCzfLhbW3SmWbxcL6/8Uy7eLhZyVYvl2sXiKhWL5brGQ4FIs3y4WElyK5dvFQoJLsXy7WEhwKZZvFwsJLsXyzWLJCwkuxfLtYiHBpVi+XSwkuBTLt4uFBJdi+XaxeIqFYvlusZDgUizfLhYSXIplVca6h+re7hQLCS7F8u1iIcGlWL5bLIachWL5drF4ioVi+VAmmVVGm9yyUyy4IYrl28WCG6JYvl0suCGK5dvFghuiWL5dLDzPQrF8t1gsz7NQLN8uFnIWiuXbxcLzLBTLt4uF51kolm8Xi6dYvlUs1q6b8zmXc6VYunnowJLJTi0/KevU8pObTi0/SejU8pNtziy/I62cWn7yx6nlJ1GcWn4ywqnl98g/s/ykflPLT+o3tfykflPLT+o3tfykfjPL70n9ppaf1G9q+Un9ppaf1G9q+T3yzyw/qd/U8pP6jSy/zWXV0S07W3V4Ur+p5Sf1m1p+Ur+Z5Q+kflPLT+o3tfykflPLT+o3tfwe+WeWn9RvavlJ/aaWn9RvavlJ/aaWn9RvZvkjqd/U8pP6TS0/qd/U8pP6TS2/R/6Z5Sf1m1p+Ur+p5Sf1m1p+Ur+p5Sf1m1n+ROo3tfykflPLT+o3tfykflPL75F/ZvlJ/aaWn9RvZPlrr3JKpH5Ty0/qN7X8pH4zy59J/aaWn9RvavlJ/aaWn9Rvavk98s8sP6nf1PKT+n1Pfu82+X02FfmdWbajjX/it4sv+RW2SfHp4LRzcPRrXcXgng+9q0mIN5KaZHJ9qbkJE59uEJuaRGydqbmsOJavf5uFxOybapryUNNW1AzL1q6ExadnNe/UCaokqJMPSVAnlpGg7qEuQJ0QQoI63l+COh5dgjpeWoI6nvf91MuCN5WgjjeVoI43fQF1X0reqIfyX6epmg9lTbF99MtXiTCy6iXySKRdIiyyeonw0+olwnyrlwinrl4ibL12iQwZgHqJCAzUS0S6oEsi91Ui0gX1Enkk0i4R6YJ6iUgX1EtEuqBdIktHd0GiWJHI+O0pbONdPpcoLn796LiU5fxgcztiPfr27xC/KkoDOJqiHkUHU5T2cjRF6UZHU5TmdTRFWUnrWtHyVVEW3gZT1LFON5qiLOuNpiiZ0WiKkhkNpmiY+T665ANF72hmviFV0Mx8Za+gGeoSmYPf0KSlhsYs69YvxjxN0pm9o73ZtmPz/nHs7ie/cKM3Ux7CLOXT0Xc9PXoOpedQkTp6hqECdfQMQ8Xp6BmGCtPRMwwVpaNnHCoAQM84VGqBnnGoqAU9I/nQWHp69BxKT/KhsfQkHxpLT/KhsfQkHxpLT/KhofRM5ENj6Uk+NJae5ENj6Uk+NJaeHj2H0pN8qCs9bV4fgLZusTt6kg+NpSf50Fh6kg+NpSf50FB6ZvKhsfQkHxpLT/KhsfQkHxpLT4+eQ+lJPjSWnuRDY+lJPjSWnuRDY+lJPjSUnoV8aCw9yYfG0pN8aCw9yYfG0tOj51B6kg+NpSf50Fh6kg+NpSf50Fh6kg8NpGdaFvKhsfQkHxpLT/KhsfQkHxpLT4+eQ+lJPtSVnsmspG1yy46e5ENj6Uk+NJae5ENj6Uk+NJSehnxoLD3Jh8bSk3xoLD3Jh8bS06PnUHqOlQ+V7aOL9RU93fbJ/mkY+y9g3T3U+PIBcahQprj1j8IvsQYxW7MenW0wldIV22jrptFQQcugGg0Vngyq0VCByJga2aFCjkE1Giq4GFSjocKIQTUaKmAYVCOPRuo1GioIGFQjcgb9GpEz6NeInEG/RuQM6jVy5Az6NSJn0K8ROYN+jcgZ9Gvk0Ui9RuQM+jUiZ9CvETmDfo3IGcQ1qv1A0pEzqNfIkzPo14icQb9G5Az6NSJn0K+RRyP1GpEz6NeInEG/RuQM+jUiZ9CvETmDeo0COYN+jcgZ9GtEzqBfI3IG/Rp5NFKvETmDfo3IGfRrRM6gXyNyBv0akTOo1yiSM+jXiJxBv0bkDPo1ImfQr5FHI/UakTPo14icQb9G5Az6NSJnENeotnFwJGdQr1EiZ9CvETmDfo3IGfRrRM6gXyOPRuo1ImfQrxE5g36NyBnUa5RV9XX3IalqY+5Dkr1ru1olm7wVp8k+P4rTfow/dD7+2Pn4U+fjz52Pv/Q9/rJ0Pn7T+fht5+N3nY+/8/tv6fz+Wzq//5bO77+l8/tv6fv+a5a+779m6fv+a5a+779m6fv+a5a+779mefv91xm3vinZmbJUPts6u87Wel+Li3rZ/PM2V7BLYE9gl8CewS6BvYBdALtZwC6B3YBdArsFuwR2B3YJ7B7sEthxqSLYcaki2HGpIthxqSLYcakS2C0uVQQ7LlUEOy5VBDsuVQS7B7sEdlyqCHZcqgh2XOorsFe2vzAWlyqCHZcqgd3hUkWw41JFsONSRbDjUkWwe7BLYMelimDHpYpgx6WKYMelimDHpUpg97hUEey4VBHsuFQR7LhUEewe7BLYcaki2HGpIthxqSLYcaki2HGpEtgDLlUEOy5VBDsuVQQ7LlUEuwe7BHZcqgh2XKoIdlzqK7BXNqI3AZcqgh2XKoE94lJFsONSRbDjUkWw41JFsHuwS2DHpYpgx6WKYH+/S7XWrdhttjXst7/HbSQu9YK99nPg97+WHey/sBewC2B//8vTwf4LuwG7BHYLdgnsDuwS2D3YJbAHsEtgj2CXwI5LFcGOSxXBjkuVwJ5xqSLYcaki2HGpIthxqSLYPdglsONSRbDjUkWw41JFsONSRbDjUl+BvfazgoJLFcGOSxXBjksVwY5LFcHuwS6BHZcqgh2XKoIdlyqCHZcqgh2XKoDdLrhUEey4VBHsuFQR7LhUEewe7BLYcaki2HGpIthxqSLYcaki2HGpEtgNLlUEOy5VBDsuVQQ7LlUEuwe7BHZcqgh2XKoIdlyqCHZcqgh2XOorsFe2aLMWlyqCHZcqgh2XKoIdlyqC3YNdAjsuVQQ7LlUEOy5VBDsuVQS7gEst68HOPW0N/uuzfw/JWX1DcvqG5N89JL+49bP9Emp/L2dH3ycQep9A1D2BmMN6DYo5madPvg8/9T383Pfwi/Lhl2W9JcVi0x+H75e+h2/6Hr7te/iu7+Erv/PWhq/8vlsbvva7bmX42u+6leFrv+tWht/3XTf0fdcNfd91Q9933dD3Xff9b6FvO/y+77qh77tu6PuuG/q+64a+77qx77tu7PuuG/u+60b1d12/xVQlfB2++rvu+fDV33XPh6/+rns+fPV33fPhq7/rng7/1a+RvH/J2y9vNrv1eusW4yqfHUrIH0enbB778v5aZP1ysEt5Pdjlp2H7Zdkbtt9ecWx8eizE5rz30SY/vT35adU27i7+LdZuR/u8He3Monmt2S3rerp1xnw6+l4snmKhWL5bLIFioVi+WyyRYqFYPpSp/TDn/a9HpFj6LZZMsVAs3y2WQrFQLN8slve/QJNi6bdYDMVCsXy3WCzFQrF8t1hIcCmWbxeLp1golu8WCwkuxfLtYiHBpVi+XSzkLPLFYuKjWJZckd+nsg779s/HSFz4eJCgkIb0Jmnerhb+mchDUjKL7iTddkTw2dkdSUkWhpMU/z+cpB5JR5MULz2cpDje4STlyaLuJF3SJqlddiTl+Z/hJCU9GkxSt5AeDScp6dFwkpIeDScp6dFwknokHUzS/dcV3Ga4nfUYvinm4yR/5aRw5aTdJCSYteCCdZ9O2qugx+bMOT/tlps/viG9/Bvyy7+hvPob3PLybzAv/wb78m9wL/8G//JvCC//hpf/TbuX/027l/9N7++EGrZ9HYJPXy+X+ztghrRtBuGXnZPylW/av+Rs998Q/deT9jcpDHm9/YXidk4yV06yV05yV07yV04KV06KV07a/1PY+pNQ9nTKV04qF06Ky/lJcdmZ0/62VSGV7aS8c9JuRUSz0ouu7JzkKt+09/e0vzFS5Y9wfzui2klX/tz3N38xNqyTMjbuoEjm2mn22mnu2mn+2mnh2mnx2mnp2mn52mnl0mn5oEpy2k57erDzcZqpn7bT5md77TR37TR/7bT9KrnZt/U0t3fh2X98uX5aunZavnZauXTa/qOZ9dPMtdPstdMOdIub3LfLzc5p+yQfPZ4J/utfgF8OkJTt780vYec0Uz+t7Jxmr53mrp3mr52WLp1m9kk+BzHO7Jxmrp22T9LHZTstxp3TwsFpj7mlrzdhbw/mtj0KfwuC3M5p5tpp9tpp+1Xii9/+Apa9uflrp4Vrp8Vrp6WDv+5Nt2B3/kxtvnZauTRIt1w7zVw7zV47zV26Tu4nGfXTwrXT4rXTyqUrl7925fLXrlzeXjkt7N86brW6Juj+849x7ift4n/83OcWwO+cFK+clK6clK+cVC6ctH9zqp1krpy0L+9j0eC2FhJ2TnPXTvPXTgvXTovXTkvXTsvXTiuXTju4xVdPM9dOu1Yl9lqV7N+rK9eO/Tt12Raoit076cplYP++Wfmm/btm7SR75SR35SR/BcSVy7W7crnej9xLXCuipJ0y2k/RayeVCyf52uV696Qrl+v9u3HtJHflpCsV4a9UhL9SEf7KX66/cgP3V27g4coNPFypiIPXFGSTt/Wf+Oir9x8/yG7r5rJ78qH7R9dW/cPBqwdEh+T1DSnoG1LUN6Skb0hZ35CKuiEdvAVAdEhG35D0Xb1Ti6u33daNszepdvQPd3TY9uT2ydidCfjeJxB6n0DsfQKp9wnk3idQOp9AXnqfgOl9Arb3CfR+J86934lz73fi3PudOPd+J86934mL+vvA+Q5voWi/CtUcWXn/VUjLhoy39eR1jvZpLXxLP0sEzRGaBJojNBk0R2gKaPbRxGUBzREaA5ojNBY0R2gcaI7QeNAcoaEbPkRDN3yIhm74EA3d8CEauuEjNIZu+BAN3fAhGrrhQzR0w4doPGiO0NANH6KhGz5EQzd8iGbebti6Bxpvd9DM2w3X0Nh5u+Eqmnn7miqaee9Qyaw7M9rklh00896hqmjmvUNV0cx7h6qhcfPeoapo5s1rqmjmzWuqaObta6poPGiO0Myb11TR7HbDblnW7XDc8rR/+f5kjbnlqB+H3/5ta3Cs3faiuHXrj1/pu9u/74NKLQYVHnthmfi0HW/nWcn+DgvAucMpwDmEs79jBnDucAxwjuFY4BzDccA5huOBcwwnAOcYTgTOMRw65BM4dMgncOiQj+EEOuQTOHTIJ3DokE/g0CGfwPHAOYZDh3wChw75BA4d8gkcOuQTODN3yDavs7Ru2Xl6Ks7cIVfhzNwhV+HM3CFX4czcIVfheOAcw5m5Q67CmblDrsKZuUOuwpm5Q67CoUM+hpPokE/g0CGfwKFDPoFDh3wCxwPnGA4d8gkcOuQTOHTIJ3DokE/g0CEfw8l0yCdw6JBP4NAhn8ChQz6B44FzDIcO+QQOHfIJHDrkEzh0yCdwZu6Qa7/KLTN3yFU4M3fIVTgzd8hVODN3yFU4HjjHcGbukKtwZu6Qq3Bm7pCrcGbukCtw0sSvPnLb6xGtM2YHzbybh1XRzLt5WBXNxJuinrvxtHjQHKGZd/OwKpp5t9Ktopl3K90qmok3e6+hmXiz9wqaiV99VEUzbzdcRTNvN1xFQzd8iOb9fc3PXl6fyorm9s/HdNeX1yeBV838bAJ5q4TbP8vOBLL2CVi3TcDZnQmUzicg8HKVxhMwvU/A9j4B1/sEvPYJLGmbgF12JhB6n4D2O3F1AurvxLUJqL8T1yag/k5cmYBTfyeuTUD9nfhkAv91+4//7z/++9/+8Z/+/i//cTvp1//6f/71n//zb//2rx//8T//v/+9/i//9O9/+/vf//a//uF///u//fO//I//8+//8g9//7d//vW//WX5+D//Pflo/5pu95sbml9cbnjSX1MK4faf3e//3efb/x7yr//91wlhCfmvYYm/T/h9hi/xdkTJt7Hdxvf/Aw==",
      "brillig_names": [
        "get_total_deposited_assets"
      ]
    },
    {
      "name": "_compute_collateral_debt_value",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8945853978429536226": {
            "error_kind": "string",
            "string": "Function _compute_collateral_debt_value can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_compute_collateral_debt_value"
      ]
    },
    {
      "name": "liquidate_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "debt_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "user",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "debt_to_cover",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "1ZzbbttIDIbfxde+IIeHmemrLBaFkziFAcMJnGSBRdB3r+RakusokTswac1NIAWkP/6ag6g5vS8e1ndvP75vdo9PL4tv/7wvtk/3q9fN0665e/+5XNztN9vt5sf3038voP2DygeHl+fVrr1/eV3tXxffkALLcrHePbTXlKD5kcfNdt3cQXP90R5C6MyBQ2+d44gxZ4hHY86ovbHKiHFiTkfjxMqnxv8um/DzdcLPuTNHzH7hxys9fUn9008TTx8lduGjEn0dfhbio3Fu/M7DT+Ha4WP4I/wWksEDImOQQFG6itFcx6FmCNnWjADwSUAch4AyfR2QUodQGUyz/iaINQHNNaC9hmxNCGxOMNdA5hooWROYzAnRmiDBnGCuQdGcYN5rqHmLi+YtLl6jxTWl2b9A9SSBaLLEAySRB8RDSfZQkqM9hCB4QDyUoIcSVAdIQA+IOEAIPCAuSrIDxDwrIbbOrMg8KyEx16DmGtRcQzTXEK2zQ0rmGpJaEzKYE9icYF1bGcic4JCDsEcOwuihJHgoCQ7ZFBN6QDyUsIcSdsimWMADwh4Qh7yQ1UOJOnw4s3lWwuZZCSc0J4g5wXrMirO5hmytQYDNCeYakMwJ1i1OApoTrGurEJgTHN4S4jEOIuyhhD2UCHlAHN7coh5KPHIQicED4vCRJgk9IA6fNpI9lGTxgFi/0dU8K1GwHu9RDOYE65E9DeYagrkGQnOCuQYGc4J5izOfl1HzeRk1Xy2iV1ktggm6ZY6YMH1gmNfXaN7mzMdANJm3CPMRCjUfoYiA5oQLNCSFiRahrF2L0BNjPjKyPQPZgZGuwcCA/ZJqDCyD+dgCbALGozWB/LFKuA0pxNmFRGF+Ic2v4FhmF9IlcyreIensQtL5VW+9yVPKnTWFOLF7AQEjdL8Ngc73L8RLMpqZK5DaFSSoXkH1ZZBv8aIi7fJDopP9YJ8oiES9gijnChLcontk6p4qMccpBQn6JA8SwQcFt+hNGXFQkKYUZOw3s0GWdK4AoXoFUr2CXLuCS3aazVxB9WXAWL2C6ntTqb4MpPoy0OrLQKsvg1h9VhGrzypi9W+0S7ZwzlpBhnn1RYeQ5lWx25Bm9g1yCIlvEJKEbq6QZPLTFCkPx45woA8Kcu0KAlWvINWugKovA77OIBMlHigQThW0lCvNh0xRkgdFyYGCMD73h8y9G8tQ+EH16KZFbuNfx9NuUuaWi9zGNxFNu41WCxzWDqKGYfCVj17jk1OTXrHEK5WwcPykqq8n3hsvLvHCEl04vpJ/yougyKuIxUUsLmPlEq/xVeuTXkXlNT42MOmlJV6xqPZGKfFKWOSVSrwyFXnlAq9PTpKb9CpiIRV5xb/1+tnc/bfab1Z32/XxFM3Ht939yaGar/8/r8/O13zeP92vH9726/akzeGQzbarCwzLkKWJpn1YIeuSBA69bnPblPGyKbFDEbS3mZtbbWJo4vgF",
      "brillig_names": [
        "liquidate_public"
      ]
    },
    {
      "name": "withdraw_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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odczx4dezxwfej1zfOj1zPGhlzO3+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17O3OFDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfPeTzAdkjk+9Hrm+NDrmeNDL2eu6gzF9P7iGLZrY/xE8T5TTdn1ZzP108y0haN/HFC/FoJ/99L3+IPy+KPy+JPy+LPu+JucHykZv+k6fr+47QBlv+RceGnn92LB+fQU9vpxt21yzmK72bqpZuunmm3fdYP0bPuuMqRn23dNIj3bvisY6dn2Xe8Izzb2XR1Jz3aqWirqraXu8eutju7xe+Xx661g7vHrrUnu8eutMu7xd143mL2h6J3xhZdOi9+a7e4xV5vcwbU5bS+c8+dr71w6rzBacUmd1yLNuHRetTTj0nl904xL53VTMy4eLodcOq/zmnHpvH5sxqXzurQZF+rdYy7Uu4dcMvXuMRfq3WMuvnMuZutHemMP+gG59zqjFH/v9UAp/t7X7VL8va+vpfh7Xwffx2+X3terUvy9ryul+Hvvd5Ti770vUYpf9/prF93rr110r7920b3+2kX3+msX5euvUb7+GuXrr1G+/hrl62+T/f0l41e+/hrl669Rvv4a5euvUb7+WuXrr1W+/lrl669Vvv422ddYMn7l669Vvv5a5euvVb7+WuXrr1O+/jrl669Tvv465etvk/0cJeNXvv465euvU77+OuXrr1O+/nrl669Xvv565euvV77+euXrr1e+/nrl669Xvv565euvV77+rsrX31X5+rsqX39X5etvkz0HJeNXvv52vpNgOX7l62/nOwmW41e+/na+k2A5fuXrb+97AxbjV77+9r5/XzF+5etv73vsFeNXvv72vg9eMX7l62/ve9UV41e+/va+n1wxfuXrb+/7yRXjV77+9r6fXDF+5etv9/vJleJXvv52vz9bKX7l62/3+52V4le+/na/f1gpfuXrb/f7cZXiV77+dr+/VSl+5etv9/tFleJXvv5m5etvVr7+Kt//yirf/8oq3//KKt//yirf/8oq3//KKd//yinf/8op3//KKd//yi2611/X/f5Xp+0rGrZrzbLYTxffwUy70XUJzLQ7XZfATLvVdQnMtHtdF8B0v3lZMzB6TzG5x6/3tJF7/F55/Hqrmnv8eouPe/x6a4R7/HqX8nv8elfc3/F3v6tYKX69pzXc41e+/na/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKFeLvflexUvzK19/udxUrxa98/e1+V7FS/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexUvzK19/udxUrxa98/e1+V7FS/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexUvzK19/udxUrxa98/e1+V7FS/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexUvzK19/udxUrxa98/e1+V7FS/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexUvzK19/udxUrxa98/e1+V7FS/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexUvzK19/udxUrxa98/e1+V7FS/MrX3+53FSvFr3z97X5XsVL8utdf3/2uYqX4da+/vvtdxUrx615//aJ7/fWKdxW7x697/fWK9+i6x697/fWKd7z6Hb/ijanu8Stff5Xvf+WV73/lle9/5Xvf/yq4vMWfFld46R9tLJe2Geb8+do7l87X9WZcOq8XmnHpvA45j8v7DRp97xuMNQPT+85l7cB0XpK1A9N5rdcOTOdFZDswvm8waX9pn3wJTAzu4+IYw36ttx9T7byQlZxq57Wp5FQ7LzffTPUef+dlYTH+zqu3Uvydb0+3Gr9uF5twYM87356uHH/fJUs5/r4ri3L8Xnn8fa/q5fj7XqrL8fe9/pbj73v9Lcff9/r7HL819mv8nW9PV45fz/p7HL+e9fc4fj3r73H8etbf4/g7X3+jifvFKR/E3/n6W4y/8/W3GH/n628x/s7X31L8nW9PV46/8/W3GH/n628x/s7X32L8na+/xfiVr7+db09Xjl/5+tv59nRrcst2cQ6p8NI+75N9/ipTsgfX2rhsxxnbaB+Vbfjg0vm63opL59vptePSeR0ixOU+185rFtG5dl7fiM7VTzTXzusm0bl2XmOJzrXzeuxHc7213LaLfTqY60i1W2muI9Vjhbl2vmWi7FxHqptKcx2pbirNdaS6qTRXP9FcR6qbSnMdqW5a171uSgd1U+fbTMrOdai6qTDXoeqm93PtfKtL2bkOVTcV5jpU3VSY61B1U2GufqK5DlU3FeY6Ud3U+fag7+Z6j19vLXSPX2998zv+zrcHLcevtw65x6+3trjH33e9EJZlCyS4YA7i98rj73tdL8ff91pdjr/v9bccf9/rbzn+vtffUvxr59uDluPve/0tx9/3+luOX/f6uy6619+18+1By/HrXn/XzrcHLceve/1dO98etBh/59uDluNXvv52vj1oOX7l62/n24OW41e+/na+jWc5fuXrb+fbYpbjV77+dr7JZDl+5etv51s2luNXvv52vgFiOX7l62/nWxWW41e+/na+/2A5fuXrb+f7D5bjV77+dr7/YDl+5etv5/sPluNXvv52vv9gOX7l62/n+w+W41e+/na+/2A5fuXrb+f7D5bjV77+dr7/YDl+5etv5/sPluNXvv52vv9gOX7l62/n+w+W41e+/na+/2A5fuXrb+f7D5bjV77+dr7/YDl+5etv5/sPluNXvv52vp9fOX7l62/ne+mV41e+/na+5105fuXrb+d705XjV77+dr6HXDl+5etv53u9leNXvv52vidbOX7l62/ne6eV41e+/na+x1k5fuXrb+d7kZXjV77+dr5nWDl+5etv53t7leNXvv52vgdXOX7l62/ne2WV41e+/na+/1U5fuXrb+f7X5XjV77+dr7/VTl+5euv8v2vVuX7X63K979ale9/tSrf/2pVvv9VUL7/VVC+/1VQvv9VUL7/VVh0r79B+f5XQfn+V0H5/ldB+f5XQfn+V0H5/ldB+f5XQfn+V0H5/leh9/2vfNouDquxB/F3vv66uPO/DSy8dFr8x8XJPc4Kt8kdXJvT9sI5f772zqXzdb0Zl87rhWZcOq9DmnHpvL5pxaX3fcuacem8HmvGpfM6rxmXzuvHZlw8XA65UO8ec6HePeZCvXvMhXr3mAv17iGX3vcJbMZl2no3bNeaZbEHYKYteEtgpq14S2A8YI7BTFvzlsBMW/SWwHRexawpb2BuT2AKL23WvLhtums2br8+3Gfb+x5+b2Z7j7/zFaEYf9837hjjdnGMTzXc8UvbGNaPq22M7vml75Pt+2YsPNm+b7DCk+27VSA82b79v/Bk+14OZSfb+Y6GwpPt234LT7bvOuenk812m2x6qir2yfZdFAlP1s802ZEqKGeXrTh21savkx2pgipOdqQKqjjZkSqo4mRHqqBuk13eTbbzPRF/OFlvtqudt8vXyY60zhYnO9I6W5zsUOtsabJDrbMup32yZnn/0muO2617zfngbjbUovwTMmHZ7/NhOShEO9978pqcOSYz1HLv3V7b+NX82aep8/0yryFzmDOd78T5UzL7ozvnc/o62bFKxMJkxyoRC5P1M012rBLxMdn16an4PtmhSsTSZIeq+kqTHaqQK012qNrMPQJZTXz/0iakrZ430T/9GNYvdzSdb0b6QzRx/+mvi9n9Wdna+TanJ5IpmcDON1C9JmeOyfihyOwv7f7yUOrgRrPk/Qtnxi0HN5qh6qZk/Y4mF17aL1vQ3n6+Ax9gfLQkzK19t1/tdoxDVWTtMA5V67XDOFQV2Q7jUPVpM4ydb0ysBuNQlqAdxqH8w48wus0++OcZ7mCGsg+SYDr/0ZLsT1B638ZZeLad/6heeLad/1ReeLYz/XQs9r79tPBsO/+xuvBs9f4ssGa2en9EWDNbP9ZsnX/MdrVPsz2+2j5dHb6wGazyEmUzWJ0mymawqu4HbLzZ/a+3T48hNzKDVYCCZAarFuXI9L6xekMyg1WhgmQGq1gFyQxW3QqS8ZB5QWbeOrhEZt4quESGGvgVGWrgV2RGq4FfucSD1077NzKje/rR0YvXzmmb5A3j02EsN/6/Sfa+qb4ikqPV2DIk72xGq7Il2YxWZ7/teL3YNN3sOzE6a3NhtiYt26Y9JplnNvlwtstjtkt4nu09onh9RPYR0dfNEOKLjcJbRpR7i+jF5tgtIzLdRWSvj8iHx52l8JVv6/dbnPXefw3f6Q7f6w5/1R1+0B1+1B1+0h1+Vh2+XzoP36ZH+F8LMm90h9/7qlsIv/NVd123mseu4c9+iBh950v0T+Za+Glh9J2v56tx+1xjYV+UtJ8wnPxTzB/fg46+87Vfcqqd1wmSU+28ppCcauf1h+BU185rFcmp9r6y/mSq6xZGiuHTVA9e2LhH5/xpy6tf20l8vfjxa/rl06V3hL0v2AoQjlQHNEI4Un3RCOFIdUsjhCPVQ20QxpGKj58gXB7HBZinR2KHCFPagsim+KPm23vvj/9SjE/npOX0wbzz7s6QzDtvSQ3JfNZqvyVzD/PLmc/qJ1oyn9WAtGQ+q2NpyXxWi9OS+Ui9ZyXMEz70eub40OuZ40OvZ44PvZ65h/nlzPGh1zPHh17PHB96PXN86PXM8aGXM8/40OuZ40OvZ44PvZ45PvR65h7mlzPHh17PHB96PXN86PXM8aHXM8eHXs08LfjQ65njQ69njg+9njk+9HrmHuaXM8eHXs8cH3o9c3zo9czxodczx4deztzgQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxodczx4dezxwfejlziw+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzB0+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzPv/YDbIZnjQ69njg+9njk+9HrmHuaXM8eHXs8cH3o9c3zo9czxodczx4deznyow8u1MMeHXs8cH3o9c3zo9cw9zC9njg+9njk+9Hrm+NDrmeNDr2eOD72cecCHXs8cH3o9c3zo9czxodcz9zC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYRH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZJ3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ57xodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZp5XvCh1zPHh17PHB96PXN86PXMPcwvZ44PvZ45PvR65vjQ65njQ69njg+9nLnBh17PHB96PXN86PXM8aHXM/cwv5w5PvR65vjQ65njQ69njg+9njk+9HLmFh96PXN86PXM8aHXM8eHXs/cw/xy5vjQ65njQ69njg+9njk+9Hrm+NDLmTt86PXM8aHXM8eHXs8cH3o9cw/zy5njQ69njg+9njk+9Hrm+NDrmeNDL2fu8aHXM8eHXs8cH3o9c3zo9cw9zC9njg+9njk+9Hrm+NDrmeNDr2eOD72c+YoPvZ45PvR65vjQ65njQ69n7mF+OXN86PXM8aHXM8eHXs8cH3o9c3zo5cwDPvR65vjQ65njQ69njg+9nrmH+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczj/jQ65njQ69njg+9njk+9HrmHuaXM8eHXs8cH3o9c3zo9czxodczx4dezjzhQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxodczx4dezxwfejnzjA+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjFzN2y4EOvZ44PvZ45PvR65vjQ65l7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ssTWZYmtyxJblyWuLktcXZa4uixxdVni6rLE1WWJq8sSV5clri5LXF2W+Los8XVZ4uuyxNdlia/LEl+XJb4uS3xdlvi6LPF1WbLWZclalyVrXZasdVmy1mXJWpcla12WrHVZstZlyVqXJaEuS0JdloS6LAl1WRLqsiTUZUmoy5JQlyWhLktCXZbEuiyJdVkS67Ik1mVJrMuSWJclsS5LYl2WxLosiXVZkuqyJNVlSarLklSXJakuS1JdlqS6LEl1WZLqsiTVZUmuy5JclyW5LktyXZbkuizJdVmS67Ik12VJrsuSut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZoXvde8f8PQZG8Ohr3Ikn1LP5Oz/TTsaCtfoYNCbuHEvsJJfYWTuwrnVW+7VTimr3BsX+G4vsLxfYWz9hVOX3fl1NddOfV1V0593ZVzX3fl3NddOfd1V8593ZXz1Xflt2dc3eJZO4sndBZP7Cye1Fk8uat47PETXHsrXT+GWWvWQjw3h77s4Yf4190Lbm9irngTe8WbOJE3ceHxJsE9vcnBL/KS2zYGcsvzvk/L8Xaqy77n2uIev73P9iN+33n8684/rM59jX9VHn9QHn9UHn9SHn/WHb9ZlMdvlMdvlcff+/pbil/5+muUr79G+fprlK+/Rvn6a5Svv1b5+muVr79W+fprla+/Vvn6a5Wvv1b5+muVr79W+fprla+/Tvn665Svv075+uuUr79O+frrlK+/Tvn665Svv075+uuUr79e+frrla+/Xvn665Wvv175+uuVr79e+frrla+/Xvn665Wvv6vy9XdVvv6uytffVfn6uypff1fl6++qfP1dla+/q/L1d1W+/gbl629Qvv4G5etvUL7+BuXr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",
      "brillig_names": [
        "discover_new_messages",
        "decompose_hint",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "constructor",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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Lm3GhXr3mAv17iGXTL17zIV695iL75yL2fqR3tiDfkDuvc4oxd97PVCKv/d1uxR/7+trKf7e18Hv47dL7+tVKf7e15VS/L33O0rx996XKMWve/21i+711y6611+76F5/7aJ7/bWL8vXXKF9/jfL11yhff43y9bfJ/v6S8Stff43y9dcoX3+N8vXXKF9/rfL11ypff63y9dcqX3+b7GssGb/y9dcqX3+t8vXXKl9/rfL11ylff53y9dcpX3+d8vW3yX6OkvErX3+d8vXXKV9/nfL11ylff73y9dcrX3+98vXXK19/vfL11ytff73y9dcrX3+98vXXK19/V+Xr76p8/V2Vr7+r8vW3yZ6DkvErX38730mwHL/y9bfznQTL8StffzvfSbAcv/L1t/e9AYvxK19/e9+/rxi/8vW39z32ivErX3973wevGL/y9bf3veqK8Stff3vfT64Yv/L1t/f95IrxK19/e99Prhi/8vW3+/3kSvErX3+735+tFL/y9bf7/c5K8Stff7vfP6wUv/L1t/v9uErxK19/u9/fqhS/8vW3+/2iSvErX3+z8vU3K19/le9/ZZXvf2WV739lle9/ZZXvf2WV73/llO9/5ZTvf+WU73/llO9/5Rbd66/rfv+r0/YVDdtYsyz20+A7mGk3ui6BmXan6xKYabe6LoGZdq/rApjuNy9rBkbvKSb3+PWeNnKP3yuPX29Vc49fb/Fxj19vjXCPX+9Sfo9f74r7O/7udxUrxa/3tIZ7/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexQvzd7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf9/rru99VrBS/7vXXd7+rWCl+3euvX3Svv17xrmL3+HWvv17xHl33+HWvv17xjle/41e8MdU9fuXrr/L9r7zy/a+88v2vfO/7XwWXt/jT4gov/aON5dI2w5w/j71z6Xxdb8al83qhGZfO65DzuHy/QaPvfYOxZmB637msHZjOS7J2YDqv9dqB6byIbAfG9w0m7S/tky+BicF9DI4x7GO9/Zhq54Ws5FQ7r00lp9p5ufnNVO/xd14WFuPvvHorxd/59nSr8es22IQDe9759nTl+PsuWcrx911ZlOP3yuPve1Uvx9/3Ul2Ov+/1txx/3+tvOf6+19/n+K2xX+PvfHu6cvx61t/j+PWsv8fx61l/j+PXs/4ex9/5+htN3AenfBB/5+tvMf7O199i/J2vv8X4O19/S/F3vj1dOf7O199i/J2vv8X4O19/i/F3vv4W41e+/na+PV05fuXrb+fb063JLdvgHFLhpX3eJ/v8VaZkD8bauGzHGdtoH5Vt+ODS+breikvn2+m149J5HSLE5T7XzmsW0bl2Xt+IztVPNNfO6ybRuXZeY4nOtfN67EdzvbXctsE+Hcx1pNqtNNeR6rHCXDvfMlF2riPVTaW5jlQ3leY6Ut1UmqufaK4j1U2luY5UN63rXjelg7qp820mZec6VN1UmOtQddP3c+18q0vZuQ5VNxXmOlTdVJjrUHVTYa5+orkOVTcV5jpR3dT59qDfzfUev95a6B6/3vrmd/ydbw9ajl9vHXKPX29tcY+/73ohLMsWSHDBHMTvlcff97pejr/vtbocf9/rbzn+vtffcvx9r7+l+NfOtwctx9/3+luOv+/1txy/7vV3XXSvv2vn24OW49e9/q6dbw9ajl/3+rt2vj1oMf7Otwctx698/e18e9By/MrX3863By3Hr3z97Xwbz3L8ytffzrfFLMevfP3tfJPJcvzK19/Ot2wsx698/e18A8Ry/MrX3863KizHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18/8Fy/MrX3873HyzHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18/8Fy/MrX3873HyzHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18P79y/MrX38730ivHr3z97XzPu3L8ytff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M0/40OuZ40OvZ44PvZ45PvR65h7mlzPHh17PHB96PXN86PXM8aHXM8eHXs4840OvZ44PvZ45PvR65vjQ65l7mF/OHB96PXN86PXM8aHXM8eHXs8cH3o187zgQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxodczx4dezxwfejlzgw+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzC0+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzN3+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17O3ONDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfMVH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZB3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZx7xodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZx5wodezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5hkfej1zfOj1zPGh1zPHh17P3MP8cub40OuZ40OvZ44PvZ45PvR65vjQi5m7ZcGHXs8cH3o9c3zo9czxodcz9zC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYGH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZW3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ+7wodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZy5x4dezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5is+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzMP+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17OPOJDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfOED72eOT70eub40OuZ40OvZ+5hfjlzfOj1zPGh1zPH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+E3SFW+SL3iTF4/Mhd/Enf7RzBL3sG9/u5byev5bhPPfIp7/Fun8t8hnv0VelvPfQmI9+faHWXmx57+FO/8t/NkLb17W898inP8W8fy3SOe/RT79Lcxy/luY89/Cnv8Wh0m7rlvXdE3PlZ79uCjWXJRqLjpOlSXus/r1d/5LRZJfPOZaYt5L2OX2oPjLZabuMlt3mau77PhmudweKD0ue9qEfbtsrbss1F0Wqy5zL3TLj+3olxzMl8tekMxp25bemGX5QtL5usvWusti3dxS3WUvPjg5u6cg179e5pe6y0zdZbbuMld3ma+7bK277PiDcxuaH5fZ5yz5+89z6ng/Lek3SVe8Sf7zN/n+WWQ+fkIo+xbm/LewP32L+2Wu7jJfd1ndLfLF87niZbHuslR3Wa66LCx1l5m6y2zdZXULaahbSF886ojrfmON8flnqkefFhuX/RtG0dovb5FPf4sXjzpE38Kc/xb2/Ldw57+FP/8t1vPfIpz/FvH8tzj/0x3P/3Sn8z/d6fxPdzr/053O/3Sn8z/d6fxPdzr/053O/3SnH3+675flqsvyUneZqbvM1l3m6i7zdZetdZeFusti3WV1WZJrsmRdlqXuMlN3ma27zNVd5usuW+suC3WXxbrLUt1ldVli6rLE1GWJqcsSU5clpi5LTF2WmLosMXVZYuqyxNRlia3LEluXJbYuS2xdlti6LLF1WWLrssTWZYmtyxJblyWuLktcXZa4uixxdVni6rLE1WWJq8sSV5clri5LXF2W+Los8XVZ4uuyxNdlia/LEl+XJb4uS3xdlvi6LPF1WbLWZclalyVrXZasdVmy1mXJWpcla12WrHVZstZlyVqXJaEuS0JdloS6LAl1WRLqsiTUZUmoy5JQlyWhLktCXZbEuiyJdVkS67Ik1mVJrMuSWJclsS5LYl2WxLosiXVZkuqyJNVlSarLklSXJakuS1JdlqS6LEl1WZLqsiTVZUmuy5JclyW5LktyXZbkuizJdVmS67Ik12VJrsuSut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZoXvde8f8PQZG8OLnuRJfuWfiZn++myo618hQ4KuYUT+won9RVO7iqcV73tVuGYvsKxfYXj+grH9xXO2lc4fd2VU1935dTXXTn1dVfOfd2Vc1935dzXXTn3dVfOV9+Vvz3j6hbP2lk8obN4YmfxpM7iyV3FY4+f4Npb6fpxmbVmLcRzc+jLHn6If9294PYm5oo3sVe8iRN5ExcebxLc05sc/CIvuW1jILc87/u0HG+nuux7ri3u8dv7bD/i953Hv+78w+rc1/hX5fEH5fFH5fEn5fFn3fGbRXn8Rnn8Vnn8va+/pfiVr79G+fprlK+/Rvn6a5Svv0b5+muVr79W+fprla+/Vvn6a5Wvv1b5+muVr79W+fprla+/Vvn665Svv075+uuUr79O+frrlK+/Tvn665Svv075+uuUr79O+frrla+/Xvn665Wvv175+uuVr79e+frrla+/Xvn665Wvv175+rsqX39X5evvqnz9XZWvv6vy9XdVvv6uytffVfn6uypff1fl629Qvv4G5etvUL7+BuXrb1C+/gbl629Qvv4G5etvUL7+BuXrb1S+/kbl629Uvv5G5etvVL7+RuXrb1S+/kbl629Uvv5G5etvUr7+JuXrb1K+/ibl629Svv4m5etvUr7+JuXrb1K+/ibl629Wvv5m5etvVr7+ZuXrb1a+/mbl629Wvv5m5etvVr7+Zt3rr1t0r79u0b3+ukX3+uu63/+qFL/u9dcp3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yivf/8or3//KK9//yivf/8ovutdfr3z/K9/9/lePlw4xm+f4jwZvUYcUHi+c1o+59r5WS86193Vdcq691wCCc+1+vy7JufZeW0jOtfM6ZM1reszVfj9XH/MWh08u7YNtTodhm7hH7fw+2rn8wabzGqcpGw+bl2w6r83i6u3H6BiW8D0b57axzj8FfTR0DesW8hqXp8G/6r+vMee8v/KypE+j7xg7LxG1YOy8+tSCsfPCVgvGzmtmJRh7375PC8bOK30tGDs3EVowdu43tGD0YJTAiIsRwYiLEcGIixHBiIsRwYiLkcDY+yaoWjDiYkQw4mJEMOJiRDB6MEpgxMWIYMTFiGDExYhgxMWIYMTFSGDsfStpLRhxMSIYcTEiGHExIhg9GCUw4mJEMOJiRDDiYkQw4mJEMOJiJDD2viG/Foy4GBGMuBgRjLgYEYwejBIYcTEiGHExIhhxMSIYcTEiGHExEhh7P9ZEC0ZcjAhGXIwIRlyMCEYPRgmMuBgRjLgYEYy4GBGMuBgRjLgYCYy9Hw6lBSMuRgQjLkYEIy5GBKMHowRGXIwIRlyMCEZcjAhGXIwIRlyMBMbej9jTghEXI4IRFyOCERcjgtGDUQIjLkYEIy5GBCMuRgQjLkYEIy5GAmPvB5VqwYiLEcGIixHBiIsRwejBKIERFyOCERcjghEXI4IRFyOCERcjgHHt/bhnLRhxMSIYcTEiGHExIhg9GCUw4mJEMOJiRDDiYkQw4mJEMOJiJDD2fgi9Foy4GBGMuBgRjLgYEYwejBIYcTEiGHExIhhxMSIYcTEiGHExEhgtLkYEIy5GBCMuRgQjLkYEowejBEZcjAhGXIwIRlyMCEZcjAhGXIwERoeLEcGIixHBiIsRwYiLEcHowSiBERcjghEXI4IRFyOCERcjghEXI4HR42JEMOJiRDDiYkQw4mJEMHowSmDExYhgxMWIYMTFiGDExYhgxMVIYFxxMSIYcTEi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",
      "brillig_names": [
        "get_contract_instance_internal",
        "decompose_hint",
        "lte_hint",
        "discover_new_messages",
        "notify_created_nullifier_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "repay_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fromPublicBalance",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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PvR65vjQ65njQ69njg+9njk+9HLmBh96PXN86PXM8aHXM8eHXs9cYH45c3zo9czxodczx4dezxwfej1zfOjlzC0+9Hrm+NDrmeNDr2eOD72eucD8cub40OuZ40OvZ44PvZ45PvR65vjQy5k7fOj1zPGh1zPHh17PHB96PXOB+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczF3zo9czxodczx4dezxwfej1zgfnlzPGh1zPHh17PHB96PXN86PXM8aGXM5/xodczx4dezxwfej1zfOj1zAXmlzPHh17PHB96PXN86PXM8aHXM8eHXs7c40OvZ44PvZ45PvR65vjQ65kLzC9njg+9njk+9Hrm+NDrmeNDr2eOD72cecCHXs8cH3o9c3zo9czxodczF5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfOID72eOT70eub40OuZ40OvZy4wv5w5PvR65vjQ65njQ69njg+9njk+9HLmCz70eub40OuZ40OvZ44PvZ65wPxy5vjQ65njQ69njg+9njk+9Hrm+NCLmbtpwodezxwfej1zfOj1zPGh1zMXmF/OHB96PXN86PXM8aHXM8eHXs8cH3o5c4MPvZ45PvR65vjQ65njQ69nLjC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYWH3o9c3zo9czxodczx4dez1xgfjlzfOj1zPGh1zPHh17PHB96PXN86OXMHT70eub40OuZ40OvZ44PvZ65wPxy5vjQ65njQ69njg+9njk+9Hrm+NDLmQs+9Hrm+NDrmeNDr2eOD72eucD8cub40OuZ40OvZ44PvZ45PvR65vjQy5nP+NDrmeNDr2eOD72eOT70euYC88uZ40OvZ44PvZ45PvR65vjQ65njQy9n7vGh1zPHh17PHB96PXN86PXMBeaXM8eHXs8cH3o9c3zo9czxodczx4dezjzgQ69njg+9njk+9Hrm+NDrmQvML2eOD72eOT70eub40OuZ40OvZ44PvZx5xIdezxwfej1zfOj1zPGh1zMXmF/OHB96PXN86PXM8aHXM8eHXs8cH3o58wUfej1zfOj1zPGh1zPHh17PXGB+OXN86PXM8aHXM8eHXs8cH3o9c3zo1czNhA+9njk+9Hrm+NDrmeNDr2cuML+cOT70eub40OuZ40OvZ44PvZ45PvRy5gYfej1zfOj1zPGh1zPH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Jq/3avJ6ryav92ryeq8mr/dqDnqvy/aGoVnE7Aw7yJJtSz+zLPbTsL2tfJUOCrmFE+oKJ9YVzlJVOEe97VLhmLrCsXWF4+oKR+oKZ64rnLruyrGuu3Ks664c67orL3XdlZe67spLXXflpa678nL1XfnlGVe3eObK4vGVxRMqiydWFs9SVTx2/wmuvZWuH8OsNXMinptDn7bwffjz7gW3LzFXfIm94kucypc4//gS756+ZOcXedGtGwO56Xnfp2l/O9Vp23Ntco/f3i/2I36pPP554+9n577GPzcev288/tB4/LHx+Je24zdT4/GbxuO3jcdf+/qbir/x9dc0vv6axtdf0/j6axpff03j669tfP21ja+/tvH11za+/trG11/b+PprG19/bePrr218/bWNr7+u8fXXNb7+usbXX9f4+usaX39d4+uva3z9dY2vv67x9dc1vv5K4+uvNL7+SuPrrzS+/krj6680vv5K4+uvNL7+SuPrrzS+/s6Nr79z4+vv3Pj6Oze+/s6Nr79z4+vv3Pj6Oze+/s6Nr79z4+uvb3z99Y2vv77x9dc3vv76xtdf3/j66xtff33j669vfP31ja+/ofH1NzS+/obG19/Q+PobGl9/Q+Prb2h8/Q2Nr7+h8fU3NL7+xsbX39j4+hsbX39j4+tvbHz9jY2vv7Hx9Tc2vv7Gxtff2Pj6uzS+/i6Nr79L4+vv0vj6uzS+/i6Nr79L4+vv0vj6uzS+/i5tr79uanv9dVPb66+b2l5/XfX7X6Xib3v9dY3vf+Ua3//KNb7/lWt8/yvX+P5XrvH9r1zj+1+5xve/co3vf+Ua3//KNb7/lWt8/yvX+P5XrvH9r1zj+1+5xve/co3vf+Ua3//KNb7/lWt8/yvX+P5XrvH9r1zj+1+5xve/co3vf+Ua3//KNb7/lWt8/yvX+P5XrvH9r1zj+1+5xve/co3vf+Ua3//KNb7/lWt8/yvX+P5XrvH9r1zj+1+5xve/co3vf+Ua3//KNb7/lWt8/yvX+P5XrvH9r1zj+1+5xve/co3vf+Ua3//KNb7/lWt8/yvX+P5XrvH9r1zj+1+5xve/co3vf+Ua3//KNb7/lWt8/yvX+P5XrvH9r1zj+1+5xve/co3vf+Ua3//KNb7/lWt8/yvX+P5XrvH9r1zj+1+5xve/co3vf+Ua3//KNb7/lWt8/yvX+P5X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",
      "brillig_names": [
        "discover_new_messages",
        "decompose_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "951653053333916160": {
            "error_kind": "string",
            "string": "Deposit cap exceeded"
          },
          "1602191554767750373": {
            "error_kind": "string",
            "string": "Function _borrow can only be called internally"
          },
          "1840251649407153602": {
            "error_kind": "string",
            "string": "Insufficient borrowed amount"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4270187767586857285": {
            "error_kind": "string",
            "string": "Function _compute_total_collateral_value can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5235018679007078561": {
            "error_kind": "string",
            "string": "Invalid asset or market id"
          },
          "6787403583199288031": {
            "error_kind": "string",
            "string": "Insufficient balance"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8945853978429536226": {
            "error_kind": "string",
            "string": "Function _compute_collateral_debt_value can only be called internally"
          },
          "10435052277855889085": {
            "error_kind": "string",
            "string": "Function _withdraw can only be called internally"
          },
          "12348881442450494403": {
            "error_kind": "string",
            "string": "Function _compute_utilization_rate can only be called internally"
          },
          "13135008234568508716": {
            "error_kind": "string",
            "string": "Function _repay can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14434150440419769526": {
            "error_kind": "string",
            "string": "collateral >= debt"
          },
          "14687457983715723088": {
            "error_kind": "string",
            "string": "Asset is not borrowable"
          },
          "15333773746166717806": {
            "error_kind": "string",
            "string": "Insufficient collateral"
          },
          "16022896159229267359": {
            "error_kind": "string",
            "string": "Function _deposit can only be called internally"
          },
          "16523063005220065570": {
            "error_kind": "string",
            "string": "Function _liquidate can only be called internally"
          },
          "17134621154673181869": {
            "error_kind": "string",
            "string": "Function _compute_borrow_rate can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AAYkAgAGAACYDiMAAJc7CygABYBfAAYkAgAGAACX3iMAAJdQCygABYBkAAYkAgAGAACXriMAAJdlCygABYBmAAYkAgAGAACXficCDQQAPAkBDQsoAAyARQAFJAIABQAAl5MlAADHri0MAQctDAIILQwDCS0MBAouCIBnAAsjAACZXgsoAAyARQAFJAIABQAAl8MlAADHri0MAQctDAIILQwDCS0MBAouCIBlAAsjAACZXgsoAAyARQAFJAIABQAAl/MlAADHri0MAQctDAIILQwDCS0MBAouCIBgAAsjAACZXgsoAAyARQAFJAIABQAAmCMlAADHri0MAQctDAIILQwDCS0MBAouCIBhAAsjAACZXgsoAAyARQAFJAIABQAAmFMlAADHri0MAQctDAIILQwDCS0MBAouCIBiAAsjAACZXgsoAAyARQAFJAIABQAAmIMlAADHri0MAQctDAIILQwDCS0MBAouCIBjAAsjAACZXgsoAAyARQAFJAIABQAAmLMlAADHri0MAQctDAIILQwDCS0MBAouCIBkAAsjAACZXgsoAAyARQAFJAIABQAAmOMlAADHri0MAQctDAIILQwDCS0MBAouCIBmAAsjAACZXgsoAAyARQAFJAIABQAAmRMlAADHri0MAQctDAIILQwDCS0MBAouCIBoAAsjAACZXgsoAAyARQAFJAIABQAAmUMlAADHri0MAQctDAIILQwDCS0MBAouCIBpAAsjAACZXi0MCgQtDAcBLQwIAi0MCwUtDAkDJiUAAH8ALQgBCycCDAQEABABDAEnAwsEAQAoCwIMLQwMDS4KgEgADQAoDQINLgqASAANACgNAg0uCoBIAA0tCAEMJwINBAUAEAENAScDDAQBACgMAg0tDA0OLgqASAAOACgOAg4uCoBIAA4AKA4CDi4KgEgADgAoDgIOLgqAagAOLQgBDQAAAQIBLQ4LDS0IAQsAAAECAS0ODAstCAEMAAABAgEuCoBGAAwtCAEOAAABAgEuCoBFAA4nAg8EEC0IABAtDA0RLQwLEi0MDBMtDA4ULQwEFQAQAA8AJQAAxXctBAAAJwIEBA8tCAAPLQwNEC0MCxEtDAwSLQwOEy0MBhQAEAAEACUAAMV3LQQAAC0NDgQLKAAEgEUABiQCAAYAAJqeJwIPBAA8CQEPJwIEBA8tCAAPLQwNEC0MCxEtDAwSLQwOEwAQAAQAJQAAxqAtBAAALQ0NBC0NCwYtDQwPLQ4EDS0OBgstDg8MLgqASQAOASgABoBKAAstDQsECygABYBZAAYLKAAEgEgACyQCAAYAAJ0IIwAAmwwLKAAFgGAABiQCAAYAAJzeIwAAmyELKAAFgGEABiQCAAYAAJy0IwAAmzYLKAAFgGIABiQCAAYAAJyKIwAAm0sLKAAFgGMABiQCAAYAAJxgIwAAm2ALKAAFgGUABiQCAAYAAJw2IwAAm3ULKAAFgGcABiQCAAYAAJwMIwAAm4oLKAAFgGgABiQCAAYAAJviIwAAm58LKAAFgGkABiQCAAYAAJu4JwIMBAA8CQEMCygAC4BFAAUkAgAFAACbzSUAAMeuLQwBBy0MAggtDAMJLQwECiMAAJ0yCygAC4BFAAUkAgAFAACb9yUAAMeuLQwBBy0MAggtDAMJLQwECiMAAJ0yCygAC4BFAAUkAgAFAACcISUAAMeuLQwBBy0MAggtDAMJLQwECiMAAJ0yCygAC4BFAAUkAgAFAACcSyUAAMeuLQwBBy0MAggtDAMJLQwECiMAAJ0yCygAC4BFAAUkAgAFAACcdSUAAMeuLQwBBy0MAggtDAMJLQwECiMAAJ0yCygAC4BFAAUkAgAFAACcnyUAAMeuLQwBBy0MAggtDAMJLQwECiMAAJ0yCygAC4BFAAUkAgAFAACcySUAAMeuLQwBBy0MAggtDAMJLQwECiMAAJ0yCygAC4BFAAUkAgAFAACc8yUAAMeuLQwBBy0MAggtDAMJLQwECiMAAJ0yCygAC4BFAAUkAgAFAACdHSUAAMeuLQwBBy0MAggtDAMJLQwECiMAAJ0yLQwKBC0MBwEtDAgCLQwJAyYlAAB/AC8MAAQABS0IAQQnAgYEAgAQAQYBJwMEBAEAKAQCBi0MBgctDgUHJwIGBActCAAHLQwECAAQAAYAJQAAx8AtBAAALQwIBS0MBQEmJQAAfwAtCAEMJwINBAQAEAENAScDDAQBACgMAg0tDA0OLgqASAAOACgOAg4uCoBIAA4AKA4CDi4KgEgADi0IAQ0nAg4EBQAQAQ4BJwMNBAEAKA0CDi0MDg8uCoBIAA8AKA8CDy4KgEgADwAoDwIPLgqASAAPACgPAg8uCoBqAA8tCAEOAAABAgEtDgwOLQgBDAAAAQIBLQ4NDC0IAQ0AAAECAS4KgEYADS0IAQ8AAAECAS4KgEUADycCEAQRLQgAES0MDhItDAwTLQwNFC0MDxUtDAQWABAAEAAlAADFdy0EAAAnAgQEEC0IABAtDA4RLQwMEi0MDRMtDA8ULQwGFQAQAAQAJQAAxXctBAAALQ0PBAsoAASARQAGJAIABgAAnr0nAhAEADwJARAnAgQEEC0IABAtDA4RLQwMEi0MDRMtDA8UABAABAAlAADGoC0EAAAtDQ4ELQ0MBi0NDRAtDgQOLQ4GDC0OEA0uCoBJAA8BKAAGgEoADC0NDAQLKAAFgFcABgsoAASASAAMJAIABgAAoZwjAACfKwsoAAWAWAAGJAIABgAAoWwjAACfQAsoAAWAWgAGJAIABgAAoTwjAACfVQsoAAWAWwAGJAIABgAAoQwjAACfagsoAAWAXAAGJAIABgAAoNwjAACffwsoAAWAXQAGJAIABgAAoKwjAACflAsoAAWAXgAGJAIABgAAoHwjAACfqQsoAAWAXwAGJAIABgAAoEwjAACfvgsoAAWAZAAGJAIABgAAoBwjAACf0wsoAAWAZgAGJAIABgAAn+wnAg0EADwJAQ0LKAAMgEUABSQCAAUAAKABJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAZwALIwAAocwLKAAMgEUABSQCAAUAAKAxJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAZQALIwAAocwLKAAMgEUABSQCAAUAAKBhJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAYAALIwAAocwLKAAMgEUABSQCAAUAAKCRJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAYQALIwAAocwLKAAMgEUABSQCAAUAAKDBJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAYgALIwAAocwLKAAMgEUABSQCAAUAAKDxJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAYwALIwAAocwLKAAMgEUABSQCAAUAAKEhJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAZAALIwAAocwLKAAMgEUABSQCAAUAAKFRJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAZgALIwAAocwLKAAMgEUABSQCAAUAAKGBJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAaAALIwAAocwLKAAMgEUABSQCAAUAAKGxJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAaQALIwAAocwtDAoELQwHAS0MCAItDAsFLQwJAyYlAAB/AC0IAQsnAgwEBAAQAQwBJwMLBAEAKAsCDC0MDA0uCoBIAA0AKA0CDS4KgEgADQAoDQINLgqASAANLQgBDCcCDQQFABABDQEnAwwEAQAoDAINLQwNDi4KgEgADgAoDgIOLgqASAAOACgOAg4uCoBIAA4AKA4CDi4KgGoADi0IAQ0AAAECAS0OCw0tCAELAAABAgEtDgwLLQgBDAAAAQIBLgqARgAMLQgBDgAAAQIBLgqARQAOJwIPBBAtCAAQLQwNES0MCxItDAwTLQwOFC0MBBUAEAAPACUAAMV3LQQAACcCBAQPLQgADy0MDRAtDAsRLQwMEi0MDhMtDAYUABAABAAlAADFdy0EAAAtDQ4ECygABIBFAAYkAgAGAACjDCcCDwQAPAkBDycCBAQPLQgADy0MDRAtDAsRLQwMEi0MDhMAEAAEACUAAMagLQQAAC0NDQQtDQsGLQ0MDy0OBA0tDgYLLQ4PDC4KgEkADgEoAAaASgALLQ0LBAsoAAWAWQAGCygABIBIAAskAgAGAACldiMAAKN6CygABYBgAAYkAgAGAAClTCMAAKOPCygABYBhAAYkAgAGAAClIiMAAKOkCygABYBiAAYkAgAGAACk+CMAAKO5CygABYBjAAYkAgAGAACkziMAAKPOCygABYBlAAYkAgAGAACkpCMAAKPjCygABYBnAAYkAgAGAACkeiMAAKP4CygABYBoAAYkAgAGAACkUCMAAKQNCygABYBpAAYkAgAGAACkJicCDAQAPAkBDAsoAAuARQAFJAIABQAApDslAADHri0MAQctDAIILQwDCS0MBAojAACloAsoAAuARQAFJAIABQAApGUlAADHri0MAQctDAIILQwDCS0MBAojAACloAsoAAuARQAFJAIABQAApI8lAADHri0MAQctDAIILQwDCS0MBAojAACloAsoAAuARQAFJAIABQAApLklAADHri0MAQctDAIILQwDCS0MBAojAACloAsoAAuARQAFJAIABQAApOMlAADHri0MAQctDAIILQwDCS0MBAojAACloAsoAAuARQAFJAIABQAApQ0lAADHri0MAQctDAIILQwDCS0MBAojAACloAsoAAuARQAFJAIABQAApTclAADHri0MAQctDAIILQwDCS0MBAojAACloAsoAAuARQAFJAIABQAApWElAADHri0MAQctDAIILQwDCS0MBAojAACloAsoAAuARQAFJAIABQAApYslAADHri0MAQctDAIILQwDCS0MBAojAACloC0MCgQtDAcBLQwIAi0MCQMmJQAAfwAvDAAEAAUBKAAEgEsABi8MAAYABC0IAQYnAgcEAgAQAQcBJwMGBAEAKAYCBy0MBwgtDgUIJwIHBAgtCAAILQwGCQAQAAcAJQAAx8AtBAAALQwJBS0IAQYnAgcEAgAQAQcBJwMGBAEAKAYCBy0MBwgtDgQIJwIHBAgtCAAILQwGCQAQAAcAJQAAx+UtBAAALQwJBC0MBAItDAUBJioBAAEFZGGIqMbPlMs8AQECJioBAAEFXjGzmQPOmt88AQECJioBAAEFKIaSsEfc/UM8AQECJiUAAH8AJwIHBAgtCAAILQwFCQAQAAcAJQAAuIEtBAAALQwJBgEoAAaASgAHLQ0HBTAMAAUABCYlAAB/AC0IAQwnAg0EBAAQAQ0BJwMMBAEAKAwCDS0MDQ4uCoBIAA4AKA4CDi4KgEgADgAoDgIOLgqASAAOLQgBDScCDgQFABABDgEnAw0EAQAoDQIOLQwODy4KgEgADwAoDwIPLgqASAAPACgPAg8uCoBIAA8AKA8CDy4KgGoADy0IAQ4AAAECAS0ODA4tCAEMAAABAgEtDg0MLQgBDQAAAQIBLgqARgANLQgBDwAAAQIBLgqARQAPJwIQBBEtCAARLQwOEi0MDBMtDA0ULQwPFS0MBBYAEAAQACUAAMV3LQQAACcCBAQQLQgAEC0MDhEtDAwSLQwNEy0MDxQtDAYVABAABAAlAADFdy0EAAAtDQ8ECygABIBFAAYkAgAGAACn6ScCEAQAPAkBECcCBAQQLQgAEC0MDhEtDAwSLQwNEy0MDxQAEAAEACUAAMagLQQAAC0NDgQtDQwGLQ0NEC0OBA4tDgYMLQ4QDS4KgEkADwEoAAaASgAMLQ0MBAsoAAWAVwAGCygABIBIAAwkAgAGAACqyCMAAKhXCygABYBYAAYkAgAGAACqmCMAAKhsCygABYBaAAYkAgAGAACqaCMAAKiBCygABYBbAAYkAgAGAACqOCMAAKiWCygABYBcAAYkAgAGAACqCCMAAKirCygABYBdAAYkAgAGAACp2CMAAKjACygABYBeAAYkAgAGAACpqCMAAKjVCygABYBfAAYkAgAGAACpeCMAAKjqCygABYBkAAYkAgAGAACpSCMAAKj/CygABYBmAAYkAgAGAACpGCcCDQQAPAkBDQsoAAyARQAFJAIABQAAqS0lAADHri0MAQctDAIILQwDCS0MBAouCIBnAAsjAACq+AsoAAyARQAFJAIABQAAqV0lAADHri0MAQctDAIILQwDCS0MBAouCIBlAAsjAACq+AsoAAyARQAFJAIABQAAqY0lAADHri0MAQctDAIILQwDCS0MBAouCIBgAAsjAACq+AsoAAyARQAFJAIABQAAqb0lAADHri0MAQctDAIILQwDCS0MBAouCIBhAAsjAACq+AsoAAyARQAFJAIABQAAqe0lAADHri0MAQctDAIILQwDCS0MBAouCIBiAAsjAACq+AsoAAyARQAFJAIABQAAqh0lAADHri0MAQctDAIILQwDCS0MBAouCIBjAAsjAACq+AsoAAyARQAFJAIABQAAqk0lAADHri0MAQctDAIILQwDCS0MBAouCIBkAAsjAACq+AsoAAyARQAFJAIABQAAqn0lAADHri0MAQctDAIILQwDCS0MBAouCIBmAAsjAACq+AsoAAyARQAFJAIABQAAqq0lAADHri0MAQctDAIILQwDCS0MBAouCIBoAAsjAACq+AsoAAyARQAFJAIABQAAqt0lAADHri0MAQctDAIILQwDCS0MBAouCIBpAAsjAACq+C0MCgQtDAcBLQwIAi0MCwUtDAkDJioBAAEFFjwguvQQBOU8AQECJioBAAEFy9RVN/zZx1A8AQECJiUAAH8ALQ0CAwAoAwIDLQ4DAgsoAAGASgADJAIAAwAAq1wnAgQEADwJAQQBKAACgEQAAy0NAwEtCAECJwIDBAIAEAEDAScDAgQBACgCAgMtDAMELQ4BBC0MAgEmJQAAfwAtDQUPACgPAg8tDg8FHAwCDwAAKAQCAi4EAAWAAygAgAQEAAElAADD/S4IgAUAEC4IgAYAES0ODxEWDAgEHAwIBQAcDAQIAAQ4BQkEBSgACIBDAAUAOAQFCBYMCgQcDAoFABwMBAkABDgFCwQFKAAJgEMABQA4BAUJACgQAgotDQoFJwILBAIAOAoLBDoD6AAIAAkAAQAEAAUgAgABIQIAAi0IAQUAKAUCCi0NCgknAgsEAgA4CgsIIjSARgACAAgtDAIJJwILBAMAOAkLCgAQAQoBJwMFBAEAKAUCCy0OCQsAKAsCCy0OCQstDAkEBigEAgQkAgABAACsuyMAAKySLQ0FAQAoAQIBLQ4BBQAoBQIDLQ0DAicCBgQCADgDBgE8DQECIwAArLsnAgIEBi0IAAYtDAQHLQwFCAAQAAIAJQAAqzEtBAAALQwHAQEoAAGASgADLQ0DAhwMAgMGHAwDAQAcDAECBi0MAgEmKgEAAQVFp8pxGUHkFTwBAQImKgEAAQXUzIH69npdbjwBAQImKgEAAQWQ0MDCajsmvTwBAQImJQAAfwAnAgYEBy0IAActDAEILQwCCQAQAAYAJQAAyAotBAAALQwIBQsoAAOAUAABASgABYBKAAYtDQYCJAIAAQAArZ8jAACtfQsoAAOAVAABJAIAAQAArZYnAgUEADwJAQUtDAIEIwAAragtDAIEIwAAragtDAQBJiUAAH8AJwIGBActCAAHLQwBCC0MAgkAEAAGACUAAMgKLQQAAC0MCAULKAADgFAAAQEoAAWASgAGLQ0GAiQCAAEAAK4YIwAArfYLKAADgFQAASQCAAEAAK4PJwIFBAA8CQEFLQwCBCMAAK4hLQwCBCMAAK4hLQwEASYqAQABBTtCwSZzO6FFPAEBAiYlAAB/AC0IAQsnAgwEBAAQAQwBJwMLBAEAKAsCDC0MDA0uCoBIAA0AKA0CDS4KgEgADQAoDQINLgqASAANLQgBDCcCDQQFABABDQEnAwwEAQAoDAINLQwNDi4KgEgADgAoDgIOLgqASAAOACgOAg4uCoBIAA4AKA4CDi4KgGoADi0IAQ0AAAECAS0OCw0tCAELAAABAgEtDgwLLQgBDAAAAQIBLgqARgAMLQgBDgAAAQIBLgqARQAOJwIPBBAtCAAQLQwNES0MCxItDAwTLQwOFC0MBBUAEAAPACUAAMV3LQQAACcCBAQPLQgADy0MDRAtDAsRLQwMEi0MDhMtDAYUABAABAAlAADFdy0EAAAtDQ4ECygABIBFAAYkAgAGAACvYycCDwQAPAkBDycCBAQPLQgADy0MDRAtDAsRLQwMEi0MDhMAEAAEACUAAMagLQQAAC0NDQQtDQsGLQ0MDy0OBA0tDgYLLQ4PDC4KgEkADgEoAAaASgALLQ0LBAsoAAWAWQAGCygABIBIAAskAgAGAACxzSMAAK/RCygABYBgAAYkAgAGAACxoyMAAK/mCygABYBhAAYkAgAGAACxeSMAAK/7CygABYBiAAYkAgAGAACxTyMAALAQCygABYBjAAYkAgAGAACxJSMAALAlCygABYBlAAYkAgAGAACw+yMAALA6CygABYBnAAYkAgAGAACw0SMAALBPCygABYBoAAYkAgAGAACwpyMAALBkCygABYBpAAYkAgAGAACwfScCDAQAPAkBDAsoAAuARQAFJAIABQAAsJIlAADHri0MAQctDAIILQwDCS0MBAojAACx9wsoAAuARQAFJAIABQAAsLwlAADHri0MAQctDAIILQwDCS0MBAojAACx9wsoAAuARQAFJAIABQAAsOYlAADHri0MAQctDAIILQwDCS0MBAojAACx9wsoAAuARQAFJAIABQAAsRAlAADHri0MAQctDAIILQwDCS0MBAojAACx9wsoAAuARQAFJAIABQAAsTolAADHri0MAQctDAIILQwDCS0MBAojAACx9wsoAAuARQAFJAIABQAAsWQlAADHri0MAQctDAIILQwDCS0MBAojAACx9wsoAAuARQAFJAIABQAAsY4lAADHri0MAQctDAIILQwDCS0MBAojAACx9wsoAAuARQAFJAIABQAAsbglAADHri0MAQctDAIILQwDCS0MBAojAACx9wsoAAuARQAFJAIABQAAseIlAADHri0MAQctDAIILQwDCS0MBAojAACx9y0MCgQtDAcBLQwIAi0MCQMmJQAAfwAvDAAEAAUtCAEEJwIGBAIAEAEGAScDBAQBACgEAgYtDAYHLQ4FBycCBgQHLQgABy0MBAgAEAAGACUAAMflLQQAAC0MCAUtDAUBJiUAAH8ALQgBDCcCDQQEABABDQEnAwwEAQAoDAINLQwNDi4KgEgADgAoDgIOLgqASAAOACgOAg4uCoBIAA4tCAENJwIOBAUAEAEOAScDDQQBACgNAg4tDA4PLgqASAAPACgPAg8uCoBIAA8AKA8CDy4KgEgADwAoDwIPLgqAagAPLQgBDgAAAQIBLQ4MDi0IAQwAAAECAS0ODQwtCAENAAABAgEuCoBGAA0tCAEPAAABAgEuCoBFAA8nAhAEES0IABEtDA4SLQwMEy0MDRQtDA8VLQwEFgAQABAAJQAAxXctBAAAJwIEBBAtCAAQLQwOES0MDBIt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",
      "debug_symbols": "7b3bjiQ7cqb7Ln2tCx7sOK8y2BAkjWbQgCANJM0GNgb97ttzVYZH1Ap6MtLKaGUKd11I1eqw/H4zGs908v/+5X/88z/+n//193/91//5b//xl//23//vX/7l3/7pH/7zr//2r9t/+r9/+7u//OO///Vf/uWv/+vvH//ffykf/6ur/mHwH//7H/714z//x3/+w7//51/+W6+if/eXf/7X/7H9s1fe/sT//Ou//PNf/pv2v/0/f/cXKGIwqn1k1KjKp1Ejhkejv3smANx+3LH0/cc4+nGtcvtxbYD7jyvqDz2SS09LFp+WLD69JdPDufRAsvhAsvhgTaaHcumhkkwP5tLD4/gI002PsPy502OwGOn3jbAOSRUK3JwCxq/DVQsi3n5dUGn/OeEPhqxnjLtBZ0aAHz3Ajx7gBwybqYq13KxQyp+TEYvFCC1GajCibjESg9G4/lfF20i5KvPXJST19lvp9/au/2iVcNxWOAKkrwbwYoDW1QBaC6BSVwNwNcAhTQvvAH4CVFgNkMWA1lYDeDGgr/ag02IAlG8C/jBCi5EajLBbjNhgRBYSicGILSS2+CTVYkQGI7WkkYLFyBByLmAxMiQsVwupWnz6duv5h5EhjbhXixFajCwht7RGjMViZCJZfLK0RmxpjZgtacSGNoLFEnJLa8RqSVg1kKQUixH88joPs7Rbr15r239cS/mBkOUIh92NKUKXI9p6L9r6sujrM6qv9wLWlwWW9YhfL4vat+XYWwPS+8Miyw7RAAj1CAgHQLhGQDAAIiUCEuLJr6fwtivQ9g0CvSOGux1Y5LZuuf3zvpuwrfoOJs1Yb+oFe3n88Yd2BQfteluzblrha+2g+yQetNJE+30PSIDgSbtH3Nv+461ufa291i776vy2Un9vMZE/BGnp2QRJMkG1xQra/rLe/zI/VF34oYdz6WnJ4tOSxafXZHoolx5IFh9IFh+HUbOvHkymR3PpIUimJ1l8uCfTE9xfUL/9lvB+RkjpDzHSMomhRGI0U2Q0UWS2KV2i0GxqUsWm1lRqUsWmlVRqIJUayaSmp6rhPVGPufXiueYP2//JNYGoBbNFCLNFiHLNsTZBuSZZtXC2CHG6COWaZ9UikE2QJBOkuaaim6BkEaol1+LuJijTCLqmml3UiqnUaCY1radSkyo2PVVseqaZV4VUsYFMM6+KqVo/TNX6YaoaHr0nMVETvcUv9y8UpcqTHk5VxzlV+yepMkdTtTipdgFaql2AVjJlcaupYpNqF6C1THWqtUy9eOuZdkhaT5U3qUbGDVK1Nw7H0B3VUKosjh6Lsmj//LFsU91nPZpLT/RodKqHc+mJPiIz1ZMsPtFj5Kke3x5dH76jH8/2itLt5qKPFfWH0/38qUiTKeoF0imSYEXbsPj2lUX96UKsm6La0ynibIqcx/IeijCdIs2mqKfL7J4usyFdZkO6zMZ0McJ0eUTp6hqla48Y0ilKFyNJl0eSrq5peHv09aectYeP/GeKoHA2Rc5r5R6KHNY9Vernj3spkxmt4wffFTyG5Er7Tfelzk5QPf4Yf4r9Dz2YS4/HErurHgjWMznxBl2TCYJsEYJsEcKeTZAkE0TZIkTZIsQtmyBOJkhqNkGUTJBmi5BiNkHBXceXW6PosQ3gqEYyqampYlNTxaalik1LFZveU6lJFRtoqdRQJjVYUqlJVcMxVa9JqWo4parhnCpvokfsEzWp2htN1RZrpiymkik2VDLlDdVMdYoqZlLTMvXh1FLlTapxMaUaF1P0CvfXalKNRCnVSJQwVd6kGokSJVuwpWxL2pRtSZskW4SyLWlTtiVt0mQR4pIsQlySLfpzLdkEQTZByXbUuWWLUEu2X8w90xyZO2dSA5nmyAyZ5sgMmdZyGVPFJtU6NxOkUpMqNpxp5sWcqvWLXnWffBDK0XOKmR4tyfRAMj2aSo/HC56+eiSXnuo8EsRf/ZhYKmVT5H0q30ERBiuafb4j3ifzHRRBOkWSTRG0dIoomyJMl9mYLrMxXWZTusymdDHidHkk6eqapGuPtKZTlC1GWrLlkZZsdU1LeHs0+XRXw0f+U0UN0inSbIoOzgYJ36Yw2z/lUdEPK7ZYHYxXZ1bjvPrp3jL9OmYfj1vUPQwFfvrO+w/IwX0qzhAMgBzcAOkMifCEhwXftx7rlv+98p/SpZXxG9Vb7u/1ABgn0goi7jN41D9L2yAUABm/Ju0NifAEIjyBCE/Gk7eKtdzMUMpTTo4nWDOr8RGzqRVbrLiarMhiNT75tDWPt3q9Vf3nej2+82ZmNR5uT63QZKUGq1osrDo+1zK1srFMfo1f4fnC6rk6yn4OYlsO3H/aUT8JsprQ23ICrSZAWU7A1QRc7sNBu+5JcMjW/a4iebhpaSdQX07g1QSuywm0miDLfRBcTjC1+QomKzFYHbyBMrUii1U1saplxNKaidVMfvViskKTlSWjDl6emFqZIo8mFpqyl0wsMvnFv77kzCzt1lxs65H7j2spnwxcz3DYXpgzaD1DA/zQ9eXRSw1gBPhRSwCD1zMcDrpsMx7YF0B6f5i83ykUQXE4kPIKBUIoEkFxOAzyCoUjKBjiCzpkctX9gF5tj8f5PijPv8cit6Wx7Z/3vY7xdbNYbx4I9vL44z/0k0N93zTzXX/niX7H63I3/e7x7/pcyg6jn1coGkFxeKGzt32Fu7eHPRrsnwhdjtC+HsGrEeAw+pkicDmirveiri+Ltt4Lh2HPDNHXe9HXZ1Rf3oAA9PWI9UmL64sbnYtb+xPC4cHJKQLWI2Q5wuFGjCmCliNkfXHL+uKW9cXtPcgZIZZ7gaWtRyxPWqxlPQLWIxyKu/fb9K13rE+I1tcjeDnCYxw1Q+B6hC5HwPrihvVJi+u9wPVJS+uTltYnLa1PWl5f3Ly+uGV9ccv64vZYLOp8WxHtUOgJ4fCF/AThceXsFOGQUdtUa0c8LGcPz/17rtOSw0fm/Y7oWPrX4msV2ddBHz59qZ+HU8jhSxNfQR7rT76CMFbQV7eSNHLYzPNUkyo2kCo2DrfheqrRTGowVWwwVWwcbsP1VCOZ1HBLpYYzqZFUsRHKpEZT9QyaqvXTTK0fl+DWr319QegmSJIJqtkiVLNFqLVsgjiZoJ4tQj1bhKBmE0TJBGHJJgiTCaJsEfLY/fcVlGl24XEbrqeaTLMLllSxkVSx0VSx0UyxkZJpViolVWxqTaUm01qu1OBZ6de3AzdxuP/KV4/k0hM9o5jq4Vx6IFl8oqcTMz3es4mHayPG236Tm6WbeO9ROCjSbIq89yqmiiZ3OTbxnlH8uiLvPQsHRZRNkZR0iiCdonSZrekyW7Nltsf9u96K0sWoZssjrdnqmrZs7ZHH/bvOinq6GPV0eQTp6hqEt0df3+PcNHzkP1VELZ0izqbI4XKCjrqf0ab+07ngHwhajvAYCc8QsB4hyxEeg88ZYnVx91LaesR6L2pdj1jvRSvrEbAeIcsRfX3S9vXFDc7FDfCMwPUIXY7w+ChwhuDlCKrrEeuLm9YXN68vbpblCFnvhaxPWl2ftLo+aXV50tbS1yOci5vaE6K29QhajvAeR40QsB4hyxF9fXH39cUN64vbexw1QOB6L3B90uL6pKX1SUvrk5Ydipv3w62dEZ8RuB6hyxEe46gZgpcjPMZRM8Ty4m6lrEcEeLE8aZvHJ1Kst6MvXRo9I2Q5wuMzphmCliM8LiyYIWA9Yn1xw3ovYL0XuL7q4XovaH3Vo/VVj9dXPV6ftLy+uMW5uKE8I3g5wmWQM0HgeoSuRvTS1yOWF3evdT1ieXH3VtYjArxYn7R9fdL29UkL65PWY7FIy+1jha7PW4fdY7FohoD1CFmO8BhHzRC0HMHri5vXJ62s90LWJ62sT1qPk0VKd4QOELwaAaWtR6z3wmMEMkF4jECUbs/JQanyjPh1L6B02hHy7IXDMssUIcsRDmeBZwiHp0K2rLxlFFSlZwQtR9B6LxyOmswQDqsHUPeH3TZae0bocoTDFskUwcsRWtcjcD1ieXFj6esRshxR13vh8FgZNNgb8yZPGz3osEUyRdByhEffPUPAeoQsR8B6L3B9WWCAF7ocQeu9oPUZxesbEF7fgMj6pJX1xS3Oxa36hHC4qWuK4NUIcngudYrA9Qhdjqh9PWJ9cbf1xe09yBkg+nov+vqk7euTFtYnLaxPWo9llk3oDQGlPCNoOcLhBtcpAtYjZDnCYxw1Q6wvblmftLLeC12ftA4vGABg2REfv/gzQlcjuCz3gh2+6JkiHBpzqPv+xcZ4Qngss8wQtBzhscwyQ8B6hCxHwPrihvXF7TECmSHWe3EwApG2I+ThsfohotbS6uevt3/DT08Y/oBgBEQDIAc7Ss6QCE/GvXivsn/50Cs/Qn5YqcFKxo1vhbLfuAOME4cK7k9ub//WJ4dk3Px6QzAAAhGeQIQnGOHJ+JxZxXob1lR82Ke/5eT46NjUii1W46ujplZosRqv1U6txjVU8Vavq/JzvR7v6U6t0GSlBisdb6ZOrUysCiYrE6uZ/Bq/E/WF1XN1lP3LOHm4Uq3/eMy26/iTc1cCrSYcNL+eBFhO0NUEXO7DQbvuSCCHbN0f75bOAwKvJnBdTsDVBCnLCet90NUENbX5Kt+3goN7A6dWZLGqxWRlYrVqsjKxusmvDiYrtVhBN1mxxQpNkUcTi0zZSyYWm/xy+B6DWW4rO1Lr/Xhc3dbTfzB0PcPh2MaU4bDfMGdE+LG+PGrBAEaAH3V9eVSHcw9zxq+XR+0N9gWQj8+snikOOw+vUCCEIhEUhy2IVygUQXHYiHiFEuKLw4EI7Hirk7jt+/3tYcdjsD2i+5gbtP60tjgYn98vlBcgePzxD/HoIH6/hR5/uoR++OMit0W97Z8yEY/7aXrBh68Sb+LZI/Kw69mWyifiQW8jJKQCjz/+oQeS6dFcehy+CvqWnvb1W8ubIEkmSLNFSJNFqDl8w+ssiJMJqtkiVLNFyGEU7SyIkgnqJZsgTCYIskXI4UMwZ0HBXcdXj2eDxyV8nmo4kxpKFRtKFRtOFRtOFRtpqdSkio3WVGowlRpNpMbj6kNPNZl6zR49l6hyP2YnD7cG7Xoy1fHeMrV/vaXKnJ6pxenRo/WJGsqkBlNlMaaKDaXKG0pVpyhVLx699v61GkmVN6lGxh53SXqqydRrQsmUxZBqLAo1U95AqpEoZFvRhmwr2tCzRahni1C2FW2AZGv+gNkihOkipMkEOVwl4iwo2YY6cLIjB8DZIiTJNtRBMs2RIdVKN6Ra6YZUK92YaqUbS6rY1FSxqZlmXthSxaZlmnlhz9T6YfSqO4vebrOX2p/1RM8ppnogmR7JpSf6lMxUT7L4UEumx3ckuM25v9ZTi9Ltjsvt3/Lwc/6hyPlMvociTKdIgxXVVm+fjGz/BnxSJJBOkWRT5Lxv4aGIkimiUtIpypbZVLJlNtVsmU01XWa3dDFq6fKop6trkK49AsymCNPFCNPlEaaraxTeHt0/8631p+98PxWFj/zniiSbIucvYD0UOaym4f3rdYz8ep08huQP3ywj1l8Np8eQ3FURO7yM460IYxXN9tO4lmyCskWoZYtQg2yCNJmgni1CPVuEHF4VchYkyQRhyyaIkwmibBEiSiaIg7uOLzdImTGVGs2kRlLFRlLFRlPFRjPFRjyW2B3VpIpN7anUcCY1raZSk6mGS8/Ua0q2uYRkm0sIZIsQZIsQJpttCSabbQllixBlixAnm20JJ5uPitRsgpLNR0WzRUiTLfZKqtmFpppdaJFMampLpYYyqWmpYtNSxaZnmnlpTxUbyDTzUkjV+kGq1g9T1XDMtLailKqGU6oazqnyJtUegEqq9kZTtcWaKIuxlESx2dQkyptNTaI6hSXTHsCmJlEfjqWlyptM4+JNTar2BhL1mpuaVFmMwVn89Wehmx7NpSd6ZXuqh3PpiR6RTvUki0/0qvZUj++S7Z/eynr+8eyT4k2RZlOkkE6RBCuafMSDtfR0ijibolrTKcJ0ijSbopYus1u6zO7pMruny2xIFyNIl0eYrq5huvbI4x5QZ0XpYsTp8ojT1TUJb4++/ppyU6TZFCknU+TyaKyzovHanrRdkbB+rajW0uoOKfDTt9R/QA6Gzs4QDIAcfH/qDInwZLyo27dq/GnWe+VHyB9WDsOguu0Y6T4/fpT2/QXP5vCCkaseTBYfTBYfh3eMfPVgLj2cLD6cLT6aS4/DMQVfPZJLj/ZkenLFpzsMCH31JItPTRYfhw8XXfW08PEGV7z9bYbHEeJNEWVT1NPFqKeLEaSLEaSLEaaLEaaLEaWLUfwIf6Yofow/VZQuRpIuRpIvRppNUfxof6pIkimC+BH/VBFnU1Sz9SJQs/W00LK1kNCytZDQsrWQ4HCBibeidC0kZOtFANK1kJiuF0k3F4F0cxHwmItUKfvp0ioIv7B6BA5HP1z1MCTTI9F6Zhnk8ASstyLOpsjhYpWPoxK3g/fbvwl/JYsc7lXx1IMOH2z66oFoPZMMQo9dEF9FDp9ueiv69XrfPlZVbr/eRuv8K1nksBPiq4dy6XG4yPGbemYZ5DAX8lak2RQ5zIUaMtVdkRT9lSwCzqXHYR7kq4ei9cwyiEo6RZhM0cErf1snuZ+dBcbZTHEr/H2miPp04JLGC3beEAyA9AhPeoQnEOHJ+IqAivX2fNaWneUR8ofVuGWbWrHFarxSMrVCi9V493NqNa6hivvqjPLTaWUafyQxtUKTlVqsxjtmUysLi8fzrKmViVW7yYq/afVcHWW/U1T6vRPpqD8I48sYXQm0mnDQ/HoSYDlBVxNguQ8H7bojAR2ydX/lUDoPCLyaQHU5AVcTuCwnrPdBVxPE1OaLWKy0mawsowgpxWRlYtVqsjKxmsmvBiYryyhCejdZscUKTJEHEwubycrEIpNfDnN0Zrm9xrul9f3L020f9ZOh6xkOO4pThsNZxTkjwo+A8tCAvNL1fng8BjBlOJyCmzMc9iZ7g30BpPeHyftO8Tir9gIFQigSQekthEIRFI9vS16ghPiCDplcdb/Ur7ZS60+U599vu9G3pbHtn/K3h+XFwRAd680D2bb8Hn/8Q79Dfd80811/54l+0H3a8PE0x0Q/wE2JAMGTfnKPf9fnUnY5pzWlOFxz8wrF4bJBvmeg/HzlyB8I6esRvBzh8R7TDIHrEboYQaXgckSt6xHrvXAY9kwRAV6sz6je1yN4OQLWJy2sL25wLu4qTwiPW8pnCFmOoLYeQcsRXNYj1hc3ry9uWV/c3oOcAULXe6HLk7aWsh4B6xHLk7Z6vMso1HYE0zOClyM83mefIXA9QpcjPMZRM8T64ob1SQvrvcD1SYvrkxbXJy2tT1paX9y8vrh5fXHz+uL2WCwSvX0u9rGD8YTwWMmZIX59kLMtpNyOMG+T7MlDMI6LqLSt3/56fHS/J3abbE0+i63bgvF+urO0PlCE2RTVkk4RxCr66kOHTY1mUtNSxaalio3HoNBRjWRSA6liA6li4/GqtaMazqSGaio1lEkNp4oNYyo1qXoGSdX6SarWT4Nbv+0v6/0vP56pgE9BnEuQx9XVzoKyRajWbIIomaCWLUItW4R6ySYIswnSZIIAsgnKFiHs2QRlml10yjTz6qlmF51TxYZTxUZSxUZSxUYzzUq7ZooNlJJKDaRSEz4rpf3H20ryk57ak+nhXHpaTaaHcunpyeLTMZke57EyT66mkoK3Dzik8MMuMP/Q471D8ct6JJce712KqZ779X6yNcbPejiXHu+dil/Wg8n0aC493JPpSZbPkiyfJVk+S7J81lzxwZIrf7Dkql9Yc7U/WCWXnpYsPi1Z/vRk9atHtz+4H+MTFHrSAyWZHkimR3LpCZ9fzPRwLj2ULD7euxW/qofD6zvcLwBReNaDyfRoLj3Sk+mRXHo0WXyUU+khh/kFVbgteX18HfW1Hs8PQ6g4fNVS+/5VS9XJ6xcVbx/ZtHJfiu2t/pDj8A2GqxzMJUdj5Xy5T0YO8yJPNZJJjcNlbt9SMzvuQp2SCYKaTRBmSiAsqdRAJjWUKjaUKjacKjacKzapuk9JFRtJ1X1qS6WGotV8eWCBS02mB5Pp0Vx6KiTTkyw+8ROJiR521dNamcz6CPa3kLfBzf5j+NTTazI9lEsPlFg9kw0odp5J/LoezaUHezI9nEsP1WR6kuUzJctnTpbPnCyfJVl8JFn+aK76JSVX+yOFcumpyeJTk+VPzVW/pEW3P18fEBDnrYpf1uO8WfHreiiXnvD5xUwP5tKDyeLjvFvx63rC6/uXBxaEejI9nEsP12R6KJceSRYfwWR6HMY/jeCmp5fJTbG1UrldwLv9G+4joM9TPuJwhMtbkSRTpA6XW31L0Zd7Tuox5/FT4zHjcVSDsWq44u0vM1R+0uPw6JOvHkimR3Lp6T2ZnmTxgZZMD+XSg8nqOyZrD9F7/PPTAe0/EATrEbIcwW09gpYjpKxHrPdC13uhq73gUtp6hCxHVFiOaGU9Yn1x9/Ve9PVl0ddnFPT1iPVe4PrajQ5J27ntCO1PCI/jDTPEei94vRce55UnCI9DyDPEei8cvgicIKpHx/qAgOeqVwsvR9T1XtT1Xji83DhDeHSsUPeWFhCeEbgcAeu9gPVeeBwXnCHEI6PqHYFPCI9NN+D9K2F8OLe8I2Q5gtd74bG7NEOQLwLkCaF1PUJXI5pHlzRBeHRJ1HfE9j/PCF6OcLiDdorA9QhdjvBYe58h1hc3rPcC1nuB66serveC1lc9Wl/1aH3V4/VJy+uLW5yLW8ozgpYjPFabZwhYj5DVCI8nx6aI5cXda1mPgPUIXY5o671o65O2r0/avj5pYX3SwvriBufi1qcpjMfbVlMEL0d4j6NGCFyP0OUIXl/cvL64ZX1xe4+jBghd74WuT1pdnrRQ+nrE8qQFj3OojLfD28RanxG0HOFx9mCGgPUIWY7wGEfNEOuLG9YnLaz3Atcnrcd3W9L3fT2h9ozQ5QiPjZ4ZgpcjPI43zBC4HrG+uGW9F7LeC11f9XS5F1j6esTyqoe1rkfgesT64m7Oxc30jJDlCI9BzgxByxEei0UzBKxHrC9uXF/cuL64qa5HrPeC1yctr09aXp+0sj5pPRaLtO/3Ourz1iF6LBbNELgeoasR5DGOmiF4OaLW9YjlSUttvRcN1yPWJ63HySLVG+Lj851nhCxHwHovYL0XHiOQCcJjBKIqO+L5VDA5jEA+Phy4ISo8nQomh2WWKWK9Fw5fkUwRv96AcNk/fdpoT8uP5LAGMkXIagQ7HJiZImg5wuHAzBQB6xHri9thDWSKWO+FwxoIV71tLmxBgWcEL0dAXY/A9QhdjnA4MDNFrPeC1pcFrffCYYFiiljvhazPKFnfgOj6BkTXJ60uL24pzsX9/F2SOFxzMUPUth5ByxEOp1mmCFiPWF/cfX1x9/XF7T3IGSHWe4HrkxbXJy2uT1pan7Qeyyy93s4Ncoenz/k9bvSdInA9QpcjPMZRMwQvR+j64tblSaulrkfgeoRH0t6XggGezoGox0rODLHei8bLER4jkE51L+7nE9rqscwyQXiMQGYIXI/Q5QiPZZYZYn1x0/ridhmBfI3g9V4cjEC2qc0NsY0gvkbUbRfmxtj+Dfdttx+3pPPRZZ/OEIiAaABE13siZdyL9yq3zqD3x1t6+w+rca85sxo3vhXKbX2/AuPEoYL7dwDbv/XZoXHz6wwZTwG9IRGeUIQnFOHJ+NPKivX2vk7Fh098bzk5/lpyZjU+0za1IovV+LqHqRUarOp42rDNwW/1uirzsxVZrMbbtFMrMFmJxaqZWOPjSjOrbmJ1k1/jO/q/sHqujlJvv5WHJfaO+kng1QSsywm4nKCrCQTLCct9OGjXPQkO2Vp4J/AzQdpyAq0maFlOwMWEVspyAiwnWNr8VrvJii1WrZqs0GLVTaxuGbE0MLHA5BdYRhENwWRlyihqJitT5NnEYlP2ioklJr8crnLjbf/51lzUel+3raV8MiCAocsZ3WO/YcoI8KOuL4/eSgAjwo+A8vA49zBjOHzhWreA7wsgvT9M3u8UDKFoBMVh/+EVCkdQHHYhXqFQBIVDfHE4ELE1tPdh9MM4Gkc/Bt3H3KD1p7XFwV8GuMkQIHj88R/iHd4020oTdvHSvhaPRW6Lets/ZSIe6/394V6exXtEvuyITv1r8QJMux7582nNTY/m0uMwmvLVI7F6tr+s97/MD1UX/hDkcVmcs6BsEarZIuTwxoGvoNayCcoWoZ4tQg6jaF9BDid9nAVhMkFYsglKFyFNJoiCuw7qtz9MeP/pj7eaNzWSSQ23VGpSxUZSxUZSxUZTxUY5kRosmWKDhTKpqSWVGkilJlMN97jr0VNNsrkEZptLYM8WIcgWIUg220JMNtvyuMfSVxBlixAlm2153KjpLAiyCUo2H0XJFiFJttiLqWYXmGp2QaWmUoOp1GgmNTVVbGqq2DRIpSZVbHqmmRf1VK0fpGr9IFUNx0xrK4TBNbzK/cM4qfKsJ1Udp1TtH6fKHE7V4qTaBaBUuwCkqbJYM8WGU+0CcMlUp7hm6sW5Ztoh4ZYqb1KNjLlnam8YMvWaDKmyONVYlDFV3qQaiTIlO1jJlGw1kjlbhDhbhCTZVp/H1dG+gjRbhDRZhKQk2+qTkmwzVGqyrT6pyTZDPW7GdhYE2QRlmiNLqpVuSbXSLalWuiXVSrdgqthgqthQppmXUK7YZJp5Cadq/aJX3Vn0do211P6sJ3pOMdVDufRoSaYHU+nRkis+WiCZHt+RIAB8racWpdtH2du/H7/K5h+KakuniLMpajVYUW37jRDbvx/fCb0pomyKekmnCNIpkmyKoKVTlC6zMV1mY7rMxnSZTelixOnyiNPVNUnXHglnU6TpYqTJ8mibhiSra5ui8Paoy340s0JpT4rCR/5TRa2kU4TpFDmspmHf74BEnFzZ5njfnBaPIfnjLWO9/mo4PYbkvoqgp1PEsYom+2lasGUTlC1ClC1CDld++gpyuB3UWVC2CEm2CHlc+OkqyGM3wFcQZBOkuQRt/zebIEkmqAZ3HV9tkG5qOJOaVlOpSRWbnio2PVVsIFVsgDKpwVSxQUylRjOpoZ5KTaoazql6zWxziSrJRso121yiSqqqHj2RmKiRRGpayVTVW8nUmbdUk4dWU8Um1eShtVSx6SWVmkytX+upWj9IVcMh0yCwpZrKNExVwylV3lCm0VbjVO2NpGqLJVUWa6rYpBqlN81Up3rJtFjRS6Y+3ONdV0c1qcbFPdW4uPdMvWZPNRLtEJzFX3/box6vzbrqwZ5MD+fSEz0inepJFp/oEzJTPc5Ltj8/Ufr849l3YZsizaZIIJ0iCVY0O4ndtadTxMkUQanpFGE6RZpNUc2W2VDTZXZLl9ktXWb3dDHq6fII0tU1SNceeXyn6qwoXYwoXR5RurrG4e3R5JMYCB/5TxUJZ1OkLZ2i8dqetF2RsH6tqNbS6g4p8NMHcR8QPBg6O0MwAHJw9aUzJMKT8aJur3I7k9V75UfIH1bjDnXLrD3LgHEirSDiPj9GfZY2XqXzhkgAhCI8oQhPOMKT8edVdat1NzOU8pST43OLM6vxtuXUCkxWYrCi8Xbd1GpcQzcRNyvlp3pN4+2vqZVYrMYPS0ytyGLVTazx1GpmBSYWmPwaX8AztUKTlSmjDpq+mZUp8mxisSl7xcQSk19av2k1GC7uZ6yl3weLHfWTQIsJXMpyAiwnyGpC7csJy334drv+fYJDtu5Xd0jnZ0Kvywm4nKCrCQDLCct9wL6cYGnzmZrJyjKKYC4mK8tYkcXEEsuIhdXEUpNfahlFSOkmK0tGSa0mK0vkpZlYprG9dBOrm/zqv764ySz7FVPbmu7+41rKD4bD9smcIesZDlscc0aAHxRQHhSQVxzgBweUh8P3qXPGr5dH7dt+za0t6f1hiWanOBxSf4UiARR1+PTzFQpFUBwetnqFghGUFuKLw7tStep+yLG2UutPlOffY5HbAuj2z/v76uPbF7fNlFuFx14ef/xDv0N93zTzXX/niX7P2yM9LnT/U/y7Ppeyw+jnBYrDh4svUDwuSmTZT+VuY/L9x9g/EbwcQXU9AtcjdDnC422jGWK9F7K+LGS9Fx7f5s0Qq73Y2pHSAxi8nlFrAAMDGAFl3pzLvNUBQ9Yzegtg0HqGx5P3UwYEMALKHAPKHAPK3HvMM2QE+MEBucsBucsBuSsBuetxnYLQPk3bIM8MrQEMDGDockb1GF9NGbyeUWsAY33uutzwO2VgACMgd3tA7vaA3IWAMoeAMoeAMseAMvdYUtJyOxG+bUCUZ4bHx/8zhsfYZ8r49bzSbTb2+eNtgyPuOaBNvcdVU9t+ya7+8duh8ZKpyL5i+vDj+uMYy4ciSKdIsyny+ID+O4q+ugbmQ45kktNKqui0kis6HhfEesrhVHJarui0XNHx+CzdUw6lkgMllxxMJQdzRcfjy3hPObk6CcrVDFKuZpCDm8H29dMFH4oomyJJFyNJFyMt6RRhMkW9ZItRL/lipNkUedxv66xIsilqPZ2idDHqLZ2iVHOODqlmZD3XnKNjruhgruhQruhQruhwqvmqy927nnI0lRxJteTbJXi++vXFzZsgbdkEUS5BED3PmAvCZIJqtghFTzLmgpzHzw/Xro03Cid3f2+SvPczPCRxOkne+xpTSZMLNz8kUTpJ3vsbHpIgnyRJJwlbPkn50pvypTflS2/Kl96cL0qSL5ckX43TfO2ScjZJWNJFCUu6XMKarsZhDW+Xvr5+e5MUPh2YS+olnyTMJ+nX19u09htEK/001/3BcBhMzxmynuEw3J0zaD3DYUA6ZwT4wQHlwQF+OBxpmTMC/NCAvNKAtkTXtyVUWgBjfZlTdS7zn7u0TwYGMHQ9w+FgxpzB6xm9BjACyrwHlDkElLn32GfEwAA/MCB3KSB3KSB3KSB3HS6d0ga3LRJtDz++M2Q9w+H2hTmD1jM8xldTBgQw1pc5lx7ACPCjtgDG+txlh3s8tbed0akMGBjA0PUMh9sX5gxez3A4QzpnBJQ5BviBAX5QQB2kCD8C6iAH1EEOqIMSkLsSUObiXOajPspj7DNlyHKGeKwtTRm0nlFLAAMCGAFl3gLKvPF6Rg/wowfkLgTkLgTkLgTkLgaUOTqXuT6vhQvVAAYGMHQ9w3t8NWTweoYElLkElLkElLn3+GrIWO+Hlh7AWJ+7WmsAAwMYDmUOePsEQ0Gf5x8eL8TMGbKe4TG+mjJoPcNjfDVlBJQ5BOQuBviBAbnrcHmQYr/durlJ5gGD1zM4wA8O8MNjXDJjeOx5TRnL/ager63MGeLB2I+XUtFnRnXwgxrvDJQBQ9YzGq1nOLxqNmc49B/bRs2NwfTTywLPP/a8Jbh6vE2ytaa6q1f6Wv0fVzd//vrjnseRJEknyePsjbckjpX05b0I1eNNFVc5lEqOw40j35LTJpcdfWx3ZlMk6WIk+WKk2RR5rCg5K8oWo+0f6RRJNkW1p1PE2RR57DA6K0oXo17TKcJMQ5EKJZccSCUHc0UHc0WHckWHkkVHU8nhXNFhSSVHWi454fNVuv2Y6OFdql2Q1myCMJsgzSWoFcgmKFuEoicZc0G+42epk+sopOwbfFL4YaGZPwW1mk0QJRPUS7CgLriv4Nc+EITZBGkyQdCzCeJkgrBmE5QtqTFbUlO2pKZsSc3ZIsTZckiy1TLN1g4p5RLUS7IIebyZ5CwoWS3rNbodwv3sgKDQQJAkE+S8seEgiJIJCp91TAVhMkGQLULOOxsOgsKrPewNIyo8C8KeTRAnE0Q1myBKJoizRYgxmyCH8ZDsl9iqFvhakOv51C4Orahw29V3+Vp9xduXTu3hst7e6k2P5NKjPZkejtXz9b4aeEyXPOVQKjke1zt8R870sIzHw0/eijSbotZTJVGTVHI8Pq/0lJMrOpArOpArOpgrOpirL6Vc0aFcfSmXXHIgWs7XRx2ANZkg6dkEcTJB2rIJShYhjJ9ezAShr6DZx6iV9ltnKz3cGgi7IE0myHuG8euCJFbQbL8KvecXvy6IkwnqNZsgzCZIkwmCbEkN2ZIasyU1ZktqyhYhypZDnK2WcbZ2yHs/49cFZYuQZsshTVbLqES3Q5OTBeS9rfHLgrw3Nn5dEGQTJMkEhc86poKyRch7Z+PXBYVX+6+POhDUbIIwmyBNJgghm6BsEaKeTdCvj4dqKeW2kLn9G2bXoW1DjJsDH0l8HxPdzgmRwzmwBaIooSiHe7a+KYq3Wcbnrxnq/UjDbdWaHL5DcZek6SQ5TIzcJUk2SR7PDrpL4nSSqntziT8dC/2kUASllRAKhFAkguIwk3iFEuILhPgCIb5gSI5RSH2hkLrPIaXPIaUvIb5ISLloSI4pBlCklBAKhFA8MrnWvlNqf74SXWoPoYT40kJ86TWEQhEUCPEFNILi0iPX2u6U56dVN4qHL63iTmk/L/L8oBCEUEJ8YY6guPTIje9tcocRhSMoLn3ljKIus+85xaPlh3p/YQH682Mu6tKLzSkhvrQQX1x6sTnFoxeDh5ESED1TXHoxfGhhkGRAoQgKhvji0otNKS69GDDdKRUGFI2gcA+hcARFaggFQyghpa8hpe+yRD+htFJ6CMUjk+/f127/Rn2m1BZCoQiKy9r4nAIhFImg9BBfIKRcIMYXjaBgiC8YkmMU0sJQSAvDIZnMIaXP7qXP/ZkiPYTCERStIRQMoWgApZYeQoko/VprCIUiKC3El4YhlJBM7iGZ3EMy2WW1h+G+zs+sAwpFULCEUCCEIhEUl/HYnBJS+hySyRzii4RksnhksvT7qrXIoIVxWVOaUjTCl20qHkLxaPlZ653Snku/uaz2zCkUQXFZ7ZlTIIQiEZQeUvo9pPR9xjBTSogvB2MYaTtFHpryMeVjg/9GqY9Hpj8/hWhHr8x4UzSCcrAv5k0J8WXc7/etD/206/3xUPtn0hy8a1Ch3C4vrsA4S03Ehw1IfRZ38FiBO4UjKD3Elx7iC4T4Mm6YKt4PLaCU59Qcz5bmZmoyG38yODdjk9n4DPbcbFxbFfepuvKgko9XT+dmbDIbr2/OzdBidnBb9dyMTGbVRqs238b3KE/NxoPNuZkpuQ4uD56b2QoAbDQwpfLB5bZzM5tvDh+ZMMtt5i613i87rKXcIBAB0QCIw6sRL0AiPJGIMtGI7NIQTwLKBB3u55lDHO7cqb3tdw9s2wsPo4YHDMZgNATjcS73FQyHYDzO/76CoRAMxHjjcEfMH4cJb5hWav0J8/x7LHIbm2//lMdZzvOP5X4kV7CXv/15SoQe+02baL470HnigOcbQ83josk/lUDXQUF7fHf7CkZCMB5nl7c5ttxXgujprP9G4QiKx3c+L1A8Cmb7n51S4fmMrMf1ia9QOIDicdHhKxQMoWgEpfYQSogvLcSXFlErqYf40kNqJYTUSgiplRCSyehS+rqvuGwrjGVAkQiKx1mZFygUQfE4u/wCBUIoIaUvIZksIb5oSCarRyY3vrcwvTxT2GWkNKdgCEUjKC4jpTmFIygtpPRbiC89xJceUishxBcIqZUQUisxpFZiSCZTSOm7jC56hzsF6Zni0VduG9X7Sdw2uHNho3jUSrzvTFZ8+Hn7XO6Tg75S6bak2Et/Pq8gB5soM7ODbZGpGdjM1GTWbLSDufPMbLzL3ovePv/udXC8S8az26kZ2Ghgo6GNNt5ln5qNm5i5mY3GNtp4b3tqdnAIcGoGNjM1mamNpiaaFlMktVabmakGaDuoAfsmTN+2FGaN+OyIqDaOoPQaQqEICoT4ctD+TY7u6nglxvnwpo7HSu4UjaBIiC8S4osG+LINni3nVDczMpkdnK6cmqHNTE1mB6crZ2a9GM4EbmZoM1OTGXSbGZvM0EZDMZmRjUY237jazMhkJrbkOmgPp2a2AlAbTU2pvPW0NjOTb9Xhi8jZacHucanDHOKwLvoChAMgPcKTHlEmEJFdEOEJRpSJw6buHOKxpzs96bhhOATDNQaDMRgNwUiPwUgIRmO8cTkF9/uO7naXixx+49Hd7nJHxPSwa3e5JOIFTCsxGIeWq9H94MO2Zf90UfNG0QiKx3Wdc4rHdZ3btuN9+4sFBxQMoWgExWMj9wUKR1A8NnJfoISUPof4wiG+SEitlBhfQmqlhtRKjaiVvdQQikfpC+zrqR+7qM8Uj28nX6BACEUiKK2FUCiC0kNKv4dkMoT4AiGZ7PHo57aNfm9hFAYUl5HSnMIRFJeR0pyCIRSNoHBI6XOILxLii4TUSg3xRSNqJZQaQsEQSkQmQ40ofXAZXSjjnaL8TPHoK+HhCUtolQYUj092Jkd3Oxz0lV8fON3MxGR2sC0yNSOTGVebmY0mxWYGhjOBm5mazNRGM52u7FjAZiYms3ETMzez0ZqN1thkZjrg3bGTyQyqzcxGQxsNbZEkW7mRrQYwrD8iulE0giI9hCIRFI3whQ7av6+P7vaDKyemZhBw4nejQAhFIygY4guG+EIhvphupt3MTCd+SarNDG1mphO/dHBwcWLG5buHMgd7+fsbPNLvQ/utcbshcD1ClyNqX4/g5YjW1iPWe9HreoRD0u7nYeTh8MwdAWU9AtYjZDkC+3rEei+orUeYDuaz7TMAZrSZmY7Ks+l6+M3MRrN9BsC2zwCkdJuZ6asPqc1mZkouacVmZioAsX3AJLYPmARsNLD5BqavPsT2AZOgLbmo2sxsBWBrucT2AZOIjSY232wtl9haLlFTcmlpNjNTAait5dJqSmVtNlqz+dbX33y/QSACogEQwAhIhCcYUSYUkV0U4klEmXCEJxzyyYzGfACkEvINmGqNwWAMJuIbMCgFYjAx3nic4UDcp9Lbv9tP54PXfpu16RcP/U3v+kG/1u/5aRYUj+u7EeAh/oW+1l8/Zj+3n38ouP+cb6I4oSiPR2j9RVG0qO1v6/1vP35HCJ+aPO7TdNeUME6YME4ej6x4a/J4kcVdU8I4ccI4edx76q5J82mSnlCT5NOkCeOknE5TLeF9C/Xbn6aP//72l+kmiJIJqiWboGwRatki1LJFqGeLUMdkgiBbhDy+s/AVJMkEYcsmKFu1p2yda8LZSE04G3G5DMxbkySMk0BCTflmbVUTxknzxamVfLO2VvLNbl0uMHPXlG9221rCOLV8K8wt2/ykZZuftK7JBEHPJoiTCcJsEcJsEaJkM7hG2SLEyWZwjbM1jJytYZRs1V6SLdw0jT+gIPcvQaXKQFKyit9Lsqaxl2RZ1Guylqhn24bo2bYhes+W1D1bhLJtQ3TIVssgWX/fHU7S+wqibDmUbVTdOVs7xNk6V8mW1PGDWJb95QOpfSAp/ojPXBJnkwTxB3zmkiidpJovSvHj67kk975fJt9g1KJ0u+Rs+7fc//rtZDv4f5jgIUoSivIf/k9F1XZ/Tag2wIEoTijK/8sED1GYUZQmFIU9o6iMiU4ZE50yJjplTHTOGCnJmFOSsfZpxnZKJZ8oLAkjhSVhTmFNWPuw/oZ2avZJLP6GicNcVK8ZRVFCUS5L9cT7LcpIWr8W5fpBPboM5+l+vxByne3C/vRzqU9vWGyiNKEolxV+d1ESLWp6jO/gevnfrClhnDhhnJjzaZKWUFPCOGnCOCml00QuexHemjCfJpdPjr01ZYyT5tPUwvuWr3duqUkyQb1lE5QtQpAtQpAtQpgtQsjJBFG2CBElE8QlmyDIJihbtZdsnatkq/aardprshzi+AH/RFBN1g5xTdZSc0uW1NyyRahny6GerZZ1TSbI5YIhT0GYLYeyjak525iaKVvnmm0Iy9mGsCzZcijbEJY13yoxJ1xNl4Sr6VISxinharokXE2XljBOLWOc8u06iMMTT/6a8u38C+Tb+RdIGCfMt6MtmGzSLVSzCUo26RZKNukWTraALJwtQtmW2EWSzeBEs0VIk83gtCRrGDV+zX/2La3Gz0rmkiCfJEknKf6Az1xSvijFH/KZS/IeP/7pXPjg59NvshVKRlGYUZSGi5p+2KTunya4iJKEotz3TlxEUUJRXDKKypjonDHRJWOiS8ZE14yR0nw5hS5PObuLqvnaqU0UJhTVMkaqZcyplrH29d/QTk0+f8byGyYOL4iShKKwZxQ1XrOTtovaloYnompp+9fr2zbJTx+k/6AcDLq9KRRBObiK35sS4sv4zE2vckuy3is/Uv4wq+MFuo9Xy284YJyIK4i4T7RRn8XV8ZqbN2W8jOZOCfGlh/jSQ3yBYQXY/otyb//Kc2qOD4/OzdBmpiaz8f0IczMxmY2nzFXvPYnyoJKPdwSnZuN9u7kZm8zGZ/TmZiZaGz/GMDez0Wq1meE3zZ6rp+xHIKTfRyQd9RMxnkf4ImA9QpYjeluP4OUIWO/FQWvviUCHpN3vXZLOIwSuR+hyBPX1CFmO4PVeMC9HiK0PEDKZabGZgc1MLGa9gM3MNJzp1UarNt9as5mZBhi9V5sZ2sxsBQA2GhabmZFm883hnjRmabcWZFs23H9cS7lBOADi8JLKCxAJgEiEJxJRJhqRXRrgCZQWAYnwxONW3L5tDtyald4fZvwPGArBeOwnvYKBGIyEYDx2cV7BcAgGYrwBh4Suuh/Mq6087J18YJ5/v62O39bVtn/e3wod37K7rQXeav421nz88Q8H0KHib6L57kDniQOe1wRvDriXQNdBQXt8y/IKRkMwLqeVVPddHCr1pwurPykaQXH5IGNO4QiKy6fdcwoGULDUEEpEufg8GjCnUASlhfjSQnKsRbQw2HsIJSSTIaT0wb30mz5TXC7kmVMghCIRFJdD5nMKRVA4pPQ5pPQ5pPT9R0pDSogvGpLJGpHJVEoIBUIoDqVPhelO0fJMqT2EwhEUj/HYCxQMoWgEpYeUfg/JZAjxBUIyGUMyGUMyGUMymUJKn0JKn0NKn0NK32PlimrZd1mpgjxTBCIoHiOlFygeOdbuJ0ap9Z/KZfEyMheXKKnc9T/cs3HwEYTsv378rKbeDtmwx2WB3po8VsLcNWG0pi+vU0H22H/0FZQtQj1bhDpkE6TJBEG2CEG2CHl8SOcrSJIJopZNECcTxNkixJRMkGTrOiRbwyjZGkYNbxjb5LbUTZOk0yQlX5ykJIxTbQk1cT5NLWGcWsI49ZpQE+XTBCWhJsynCRPGyeMYg7umZPMToWQzOMk2P3G5INxXULYISbYISbYIabI5rssF4Z6CXC4I9xWUbAFZS/gcd3J/MrpcD+4tSdJJip+TzCVxOkk9X5TiJyRTSf7zEeGvJU3v4d5EQUZRmlCU/37JVNT0Mkv1n5M4iPLfN/EQRQlFcckoCjKKypjokjHRJWOia8ZE13yRolLy5dQmKl/to1LztVObKE0oqmWMVMuYUz1j7eu/oZ2aXHlN5TdMHOaisGUUxQlFedwQQR3aLqrzT/PjTwpFUFxG0XMKhFAkguIycJ1TQnzRkHLRCF+qy5GaOSXEl9pCKBEtTG0lhAIhlJDS7+6l/3On90nhCArUEAqGUDSCgj2EElL6FFL6FFL6/iOlISXGl5BMlpBMlpBM1pBM9riviwD3+QuBtCdK87iF4gUKhFAkguIyHptTKILSQkq/hWRyD/Glh2RyD8lkj9tSCfv9q3rEyWvknl9vb/o9Wnts9yihTr4+//J4EjWXqzBcBVEyQVSiBc3OI2+aIKEmzafJ5RCwZzK5rPF5CnJZDnQVlC1Cmi1CmixCvSSLUC/Jetles0WoJutleyvZBEE2QdmqfU/WufbOmUYggz/O2wTi9sdZ2/2Pb236pw/Q3sCHVOXwQxOmiuunpoRxooRxIsqniWtCTQnjJAnjJJhPk+ZbZeguxyu8NeVbZYCSL05QJJ+mmq9vgZqvD4aWbE0WWrLZIvRks0XokE1QstkiQLYIQbYIYbL5NGC2CFGyZTSgbA0j/4aGkW7dGW375gNJmE+SppMkPZ8kSSdJ80VJOZsklwcNf5JEgF9L+mgK77++64ddEqaTVEs+SRAtSbbFkM9fC9R7h3L7WAirppPUej5JnE5Sr/kkYT5J+dIb8qU35EtvzJfemC9KlC+XKF+N43ztkpR8khJGKV8uab4ap/HtEvLtfSxBoSdJ5H5izEESpZMUP0OZS4J8kjSdpJYvSu6nx35dUv8NjQDsTSUqDCRxOklQ80nCdJKw5JOUMEqaTpLLDGXbRt8lcXl69HOjSASFQ3xxOVE1p5AL5b7eyc+PsBNpDaFoAIWLR6cvpe8U6TygaATF5dn6OYUjKC6naeYUDKGElH4P8aWH+AIhtRJCfMGQWokhtZJCaiWFZDKFlD67lz7WAUUiKC5fnc4pFEFxObk9p0AIJaL0pbQQSkTpS60hlBBfWgmhQAglJJN7SCb3kNIH99LnNqBgCEUjKP7jsSGFIyj+47EhJaT0KaT0OaT0/cdjI4qE+CIhmawhmawhmawRmawuVw9r052ihAOKRFBcvjGbUyiC4jIem1MghBJS+j0kk3uILxCSyeCSyfcXCri0AcXltN6cEuILhfjiMoaZUlweNlDlOwVhQHHwhWvZL5/lCgNfBEIoIb54HNmaUdjlvSkuBHdKqQMKR1A81mFeoGAIRSMoHp9RvEAJKf0eUvoe6zBzCoT44rEOw1XvV0G1Ts8Uj2M5L1AghCIRFI9PnF+gUASFQ3zhkHKREF+EIyga4otG5FgtJYQCIZSITHZ5nOkFinvpY3mmeJzteYGCIRSNoHiskLxA4QgKhJQ+hJQ+hJS+/0hpSAnxhUIymUIymUMymUMy2WW1p+93pG3/xkH/4rLaM6dIBMVlPDanUADF5XGmFygQQonI5FZDfKkRmdyaRyZDua8nw/NJlY3CEZQe4ovHqZsXKB4tf6f7bgKUQem7rPbMKRBCkQiKy2rPnEIRFA4pfQ4pfZ8xzIwiIb4cjGGk7RRhnVC2raR6o2yLIT+9gvaDcnDvgTeFAyhH79l4U0J8Gff72//71pP3XvmR8sNsvNVRoezbCsA4EVcQb99+bv/Wgbhx5+dOwQgKhviCIb5QiC/jj3Ir1tu1ARWlPKfmeFdhbsYms/HXtnMzNJmNvyWZm41rq+I+XFd+ruQwvidyboY2MzWZjT9FnZvZaOPDcHMzG63bfBuvrk7NxgfK5ma25DpoD6dmtgIgG41sqcw2Gtt8G29wfmH23BrLPnGXfh9RdtTBb+/t9uPbuB+//SFHWi45nEqO5oqOpooOllTRwUKp5NRc0am5cqf1XHJyRafnyh0Ijo7cjrqi9IEcCu5C93PXVHggh1suObHNIOFtB5Eevka6yxHIJUdTyQnu0SdyKLhHn8pJlcoHN3j+PjkONWvfanq8pOQBocsRHgOBGYKXIzw67BlivRdQ1yNwPeLXt3uY9yGI1HqvfLWUT4jDbQEvQCQAQhABifCEI8qEI7JLIjyRiDLRCE88PrDrbb/btPb+sC6/Y9jjC7tXMBSC8biP/BUMxGAkBOPxmd0rmBhvXA5FEd4/TqPHS4H7jcIRFJfj43MKhlA0guJx4dELlBBfKKRcKMQXl0NRc0qILxKSYxLSwmhIC6MhmawRpS/Fu/QHl5tvFImg1BZCoQiKx1VEL1AghBJS+j2k9HtI6buPlMaUEF8wJJMxJJMxJJMpJJPJvfTbgMI1hIIhFI2guI/HxhSOoGhI6WtEJmupIRQMoXhkMj98CCH9+SModfnQbk4J8aWF+OIyhplTOIICIb64jC7mFPSmYHumjM/UNqXbZlov/fkwuh4srEzN1GR2sIMzNROTmdhoB73bzGzcXfWyf4Hf6+DbHR33PxMzKaXazGy0aqONL+Cbmo2nr3MzG63baB1sZmoyGz8zPzcTkxnaaGijkS2SbCs3ttUAOagBILtZK5NGfPb930ahCIqWEAoGUA5uFPOmHLR/X3+XuS0pFpPZ+MZq3w/6pB58YORN4QgKhviCIb5QiC9s+XZxMwObmZrMxgO4uRmbzLTZzFaeVv8D0Upfj+DliFrXI3A5opX1iAAvdDmirzz4+/zb1vcRXINybyA7lE9BS0+/mgRZvmeVZvpWV5rpW105uFpnakbNZmajcbeZ2Whi803IZKbVZmZLLrV8Gy+9dJuZjVbBZmajNZtvbXmP2pd+RviJoOUIKOsRsB6xvEftuN4LXD6Y7bT6U5oNwcsRXNcjcDlCynpEgBe6HKHLZ2B9/TwSSluPWN5fQC3rEctnYLB+Hvn965EMCFlY9QafCpXblIrrYEYFHqMVRzlQfpec1kdyMJUcXF8DcH09xuXjPqC+HrF8sgK8vvPh9V5IXY9YPmICLesRsB4hqxFY+nrEei9qW49YPu7DVtcjcD1ieX+Bva9HLJ+sIKz3Apb3F4jL1wkQaTmCynoErEcsXydAXu8Fr+8vZPlQDWV91dP1/YWu7y90eX9BBdYj1ntR+3rE8nVlam09Ynl/Qb2sRyyfJRGs98JjY2qGWD5UO7gsyxexvL8gqusRy/sL4rIeEeDF+v5Clk/tD27gckXo+v5Cl/cXXOp6xHovalmPGPYXrteticddW3NI6xEQDYD0CE96RJlARHZBhCcYUSYY4QlFXEq4YTgE43GjwysYjMFoCEZ6DEZCMBrjjcedoVKp3zAfn5XsP//86lrE48rQFygUQfG4MPQFCoRQJILSQnzpIeXSY3zRCAqE+AIhOYYhLQyGtDAUkskUUvrkXfqt1GeKw5Xnr1A4giI1hIIhFI2gaEjpa0Tpu9yA9QKFIig1xJeKIZSITNbWQyghmdw9Sv9hAiMNdUChCAqUEAqEUCSC4jIem1NCSp9CMplCfOGQTOaQTOaQTJaQTJaQ0teQ0teQ0teA0tfisnLVeN/akl7rgMIRFJeR0pTiMoaZUySC4nFX6MeX8XdK/+mm2MHPoeyXbEG7T6gryWgftD/s3rd7+hIOl4Opt305mOT+KVZTuTnMJ3PY4xb4/1oO48kc9ri99r+Ww6crYT2Zw9TP5rCczGE+28CD6WQOy9kGHnK2EtazDTxc5v3/pRw+2cCjlpMNPGo52Xy41pMNPGo9Wwm3kw08ajvZfLj2kw08qsuhvP9SDp9sPlzhbAMPOFsJ49kGHniy+XClsw086GwDDzrbfNjlnMt/KYfPVsJytoGHvNd8uLf9QdDOWgcO63u10i84/F51eOpwe7NFvLnD9b1GWi84fLaUbu/VLc0d7mdL6X6ybqm92RLPCw6frVvCs9XhN1vimTv8Zks8Lzh8thLms5Uwn60ffrMlnrnDAmdz+L32luYO69mGlnqyoWUv77V7+ILDJxt49LOtafV6soFHb+91bOkFh+FsDp9saNn7yQYe/c0Ops0dxuwl3O435/YCXzvMqrc/vf2zPf74h7cu5x2ol91bov7o7SdFIyguO/tzCkdQtIZQMIQSUfpQMIQS4kuFEEqIL62HUCJqJfQaQgnJZJcbaXn/9ccF98+37YDLDWhzikRQXA40zykUQXG5kXZOCSl9CslkDvGFQzLZ5QY01nsLI3VE4QiKy0hpTsEQigZQ0OWb3zklovSxhvhSQ3xpLYQS4kuvIRQMoYTUSgjJZAgpfXQv/d4HFIqg+IyUphQIoUgEhVsIJaT0JaT0JaT0RSMoGuKLRmQylRZCichkqiWE4lH6QnynKD5SQlfPpcjtMmGpnb7+ca1butyEVIL++PMfwXHZD93GI3twlJ87X3K5HWNK6SG+uOw+TSkuQy9t96qxjbJdk/Z7e1x1rz2931+I611v7kpyd39nHUWHBkxL293V8nNwPikaQfG4VfQFCkdQPI4pv0DBCIqE+CIh5aIhvigFULjUEAqGUCJaGK49hBKRydxCSr+5lz7RM8VjdPYCBUIoEkGBFkKhCAqGlD6GlD6GlL7/SGlICfGFQzKZQzJZQjJZQjLZ4yOdj6sgd0pFeaZ4fBnzAoUDKOIyHptTMISiEZTaQygRmSwtxJcWksk9JJO7SybzfnhEWx1QPJ7OfIEiERTsIRSPHGud7pSHn+8Uj8sJ5xSPh7lfoEgExeMY1Mcx2p0C/ad+//nnBHr7NWG9L86OlzYFbiu525YIPv74U79LXsk9Sr3ic5S0hVAogKKlhFAghCIRlNpCKCGl30JK32WFZ0rpIb64rPDAfdN42ykqA4pGUDx2+V6gcATF44DVCxQMoYSUPoX4QiG+cEit5BBfJKRWSkit1JBaqSGZrOtLv5VS3Eu/w4AiERSXkdKcQhEUl5HSnAIhlJDS7yGl30NKH2oIJcQXDMlkDMlkDMlkCslkj3sWt6HjftRNqQ0oLqeG5hQMoWgExWU8NqdwBEVDSl8jMrmWGkLBEEpEJleXvTACuFOkDygSQWkUQXHZpZpTPHKM7weKP04IPVNcVnumFJd1mDmFIigeH7p97KnsFNGfztov3Q350O+SV3gftzAPosQlhAIhFImguOyyzSkUQdGQ0teQ0teI0m8uKzxzSogvBys8st8p1+Th86IxpT6cE6vbHPipHWsHp52dKQennb0pFEHpIb6MTwj3Krc+rPfKj5QfZuNutULZh0nAOBFXEG8fOW3/1oG48ffj7hSNoHCILxzii4T4Mj6isY1O9wYNpTyn5njmOjPr46no3AxtZmoyG3+IPDUbL3x/zDYfuoaBGdrM1GQ2voR2bsYmM7DRxgf4pmZoo6HNt/HzNnMzMpmxLbkO2sOpma0AxEYTWyqrjaYm38DhPodtYLh/nFzr/QOvWsoNQgEQh8vzX4BwAKRFeNIiyqRHZFeP8AQiygQiPPHY/usN9vFX7w+jhgcMxmA0BOPxNdwrGA7BeOwBvoKhEIzEeCO/ntAfm7y3i1f+2PL7258XVMBhOe0VCoRQJICCDiOYVygUQakhvtSQcmkhvjh8rPYCpYf40kNyDEoIBUIoIZmMIaWP3qVfS32mOLxe+woFQygaQXH4vO8VCkdQJKT0JaT0JaT03UdKY0qEL1R6CCUik6nWEAqGUDxKv+4TmI/jMfpMaRBCkQiKy3hsTqEIist4bE4JKX0IyWQM8QVDMplCMplCMplDMplDSp9DSl9CSl9CSt9l5artRzI/DrG0AQVDKBpAYZfx2JzCERSX8dicEuJLCymXFuKLy0hpTgnxBUJyDDCEEtLCYEgmY0jpk3vpAw0oFEHhEkKBEIpEUKSFUEJKX0NKX0NK33+kNKBIgRBKRCZLbSGUiEyWVkIoHqXfK+yUDm1A0QhK7yEUjqC4jMfmFAyhhJQ+hmQyhvhCIZlMIZnMIZnMIZksJYQSkskiERQNyWR1yWS57yVB7U8UdTkNNadQBKWWEAqEUCSC0kJKv4X40kN86SG1EkJ8gZBaiSG1EkNqJYZkMoWUPrmXfns+paY+I6UpBUMoGkGRHkLhCIqGlL6GlL4GlH4tBUIoIb7UHkLhCEqrIRQMoXiUPuh9/oKtPlM6hFAkguIyHptTKILiMh6bU0JKH0MymUJ8oZBM5pBM5pBMlpBMdjmdPqeEZLLLHh/ulzx9fFPxU//y/HPPC+o2/bpW/x+U6nLOCpV2yuMz6XeKRFBqiC8uo6M5xaNV4f35+j/Ohz1TXE4+M+idMsoxly/RphSXL9Gk3seTWmlA4QiKy3meOQVDKBpBcfkSbU4JKX0JKX0JKX0JKX2Xvn5OifCllR5C8chkxdsQ5o8VkGeKy3meOYUiKC7neeYUCKFIBKWHlH4PKX0IKX0IKX0IKX0MKX0MKX2X8dicEuILh2Syx/nqbex4p2zzpAFFIygS4ouE+OJx0mZK6R4nbV6ghPji8Z37nOIxutgodKdUHVA8fGm0f+24Rac9U3oJoYT4AiG+ePTIc4rHF08vUEJ88egr5xSPEx0fLcid0vuA4u7LiOKxqvACJcQXDfHFY74/pUCBEEqILx7nE+YUj5OcGwXuFBxQeg2h+NSXfqfQ8+jC44bej9LddxMqUBlQKIKCIb5giC8eu+0vUDSCwiG+eHzr+gKFvSnyvEMN2kIoEb643DQ7p3h89fACBSMoLcQXj5XeOcXjy82Nsn/ruuXTiOLjS7lTKjxTwMMXbHqnsA4oEkHBEF88VkdfoFAExWN19AWKR19JeB/10ahWuqyOTikeZ/hfoHAExWVeOadgCCWi9F3uTX2BElH65LFb/QIlxBePU2qVH1auRmeuyOOU2pzSQ3zpGkHx2OF9gSIRFI8d3ipwH1sKDzLZ48TdnOIyhplTMISiERSPE3cvUEJKX0JKX0JK3+MGrRcoEb7wwdq461O9G0UjKAen070pEkFpIb6Mv6qbPKFceTyBn5odPO7p+vbuRsEICpcQSogvEuKLhPgyvk1n8szwZsYWMynNZkYms/Ha7NwMTWbtu0/xPpeX1Ntvpd+7qo56Q9ByRC/rEbAeIcsR335V2oBY78V4wuSLcEjasn+Y2PknxGAM1+8fskG5N5AdyqcggmyC1pczr89W5uUIWd/EHvS6nghd38RqgBe6GqGlh1bUj8XD2x+mfq+ojehTUK3ZBC0vZ21lPQLWI5Y3sQc34PkiljexB3ff+SKWj2IPbr1zqqifCFyP0OUI6usRshzB673wGN1MEN8e3XyakclMbbRvjyw+zdRg1sq3RwCfZmwyq81mZqO1ajNDm5mtAL49V/80E5MZ2AoAyGT27U7i08xWAGSjka0AyFYA376f6tOMTWbf3uP6NEObmZrMvn3d+KeZKSS1VJsZ2sxMIanfvoP708xGa91mNi4A3T977KWXZ7ODGwKmZmQyO/iWb2qGJjO00Q4uE5yaDZugXvbVsF6fN70+Tr3YzGw0ttHYRht/KjA3Y5OZ2mhqorVxyzU3I5PZeGtnboYms2ajNRut2yLZbeUG3WZ2UANAdrNWvp4PTffbtwD2EApHUKiFUEJ8OWj/vj7Q0NpBQzYx6yVgJ3yjaARlPHZyp4T40kJ8aSG+dMuBhtbHn7HOzchkhsVmBjYzNZnRyj2J59/eSxaR/vbnVbVNjqaSw5BLTq7oSK7oSK7oaM8lJ1V0Dm6t+G1yasklJ1WrDEsPyxnkUCo5S7eSDXI4lRxI1QzC0lN635eDuZpBzNVJ5BqcAufqJDhXMyi5oiOpcgdLcHTk9mUUSh/Iie7R9bagRYVHcjCXnNhmkPC2ekvcBnKCe/SZHGip5GDJJQdzycmVytRzyVl5TmywsilMt3b54wj+XVJT+ZTEmE+SppMk+QpOaz5JlE0SlXRRopIvShXySZJ0klq+gusln6R0HQpBvihBvihhzycpXbdL1PJJyhclzhclydcIeGxoektKN/YmzRclTRclLukaAa7pxt5c0w3huOWLUr6BLvd0jQD3dDMUhnRDOIZ8UULTd4OMpq+mmJrNzPTZGnOxmYHNzPTdIIuNJrYCUFsBqOnDTSnVZoY2M1MBSO02M1MBSLPRmq0AuukjOfn2wzY/zL793tqnGdjMxGSGzWZmCwnZQkK2kJAtJLZvWYVtIRFbSGzfsoraaGorAB0XwOQDwIPre+Zmpg83D+7mmZuZPtzUZqM1tJnpXwzfaOnBbaVTMxsNbDSw0bDbzEwfbqrto1S1fZSq3Gxmpg8AD64dmZuZPtw8uHZkbmah9VKazUxMZhVsZgc1wPOTvV4ahFAkgtJ7CCXEl4P27+tvIntBMZlFXCrcD67a8KYcrBp7UyJ82VIjhBLiS7V8SrnVpWozI5NZLzYzsJmpyQwsSwa9mi426vXbXw58monJzLRo1ivZaNxtZjaa2Hwz3eTWq+kmt83Mllymm9x6M93ktpnZaBVsZjZas/lmWv3qrTebmSm5GhSbma0AbC1XM13J1hvZaGTzzdZyNVvL1diWXKY7KDczWwHYWq6mplTupnX73k3r9r2XlcfkfyA8znTOELIc0dp6BC1H9Loesd4LKOsRDkn75UW6G0KXI7CvR/ByxNKTjp+I9V5wXY/49bflmPcPKKXW+6GFWsoNogGQ8ca8M8Thwb8XICGeBJQJFIyARHhSIQIS4cm3b50dLJVt06B9qWyreWWEkRBMbzEYCsFAicFADEZDMBjjDTq887x1t7eue/v3w7OdOPo56N55w7ad/7eH9ehBRw/77o0AweOPf+in7qEf+K5f+9f6qe9XB+D9p0o3QZJMEGeLEGeLkLRsgjiZIM0WIU0WIfz2QwDLBVEyQbVkE4TJBLVsEWqQTVCyrgN7sobx4Kag3ygIwhvG7W/r/W/zw6AXbpoonyZMGCdMGCcqCTVhPk2cME6cMU6aT5PDoq+/JsmnSXtCTfniRKUl1JRsfkI12QyOss1PqGWLUMsWoZ4tQj1bhCDZHPfg2qffKUiTCcJkC8gHd1D9RkGUrdpTts414WyEEs5GSBLGSTLGKd+sjRwOuPhryhcnLvnixCXfrI1rvtktV86nqeWb3XJLGKeeb4WZs81PONv8hAGyCUq2B8eYbA+OMVuEKFuEKNkMjjlbhDjZDI4lW8Mo2RpGyVbtNdnCDWu+UZEk3BuRkjBONWGcar7zCdLyjbKlJYxTwtmI9HwrXQL5VgQlfk7ygqZ8K12CCeOE+Va6JNv8RLLNT4ST7TAJJ1u4EU62bSqSLUKSLULxGyYzQckidHQl728UlKxh1GyntjTbqS3N9lWJxn9VUuV+Y6JUGUjKVvF7sqZRs+2LKGRribJtQ2i2bQilbEkd/602i/bPX0vtA0nxX2vPJXE6SVLzSaJ0kjRflBTzSfLu+4XKZDhSlG5XzG//lvtfR/5DFBT3gb+LKEkoyn1fYi6qtnr7+fZvwIEoTijKfWfCRRRmFKUJRfWeUVTGRIeMiQ4ZEx0yJjpmjBRlzCnKWPs4YzvFklCUZIyUZMwpzVj79De0U9s+9y5qG6c8iaq/YeIwF1VrRlGUUNTBYr20XZQ83K+oY8rkDauNgiEUjaAcrJR7U0J8GT+nMXkkDI7e2HF9Jgrq+Ii0O4UjKBLii4T4ohG+tGJ5f2szA5uZmswOHtGemrHJ7OAhjKmZ5V0ZaL3bzNhkBtVmhiYztNGQTGZko5HNN1KTGYPNzJZcpgfQNjNbAaiNpqZU7qXZzEy+9VpsZmgzMyVXNz2AtpnZCsDWcvVuSuUONhrYfLO1XN3WcnWyJZfpAbTNzFYAtpbr4DWVqZnYaGLz7dst1/NY6+v3ljYEr0bAtx9WMyBwPUKXI5Y/2AZQ13vx7dbegFj9ahRAb+sRtBzh8WDbDIHLEbjeC4T1iF/fE5i9SwTg8GnLCxAOgDjs67wAifBEIspEIrJLIzzRgDLB0iIgEe9dATpsd7yEwRiMhmBCHnDbMByCCXnADTxee3gF43Cgplbdz2Fuu1y1/oR5/j0WuS2jbv+8f7IxfiVsqwu3mo+9PP740wGHir+J5rsDnScOeD5zBh6vQ/ypBLoOCtrhwYdXMA4fAryEcTjdBEVum3Yfu+v3tB3u8PoWOoOHftK7/gZf669VZA/qw5mHehs0o8dBGm9NHudo3DVxtKYvv3UB9HjCzVdQsgi5vJLgK4iSCfI4x+MrKFuEWrYIeZyvdxXUSzZBkE2QJhME2SIEkkwQZus6MFvDSNkaRgpvGGf3IIHLKwnumhLGSRLGSSChJs2nSRPGSfPFiUtPqEnyaaotoSbOp6kljFOjfJqyzU9cnkjwFZRsfsKQLUKQLUKYLUKYLUIedxP5CsoWIe7ZBCVbQGYJn+NOLrfZJFE6SVrySYJ8kjSbJCnpoiTxE5KpJP/5CMrXkuaXJIn/PomDKP+9Eg9RGC5qetOA+M9JPERBRlGSUBS0jKIooSjMmOiYMdExY6JTxkSnjJHijDklGWufZGyntGYUlTBSWhLmlJaEtU/Lb2inZvcR6W+YOMxFNcgoShOK8rgzFKrCLqrVyfzY9QS0ugzn6/5Z0B/3ocyCOjnZqy6jeW9NnE8T1mhNXy/PqssmiKcgKtkEQbSg6X6suuyDOGvihHHihHFy+TDDW5Pk06QJ46Tp4oSltISaOJ+mWhNqonyaWsI4NUyoSVMNVLC47D24CpJkgiBbhCBbhDBbhDBbhKhnE5QtQtyyCaJkgiR8jjs5obFJwnySNJ2k+DnJXJJkk+Ty3IK3JE4nyX8+Qvi1pOlJn00UJhTVSkZREC5qtl2G1X9O4iCq94yiOKEoqBlFYUZRGRMdMyY6Zkx0ypjolDFSnDGnOGPtk4ztlJaMolJGKmFOtZKw9rXyG9qpyaEabL9h4jAX1XpGUZJQVPdYs+ut76I60qOoTwpHUFxG0XMKhlA0guIycJ1TQkqfQnyhEF84pFZyiC8SUislpFZKSK3UkEzWiNLvxb30uQwoFEGpJYQCIRSJoLQWQgkp/R5S+j2k9LtGUCDEFwjJZAzJZAzJZArJZAopfXIvfcFnCvcQCkdQ/MdjQwqGUDSCoiGlrxGlD6WGUCiCUkN8qRhCichkaD2EEpLJ3aP0odNOAeIBhSIoUEIoEEKRCIrLeGxOCSl9CslkCvGFQzLZ5ZMzLPuvYRtKDCgaQXH5LGxO4QiKy00QcwqGUCJKHwuGUEJ8qRBCCfGl9RBKRK3EXkMoIZncQ0of3Esf24AiERSXkdKcQhEUl5WrOQVCKCGlzyGlzyGlLzWEEuKLhmSyhmSyRmSyz4OEc4pH6VO9H9Khh8dYd4rLytWcgiEUjaC4jMfmFI6g9JDS7yGZDCG+QEgmQ0gmu5y52n6yU7j1AUUiKBTiC4X44jKGmVJcxjBzSogvLqOLOcWlVvJ9N4HheTeBi4cvTHeKFBpQNILi8uDWlOJyNcuU4nLqRpR3itbJ97uedzaiz3tVInjX//OodXDou1Qunz+vpfWRKE0oymV3yl2URIv6+gYJdlnNcRXEyQS57KZ9S1CbXRnFLntvzpo4YZw4YZxc7mzx1oT5NGnCOGnGOGk6TT6PWXlrknyaak+oKWGcWkuoiXINVKTXbIIwmSDIFiHIFiHMFiHMFiEq2QSli5AmE8Q9m6DfMMfd3z4hau1ZkrR8kiidJC35JGE2ST6vUjlLgnyS3MfZDz8fSpKC+02Shev9x5+Xd2ht+SRxOkmthkvq+6+3MWwfSKJ0knrJJwnySZJ0kqDlk5QvvTFfemO+9MZ86U35osT5conz1TjJ1y4Jp5Ok+aKk2XKJSslW4zZJ8e0S7qcVZFu1GUjSdJL8N0x+XRKnk/QbZihTSZROUs8XJf8dk1+X9BsaAdibym3s/ywJIJ8kSScJWz5JnE4S5YsSUTpJHjOUj2f8br/+eI7ta0mep2Y3/eihv9Fdv87OguL+44drknurN0WaTZFAOkUSrejLfTsqHpMrX0GcS1D1uA7se4JmB3U2TZhPUy0JNUGyZKqaTJDHR6O+grJFqGeLUM8WIcgWIUjWy7q8fuUrKFsvSzWbIIwX9OXxCqpc8kmCfJIknSTp+STli9LvmIrMJJGzpG1EOplAEuyPqxLdb/OGT0mtlHySMJ8kjZY02w1r7nMRB0mSTlJr+SRROkm95JOUL717vvSGfOkN+dIb80UJ8+US5atxnK9dYkwnSfJFSfLlkuSrcRrfLk3OMjT37ZJfltTdN0wcJGE+SZpO0m+YoUwl5YuS+46Jg6Tf0Ah8fbyi95ZPEqWTBCWfJEwnCfNFCSGfJI/xUoUHSfp0+fO2YNojKB4Xb71A8WgQGuwXJ2J7/LbyRvG4zvQFCoZQNILi8ZjgCxQOoEDpIZSIcoEa4ovLovSU0kJ8aSE51msIBUMoIZkMIaUP7qX//MgjuTzz9wKFIigeNxG9QIEQikRQOKT0OaT0JaT0/UdKI4qG+KIhmawRmYylhVAiMhldzkL3XnfKNgceUDCEohEUl/HYnMIRFJfx2JwSUvoQkskQ40tIJmNIJmNIJlNIJlNI6VNI6XNI6XNI6busXN33VP949v6RMjjXV6nc3oba/g33Pdjbd4/oMnzzFuUy2nMXBdGiuOLtbzM8PCJzO0+LqtkkkcsCnbMkTifJ4xpFb0n5otRqPknuzWV/nu9QLyEUCKFIBAVaCIUiKBjiC4b4QiG+UEiOcUh9kZC6LyGlryGlrxG+cCkhFAihaASlhvhSI+o+u3xHA3o/QYHPD/VuFI6g9BBfeogvLitdU4rLiak5JcQXlxNHc4q4UO61cls7e6a4rA5ts+idQs/PAW8UiaB4XF77AoUiKC7rN3MKBFCklBBKRLlIDfHFZR9tSmkhvrSQHGsRLYz0FkIJyWQIKX1wL/3OA4pGULCHUDiC4rKPNqdgCCWk9Dmk9Dmk9P1HSkNKiC8akskakskakclaegjFo/TpYf7C7XlH2OU1rRcoFEFxGY/NKRBCkQhKDyn9HpLJEOILhGQyhmQyhmQyhmQyhZQ+hZQ+h5Q+h5S+y8oV0/1ck5Sf1vos52hcXmnyF8UJRbkMDr8lanb+weWlJldJ7PJSk7ckyCdJ00mq+aJUJZ2k5t5c1qf5zkbhCEqvIRQMoWgExeXLyjklxBcM8QVDfKGQHOOQ+sIhdV9CSl9CSl9DfNGIcvF5j2VOoQhKDfGlYgjFI5Mf3vhCbfpMcVlPm1NCfOkhvrisdM0p7EKBOwXxmeJx0pjK/gzbx1uQMqBwBMVjT/AFCoZQNILisSf4AiXEFwkpFwnxxeNc0wuUCF9a6SGUiBam1RpCwRBKSOk399LHNqBIBKW3EApFUDxOT71AgRBKSOljSOljSOn7j5SGlBBfOCSTOSSTOSSTJSSTPc6ZU+1l//U2Jn6meGyQvUDBEIoGULrLeGxO4QhKrSGUiEzuLcSXhiGUkEz2eEeWWttXSD7epBlQJILisab0AoUiKB6np16gQAglpPQpxBcK8YVDaiWH+CIhtVJCaqWG1EoNyWSNKH0o7qXPbUDhCIrLSGlOwRCKRlBaD6GElH4PKf0eUvpQQigxvoRkMoZkMoZkMoVkMoWUPrmXvvZnisvK1ZwiERT/8diQQhEU//HYkBJS+hpR+lhaCIUjKDXElxqRydhKCAVCKCGZ7LKTuK2A7L/uigMKR1CghlAwhKIRFJfx2JwSUvoUkskU4guHZLLH89m0zYL2X2OtzxSPOyRfoIT4oiG+uIxhZhSXy7FfoIT44jK6mFJc9sWg653S+4Di4QvifqKbqJZniss6zJyiERSP88lzisupG1J4+DUOKBxBoRBfKMQXl15sSnHpxUj7/dcyonj4Ig+71UKDTHbpxeYUCKFIAIVd5vtzCkVQagmhhPjSQnxpEbWSe4gvHUIoIbUSQmolhGQyhpQ+upf+w8/vFI2geNwd/QKFIygu8/05BUMoIaUvIaUvIaWvLYQS4YuUGkLBEEpEJkvtIRSP0teHtQt9fhWdxeN+mBcoFEFxGY/NKRBCkQgKhJQ+hGQyhviCIZlMIZnscXL444ap26+36TAPKBpB4RBfOMQXjzHMnOIxhtko+xrstkxRBhQPXyqWO0We+0r1WO15gUIRFI/VnhcoEEKRCEoLKf0W4ksP8aWH1EoI8QVCaiWG1EoMqZUYkskUUvrkXvr6/DWHeqz2vEDBEIpGUDxWe16gcARFQ0pfQ0pfA0pfXG4wfoES4kvtIRSOoLQaQsEQSkjpd+/Sb1UHFImguI/HxhSKoLiPx8YUCKGElD6FlD6FlL77eGxMCfFFQjJZQjJZQjJZQzLZ460Kbry/dMy9Pp0dFZf7k1+gYAhFIygu47E5hSMoLaT0W0gm9xBfekgme5yC/riZZadAb88UjxsOX6CE+OJxCnpOcRnD9Ib30qdB6RNHUFzGMHMKhlA0guKypjSnhJS+hpS+yxhmRmmlhlA8MhlkP8/P2AYUl923OQVCKBJBcdl9m1MogtJDfOkh5QIhvnic7ZlTMMQXDMkxCmlhKKSFoZBM5pDSZ/fSf34ZXLY+OYSCIRSNoHi8lvUChQMovdQQCoZQIkq/+4+UhpQQX1oPoYRkcg/J5B6SyS6rPVTua0qPzzHvFJfVnjlFIigu47E5hSIoLuOxOSWk9CkkkznEFw7JZHHJ5PtdBMzUBhSOoGiEL1BKCMWj5Se8rymRPpc+uKz2zCkQQpEIistqz5xCEZQeUvo9pPR9xjAzCoT44jKG2bY9d4o83w8jLjcbv0DhCIrHzcYvUDCEohEUDil9DvFFQnyRkFqpIb5oRK3EUkMoGEKJyGSsPYTiXvr4fH4MXUZKcwpFUFxGSnMKhFAkggIhpQ8hpY8hpY8YQaEQXygkkykkkzkkkzkkkyWk9MW99B9+fqdoBMV/PDakcACF/MdjQwqGUCJKn2oPoYSUvv94bEgJ8aWHZHIPyeQekskQkskup6H0fjPYx/ftzxSX3bc5hSIoLuOxOQVCKBJB4ZDS55BMlhBfJCSTPe7ollL3/UopzAMKBlC4lBCKRFBcxjDKcqdUHFAkguIyhplTKILisqY0p0AIJaT0IaT0fcYwMwqG+OIxhtkGfbxT6qDlZ4/dtxcoGELRCIrH7tsLFI6gSIgvElIuGuKLxwsgU4qUHkKJyDGpNYSCIZSITJYWUvrNvfSlPFM8vkp7gUIRFI8X2F+gQAhFIigYUvoYUvoUUvr+I6URhUN84ZBM5pBMlpBMlpBMdlntabCvJ29diQwoGELRAIq6jMfmFI6guIzH5pSI0tdWQigxvoRkssedkNug7r520UUHFImgQIgvWEMoHi1/03KntOf1ZHVZ7ZlTMISiERSX1Z45hSMoElL6ElL6PmOYKSXGl3Emy0Obwfo1pdb7aybbv+E+3yf8g6JH91p7UySCcrAv5k0J8aV9t/R/mHWwmdloYKOBjYY2GtpoZKORjcY2Gtto0m1mYjJTG01NtFq6zYxNZgfTpqkZmcwOJjZTM7SZmZKr2pqg2m3FDbbiBltxH6xcTs1sxU225CJbcbMtuWwtV7W1XNXWclVby1XVVtxqSq6jSyenZqbkOroWcmqGNjNTcbcGNjNTcbfebWa24oZmM7MVN9qSC23FTbbkso25mm3M1dhW3GxLLrEVt9iSS23Frabk6qXYzNBmZiruo3vXpmam4j66GW1qZiru3pvNzFbcUG1mw+LuoLdHfTt2+tuXE2e+rWM/HIuF298fX3/h9/fHwzHHv09r//54gOf49xeXryzWP/7I0e/vj4eFbn8fxk8GO/79xfrrYv3jltzv77e1+XNwuZPj319bfwEW61/cvwDWxX9/bfsPtDj+tDj+4/6rKt7+/jbx5q//vtTbb6Xfd2j6xyfvT79FuYlB6T/99lMO5JIjqeSMpzvL5FC77aZRx5EcTiVHU0UHS8klB1PJGW8r/jY54xfWfp8cipVT73JoIKfXXHJyRQeCu1C9rQhQ4ZEcSiUHey45kkoOQS45mkoO54oO58qd4NHgTI7D8fD68fjFTbz0/tOh2sHPoewHfuDhtFclGfna9tG19HJXQjgMTL3dPC61/fTjP7ylAu/kbdmnkwfevlfZNtq9fRh+7d7WtyrbqbenKluHDz4z1VvBu7f09Y9rpXL709u/H165uAfnrVLhODg/vI0eKH+9uEOYaiWOMNVKHAWP2ycTdKJUyxcHV4r9NjlMqeRIqsUdEk0lR1Ot4nJpmRZ3uHAqOTVXdGqqtaaDe89+n5xUqykHd5z9Njm5lk0ZMJUczBUdzJU7uVZxmX/928XaS79NV7Z/09NdEsoOt9K/QoEQikRQHF46fIVCARQpJYQCIZSI0heHG11foYT40loIJSSTe0gm95BM7h6lX/dR9vbvXv/29YpZhV1T5buk8YoZy34fNQve//RwxYy3BcDbj4nkb5PlRNB9oa9ie15g87hebQvHvU/vlfXr4ICW24VMoHWyIPrxguRtCAAEA/3qoR94199KmxWu3P72tg9znx7X21BDsCfUJPk0UYvWRH0fJOJ9BVPpJoiTCeJsEeJsEXK4xMVZECUTpNkipMkipC7DdldBmE2QJhPksf3vKyhbhFrPJihZ16E9WcOoPVvDCOEN4/a39f63H84aFLhpwnyaMGGcMGOcNJ8mh/fE/DUljBMnjBNLPk3SE2rifJq0JdSULU69lFITako1P9kE1VQzuA9BqeYnm6CWLUItW4R6tgj1dBFKNcfdBEG2CIEkE4SpFpA/BIXPcVn2PbBtu3kgiWo+SZhPkqaTFD8lmUvKF6X4Cclckvs4u882I4vS7aOj7d9y/+vIn6L890k8RFE+UdV/v2Qqqra6//yn3eS7KMwoShOKqj2jKE4oqtWMojImesuY6D1joveMiQ4ZIwUZcwoz1j7K2E4RJRTFGSPFGXOKM9Y++Q3tVBfYRcHj1Ocm6jdMHF4QpflEtQIZRXms2TXZr0joveCjqB8Ul0H3nMIRFJdh8ZyCIRSNoPQQXyCkXCDEF5cjNXNKjC8hOUYhLQyFtDAckskcUvrsXvpVnykun4TOKRJBcTkaMqdQAKWXEkKBEEpE6ffaQigcQWkhvrSQTO4hmdxDMrmHZDJ4lH7nB4qWAYUjKFhDKBhC0QiKy3hsTgkpfQ7JZA7xRUIyWUIyWUIyWUMyWSNKH0oNoWAIJaL0wWV0AXqn4MPtxTvF5WOsOQVDKBpBcdmzm1M4goIhpY8hvlCILxRSKznEFw6plRxSKyWkVkpIJmtI6at76f98ofUfFHRZh5lTIIQiERSXdZg5hSIoLaT0W0jpt5DS7z2EEuILhGQyhGQyhmQyhmQyhpQ+uZc+4oDCERT/8diQgiEUjaD4j8eGlJDS15DS14jSJ//x2JAS40tEJlPtIZSITKZWQygepX9/C2H7N9IzxWVfbE6BEIpEUFzGY3MKRVAwpPQxJJMpxBcKyWTyyGQu96uFuQ9aGO4hFI6guOyLzSkYQtEIioaUvkb4wqWHUCJqJdcQX2pEreRWQygYQgnJ5B5S+t299OH5BBG7jJTmFIqguIyU5hQIoUgEhUJKn0JKn0NKnzGCIiG+SEgmS0gma0gma0Qm+zzyc3/Z6uMDNRpQMISiERSX8dicwhEUl/HYnBJS+j0kk3uMLyGZDCGZ7HLmSnT/7rUrPO+LicvVcHNKiC8U4ovLGGZOwQiKhPjiMrqYUlzWYe53lm0ULgOKgy9Q2k6BQj/NKwc/r1RuL65v/4a+//zH81e9aGkZRXFCUbVGi+KKt7/NUB+eOqWbJEonyeOglLckyCdJ00nq+aLUJZ0kcG8uuT/1FAocQcEaQsEQikZQPL7Ie4ES4guH+MIhvkhIjmlIfdGAul9L6SEUjaDUEF9qSLm0GkKhCEoP8aVjCCUkkz1Wh2Bbdd4plduAIhEUDPEFQ3zx2OGaUzzOZr9ACfHFY+/pBYp6U0SeKQohlAhftsofQfH48usFCrtQ9rvqoVV6pjQXX2qbUDiC0kN88Xj08wUKRlAQIigeZ00/lrb3BUx4vk1oqy49hMIRFI+zpi9QMISiERQNKX2NKP1WagiFIig1xJeKIZSITG6th1BCMtljjlyB9E75+Qae4c/380n1YZty64RGC+LSb99JsGDdf/2xkP78Y2o3IUwkX//4Q+o+Ha7Y6PHnn8HxKALcf739++fPe59/vkXvNugErfS1BwJw+9MCBM/6PTYLKha666c6K1zZvX28/76i3jRRPk0eGxHumjBa05fvHtbm8W2Vr6BsEeJsEfJ4XtBXkCYTJNkiJNki5DJsdxUkuQT10rIJ4mSCarYIVUomqCXrOnpL1jD2lqxh7D28Ydz+tt7/9v1w0LaoftMk+TRBwjhBwjhhS6iJ82mihHGihHHimlAT5dMkJaEmzKdJE8bJY2fcXVOy+QmUZDM4yDY/gZotQjVbhFq2CLVsEerJ5rjQs0UIajZByRaQAcLnuHz/aFC26eOzJI/zJ96SJJ2k+DnJXBKnk8T5ohQ/IZlK8p+P6GwzsijtPy8q97/++cT0JgoyitKEovz3S6aiZq/Ob6Iknyj03zfxEEUJRdWSURRkFJUx0VvGRG8ZE71nTPSeMVKQMacgY+3DjO0UakJRlDFSlDGnOGPt49/QTnV5OF9c2rOo3zBxmIvSllEU5xNFLh86ENxF0fPFVBuFIiguo+g5BUIoEkFxGbjOKSG+9JBy6SG+uBypmVNCfMGQHMOQFoZCWhgKyWQKKX12L/3HNbmdwhEUqSEUDKFoBEV7CCWi9LnUEEpE6bP/SGlIifElIpO59RBKSCb3kEz2uDapMtzvTGXiZ4rHVRAvUCCEIhEUl/HYnEIRFAopfQrJZA7xhUMymUMyWUIyWUIyWUNKX0NKXyNKX0oLoXiUvjws2gn+1FcOu9avLwqv4jJ8cxeFGUVptKjJBc9VXD68c5Yk6SS5nLZ1lsTpJEG+KAGlk4TuzSU9XxUpiCEUjaB4XEP+AoUjKC6fyc0pIb5IiC8S4ouG5JhG1BctEXXf5X2YFygRpa8txJcWUi4tJMdc9jfnlBBfoIdQPDJZe90pSvhMcVlPm1MoguKynjanQAhFIigcUvoc4ouE+CIhtVJDfNGAWtlKKSEUCKFIBKW2EIp76bM+U1xGSnMKhlA0guJycdOcwhEUCCl9CCl9CCl9hBBKiC8UkskUkskckskckskcUvriXvpKA4pEUPzHY0MKBVCq/3hsSIEQSkTp19pCKCGl7z8eG1JCfOkhmdxDMrmHZDKEZLLHJtrHSOhG2Vp5fqZ43Ir/AgVDKBpB8RiPvUDhCAqHlD6HZLKE+CIhmexxMn9rDfeXT7Z8gmeKx0mwFygSQGkeJ8FeoFAExeNo1wuUEF9aSLm0EF88zsy/QAnxBUJyDCCEEtLCYEgmY0jpk3vpswwoGELRCIrHs5YvUDiCIjWEElL6ElL6GlL6/iOlAaWXHkKJyOReawgFQygRmdw9vmHcetz9ccePlnFAkQiKx/nwFygUQXEZj80pEEIJKX0MyWQM8YVCMplCMtnjG8atNbyvkGy6BxSMoEiILxLii8sYZk6RAIrLaxdzisvoYk4hF8q93+/y3O9DqyEUj0yG/X3nj4eEn89cgceO1QuUEF8gxBeXHnlKcemR55QQX1z6yinFZf8F7h/AfugeUCiCIiG+uMz3pxSXnZE5RQIoOK4vKDczlPsgrn++TL4tQzaT1TDTqJVPK+o4sBrfRzGzGp9Un1oN1yWo3q1oYDU+uTS1srAObuNEvSUFFR5ZocVqvNM0tTKxmonVbCy1WI3PDBPePjEibgOr8encqRVZrMbnWqdWarEiUzQOVrBrvZ12aduW990OyqfdwRxobqdzOxnYHbTwczsbj8c3xsr+zqB0eI7mwb1mM6vxGt/Uii1W4z3RqRVZrMDEGp9rn1qNI194txq0IDx+SvfYatChU9u/aHzswbb6+MkY76r5MsZ968z78f1FUysxWMl4BWBm1S25IOM52tQKTFZisRrvTU+tLDVeyMQiS40XtmSUsCyvITK+EcyVoaYcP7ghYGplae90fI/RzGp8xqGWts9kCtzHFsqD4IHuDNB6H0Z/TLKf9WzrHzdB8HAc4vOGqKZUx4J0n77XqqGCDiK0X3JTi0wiVJH5nl79a0GK/bZKqfjw4PEuaDxFexS07QY8CvphNu5HpmbjpeoKsC+lAvKgwownXDO7XsaHB1+wI5vdeNr1gh0a7YaVu95fud7aonsWws1sPI6cm4nJDGy0g7r7cDUtURmYocmMbb6Ne4upmVabmYlWS7WZ2WgHdWBqBjYzU7nV8enVuRmbzLoplWsnkxk0m5mazBBMZlRsZraQsI3GNt+O2pKvzQ4eWyK9DZ643FOrtX6zUouVWlgHa5G94G1AsjWIkwEJP7yf2waIceuxdSJ1RyD9eRjTD1Yup2bjzdO5mZjMxsuQczM1mYEpJFwPROpexttKxddlvHU4XPbxbOswoEgEZdzKu1M4gtJDfDlImk63cX3vD/OTAwrfzyoWxhFlnNHQb+o6AM8oDzeEba1OeaaMd6077Cu6G0VmFK37qaiiKAMKR1DGazPuFIqgjPfG3SkhvozvV/CmaEgma4QvB+u77pQQX2qILzWihZHWQigRtVLG58i8KfDdHPthhs1mxiaz8SpKx3ZbWeo47Wpr1/uyHrQ+oFAEZTyLc6dgBEUifDnaaPhyc2azEotVbSYrsli1YrJCi1U3scbXokytDFumXWH5llXX8TKPL4OrxXtWi5WwxUoN2+dQxptpXx+5g4PV9plVNxyegzLeCJ9aicVqPC37+vDcZiUWKzKxxle0fH3IDA6uwJtakcVKTCwxsdTEUjRZGQ60QR1/kjqzGvdXM6txzzO1QpOVKRpg6PM3K7FYWY6nbFZksaJiskKLFZtYDCYrQ58Pdf0xFTi4RsiV0SyHWjYrtVg1tlh1S5/fjg5I0L40ug3fd7s6jt5e01t5qOmtDvdV9s83eRum3CP98XrraJ7x+WN4ONLSyui3W7D3I7Ct6OTXuH8Zgw9rsh+//YwLXXEZxeXgRMAVlytfRnHp5cqXcVyufBnG5eBUzhWXK1+GcWlX+zKOC19xGcWlX+PdcVzkpHHZz6VQxUFc4Kz5MovLWduXSVzwypdxXK58GcaFrnwZx+Ws491JXPjKl3FcrvZlGJfx801XXOQa7w7jMt5LueIy3vE9fVxg/KnNu8Xl09dT5MAPX+sp2oFPX0/RF/zwtZ1i/Pjp6ynGhD987adYB//09UR9DpxiP+zT11PM+X/4iicqVzxRfaX3aYeb3LaMWn/Q8eDr+9TXqa/8PvV17iucyNf3GftPfX2js55zX0/UNumJ2iZ9n7HEzFcs5ylXLOfpc/CN1hGnvtb32X+a+/o+601TX9/o3OXc1xP1Oe1EbVM/Udv0Ruc7p77Cicr1jc5hct1l8J/OKH/v1z8ig+/TQ30rMh+Xdt48pIcXeB8i8z5tvHNk6KS1aR6ZNzp36B2Z91lp+l5kmHcPWUd9k5y1BZ5H5n1mFN6ROWvfNI2Mvs+o1jsyZ+21Z5GhN/r63jsyV699EJl65cxRZK5e+ygyV699EJl29dpHkbl67YPIvNFZXu/IXC3wUWSuFvggMnDWnNGyv/albRQZPGvfNI/MuG+qst9j3gB/iswPu4NH/b6we1a3Lc/fVhxR8eHXpQ9+TfsTofwQpbuig3NwM0+42CLAB28vTu0OXnWb2h2cy53aHdxjOLOT8W28c7uDveap3cGzdVM7Muo0xvPgNYIX7DRZjRHhbIo0W6uiLVuMtKeLEfRsijhdjCRdjL7fL6xVhEePIP9GRT1djHqyXgQPXln4rYrSxShbT4u1ZotRzdbTYs3W02KldDHK1tNizdbTYqvZYtTS9bQtXU/bKF2M0vW0LV1P22u2GPV0PW1P19P2Nzol5nhX9RaXs97FNonLae/um8XlypdRXKBc+TKOy5Uvw7i80be8vnG58mUYl3a1L8O49OuNo3FcrvHuMC5w1jeOvrx7eIvLWfNlEpdz3C1oiMuVL8O40JUv47hc+TKOy3UX/jAufOXLMC5ytS/juFxvHA3jcto3pmdxud44GsUFy/Um1jgup3nXArGe5l0LfKd7Bqe+nuN9509fT3NPPuI51kA/fYUT+XqiPueN7hmc+3qat88Q3+i7yLmvJ6qv9D7t8ORe0M3X09zji8inue918/U0d4zjO90fOPf1NHeM4zvd8Tf19Y1u7Zv7epo7xpHKecqVynn6HHqjdcS5r6d5IwupneYtpc1XOJGvJ+pz+onapn6itumNznfOfT1Rub7ROUzXt1m2yLxPD+X6mgQSXe9sHETmjV5g9o7MWW+4nEfmuhV1eCsqkpy1BZ5H5n1mFM6R0bP2TfPIXK9JjCPDb/SGtXdkrhb4KDJXr30QmXrlzFFkrl77IDLt6rWPInP12geReaPTud6RuVrgo8hcLfBBZOBqgY8ic9acmbxAgoxn7ZumkSHTCxWb3bdfJnlW93C/I0mD+6+H9zsy3Q4k88PqZCX5VCSmN09Qqi0C0qvNDpvNjrvN7uAew5mdVrTZdbLZgVGnMZ5qe5UIlWqyzFfSbIqYcymiUno2RTVZHm2KkuURFcBsijBdHmVrj8j7JQoHRZotj2q69qi2bLW/9mx5VNO1R5Wz1f7K6fIoXXvUarba31q2PGrp2qOG2Wq/9/shDorStUdNs9X+XrLlUU/XHvWjUe2+rlYrl5/sBgzpN0UsWPdfE45+DPf3Q7CUxx9/KsJsio5el/2NitLFSNLFSPLFSLMp0mwxgpItj6BQNkU1W5sNB3e7/UZFB+dHfqciyabo6HX336goWwsJR7slv08RpmshMV0vkm5UC5SuF+F0LSSni5GkyyMNjxE22hU1flKE8X0/1X1Ouy2DPitqLqXW7oqIvlZUVdv9/If2h2uNVW6iNKEonxGAsyjIWHyAGUVlzCmEjKIyRooyRooyRooztlPMwaKA9dYVg3QZSJKWTxKlk6QlnyTMJolKuihRgXySJF/LdHRF2u8V1UpGURmLr2dqxQcbkHw7Ro9yv7C6d73Jz9Qvfl8+/NeOPnDCjMaEsyfKOCcgSjjSJcrYSmacExBnjJRkjJRkbKe0phtgarr5E+ebGXC+mcHRfSC/U1LNF6Uq6SS1lq9lOrrb4DeLgoyiEnbBDAm74KPv2H+vKMwYKcwYKcrYTlG+4QqnG9Qxp1vuZc43XJF8wxXJFyXt+SQlnNtJSbgGJSXhGpTUhF2w1IRdsLSMkcq4pyEZTxpJz9hOQbrhikC6QZ1gujUoCT/49IKkdMMVoXxRonRrUMIJ53YiCdegJHyS8JKojF2wZuyCNWGktCSMlGY8aaQ1YTulNd1wRVu6QZ22dGtQ2tINVzR8i+MFSfmiBOnWoDT+QoLJh1LqM1L51odSyLcfE40UhX9uS9C+VKTxMdq7k02RTDqfCnq/yXgr7z87wCX+/oKvv4bbFFE2RbWnUyTZFDVIp0izKerpYtTT5RG0bIrkfd4VqHpztbWik1/j3tHg4HXZLS7vc3e+a1z0fd6Z9o3LlS+juNRy5cs4Lle+DONS3+fVKN+4XPkyjEu72pdxXPiKyygu/RrvjuPyPq9ofS8ueluUo4qDuLzRu2u+cTlr+zKJC175Mo7LlS/DuNCVL+O4nHW8O4kLX/kyjsvVvgzjcvC1+RWXa7w7jMvBlu8VF73iMohLO/iO583i8unrKXLgh6/1FO3Ap6+n6At++NpOMX789PUUY8IfvvZTrIN/+nqiPgdOsR/26esp5vw/fMUTlSueqL7S+7TDTW5bRq0/6Hjw9X3q69RXfp/6OvcVTuTr+4z9p76+0VnPua8napv0RG2Tvs9YYuZrL+cp117O0+f0N1pHnPpa32f/ae7r+6w3TX19o3OXc19P1Oe0E7VN/URt0xud75z6Cicq1zc6h8l1l8F/OqP8vV//iAy+Tw/1rchUotv3oZVYRpF5nzbeOTJ00to0j8wbnTv0jsz7rDR9LzLMu4eso75JztoCzyPzPjMK78ictW+aRkbfZ1TrHZmz9tqzyMAbfX3vHZmr1z6ITL1y5igyV699FJmr1z6ITLt67aPIXL32QWTe6Cyvd2SuFvgoMlcLfBAZOGvOaLlfzd1GkcGz9k3zyBw8RSNys2uAP0Xmhx3hd+2e1SHqbcURFR9+Xfrg16T7hbkPUborOjgHN/MEiy0CePTc0cwO1GZ3cC53anf0tvTEjo6u2J/ZHb24NLM7esZmZkdGncZ4EqPRTpPVmMOn0H+fIs3WqnDLFiPu6WIEPZsiThcjSRej7/cLixUdvmr4+xT1dDHq2XoR4XQxStfTSrqeVmu2GGm6nlbT9bRK6WKUrqfVbD2tlJosRlKy9bRSsvW0sq0NZVOUrafdFCXrRaTWbDGq2Xpaqdl6WqlvdErM8a7qLS5nvYttEpfT3t03i8uVL6O4bP+44jKMy5Uvw7i80be8vnG58mUYl3a1L8O49OuNo3FcrvHuMC5w1jeOvrx7eIvLWfNlEpdz3C1oiMuVL8O40JUv47hc+TKOy3UX/jAufOXLMC5ytS/juFxvHA3jcto3pmdxud44GsWll+tNrHFcTvOuhfR6mnct5J3uGZz6eo73nT99Pc09+dLPsQb66SucyNcT9TlvdM/g3NfTvH0m/Y2+i5z7eqL6Su/TDk/uBd18Pc09vtL5NPe9br6e5o5xeaf7A+e+nuaOcXmnO/6mvr7RrX1zX09zx7hAOU+5QjlPnwNvtI449/U0b2QJtNO8pbT5Cify9UR9Tj9R29RP1Da90fnOua8nKtc3Oofp+jbLFpn36aFcX5MQoOudjYPIvNELzN6ROesNl/PIXLeiDm9FFZCztsDzyLzPjMI5MnrWvmkemes1iXFk8I3esPaOzNUCH0Xm6rUPIlOvnDmKzNVrH0SmXb32UWSuXvsgMm90Otc7MlcLfBSZqwU+iAxcLfBRZM6aM5MXSATxrH3TNDJkeqFis/v2yyTP6lzvd0QxvXkiVG0RoF5tdthsdtxtdgf3GM7suKLNrpPNzvZKkDAZdRrjySw2O2nJagxrSacoW6siPVuMpKeLEVA2RZwuRpIuRt/vFxYr0pYtRtrTxQiy9SLK6WKUrqfVbD2tlpYsRlqy9bSbomS9iBZOF6NsPa2WbD2t1potRjVbT6s1W0+rldLFKFtPqzVbT6utZotRS9fTtnQ9bXujU2KOd1Vre6MzYr5xOevdfV/H5bx3983icuXLMC7nuOfPEJez3iU7icsbnX7yjcvVvgzj0q83jsZxuca7w7gAXHcP4yguZ82XSVzOcbegIS5XvgzjQle+jONy5cswLnzdhT+Oy5Uvw7jI1b6M43K9cTSMy2nfmP46LvBG37n6xuV6E2sYl3qady02X0/zroW+0z2Dc19P0Rd8+nqae/IVzrEG+unrad5S0ne6Z3Du6yn2w374iqd5+2wDn6hc6UT1lU5zx7jCG63RzX09zX2vCm/0zvHcVziRr6e5Y1zf6Y6/ua/naZuwnOaO8c3XE5VrPU+fg2+0jjj39TRvZCm207yltPl6nnkO9hP1Of1EbVM/Udv0Ruc7576eqFzf6Bym69ssW2Tep4dyfU1Cka53Ng4i80YvMHtH5qw3XE4jI9etqMNbUbfInLUFnkZG32dG4R2Zs/ZN88hcr0mMI0Nv9Ia1d2SuFvggMm/0/b13ZK6cOYhMu3rto8hcvfZRZK5e+yAyb3Q61zsyVwt8EJk3OvnrHZmrBT6IDJ41ZyYvkGyROWvfNI0MmV6oUOJvv0zyrO7hfkeSBvdfD+93ZLodSOaH1clK8qlITW+eKFdbBPj7t8n+sEO02THZ7NT05olKFZtdV5sdGHUa4ym2V4k2O0iW+cItmyIpyRRpoWyKarY80pYtjxQkmyJMl0fp2iPvlyg8FOXKIyglWXu0Keq5av+mCHLl0YeidHnEuWr/pkjS5VGy9ghKrdlqf23Z8qima48qZqv93u+HOChK1x61kq32t5Itj1q69qgdjWr3dbVaufxkN2BIvyliwbr/mnAoaL83mInk6x9vOvS+dIiNHn/+w4GjZ7QWOlD3kG5b2wNFkE6RZlMk6WIk6WKk6WJ0NL37bYqOHkn5pqJ2V0Q0gHAA5ODaO2cIBkBaiYCEeKIBELjeVXj+2uYjLtc7HMO4nONOK0NcrnwZxoWufBnH5cqXYVz4FHerGeJy5cswLm/0tZpvXK53oYZx0Wu8O47L9a7C833wsG1OXu9wjONyvdsyjEu98mUclytfhnF5ozu2fONy1vHuJC6nfQd1FperfRnG5XoH9SAu13h3GBe83oUaxoWud8TGcTnLuw+br3yWN6Q+fD3L22Afvp6iL/jh6zneFf309Sxvg22+vtH7AHNfz9PnvNP7AHNfz/Lm2+brad4Z/fD1RPW1neWdlg9fz3Jn/ubrae7M//D1LHfmf/h6lrvVN1/f6Kzn3NcTtU1vdCPQ3NezvCG1+fpG74zOfT1Rn/NG64hzX+FEvp7lPcrN1zc6dzn39UR9jp6obdITtU1vdL5z5iuV85QrvdE5TM/3srbInPZG/K9f+Nki096njfeOzPUq1EFkTnu7+Twy1+3mo5uqt8jA9SbJUWTeZ0bhHBk8a980jwxckTmIzFl77Wlk3ujre+/IXL32QWT4ypmjyFy99kFk5Oq1jyJz9dpHkbl67YPIvNFZXu/IXC3wODJcrhb4KDJnzZmvX4XaIlPP2jfNI2N5FWmza743LKPiw6+HNyyT7vcZP0Tprsj03tJmR8YIiJrspBabXa82O2w2O+42u6PrdCd2WtFm12w61RhP7WSzc37949drjPdrRA6KMFuropIuRposRrUUyKaop4sRpIvR9/uF1YokXYw0W4xqSdaLVO93bRwUZetpN0XJepGNnC5G2XraWtP1tK1li1FL19O2dD1t43QxStfTtnQ9bW/ZYtTT9bQ9XU/bOV2M0vW0PV1PC290SszxruoKb3RGzDcuZ727bxKX097dN4vLlS/DuJzjnj9DXOCKyygub3T6yTcuV/syjItebxyN43KNd0dxwXLWN46+vHt4i8tZ82USl3PcLWiIy5Uvw7i0K1/GcbnyZRiXft2FP47LlS/DuMDVvozjcr1xNIzLad+YnsXleuNoGBe63sQax+U071pU5NO8a1Hf6Z7Bqa/neN/509fT3JO/aT/N+web9tO8pVTf6Z7Bma/vdM/g1Nd6mrfPNl/PVK4nqq/tNHeMV3qjNbq5r+9TX+e+nuaO8fpO9wfOfT3NHeP1ne74m/t6orYJT3PHeCU6UbnSifqcN1pHnPt6mjeyKslp3lLafD3RPEdO1OfoidomPU/bxG90vnPu64nK9Y3OYbq+zbJF5n16KNfXJCq3652Ng8i80QvM3pE56w2X08jAdSvq8FbULTJnbYHnkXmfGYVzZPCsfdM8MtdrEgeReaM3rL0jc7XAB5F5o+/vvSNz5cxRZK5e+yAycvXaR5G5eu2DyLzR6VzvyFwt8FFkrhZ4HBkpVwt8FJmz5szkBZIq9ax90zQyzfRCxWb37ZdJntU93O9I0uD+6+H9jtvk9xbSh9XJbc/6UxEWmydsjICa3jypWrvN7uBc7tQO0WbHZLNT0xs5rRS02dniudmJza61XJnfSi/pFEk2RQTZFHG6PJJseVQLZVNUs+VRTdceeb9E4aAI0+VRuvZoGyqmU5Qtj1q69qj1bLW/QbY8aunao8bZan+TdHmUrj3qNVvt934/xEFRuvaoY7ba3yldHqVrj+BoVLuvq9XK5Se7AUP6TREL1v3XhENB+73BTCRf/3jTofelQ2z0+PNPByTcAWh3B/hZ0dEzWv9lQgouOdHuDhBNNG1rt/f1U+0P14LpLVGBEorCmlFUxkhRxkhRxkgdnCP6zaIgWBSw3vZfQLqMJGk6SQeHVn6rJE4nSVs+SemihKXmk4T5WiYsmlBUhYyiMkaqZYxUyxip3jOKytdwQrruBcPnLnNJWPJJwnSSKF+UKN1InA4WPKDclp4qNJ5Ikl5vbY30pk+LEnTwHIMzBCMgGgA5uMHLGRLhycE9+c4QdoBsmzs7pMDXtUpqu9UqqQ9d666IMZ0ijVZUBO+KZqOVSqXtTSBBf3bgesFw9FLfFpfrxctRXLhcL6SO43LlyzAu57ht3BCXK1/GcTnFLebfj8sb3XjuGpfTvmA4i8v1AvMwLqd9wXAWl+sFw8HLa43xevFyHJfrhdRhXN7olhzfuFz5MowLX/kyjstZx7uTuLzR7ee+cbnal2Fc9HqBeRyXa7w7iss73XDiG5frxe5hXM7zwuLm62lea952JE/zCvfm6yn6gh++vtHd63NfT/MK90Y4zau+G+FEfc4b3WE+9RVP87r65uuJyvWNXlic+vpGN15PXkXafD3N63Sbr6d5na7JG90zPff1NK+Ybf/1aV7O3P7rE7VNb3Rf88xXLXAiX09UrvU8fY6+0Tri1Nd2mhdRN1/fZ71p6usbnbuc+3qiPqefqG2CE7VNb3S+c+ornqhc3+gcpuvL1E3prG/PTd7S3SLzPm28c2T4en/5IDJvdO7QOzLXO2LDN6Ga6vX651Fk4IrMQWTO2jdNItNLeZ9RrXdkztprTyPzRl/fe0fm6rUPItOunDmKzNVrH0Xm6rUPItOvXvsoMlevfRCZNzrL6x2ZqwU+iszVAh9EBs+aM5P3l3uhs/ZN88iY3h/uxfktI1R8+PXwLSPS/ZmbhyjdFanpZeNeqy0CtbPNDsVmx2qya6XY7GxvlvcGzWZH3WbHRp3WeAoY7SRZjdm2x5Ip2jr3bIp6uhhBuhhhy6ZI0sVIs8UIvt8vrFbU08UI0sUIsvUiIOlilK6nhXQ9LbZsMcJ0PS2m62mR08UoXU+L6XpaatliROl6WkrX0xKni1G6npbS9bTcssWI0/W0nK6nlYNvbAAL3CQB4n2FFvlmCFZDNRrCeJmK70vJj0+tA32aHdyuPDVTk9nBPRRTs3GqiuwHQ0X42exgVDIzO2jOhPYla+GRGdjM1GSmNpqaaEff/E7NxGQ2/mKRdH/g/mNP4bZj0PrNiixW49u4plYHz2D1znst3VrYx1o62F7ZatHnr7c0+Olpq9HOza2KSG0DRQfjlO8qgr4rQnlU9EnBCMpBm+RNkQjK0TtxzhSNoHBA6UMBn4jtPTuUWd3axgb7+2+1APaBKEko6mB9+zeL4oSiKGOkXKoTbCOmm6iqdSaK+z7S2vgwEOXRkkDre6Qazp5ILFJoFyUPZwd2UdJdRO3Py26ieCZK6/507baFP2inhBOK0pZRFOUTVUvNKCpjpKokFNUSNgm1ZYxUzxipnjFSkDFSkLCbqZiwm6mYsfGkklAUL659PyjSQigcQVGX0ULfR9/bfuD05fCu+7p33UbUA1GUT9TRsc7fLAoTiqoZI1WP9h/21yu3fz/swnzuP2wVCKyGYjQ82Cx+wZCMhgdPl75gaCVisRrCt/eRBvmybaG0h6X6h4VnlU/Q0dKKP4iCQFyjQEEe9fGyvdRbDm3blbtV/9z83FqTYrICk5VYrMa5N7ViixWbWOMinlmNdyCl8G7FIyv5ntUgl6jtK3HUHx6bIvpkjIccrgwYX0Q78R7Gn4VMrdRiNd7dn1mRJRdg3BpNrdBkpRar8ers1MpS40FNLLXUeCyWjMKiy2sIVl7PMOU4jj+ymllhMVmhwYrKWZ+1/fL5+S0up3gO5/txOcfzioa4XPkyjMsbXVHjG5crX4Zx6Wd97ncWlytfhnE5x9OL348LnuL5TUNcrvHuMC50imd4B3H58jnxLS5nzZdJXN7oWUnfuFz5MoyLXPkyjsuVL+O4nHW8O4nLGz0j6RkXLlf7Mo7L+1xq6hqXeo13x3F5n2e5XOPyRs9G+sblfa55/SIuP3x9o6uz576eoh344Sucoi/49PUU48cfvp5jDfTTVziRryfqc+gU+2Gfvp5izv/DVz5RufKJ6qu8Tzs8eep38/V96uvUV32f+jr39TRPc4OU9xn7z319n7H/3NfztE1Sz9M2SX2fscTU13aicm0n6nPeaB1x7uv77D9NfX2jZ/LmvsKJfD1Rn4MnapvwRG3TG53vnPt6onJ9o3OY33oy8atff0bmfXqo7z0mSbRf6E0P14ffIyNnfWZzGhk960PH88i8z9qRd2TeZ6XJ9aFjOLom/4rM0UsAV2S0nrVvmkfmfUa1zpFpZ+2155G5WuCjyFy99kFk+pUzR5G5eu2DyMDVax9F5uq1DyLzRqdzvSNztcBHkbla4IPI0NUCH0XmrDmjZb8UWdsoMnzWvmkame8/4ftp5/uILEmD+6+HT7Yy3Q4kPz4VWunHXcdYDs7BTTzB0ovN7uCxwqnd959x/mF3cC53ZlcP7jGc2h08dTm1Q7LZkVGnMZ5bc2qzk5os86toNkXKyRS11rMp6tnyqPVsedQIsynidHmUrj3qJVvt7zVbHvV07VGHbLW/Y7o8StcedU1X+zVbHkG69gh6ttoPkC2PIF17dPC2xu9UJOnyKF17dPBmxu9U1LLlEaZrj/BoVLuvq9XK5Se7AUP6TRELTp5IZ9rvDWYi+frHmw69Lx1u85THn386wOEO1D2kVPlZkdZ0iiiZIirZYkQlXYxquhgdTe9+oyL1UNTuiui5iTl6ccQZIgGQg+9EnSEcAIEIT4ACIHS9qzD42maLC1xxGcblerdlGJc3+jrLNy5Xvgzj8kb3avnG5RR3q30/LnrlyzguV/syigtf76CO41Kv8e44Lte7CoP74JHf6Fss37hc77YM49KvfBnH5cqXYVze6I4t37jAFZdRXE77DuosLlf7MozL9Q7qQVyu8e4wLny9CzWOy/WO2DAucpp3HzZfT/OGFLKe5m2wzddT9AV/+CrneFf009fTvA2G7/Q+wNTXN3ofYO7rad4aQnmj253mvp6oXPuJ6ms/zTsteKI78/FEd+bjie7MxxPdmY/yRmc9576eqG16oxuBpr6+0Tujc19PVK5vdIf/3NfTvA2Goqd5pwXf6U2Bua/nmedoOU+fo+U8bZPW87RN73Tb/tTXdqJyfaNzmK7vZeF5b8SfvPCD2t+njXeODFyvQh1E5rS3m88jA9dN1aObqrfIXG+SHESG3mdG4R2Zs/ZN08jw+4xqvSNz1l57HpmrBT6IzBt9f+8dmStnDiKjV699FJmr1x5Ghkq5eu2jyFy99lFkrhb4IDJvdPLXOzJXC3wQmXbWnJm8CkWln7VvmkfG9CoSFfC9YXlbQnv49fCGZdL9PuOHKN0V2d5boiK2CNRCNrvGNjsQmx2pzU5N74hRq9Vm15vNDow6jfFs2I12nKzGeL9G5KCIs7UqvWSLUa/pYtRqNkWYLkaULkbf7xcWK4KSLUZQ0sWoZutFvN+1cVCUrqeFdD0taLYYYbqeFtP1tAjpYpSup8V0PS1qthhRup6W0vW0BOlilK6npXQ9LUm6GKXraTldT8sHp8T0vj6rfLfrUG52YrM7uPttbsc2OzHyxMhTI+/gfqiZnR7cBSxMt5Xt7d/8sP6scrMUq+XBy0SvWLLVEs1MNDMP5g6vWKrV8uCNl1cszUwdZgLKzQ7lvkPTP1sOLqWZrIZ5TvsLUtsK0sCqgsWqNZPVMF+2XYfdigZW4zX0qZWJNR4fod46ESo8skKL1fhM/tTKxCITi2wstViNV8lp35+kh/p1txq/QDq1IovV+A2XqZUarGqxRKOO19Gk3sYp0mFgNa7LUyuyWI371KkVmKzUYgUm1njfbWY17nml8G41qCl1XJePrQY76Ns22a3jemypG9GNIesZ4z3qmffjdYeJVRuvDUytyGJ1MPq7P+FSER5qb7/ZHZw+mNuxze5g3De3M/LIyCMj7+CLi6mdeJyrkT359f7V2fhcTav9dq6mbQ3JgyK8KTrrbedfvnrETa/XoMZxuV4PG8Wln+P2ZENcrnwZxuV6be4gLnDFZRSX0742N4vL1b4M4/JGJ7h943KNd4dxget1n8ErNltcrteghnHB6/WwcVyufBnG5Xpt7iAuV74M48LXa5bjuFz5MoyLXO3LOC7X64TDuJzjFTtDXE7x+tC34wJvdNOzb1xO87ocw3lel9t8Pc0rZAztNC+abr6e5kVThnOsgX76epoXTTdfT9TnvNFLelNf3+gm6bmvZyrXE9VXOs1LPwxvtEY39/V96uvc19O8LsdwntflNl9P89IPwxud35z7eqK26TyvyzGW85QrlvP0OfhG64hzX0/zaiDjeV6X23w9zzwH3+i9uKmv/URt0xu9djf19Y3Od859PVG5vtE5TNdXPrfIXC82Dt8lZDztG3PTyJz2JbV5ZN5n7cg5MnLW908n72tskbne8TmKzPWOz0FkrpfUDiNzveMzjgxdL6kdRuZqgQ8i80bf33tH5sqZo8hcvfZBZE77kto8MlevfRCZ074xN4/M1QIfReZqgQ8iA1cLfBSZs+bM5C1LPnqN4IoMkelNxs3O9zUFkgb3Xw9fCthGpbeQPqxOVpJPRbZXKZltr1JulbHZ7GyvRDIfnMud2qnpFVOWSja7zjY7MOo0xlNQbHbUkmW+cEmnSJIp0gLZFNVseaQtWx4pUDZFmC6P0rVHKulqvybLIynZ2iMpPVnt3xQlyyMp2dojKZys9kuRdHmUrT2SWrPV/oP3S36nonTtUcVstb9SujxK1x5VzVb7D15E+Z2K0rVHR++cQLmZVWj8k90zQ/rD00Ht/g074WiprFPfH6LrJA9XQOkuihOKOjjJ+ZtFYUJRByOT3ywqZaQ0oaiDA3O/S9To95X3nz+szd9eRdpckHAXetvb8L4tOj3HtR90R79XVPWoq21/7HPzEr4WtU0Tbls229iTJh5UKntmbKOw/vjzTwco3IH9KeVtOA/Pihr8Fw/p+EWDbfywS6q1PYw7yqcdFKMd2uzGXyq9YGfkkdE/MsaTjTw2+idGnowTfqsIeG+mpYws1Wp50Em9YslGSzg4FfyKJVotD9rnVyztzIM9Z9V9G7+VWn+yHMxTthWqz59v/5RJE4Z1b8IenxO5tUlw0KhuOviu6eGFy7Em0P05TNA6aSkF4NZ7ChAMNL0Sp66DCHewWh58dfuK5TDvW6t0C0lr7eG1Y+yfhuOnN18xJKPhuKF9xRCshmI0ZCtRrD6KmahGQ7US1RhVLM1qaEw5rMVqCFbDV4LT6rPh+Gj0K4ZsNBwfrH3FEK2GajQEa3DAGhy0Buel5nFkSFYiWYuDrMXB1uJga3HIK8GBkSEZDbVYDcFqKDZDeqldHRoag0O1Wg2txFashgfF0eRu2BsNDNVo2LvVkI2GUK2GaDREKxGtPpKVSGQ0ZCuRrVFla8qJNeXEWhxqDY6+EhwoT4ZcitUQrIZiNKzNakhGw2YNTrMGp1mD81LzODS0EsFaHGAtDrQWB1qLA18JDg0MqVsN2Wj4Urs6NESroRoNxRocsRaHWolqLA4pB8UBpe+GgDowJKNhtRKrlXjUys0N1WjYrcSjxmpuyEeG7W7I7dnwaCUQ6/0NAyQcGLLRkKxEshKPmo6p4dGC3tzQSjxqAeaGcmRY7oYPx4VuhloOiLSv3m//ftgTvRuy0fBogDQ3PPCRutwNaWB4tPS0DSt3w21o8mwIYDW0EtFKPKpWc0M2GrKVeFSt5oYH1Yr27fvNcNA86tF6ztzwoByl3A2lPnWsWo4Wn6eG495qtmO72YnNbjwif8FObXZg5IHRPzTGE408MvpHRt7BqeHpnvBmyVZLqWZLNFuq1dJ6rmCzFKNlLd1sefAN8O/bqdd68L3lb9yp3zS9EqfBrrkefq8xtzz6ruIFy3HP1ct+gmz796A7qAdDl7nhwdBlbniwfNFL63fD56nEVqLj4VmHug/POhA/Gx7sKL1gaCUebAzNDQ9WPjdDvhsqDgzJZthKtRpaiQfb3y8YqtGwWYnjiyReMeQDw/uAsOPzjpI2aFZDKxHRaHhw5Oan4CC0geEBsYt+bcjFamglHqzRvWAoRsODpbZe+d6utvqccv1go/YFQyuxWokHGwovGKLRsFuJB/sCc8ODUyWbYbkbgg4MxWh4sGI2Tbk+nqHjPjNAuc+V++dlK9rHK+1Tq2EJbjvwn1bUcWA1roYzq3FnOrUa9mtU71b0bHVw0HdqZWKN5/6ot7EFPZwde7ACk5VarJqJ1UysbmKN6/XMatw70379GD2MW+9W4xHv1AotVuPlgamVWKzYFI3x2FgePlKCn6xGn7PeppOIo/oxXo1zJeBiApaynLDch7rch3Gb5kloy31oy8thfBbXlbDcB1heDvjrPnw99jl4vuZbhK/7p4NnYFwJv1zjJv0DaltO4MUE+vW2dUb49bZ1SoDlBFlNGC/Fyr5OLJ1HVmyxOmhlZ1ZosTpoDWdWNpZarMZXf86siBa3wcRlOQGWE3693nw9Bz448utKWO6D0mICl7qcoKsJlVcT2q/351+vh3Dj1YS+3Ie+emx4cFDZlaCrCQirCVSWE3A1gZf7wMvL4df7uAlByuqRgBRYTljdix6civYkNFhO0MWt98GBbFfCch+gr65xwKsJ2JYTlvtAy32g5T5wXU5YvcIiDnOgGWH1+oc4zIG+JqjDHGhGwOUEywqHHqyPzazEYmVax1LTOpZ2E+tg/vKV1bYDdXBtc2n7dXPl4WOUz6eRNjsqRrthmdXa9+fVK8jA7ujq5Jnd0YXrUzs02h1cL0X36/tkEJejh2i73i/NVBnZgdFObHYHR2vndmSz60b/wKhzPEKquA9wKwIP7A4eWpraHdSjuR3a7A4uRJ7bkc1OjLyD+oe0P9m2VbWB3cGnAHM7Mdnxwf2wU7uDh9Xmdmi0U5tds8Xz6AG4fn9yrzcZ2bHNDqrRDo12arM7aCfmdsa4kLEcyMhjYzmwsRzYWA5yUA4Aux3yyE5tdgePLM3s5Oj60qkd2+wOPgSa2h08jza3s/Xv0mzjF+nNaGfkjce721bApxkDDazGvd/93VTFEWucmzOrcY85tWKD1cFcdWpliYaOR9RTKzDNaw5mlXO7g/51bmfkdSOvG3lg5IGRh8byQyPvoH+d29nm3TruXyftiY571/vXmtpGVmKoQbUc1PEvWZsVmqzUYlW7yYot0RjPl6dWJtb4/JPuSw9bGoysyGIFJhbMWvKhFZrycLyyNbOibrISi9V4D3dqpRYrMbHE5Jeacl4t5VWLJTfqwWyR7l+700Mb8PlEzYed2uwOZn2Pdo9r6Hc7sdmRkcdHT/Dso3iofWAnZLPTMrVrZWSHJrtWbLw2XnX58mzAh5VarNr3v7TbrHo1WanFanzxwJe72x9WarFCEwu//23ZZjUey02t2GLFJhabWGJijev0zEq//6Xdh5UYrHrpFqvxyuvUiixW7bvR+Nv2H//ff/j3v/7DP/7LP//HZvLx3/6ff/2n//zrv/3r53/8z//vf9/+m3/897/+y7/89X/9/f/+93/7p3/+H//n3//57//l3/7p47/7S/n8X/99G951+bvtf6Nuij7ipbw1dts0Arb//FG3tpXo+ndciT4U/7Cg/ncfAzze/j9/TKJpG5b93bZCXj7+H/Xzr7aPv9phU7yp/v8B",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "repay_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBMJwAABAMnAgYEBScCBwQAHxgABwAGgEcdAIBHgEcGLgiARwABLgiASAACLgiASQADLgiASgAELgiASwAFJQAAAGQlAAAAnygCAAEEgEwnAgIEADsNAAEAAiwAgEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAoAIBEBAAAKACARQEAASgAgEYEAAEmJQAABe0eAgAGAB4CAAcAMzgABgAHAAgkAgAIAAAAwyUAAAYWHgIABgEeAgAHACcCCQQAJwILBAMAOAkLCi0IAQgAEAEKAScDCAQBACgIAgotDgkKACgKAgotDgkKJwIKBAMAOAgKCS0NCAkAKAkCCS0OCQgnAgoEAScCDAQDADgKDAstCAEJABABCwEnAwkEAQAoCQILLQ4KCwAoCwILLQ4KCycCCwQDADgJCwotDAoLLQ4GCycCCwQMLQgADC4IgEQADS0MCA4uCIBGAA8tDAkQABAACwAlAAAGKC0EAAAtDA0GLQwOCi0NCgkAKAkCCS0OCQonAgsEAScCDQQDADgLDQwtCAEJABABDAEnAwkEAQAoCQIMLQ4LDAAoDAIMLQ4LDCcCDAQDADgJDAstDAsMLQ4HDCcCDAQNLQgADS0MBg4tDAoPLgiARgAQLQwJEQAQAAwAJQAABigtBAAALQwOBy0MDwstDQsGACgGAgYtDgYLHAwBBgAAKAcCAS4EAAuAAygAgAQEAAElAAAG9y4IgAUACS4IgAYACi0OBgotDQkHACgHAgctDgcJACgBAgcuBAAJgAMoAIAEBAABJQAABvcuCIAFAAouCIAGAAstDgILLQ0KAQAoAQIBLQ4BCikCAAEAjJ5UcgAoBwICLgQACoADKACABAQAASUAAAh3LgiABQAJLgiABgALLQ4BCwAoCQIKLQ0KBycCCwQCADgKCwE5A4iAQ4BDAAUAAQAHIAIAASECAAItCAEJACgJAgwtDQwLJwINBAIAOAwNCiI0gEQAAgAKLQwCCycCDQQDADgLDQwAEAEMAScDCQQBACgJAg0tDgsNACgNAg0tDgsNLQwLBwYoBwIHJAIAAQAAA2AjAAADNy0NCQEAKAECAS0OAQkAKAkCCi0NCgInAgsEAgA4CgsBPA0BAiMAAANgCygAB4BEAAEkAgABAAADeScCAgQAPAkBAh4CAAEALQ0IAgAoAgICLQ4CCCcCBwQBJwIKBAMAOAcKCS0IAQIAEAEJAScDAgQBACgCAgktDgcJACgJAgktDgcJJwIJBAMAOAIJBy0MBwktDgMJJwIJBAotCAAKLgiARAALLQwIDC4IgEYADS0MAg4AEAAJACUAAAYoLQQAAC0MCwMtDAwHLQ0HAgAoAgICLQ4CBwAoAwICLgQAB4ADKACABAQAASUAAAb3LgiABQAILgiABgAJLQ4GCS0NCAMAKAMCAy0OAwgAKAICAy4EAAiAAygAgAQEAAElAAAG9y4IgAUABi4IgAYABy0OBActDQYCACgCAgItDgIGJwIEBAEnAggEAwA4BAgHLQgBAgAQAQcBJwMCBAEAKAICBy0OBAcAKAcCBy0OBAcnAgcEAwA4AgcELQwEBy0OBQcnAgcECC0IAAgtDAMJLQwGCi4IgEYACy0MAgwAEAAHACUAAAYoLQQAAC0MCQQtDAoFLQ0FAgAoAgICLQ4CBSkCAAIAJPhqngAoBAIDLgQABYADKACABAQAASUAAAh3LgiABQAGLgiABgAHLQ4CBwAoBgIFLQ0FBCcCBwQCADgFBwI5A4iAQ4BDAAEAAgAEIAIAASECAAItCAEEACgEAgctDQcGJwIIBAIAOAcIBSI0gEQAAgAFLQwCBicCCAQDADgGCAcAEAEHAScDBAQBACgEAggtDgYIACgIAggtDgYILQwGAwYoAwIDJAIAAQAABdMjAAAFqi0NBAEAKAECAS0OAQQAKAQCBS0NBQInAgYEAgA4BQYBPA0BAiMAAAXTCygAA4BEAAEkAgABAAAF7CcCAgQAPAkBAiYoAIAEBHgADQAAAIAEgAMkAIADAAAGFSoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJiUAAAXtLQgBBgAAAQIBLQ4BBi0IAQEAAAECAS0OAgEtDQQCACgCAgItDgIELgiARAAFIwAABl8MOAUDAiQCAAIAAAaCIwAABnEtDQYCLQ0BAy0MAgEtDAMCJiQCAAIAAAaPJQAACfEnAggEAwA4BAgHADgHBQgtDQgCLQ0GBy0NAQgtDQgJACgJAgktDgkIACgHAgkuBAAIgAMoAIAEBAABJQAABvcuCIAFAAouCIAGAAstDgILLQ4JBi0OCgEBKAAFgEYAAi0MAgUjAAAGXy4BgAOABwEAgAMAAoALLgGAC4AIAQCACwACgAsuAYALgAkBAIALAAKACgEAgAiABIALDwCAC4AJgAwLAIAHAAKADSQAgAwAAAdGIwAAB7YkAIANAAAHUyMAAAdsLgCAA4AFAQCABQACgA4uAoALgA4jAAAHsSgAgA8EAAMBAIAJgA+ADi4AAAGABQEAAAGADgABKAGABQQAAQEAgAUAAoAOLgKAC4AOAQCADgACgA4uAoAJgA4jAAAHsSMAAAgKKACADwQAAgUAgAuAD4AOKACAEAQAAwEAgA6AEIAPLgAAAYAFAQAAAYAPAAEoAYAFBAABAQCABQACgA8uAoALgA8BAIAPAAKADy4CgA6ADyMAAAgKKACADQQAAwEAgAWADYAMCwCAA4AFgA0kAIANAAAIbgEAgAqACIAPLgCACoAQLgCADIARCwCAEIAPgBIkAIASAAAIbi4BgBCADi4CgA6AEQEAgBAAAoAQAQCAEQACgBEjAAAIPQEAgAyACIAGJi4BgAOABwEAgAMAAoALLgGAC4AIAQCACwACgAsuAYALgAkBAIALAAKACgEAgAiABIALDwCAC4AJgAwLAIAHAAKADSQAgAwAAAjGIwAACTYkAIANAAAI0yMAAAjsLgCAA4AFAQCABQACgA4uAoALgA4jAAAJMSgAgA8EAAMBAIAJgA+ADi4AAAGABQEAAAGADgABKAGABQQAAQEAgAUAAoAOLgKAC4AOAQCADgACgA4uAoAJgA4jAAAJMSMAAAmKKACADwQAAgUAgAuAD4AOKACAEAQAAwEAgA6AEIAPLgAAAYAFAQAAAYAPAAEoAYAFBAABAQCABQACgA8uAoALgA8BAIAPAAKADy4CgA6ADyMAAAmKKACADQQAAwEAgAWADYAMAQCADIAEgA0DAIAIAAKADgEAgA2ADoAPAQCACoAOgBANAIAQgAqADiQAgA4AAAnqLgGAEIARLgKAEYAPAwCAEAACgBADAIAPAAKADyMAAAm5LgCADIAGJioBAAEFxWvEWg4QAAI8AQECJg==",
      "debug_symbols": "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",
      "brillig_names": [
        "repay_public"
      ]
    },
    {
      "name": "deposit_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "deposit_public"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "PriceFeed"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Lending"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "market_assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "market_assets_list",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "market_assets_list_len",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "scaled_deposited_assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "scaled_borrowed_assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "scaled_total_deposited_assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "scaled_total_borrowed_assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposit_accumulators",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "borrow_accumulators",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_compute_collateral_debt_value_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_compute_collateral_debt_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_borrow_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_borrow_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "on_behalf_of",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::deposit_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::deposit_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_repay_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_repay_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_withdraw_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_withdraw_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_compute_total_collateral_value_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_compute_total_collateral_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "on_behalf_of",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fromPublicBalance",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::deposit_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::deposit_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "debt_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "user",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "debt_to_cover",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::liquidate_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::liquidate_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "precision",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "deposit_accumulator",
                    "type": {
                      "fields": [
                        {
                          "name": "value",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "last_updated_ts",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 64
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "accumulator::Accumulator"
                    }
                  },
                  {
                    "name": "borrow_accumulator",
                    "type": {
                      "fields": [
                        {
                          "name": "value",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "last_updated_ts",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 64
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "accumulator::Accumulator"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_compute_utilization_rate_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_compute_utilization_rate_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::withdraw_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::withdraw_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_deposit_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_deposit_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "oracle",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "loan_to_value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "is_borrowable",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "optimal_utilization_rate",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "under_optimal_slope",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "over_optimal_slope",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "deposit_cap",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::add_asset_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::add_asset_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "debt_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "user",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "debt_to_liquidate_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_liquidate_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_liquidate_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Lending::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "deposit_accumulator",
                    "type": {
                      "fields": [
                        {
                          "name": "value",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "last_updated_ts",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 64
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "accumulator::Accumulator"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::compute_total_deposited_assets_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::compute_total_deposited_assets_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::borrow_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::borrow_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::repay_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::repay_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "on_behalf_of",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fromPublicBalance",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::repay_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::repay_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::withdraw_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::withdraw_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "asset",
                    "type": {
                      "fields": [
                        {
                          "name": "asset_address",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "loan_to_value",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "oracle",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "is_borrowable",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "optimal_utilization_rate",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "under_optimal_slope",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "over_optimal_slope",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "deposit_cap",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "asset::Asset"
                    }
                  },
                  {
                    "name": "utilization_rate",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "precision",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_compute_borrow_rate_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_compute_borrow_rate_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::borrow_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::borrow_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::update_accumulators_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::update_accumulators_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "102": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "103": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "104": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n"
    },
    "105": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "106": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "107": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "109": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "110": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "111": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "112": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "133": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "136": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "139": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "140": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "141": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "142": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "143": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "144": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "149": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "150": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "151": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "152": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "154": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "156": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "157": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "159": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "168": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "182": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "185": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "186": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "188": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "189": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "191": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "193": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "204": {
      "path": "/home/jean/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "221": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "223": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "266": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "269": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "271": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "276": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, FromField, Hash, Serialize, ToField},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"
    },
    "283": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "284": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "298": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "300": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "301": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "310": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "321": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "335": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "339": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "340": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "356": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "359": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "369": {
      "path": "/home/jean/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "400": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "52": {
      "path": "/home/jean/work/noir/comet/contracts/src/helpers.nr",
      "source": "use dep::aztec::hash::pedersen_hash;\nuse std::ops::{Add, Sub};\n\n// Utility used to easily get a \"id\" for a private user that sits in the same\n// \"space\" as the public users.\n// It help us to have a single mapping for collateral that have both public and private users.\npub fn compute_identifier(secret: Field, on_behalf_of: Field, self: Field) -> Field {\n    // EITHER secret OR on_behalf_of MUST be set. But not both\n    assert(!((secret == 0) as bool & (on_behalf_of == 0) as bool));\n    if (secret != 0) {\n        pedersen_hash([self, secret], 0)\n    } else {\n        on_behalf_of\n    }\n}\n\npub fn covered_by_collateral(\n    collateral_price: u128,\n    borrow_price: u128,\n    loan_to_value: u128,\n    collateral: u128,\n    increase: u128,\n    decrease: u128,\n) -> u128 {\n    let price_precision = 1000000000 as u128;\n    let ltv_precision = 10000 as u128;\n\n    let collateral = (collateral + increase) - decrease;\n\n    let collateral_value = (collateral * collateral_price) / price_precision;\n    let debt_covered = (collateral_value * loan_to_value * price_precision) / (borrow_price * ltv_precision);\n\n    debt_covered\n}\n\npub struct DebtReturn {\n    debt_value: u128,\n    static_debt: u128,\n}\n\nfn div_up(a: u128, b: u128) -> u128 {\n    let div = a / b;\n    if div * b < a {\n        div + (1 as u128)\n    } else {\n        div\n    }\n}\n\npub fn debt_updates(\n    interest_accumulator: u128,\n    static_debt: u128,\n    increase: u128,\n    decrease: u128,\n) -> DebtReturn {\n    assert(interest_accumulator > (0 as u128));\n    let accumulator_precision = 1000000000 as u128;\n\n    let current_debt_value = (static_debt * interest_accumulator) / accumulator_precision;\n    let new_debt_value = current_debt_value.add(increase).sub(decrease);\n\n    // static_debt_increase = amount / accumulator\n    // rounding up new debt.\n    let static_debt_increase = div_up(increase * accumulator_precision, interest_accumulator);\n    // rounding down repayment.\n    let static_debt_decrease = (decrease * accumulator_precision) / interest_accumulator;\n\n    // We need to allow repaying of the entire debt as well etc. This is very prone to failing\n    // if you try to repay exact due to time diff between sim and execution.\n    let new_static_debt = static_debt.add(static_debt_increase).sub(static_debt_decrease);\n\n    DebtReturn { debt_value: new_debt_value, static_debt: new_static_debt }\n}\n\npub fn debt_value(static_debt: u128, interest_accumulator: u128) -> u128 {\n    let accumulator_precision = 1000000000 as u128;\n    div_up(static_debt * interest_accumulator, accumulator_precision)\n}\n"
    },
    "53": {
      "path": "/home/jean/work/noir/comet/contracts/src/main.nr",
      "source": "mod asset;\nmod position;\nmod helpers;\nmod accumulator;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Lending {\n    use dep::aztec::prelude::{AztecAddress, Map, PublicMutable};\n\n    use crate::asset::Asset;\n    use crate::helpers::{compute_identifier};\n    use crate::position::Position;\n    use dep::price_feed::PriceFeed;\n    use dep::token::Token;\n    use crate::accumulator::Accumulator;\n    use dep::aztec::macros::{\n        functions::{initializer, internal, private, public, view, utility},\n        storage::storage,\n    };\n    use dep::aztec::protocol_types::traits::{FromField, ToField};\n\n    #[storage]\n    struct Storage<Context> {\n        market_assets: Map<Field, Map<AztecAddress, PublicMutable<Asset, Context>, Context>, Context>,\n        market_assets_list: Map<Field, Map<u64, PublicMutable<AztecAddress, Context>, Context>, Context>,\n        market_assets_list_len: Map<Field, PublicMutable<u64, Context>, Context>,\n        scaled_deposited_assets: Map<Field, Map<AztecAddress, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, Context>,\n        scaled_borrowed_assets: Map<Field, Map<AztecAddress, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, Context>, // static debt\n        scaled_total_deposited_assets: Map<Field, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>,\n        scaled_total_borrowed_assets: Map<Field, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, // static debt\n        deposit_accumulators: Map<Field, Map<AztecAddress, PublicMutable<Accumulator, Context>, Context>, Context>,\n        borrow_accumulators: Map<Field, Map<AztecAddress, PublicMutable<Accumulator, Context>, Context>, Context>,\n    }\n\n    #[private]\n    #[initializer]\n    fn constructor() {}\n\n    #[private]\n    fn repay_private(\n        from: AztecAddress,\n        amount: u128,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        asset_address: AztecAddress,\n        fromPublicBalance: bool,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        if(!fromPublicBalance) {\n            let _ = Token::at(asset_address).transfer_to_public(from, context.this_address(), amount, nonce).call(&mut context);\n        }\n        else {\n            let _ = Token::at(asset_address).transfer_in_public(from, context.this_address(), amount, nonce).enqueue(&mut context);\n        }\n        let _ = Lending::at(context.this_address())\n            ._repay(AztecAddress::from_field(on_behalf_of), amount, market_id, asset_address)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn repay_public(amount: u128, nonce: Field, owner: AztecAddress, market_id: Field, asset_address: AztecAddress) {\n        let _ = Token::at(asset_address).transfer_in_public(context.msg_sender(), context.this_address(), amount, nonce).call(&mut context);\n        let _ = Lending::at(context.this_address())._repay(owner, amount, market_id, asset_address).call(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _repay(owner: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == asset_address, \"Invalid asset or market id\");\n\n        Lending::at(context.this_address()).update_accumulators(market_id, asset_address).call(&mut context);\n\n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / borrow_accumulator.value;\n\n        assert(scaled_user_borrowed_amount >= scaled_amount, \"Insufficient balance\");\n        scaled_user_borrowed_amount_loc.write(scaled_user_borrowed_amount - scaled_amount);\n\n        let scaled_total_borrowed_asset_loc = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address);\n        let scaled_total_borrowed_asset: u128 = scaled_total_borrowed_asset_loc.read();\n        scaled_total_borrowed_asset_loc.write(scaled_total_borrowed_asset - scaled_amount);\n    }\n\n     #[private]\n    fn borrow_private(secret: Field, to: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let on_behalf_of = compute_identifier(secret, context.msg_sender().to_field(), context.msg_sender().to_field());\n        let _ = Lending::at(context.this_address())\n            ._borrow(AztecAddress::from_field(on_behalf_of), amount, market_id, asset_address)\n            .enqueue(&mut context);\n        let _ = Token::at(asset_address)\n        .transfer_in_public(context.this_address(), to, amount, 0)\n        .enqueue(&mut context);\n        // let _ = Token::at(asset_address)\n        // .transfer_to_private(to, amount)\n        // .call(&mut context);\n    }\n\n    #[public]\n    fn borrow_public(to: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let _ = Lending::at(context.this_address())._borrow(context.msg_sender(), amount, market_id, asset_address).call(\n            &mut context,\n        );\n        let _ = Token::at(asset_address)\n        .transfer_in_public(context.this_address(), to, amount, 0)\n        .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _borrow(owner: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n\n        assert(asset.is_borrowable, \"Asset is not borrowable\");\n\n        let total_collateral_value: u128 = Lending::at(context.this_address())._compute_total_collateral_value(market_id, owner).call(&mut context);\n        let collateral_debt_value = Lending::at(context.this_address())._compute_collateral_debt_value(market_id, owner).call(&mut context);\n\n        let borrow_price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n        let min_collateral_for_borrow = (amount * borrow_price * 10000 as u128) / (asset.loan_to_value * 1000000000 as u128);\n\n        assert(collateral_debt_value + min_collateral_for_borrow <= total_collateral_value, \"Insufficient collateral\");\n        \n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / borrow_accumulator.value;\n        scaled_user_borrowed_amount_loc.write(scaled_user_borrowed_amount + scaled_amount);\n\n        let scaled_total_borrowed_asset_loc = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address);\n        let scaled_total_borrowed_asset: u128 = scaled_total_borrowed_asset_loc.read();\n        scaled_total_borrowed_asset_loc.write(scaled_total_borrowed_asset + scaled_amount);\n    }\n\n    #[private]\n    fn withdraw_private(secret: Field, to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let on_behalf_of = compute_identifier(secret, context.msg_sender().to_field(), context.msg_sender().to_field());\n        Lending::at(context.this_address())\n            ._withdraw(AztecAddress::from_field(on_behalf_of), to, amount, market_id, collateral_asset)\n            .enqueue(&mut context);\n        let _ = Token::at(collateral_asset)\n        .transfer_in_public(context.this_address(), to, amount, 0)\n        .enqueue(&mut context);\n        // let _ = Token::at(collateral_asset)\n        // .transfer_to_private(to, amount)\n        // .call(&mut context);\n    }\n\n    #[public]\n    fn withdraw_public(to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let _ = Lending::at(context.this_address())\n            ._withdraw(context.msg_sender(), to, amount, market_id, collateral_asset)\n            .call(&mut context);\n        let _ = Token::at(collateral_asset)\n        .transfer_in_public(context.this_address(), to, amount, 0)\n        .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _withdraw(owner: AztecAddress, to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(collateral_asset);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == collateral_asset, \"Invalid asset or market id\");\n        \n        Lending::at(context.this_address()).update_accumulators(market_id, collateral_asset).call(&mut context);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(collateral_asset);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        let scaled_user_deposited_amount_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_asset).at(owner);\n        let scaled_user_deposited_amount: u128 = scaled_user_deposited_amount_loc.read();\n        let user_deposited_amount = (scaled_user_deposited_amount * deposit_accumulator.value) / 1000000000 as u128 ;\n        assert(user_deposited_amount >= amount, \"Insufficient balance\");\n\n        let total_collateral_value: u128 = Lending::at(context.this_address())._compute_total_collateral_value(market_id, owner).call(&mut context);\n\n        let collateral_debt_value = Lending::at(context.this_address())._compute_collateral_debt_value(market_id, owner).call(&mut context);\n\n        let collateral_price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n        let withdraw_amount_value = (amount * collateral_price) / 1000000000 as u128;\n\n        let total_collateral_value_after_withdraw = total_collateral_value - withdraw_amount_value;\n\n        assert(collateral_debt_value <= total_collateral_value_after_withdraw, \"Insufficient collateral\");\n\n        let scaled_withdraw_amount = (amount * 1000000000 as u128) / deposit_accumulator.value;\n        scaled_user_deposited_amount_loc.write(scaled_user_deposited_amount - scaled_withdraw_amount);\n\n        let scaled_total_deposited_asset_loc = storage.scaled_total_deposited_assets.at(market_id).at(collateral_asset);\n        let scaled_total_deposited_asset: u128 = scaled_total_deposited_asset_loc.read();\n        scaled_total_deposited_asset_loc.write(scaled_total_deposited_asset - scaled_withdraw_amount);\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_total_collateral_value(market_id: Field, owner: AztecAddress) -> u128 {\n        let mut total_collateral_value: u128 = 0 as u128;\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id);\n\n        for i in 0..market_assets_list_len {\n            let market_asset_loc = market_assets_list_loc.at(i);\n            let market_asset: AztecAddress = market_asset_loc.read();\n            Lending::at(context.this_address()).update_accumulators(market_id, market_asset).call(&mut context);\n            let collateral_asset_loc = storage.market_assets.at(market_id).at(market_asset);\n            let collateral_asset: Asset = collateral_asset_loc.read();\n            let collateral_price = PriceFeed::at(collateral_asset.oracle).get_price(0).view(&mut context).price;\n            let scaled_collateral_amount_loc = storage.scaled_deposited_assets.at(market_id).at(market_asset).at(owner);\n            let scaled_collateral_amount: u128 = scaled_collateral_amount_loc.read();\n            let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(market_asset);\n            let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n            let collateral_amount = (scaled_collateral_amount * deposit_accumulator.value) / 1000000000 as u128;\n            total_collateral_value += (collateral_amount * collateral_price);\n        }\n        total_collateral_value / 1000000000 as u128\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_collateral_debt_value(market_id: Field, owner: AztecAddress) -> u128 {\n        let mut min_collateral_value: u128 = 0 as u128;\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id);\n\n        for i in 0..market_assets_list_len {\n            let market_asset_loc = market_assets_list_loc.at(i);\n            let market_asset: AztecAddress = market_asset_loc.read();\n            Lending::at(context.this_address()).update_accumulators(market_id, market_asset).call(&mut context);\n            let debt_asset_loc = storage.market_assets.at(market_id).at(market_asset);\n            let debt_asset: Asset = debt_asset_loc.read();\n            if(debt_asset.is_borrowable) {\n                let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(market_asset).at(owner);\n                let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n                let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(market_asset);\n                let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n                let user_borrowed_amount = (scaled_user_borrowed_amount * borrow_accumulator.value) / 1000000000 as u128;\n                \n                let borrow_price= PriceFeed::at(debt_asset.oracle).get_price(0).view(&mut context).price;\n\n                min_collateral_value += (user_borrowed_amount * borrow_price * 10000 as u128) / debt_asset.loan_to_value;\n            }\n        }\n        min_collateral_value / 1000000000 as u128\n    }\n\n    #[private]\n    fn deposit_private(\n        from: AztecAddress,\n        amount: u128,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        collateral_asset: AztecAddress,\n        fromPublicBalance: bool,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        if(!fromPublicBalance) {\n            let _ = Token::at(collateral_asset).transfer_to_public(from, context.this_address(), amount, nonce).call(&mut context);\n        }\n        else {\n            let _ = Token::at(collateral_asset).transfer_in_public(from, context.this_address(), amount, nonce).enqueue(&mut context);\n        }\n        Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, market_id,collateral_asset)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn deposit_public(\n        amount: u128,\n        nonce: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        // docs:start:public_to_public_call\n        let _ = Token::at(collateral_asset)\n            .transfer_in_public(context.msg_sender(), context.this_address(), amount, nonce)\n            .call(&mut context);\n        // docs:end:public_to_public_call\n        let _ = Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, market_id, collateral_asset)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _deposit(owner: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(collateral_asset);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == collateral_asset, \"Invalid asset or market id\");\n        \n        Lending::at(context.this_address()).update_accumulators(market_id, collateral_asset).call(&mut context);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(collateral_asset);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        let total_deposited_assets = Lending::at(context.this_address()).compute_total_deposited_assets(market_id, collateral_asset, deposit_accumulator).call(&mut context);\n        assert((total_deposited_assets + amount) < asset.deposit_cap, \"Deposit cap exceeded\");\n\n        let scaled_user_deposited_asset_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_asset).at(owner);\n        let scaled_user_deposited_asset: u128 = scaled_user_deposited_asset_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / deposit_accumulator.value;\n        scaled_user_deposited_asset_loc.write(scaled_user_deposited_asset + scaled_amount);\n\n        let scaled_total_deposited_asset_loc = storage.scaled_total_deposited_assets.at(market_id).at(collateral_asset);\n        let scaled_total_deposited_asset: u128 = scaled_total_deposited_asset_loc.read();\n        scaled_total_deposited_asset_loc.write(scaled_total_deposited_asset + scaled_amount);\n    }\n\n    #[public]\n    fn compute_total_deposited_assets(market_id: Field, asset_address: AztecAddress, deposit_accumulator: Accumulator) -> u128 {\n        let scaled_total_deposited_asset_static = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let total_deposited_asset = scaled_total_deposited_asset_static * deposit_accumulator.value / 1000000000 as u128;\n        total_deposited_asset\n    }\n\n    #[public]\n    fn add_asset(market_id: Field, asset_address: AztecAddress, oracle: AztecAddress, loan_to_value: u128, is_borrowable: bool, optimal_utilization_rate: u128, under_optimal_slope: u128, over_optimal_slope: u128, deposit_cap: u128) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n\n        assert(loan_to_value <= (10000 as u128));\n\n        asset_loc.write(Asset {\n            asset_address,\n            oracle,\n            loan_to_value,\n            is_borrowable,\n            optimal_utilization_rate,\n            under_optimal_slope,\n            over_optimal_slope,\n            deposit_cap,\n        });\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id).at(market_assets_list_len);\n        market_assets_list_loc.write(asset_address);\n        market_assets_list_len_loc.write(market_assets_list_len + 1);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        assert(deposit_accumulator.last_updated_ts == 0);\n        assert(deposit_accumulator.value == 0 as u128);\n\n        deposit_accumulator_loc.write(Accumulator {\n            // 10**9\n            value: 1000000000 as u128,\n            last_updated_ts: context.timestamp(),\n        });\n\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n\n        assert(borrow_accumulator.last_updated_ts == 0);\n        assert(borrow_accumulator.value == 0 as u128);\n\n        borrow_accumulator_loc.write(Accumulator {\n            // 10**9\n            value: 1000000000 as u128,\n            last_updated_ts: context.timestamp(),\n        });\n    }\n\n\n    // Create a position.\n    #[public]\n    fn update_accumulators(market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let mut deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let mut borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n\n        let timestamp = context.timestamp();\n        let time_delta = timestamp - deposit_accumulator.last_updated_ts;\n\n        // Only update if time has passed.\n        if !(time_delta == 0) {\n            let precision = 1000000000 as u128; // 10**9\n            let utilization_rate = _compute_utilization_rate(market_id, asset_address, precision, deposit_accumulator, borrow_accumulator);\n            let borrow_rate_per_year = _compute_borrow_rate(asset, utilization_rate, precision);\n            // TODO: let supply_rate_per_year = borrow_rate_per_year * utilization_rate * (1 - reserve_factor);\n            let supply_rate_per_year = (borrow_rate_per_year * utilization_rate) / precision;\n\n            let new_borrow_accumulator = ((borrow_accumulator.value * borrow_rate_per_year * time_delta as u128) / 31536000 as u128) / precision;\n            let new_deposit_accumulator = ((deposit_accumulator.value * supply_rate_per_year * time_delta as u128) / 31536000 as u128) / precision;\n\n            borrow_accumulator.value += new_borrow_accumulator;\n            borrow_accumulator.last_updated_ts = timestamp;\n            borrow_accumulator_loc.write(borrow_accumulator);\n            deposit_accumulator.value += new_deposit_accumulator;\n            deposit_accumulator.last_updated_ts = timestamp;\n            deposit_accumulator_loc.write(deposit_accumulator);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_utilization_rate(market_id: Field, asset_address: AztecAddress, precision: u128, deposit_accumulator: Accumulator, borrow_accumulator: Accumulator) -> u128 {\n        \n        let scaled_total_deposited_asset = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let scaled_total_borrowed_asset = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address).read();\n\n        let total_deposited_assets = (scaled_total_deposited_asset * deposit_accumulator.value) / precision;\n        let total_borrowed_assets = (scaled_total_borrowed_asset * borrow_accumulator.value) / precision;\n        let mut utilization_rate = 0 as u128;\n        if (total_borrowed_assets != 0) {\n            utilization_rate = (total_borrowed_assets * precision) / total_deposited_assets;\n        } else {\n            utilization_rate = 0;\n        }\n\n        utilization_rate\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_borrow_rate(asset: Asset, utilization_rate: u128, precision: u128) -> u128 {\n        let mut rate = 0 as u128;\n        if utilization_rate < asset.optimal_utilization_rate {\n            // rate = base + utilization * slope1 / optimal No base for now\n            rate = (utilization_rate * asset.under_optimal_slope) / asset.optimal_utilization_rate;\n        } else {\n            // rate = base +slope1 + (utilization - optimal) * slope2 / (1 - optimal) No base for now\n            rate = asset.under_optimal_slope + (utilization_rate - asset.optimal_utilization_rate) * asset.over_optimal_slope / (precision - asset.optimal_utilization_rate);\n        }\n        rate\n    }\n\n    #[public]\n    fn liquidate_public(market_id: Field, collateral_asset: AztecAddress, debt_asset: AztecAddress, user: AztecAddress, debt_to_cover: u128) {\n        let _ = Lending::at(context.this_address())._liquidate(market_id, collateral_asset, debt_asset, user, debt_to_cover).call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _liquidate(market_id: Field, collateral_token: AztecAddress, debt_token: AztecAddress, user: AztecAddress, debt_to_liquidate_amount: u128) {\n        Lending::at(context.this_address()).update_accumulators(market_id, collateral_token).call(&mut context);\n        Lending::at(context.this_address()).update_accumulators(market_id, debt_token).call(&mut context);\n\n        let scaled_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(debt_token).at(user);\n        let scaled_borrowed_amount: u128 = scaled_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(debt_token);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let borrowed_amount = (scaled_borrowed_amount * borrow_accumulator.value) / 1000000000 as u128;\n\n        assert(borrowed_amount >= debt_to_liquidate_amount, \"Insufficient borrowed amount\");\n\n        let total_collateral_value: u128 = Lending::at(context.this_address())._compute_total_collateral_value(market_id, user).call(&mut context);\n        let collateral_debt_value = Lending::at(context.this_address())._compute_collateral_debt_value(market_id, user).call(&mut context);\n\n        assert(collateral_debt_value > total_collateral_value, \"collateral >= debt\");\n\n        let debt_asset_loc = storage.market_assets.at(market_id).at(debt_token);\n        let debt_asset: Asset = debt_asset_loc.read();\n        let debt_asset_price = PriceFeed::at(debt_asset.oracle).get_price(0).view(&mut context).price;\n        let debt_to_liquidate_price = (debt_to_liquidate_amount * debt_asset_price) / 1000000000 as u128;\n\n        let collateral_asset_loc = storage.market_assets.at(market_id).at(collateral_token);\n        let collateral_asset: Asset = collateral_asset_loc.read();\n        let collateral_asset_price = PriceFeed::at(collateral_asset.oracle).get_price(0).view(&mut context).price;\n        let collateral_amount_to_liquidate = (debt_to_liquidate_price * 1000000000 as u128) / collateral_asset_price;\n\n        let collateral_deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(collateral_token);\n        let collateral_deposit_accumulator: Accumulator = collateral_deposit_accumulator_loc.read();\n        let scaled_collateral_deposit_amount_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_token).at(user);\n        let scaled_collateral_deposit_amount: u128 = scaled_collateral_deposit_amount_loc.read();\n        let collateral_deposit_amount = (scaled_collateral_deposit_amount * collateral_deposit_accumulator.value) / 1000000000 as u128;\n\n        assert(collateral_deposit_amount >= collateral_amount_to_liquidate, \"Insufficient collateral\");\n\n        let scaled_collateral_amount_to_liquidate = (collateral_amount_to_liquidate * 1000000000 as u128) / collateral_deposit_accumulator.value;\n\n        let debt_borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(debt_token);\n        let debt_borrow_accumulator: Accumulator = debt_borrow_accumulator_loc.read();\n        let scaled_debt_amount_to_liquidate = (debt_to_liquidate_amount * 1000000000 as u128) / debt_borrow_accumulator.value;\n\n        let scaled_user_deposited_amount_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_token).at(user);\n        let scaled_user_deposited_amount: u128 = scaled_user_deposited_amount_loc.read();\n        scaled_user_deposited_amount_loc.write(scaled_user_deposited_amount - scaled_collateral_amount_to_liquidate);\n\n        let scaled_total_deposited_asset_loc = storage.scaled_total_deposited_assets.at(market_id).at(collateral_token);\n        let scaled_total_deposited_asset: u128 = scaled_total_deposited_asset_loc.read();\n        scaled_total_deposited_asset_loc.write(scaled_total_deposited_asset - scaled_collateral_amount_to_liquidate);\n\n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(debt_token).at(user);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        scaled_user_borrowed_amount_loc.write(scaled_user_borrowed_amount - scaled_debt_amount_to_liquidate);\n\n        let scaled_total_borrowed_asset_loc = storage.scaled_total_borrowed_assets.at(market_id).at(debt_token);\n        let scaled_total_borrowed_asset: u128 = scaled_total_borrowed_asset_loc.read();\n        scaled_total_borrowed_asset_loc.write(scaled_total_borrowed_asset - scaled_debt_amount_to_liquidate);\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_position(owner: AztecAddress, market_id: Field, asset_address: AztecAddress) -> pub Position {\n        let scaled_user_deposited_asset_loc = storage.scaled_deposited_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_deposited_asset: u128 = scaled_user_deposited_asset_loc.read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let collateral = (scaled_user_deposited_asset * deposit_accumulator.value) / 1000000000 as u128;\n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let debt = (scaled_user_borrowed_amount * borrow_accumulator.value) / 1000000000 as u128;\n        Position { collateral, scaled_debt:scaled_user_borrowed_amount, debt }\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_total_deposited_assets(market_id: Field, asset_address: AztecAddress) -> u128 {\n        let scaled_total_deposited_asset = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let total_deposited_assets = (scaled_total_deposited_asset * deposit_accumulator.value) / 1000000000 as u128;\n        total_deposited_assets\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_total_borrowed_assets(market_id: Field, asset_address: AztecAddress) -> u128 {\n        let scaled_total_borrowed_asset = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address).read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let total_borrowed_assets = (scaled_total_borrowed_asset * borrow_accumulator.value) / 1000000000 as u128;\n        total_borrowed_assets\n    }\n\n\n    #[utility]\n    #[view]\n    unconstrained fn get_accumulators(market_id: Field, asset_address: AztecAddress) -> (Accumulator, Accumulator) {\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        (deposit_accumulator, borrow_accumulator)\n    }\n}\n"
    },
    "56": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "57": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "64": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "65": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "66": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "67": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "71": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "88": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "92": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "93": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "96": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "97": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    }
  }
}
