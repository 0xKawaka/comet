{"noir_version":"1.0.0-beta.4+0000000000000000000000000000000000000000","name":"Lending","functions":[{"name":"_compute_collateral_debt_value","hash":"1405872517684370964","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8945853978429536226":{"error_kind":"string","string":"Function _compute_collateral_debt_value can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_compute_collateral_debt_value"],"brillig_names":["_compute_collateral_debt_value"]},{"name":"repay_private","hash":"10697001889022219872","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"field"},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","names":["repay_private"],"brillig_names":["discover_new_messages","decompose_hint","store_in_execution_cache_oracle_wrapper","call_private_function_internal","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","directive_invert"]},{"name":"deposit_private","hash":"2292839562744130126","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"field"},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"H4sIAAAAAAAA/+1dB5gct3Wevb078pY8ctmrRFJdVJvtu7JsU1a3qmVJtmRb9lY1ip0SKbHskUeKosSmQsld7r132bHTndiJ45I4sRPHimuc2HGJa9wCUPN23717Mzt7+3BciIfve3ezA+DHjwfgAQNgMBHnabci6jhzo09fR5REvf89SpaSe/AfX/cx4aYw9waZe9OZezOYe3M1T3JvCRNuKXNvGXPvBObeqcy905XUnZEuAnrz/qfcbDpdzSWriVSi6CYLpXzGTWdK2Xwin8jkM5VkPpWq5tP5XKFUyLmFRDpVTdQyhVTNfdpFo00styOXLJvk2Tt2nnl6Q3ObqaQXcdV6+IN3fZrTvD4dXfd6YSBen/rdr2SSksnR5n1wUaIDtzOXWC6I1ReVK5sBsTrkuib1d4YgVr+g/mKW6O9MQaxJgvqbIqg/zjYMINsQQ9dT0PVkYhumqt+DSqYpmT4OtuEsQaypgmUTt6Runy2INSiovxmG63Yc1eEZ6Hoaup5O6vZM9XuWktlK5jB1u0e4bE515PQ5V06fiRFjxOjT4zeTepgrWK/mGdLDPE8PvUQH2EWE9RJxzNgYR5ZnqQGoldOPFGFSOYKDHhfznR81SFiDS+MuEGw9pvK9IOpI1zp3PCub4AhxRGVbGDVIeKGByraoyyubzvciA5XNBFfdKBYZahgRZ3wahiRv3KUu9vRyXJRkQHp8jLE6rdCLwzeOcgusxHFROyuEZLeMK8TxXsEvMV0hzhCsEMcLVoglwg9Mk5UMID02sPOpaq6QSFTyqYxbyGWTBcUgm8ukErVyIlMu1iq5QjFfKFWr5VKqUHBTtWwhk0uWs6lsLV3MFP9A8BLFXC1TrRWLlVwtpQCSmWIhka+l3HI5X8mlUqlauVws5ZR3ueDWEulKNZ8olcuZZL5WKKQylT/Ilq87qsJn0sViPlvMpcqlfDGVziQz1UypVK1kq+lUqZhIFPLVfNatZWqpQsZNZvO1XKJSS2cKiVKlmnaTlF/SLVTKtVItqf5kcrVCLeumlWbSlVyiWM7WirV8LqmSrJVzaTdXdtPVUjaZKGaT+Vy5WE4ks6bzm6zU8qVC2q1m8gW3mlbVMZeruplULlUrVrOFYqKSy6RVmaYyVaWUvFvKZrOFdC6tyj9ZrpRHlUeyWq7k85VEppDNlcqZVCmfV7pJVt1KIpvPZhMqr+VStlgsJyupWj5TTap85qrVWilZThRUZTOR334PS18vRg/8x6Hr49H1Eu9akEdSOl8ab6niuUzJCcQISi9KnDh2W5OhN9pZlIig6xPJ5MxJ6vfJSk5Rcuo4TDyeLoh1kuCo+TRLJh4lF3VOFtTf6YYnHk9Ddft0dH0Kuj6V1O3l6vcZSs5UcpZXt7X0oHLh3AqZfKQjzuj2JD0wPM2Rr7c2TLhJczzdAo7LHTM2SpynCVuqG5JutH3OaCedAcHVHSMzxNVcOpMplAvWFaIBnvMs4RmVwxrxBH+215OdQ7c9nT0OS0xnC44gXENLTC6jB+nCPWecKmGnOk7Ibd8qmeSZFOBZqxTU83ixYKLe6/lwyQUijaWfQqV5LhXkmLKkjqfHzjNLb3BPIgn0xJFE1yl0nSZPIhn1O6skpyRv2VN2RrAOFSx5ypbcHpUV1N+5x+D2qJyg/p5leJaigGzAuej6Weg6T2zDeer3s5U8R8lz0SxFrzMusxQZzanPUBq4DwYdCXJPmOiTjsWZhbMs4GjqoVya53mGbHTDSQ8SXUEDu8LQQ9wKtE+wzxk9gDJRkKb2CdpS4aR5upbwlJypcThHG7DEji+pzJ9jKPPSeRZsnAnXkjz3COY5YUmeBRtjIjlOeXY7c4mUoP5mWmJ0044dPDOW8MxawjNnCc+8JTwLlvA81xKez7KE53mW8Hy2JTyfYwnP51rCc4UlPM+3hOfzLOF5gSU8L7SE50WW8LzYEp6XWMLzUkt4XmYJz+dbwvNyS3heYQnPKy3heZUlPK+2hOc1lvB8gSU8r7WE5wst4XmdJTyvt4TnDZbwfJElPF9siGc3rwveOE55djtziZsE9TfXkvWilzh28HypJTxfZgnPmy3h+XJLeL7CEp5FS3iWLOFZtoRnxRKeVUt41izheYslPG+1hOdtlvC83RKed1jCc6UlPO+0hOcqS3iutoTnGkt4rrWE5zpLeK63hOcGS3hutITnXZbwvNsSnpss4bnZEp73WMLzXkt4brGE51ZLeG6zhOd2S3jWLeE5ZAnPHZbw3GkJz2FLeO6yhOduS3jeZwnPPZbwvN8Snnst4fmAJTwftITnPkt47reE5wFLeB60hOchS3g+ZAnPhy3h+YglPB+1hOdhS3g+ZgnPxy3h+UpLeL7KEp6vtoTnayzh+VpLeL7OEp6vt4TnE5bwfIMlPN9oCc83WcLzzZbwfIslPN9qCc+3WcLz7ZbwfIclPN9pCc93WcLz3ZbwfI8lPN9rCc/3WcLz/Zbw/IAlPD9oCc8PWcLzw5bw/IglPD9qCc+PWcLz45bw/IQlPJ+0hOcnLeH5KUt4/oklPD9tCc/PWMLzTy3h+WeW8PxzS3j+hSU8/9ISnn9lCc+/toTnZy3h+TeW8PxbS3h+zhKen7eE599ZwvPvLeH5BUt4/oMlPL9oCc8vWcLzy5bw/IolPP/REp7/ZAnPr1rC858t4fkvlvD8miU8v24Jz3+1hOe/WcLzG5bw/HdLeH7TEp5PWcLzPyzh+S1LeH7bEp7fsYTndy3h+T1LeH7fEp7/aQnPH1jC878s4fnflvD8oSU8f2QJz/+xhOePLeH5E0t4/tQSnj+zhOf/WsLz55bw/IUlPH9pCc9fWcLz15bw/I0lPP/PEp6/tYTn7yzh+XtLeP7BEp5/tISnBrSBZ8QSnj2W8IxawrPXEp59lvDst4TnJEt4TraE54AlPGOW8JxiCc+plvActITnNEt4TreEZ9wSnjMs4TnTEp6zLOE52xKecyzhOdcSnvMs4TnfEM8ewrObvku/wJI8ny2Y54WW1MdFkc715+ZLxWI2lTdZNlHBPC8ep/roduYSx0Xk9Lc8akd9PN6SslkiWDbzonbkealgns+2pD4us8SOn2AJzxMt4XmSJTxPtoTnKZbwPNUSnqdZwvN0S3gut4TnGZbwPNMSnmdZwvNsS3ieYwlP1xKeCUt4Ji3hmbKEZ9oSnhlLeGYt4ZmzhGfeEp4FS3ieawnPZ1nC8zxLeD7bEp7PsYTncy3hueIYXAc8/xjM8/MsybPk+toFlqzhXCi4nnGeJWs4Fwnm2bVkDediS/qESyzheaklPC+zhOfzLeF5uSU8r7CE55WW8LzKEp5XW8LzGkt4vsASntdawvOFlvC8zhKe11vC8wZLeL7IEp4vtoTnjZbwvMkSni+xhOdLLeH5Mkt43mwJz5dbwvMVlvAsWsKzZAnPsiU8K5bwrFrCs2YJz1ss4XmrJTxvs4Tn7ZbwvMMSnist4XmnJTxXWcJztSU811jCc60lPNdZwnO9JTw3WMJzoyU877KE592W8NxkCc/NlvC8xxKe91rCc4slPLdawnObJTy3W8KzbgnPIUt47rCE505LeA5bwnOXJTx3W8LzPkt47rGE5/2W8NxrCc8HLOH5oCU891nCc78lPA9YwvOgJTwPWcLzIUt4PmwJz0cs4fmoJTwPW8LzMUt4Pm4Jz1dawvNVlvB8tSU8X2MJz9dawvN1lvB8vSU8n7CE5xss4flGS3i+yRKeb7aE51ss4flWS3i+zRKeb7eE5zss4flOS3i+yxKe77aE53ss4fleS3i+zxKe77eE5wcs4flBS3h+yBKeH7aE50cs4flRS3h+zBKeH7eE5ycs4fmkJTw/aQnPT1nC808s4flpS3h+xhKef2oJzz+zhOefW8LzLyzh+ZeW8PwrS3j+tSU8P2sJz7+xhOffWsLzc5bw/LwlPP/OEp5/bwnPL1jC8x8s4flFS3h+yRKeX7aE51cs4fmPlvD8J0t4ftUSnv9sCc9/sYTn1yzh+XVLeP6rJTz/zRKe37CE579bwvOblvB8yhKe/2EJz29ZwvPblvD8jiU8v2sJz+9ZwvP7lvD8T0t4/sASnv9lCc//toTnDy3h+SNLeP6PJTx/bAnPn1jC86eW8PyZJTz/1xKeP7eE5y8s4flLS3j+yhKev7aE528s4fl/lvD8rSU8f2cJz99bwvMPlvD8oyU8nR47eEYs4dljCc+oJTx7LeHZZwnPfkt4TrKE52RLeA5YwjNmCc8plvCcagnPQUt4TrOE53RLeMYt4TnDEp4zLeE5yxKesy3hOccSnnMt4TnPEp7zLeG5wBKeCy3hucgSnost4XmcJTyPt4TnEkt4LrWE5zJLeJ5gCc8TLeF5kiU8T7aE5ymW8DzVEp6nWcLzdEt4LreE5xmW8DzTEp5nWcLzbEt4nmMJT9cSnglLeCYt4ZmyhGfaEp4ZS3hmLeGZs4Rn3hKeBUt4nmsJz2dZwvM8S3g+2xKez7GE53Mt4bnCEp7nW8LzeZbwvMASnhdawvMiS3hebAnPSyzheaklPC+zhOfzLeF5uSU8r7CE55WW8LzKEp5XW8LzGkt4vsASntdawvOFlvC8zhKe11vC8wZLeL7IEp4vtoTnjZbwvMkSni+xhOdLLeH5Mkt43mwJz5dbwvMVlvAsWsKzZAnPsiU8K5bwrFrCs2YJz1ss4XmrJTxvs4Tn7ZbwvMMSnist4XmnJTxXWcJztSU811jCc60lPNdZwnO9JTw3WMJzoyU877KE592W8NxkCc/NlvC8xxKe91rCc4slPLdawnObJTy3W8KzbgnPIUt47rCE505LeA5bwnOXJTx3W8LzPkt47rGE5/2W8NxrCc8HLOH5oCU891nCc78lPA9YwvOgJTwPWcLzIUt4PmwJz0cs4fmoJTwPW8LzMUt4Pm4Jz1dawvNVlvB8tSU8X2MJz9dawvN1lvB8vSU8n7CE5xss4flGS3i+yRKeb7aE51ss4flWS3i+zRKeb7eE5zss4flOS3i+yxKe77aE53ss4fleS3i+zxKe77eE5wcs4flBS3h+yBKeH7aE50cs4flRS3h+zBKeH7eE5ycs4fmkJTw/aQnPT1nC808s4flpS3h+xhKef2oJzz+zhOefW8LzLyzh+ZeW8PwrS3j+tSU8P2sJz7+xhOffWsLzc5bw/LwlPP/OEp5/bwnPL1jC8x8s4flFS3h+yRKeX7aE51cs4fmPlvD8J0t4ftUSnv9sCc9/sYTn1yzh+XVLeP6rJTz/zRKe3zDEs4fwTLnZdLqaS1YTqUTRTRZK+YybzpSy+UQ+kclnKsl8KlXNp/O5QqmQcwuJdKqaqGUKqZqHfapgnv99nPLsduYS3+yR09+KqB3l3Cuov6csqdt9gnn+D0vy3C+Y529ZkudJgnn+tiV5niyY5+9YkucBwTx/15I8xwTz/D1L8jxFMM/ftyTPUwXz/J+W5HlQMM8/sCTP0wTz/F+W5Hm6YJ7/25I8xwXz/ENL8jxDMM8/siTPMwXz/D+W5HmWYJ5/bEmeZwvm+SeW5HmOYJ5/akme5wrm+WeW5HmeYJ7/15I8zxfM888tyfMCwTz/wpI8LxTM8y8tyfMiwTz/ypI8LxbM868tyfNxgnn+jSV5Pl4wz/9nSZ6XCOb5t5bkealgnn9nSZ6XCeb595bk+QTBPP/BkjyfKJjnP1qS55ME8+xYsuZ+smCeI5bk+RTBPPcI5llBHdnj849ehs/RmEoSSpI630rSSjJKskpySvJKCkrOVfIsJecpebaS5yh5rpfP85U8T8kFSi5UcpGSi5VcouRSJZcpeb6Sy5VcoeRKJVcpuVrJNUpeoORaJS9Ucp2S65XcoORFSl6s5EYlNyl5iZKXKnmZkpuVvFzJK5QUlZSUlJVUlFSV1JTcouRWJbcpuV3JHUpWKrlTySolq5WsUbJWyTol65VsULJRyV1K7laySclmJfcouVfJFiVblWxTsl1JXcmQkh1KdioZVrJLyW4l9ynZo+R+JXuVPKDkQSX7lOxXckDJQSWHlDyk5GEljyh5VMlhJY8peVzJK5W8SsmrlbxGyWuVvE7J65U8oeQNSt6o5E1K3qzkLUrequRtSt6u5B1K3qnkXUrereQ9St6r5H1K3q/kA0o+qORDSj6s5CNKPqrkY0o+ruQTSp5U8kkln1LyJ0o+reQzSv5UyZ8p+XMlf6HkL5X8lZK/VvJZJX+j5G+VfE7J55X8nZK/V/IFJf+g5ItKvqTky0q+ouQflfyTkq8q+Wcl/6Lka0q+ruRflfybkm8o+Xcl31TylJL/UPItJd9W8h0l31XyPSXfV/KfSn6g5L+U/LeSHyr5kZL/UfJjJT9R8lMlP1Pyv0p+ruQXSn6p5FdKfq3kN0r+T8lvlfxOye+V/EHJH5XoBhVR0qMkqqRXSZ+SfiWTlExWMqAkpmSKkqlKBpVMUzJdSVzJDCUzlcxSMlvJHCVzlcxTMl/JAiULlSxSsljJcUqOV7JEyVIly5ScoOREJScpOVnJKUpOVXKaktOVLFdyhpIzlZyl5Gwl5yhxlSSUJJWklKSVZJRkleSU5JUUlJyr5FlKzlPybCXPUfJcJSuUnK/keUouUHKhkouUXKzkEiWXKrlMyfOVXK7kCiVXKrlKydVKrlHyAiXXKnmhkuuUXK/kBiUvUvJiJTcquUnJS5S8VMnLlNys5OVKXqGkqKSkpKykoqSqpKbkFiW3KrlNye1K7lCyUsmdSlYpWa1kjZK1StYpWa9kg5KNSu5ScreSTUo2K7lHyb1KtijZqmSbku1K6kqGlOxQslPJsJJdSnYruU/JHiX3K9mr5AElDyrZp2S/kgNKDio5pOQhJQ8reUTJo0oOK3lMyeNKXqnkVUpereQ1Sl6r5HVKXq/kCSVvUPJGJW9S8mYlb1HyViVvU/J2Je9Q8k4l71LybiXvUfJeJe9T8n4lH1DyQSUfUvJhJR9R8lElH1PycSWfUPKkkk8q+ZSSP1HyaSWfUfKnSv5MyZ8r+Qslf6nkr5T8tZLPKvkbJX+r5HNKPq/k75T8vZIvKPkHJV9U8iUlX1byFSX/qOSflHxVyT8r+RclX1PydSX/quTflHxDyb8r+aaSp5T8h5JvKfm2ku8o+a6S7yn5vpL/VPIDJf+l5L+V/FDJj5T8j5IfK/mJkp8q+ZmS/1XycyW/UPJLJb9S8mslv1Hyf0p+q+R3Sn6v5A9K/qhEDx4iSnqURJX0KulT0q9kkpLJSgaUxJRMUTJVyaCSaUqmK4krmaFkppJZSmYrmaNkrpJ5SuYrWaBkoZJFShYrOU7J8UqWKFmqZJmSE5ScqOQkJScrOUXJqUpOU3K6kuVKzlByppKzlJyt5BwlrpKEkqSSlJK0koySrJKckrySgpJzlTxLyXlKnq3kOUqeq8fdSs5X8jwlFyi5UMlFSi5WcomSS5VcpuT5Si5XcoWSK5VcpeRqJdcoeYGSa5W8UMl1Sq5XcoOSFyl5sZIbldyk5CVKXqrkZUpuVvJyJa9Qor/jrr+Rrr8/rr/trb+brb9Jrb/3rL+lrL9TrL8BrL+vq79dq78Lq7+5qr9nqr8Vqr/Dqb9xqb8fqb/NqL97qL8pqL/Xp7+Fp78zp7/hpr+Ppr89pr/rpb+Zpb9HVVeiv6Okv1Gkv/+jv62jv1ujvwmjv7eiv2WivxOiv8Ghv2+hvx2hv8ugv3mgvyegz+rX5+DrM+b1+e36bHR97rg+01ufl63PotbnPOszlPX5xPrsX32urj6zVp8H+4QSfY6pPiNUn7+pz7bU50bqMxn1eYf6LEF9Tp8+A0+fL6fPbtPnoukzx/R5XvqsLH0OlT7jSZ+fpM8m0uf+6DN19Hk1+iwYfc6KPsNEnw+iz97Q51roMyP0eQx/qkSfI6Df0dfvv+t3y/V72/qdaP2+sX6XV78nq99B1e936ncn9XuJ+p0//T6dfldNvwem37HS7y/psal+70a/06LfF9HvYuj3HPQ7BHp/vt77rveV633Weg/zU0r0vlS9T1PvW9T7+PS+Nr3PS+970vuA9L4YvU9E75vQ+wj0urpeZ9brrnodUq/L6XUqvW6j1zH0vL6e59bzvnoeVM8L6nkyPW+k51H0vIJ+ztbPnfo5TD+X6HF6z9PDAUfvM9buHKfpPFOhgx/x1/ty9T5VvW9T72PU+/r0Pje970vvg9L7gvQ+Gb1vRO+j0PsK9Dq7XnfW67B6XVKv0+l1K72Oo9c19Dy/nvfW88B6XlTPE+p5s6VKlik5QYl+7tbPofq5TD+n6L3vpyk5XclyJWcoOVPJWUrOdka7XnS9wPs/5zvnL1j7ubddhMMtCvBLBvg918dvkvd/5nFP/x/wfvd4/7V+tW5XeL/dzlxiAOFK4+fdQmnAGemE+acGEKYB/CTg95rBd6G8X1kfie+QdAe93xGkS4gDfj3I71We32TPH643edcDBM9EuWNO0nqbxfDvQXnT7oK6ibSTZcC/0MN3RmAnUvlsKpnPJpOVqlusZHO1QirnpkqZVKFcSripTDJfyRVTrltNVctpt5ItZCrVYiGTqpWKhSxgX8Rip6olBZUpZvOlRK2YrbmldC6fKtZyuUqxUlBzORm3kihnE+VkopbPFzOZYjlTSCRq1UKmlm9gX2xEL0+3Fe0uMYKfygD+pUbwkw1bdRnCF3yXxgX855vBb9jyy83gN8r3CiP6b/K/0sN3HHndX2WGewrwrzaCn2jwv8YM/zTgvwDhRwzo51oz+I2680Iz+I26f50Z/dcA/3oP30HYiXwqmcyl9Bx8vuIm0pVyMq96l1LaLbvFcrJaSCcKtXQynSpXyiU1X19M1NxasVyo5Z8GB+wbjHBPNerOi4zoPtXot17M6MbtzDX6lBv9scesfsC+icFOFlNlt1Bzi5l8MVdVCy+uGizkqqV8tZZNFktqYJCsJBKJalr9SVYr6UKpkk2Usmq1JlNSyTXK9CV1E2WaaIxxXiqMny26hWo2mwP8lwnjl0rZXFHpE/BvFsZPlbPVWirXsAcvF8YvZtK1WiZVBPxXCONnEm41k8w16mZRGL9QcjPZfL5Rf0rC+Gpcm6oUio2xWllaP6WqW64kCvDMVPHwIQ3tIO2qcNqeK0RIeo4z8pnQIenHCFfpcVmEpIf5VNA9eP4C3dXqo7nGGT9sY6hflLkH6XBYLxPEulkQ6+WCWK8QxCoKYpUEsaBdm21r6UY/WjOCn8oD/i1G8N0q4N9qAj/RHDvehvAdOf4N/NsRfsQA/h1m9N/AX2lGP43nmjs9fBPYq8zopjEGW20Gv/FcsMYMfmOMutYMfsM2rDODXwD89WbwG2PUDWbwG2O8jWbwG2PUu8zgVwD/biP4iYZ+NiF8OduZbNi2zUbwUw38e8zgN+zbvUbw0w38LWbwG/MqW83gN+zzNjP4Dfu83Qx+Y+xTN4KfaTwjDxnBzzbqzw4z+I05151m8Bv1c9gMfqN+7jKD36ifu83gN8YP95nBb4wf9pjBb4wf7jeD3+i/9prBb/TvD5jBb/TvD5rBb9i3fWbwG/ZtvxH8XKN/P2AGvzEHe9AMfsN+HjKD37CfD5nBb9jPh83gN+znI2bwG/btUTP4Dft22Ax+w749Zga/YX8e9/CdsWOn6A29P0/vF3pi5tN43D4rwbGWC3uY8L47PN+ur/vQfcHnqEqY+XacfoxwNTHfjtMDPlQ/eL5d+/UzXOOMHy3DfiadfiadOOM3XJfDOiCItUsQa58glmQeHxDE2iOI9aAg1m5BrE2CWJK6HxbEOtilWEOCWJJ1YlgQS7J+7RTEkmzbknVihyCWpI1+WBBrWBBLsu+AMbXZsZWbHWTSBgd+k1DaeExFXZT8xrz1WPWtM5u4NBy4qU5zTXn95lXlq1ZvqK53AiJod2Gdv99tyosQv8kh8uA4rRX7ZAjF0gE85jZIMHHcCIPFbXahlRnrvNeHA8aAsqID4RXeb7cjl0iFyQdOf7weIjgjwT1EgH4mmdFPMkLwMZ9JjH5oHaZlF3GaDbkPYeHwk1AecXh8DfHxvX/2/sed0e0INqdHGL8ocw/0q7l/ieQNlw2tp2bKIZ0IW08h/Zhjst006ylXL7jObMAZXc6SG4LClCtn2wYYP8CCDXq4nuLwk1EecXh8DfHxve96/+PO6DpN6+kAkx98D9fTb3rXAz75WeH9djtyuRzXT9F2gPUkucE5bDuA9GOOyXrXbAdcOXH2BHQXY7jGGT866RNj0okx6cQZPzoQ7QRrnyDWDkGsYUGsg12KtUcQ60FBrN2CWJsEsfYKYknW+27UV1A/2C6WdpJ19ZAg1n2CWJJ1VTKPQ4JY3dq2DwtibRbEgsVDOs4EfMdpjpVof7/C++125J5+dsPpQT7wPZx+jHCV5dMcK3F65ca0oJ8pZvTT4DOF4TOF0Q+U5VTGD7BgrgU/M+DwU1AecXh8DfHxvXO8AosTTO3oM8NUJj/4Hn5mOD0yMm+4bGg9NVkOOD3gje/h9GOOyXbjBtYLrv0POKPLWVA/bphyxXyhLAcZP8Ca5v3G9RSHn4ryiMPja4iP7z2b1FNcp2k9HWTyg+/hepoj9RSXDa2nRsohUQtdTyH9mGOy3TTrKVcvpjB6HHBGl7Ogftww5Yr5QllOY/wAa7r3G9dTHH4Q5RGHx9cQH9+7nNRTXKfpS03TmPzge7ieXuThDvjkZ4X32+3IZdJcWcrh5xKDTD5pO8O6lqvXqdDtDNKPOaPrhYl2Np3w8asHoLs4wzXO+NE6EmfSiTPpxBk/+lzTCdawINYmQawdglh7BbGGBLH2CGI9IIg1LIi1UxCrLoh1UAiLs8+d8DogxEu7Q4JYkm37sCCWpC2UbI8PCmJJluNjgliSdUJS91Jt2xHOo2Sd2CeI1a12QpLXsTBmmujTjp7uJdvjLkEsyTw+IojVreMJyTzS9QH8bBnx/g84o9ue4HN2NULSg3zgezj9GOEqy6f5nM3pdTqjV9DdDIZrnPGjz9kzmHRmMOnEGT/aZ3SCNSyItUkQSzKPewSxHhTEOiSIJan7w4JYE+XYHtZjgliSdWKnINY+QaxhQayDgliSupesq5K671b7JVlXhwWxHhDEkixHyfol2YYk69cBQawhQSzJPA4LYkm2R8k8So4nurUcu3Us94ggVreOcyTHmBPjiWdGG5K0E5K8pOqXvqbzqp3wekiIl3aSupccAwx7WHS/G+BrZ3YOLRl6jy2dQzOyB6vFHBq3t27AGV0PBfWTCFPOmC+U5UzGD7Bmeb/xnjAcfgbKIw6PryE+vvdcTylxgqkd3RM2k8kPvgf61XvCCt6PAZ/8rPB+u525PJ0PhTRw2lhPgvUu1McPcPoxx2S9a7YDrpw4+wK6m8VwjTuj6w6tD7OYdGYx6UxgdRfWtUJYQTYM/LUbYOJJ21ucHuQD38PpxxyjdiERpFfOXoJ+ZpvRT2OP8myGz2xGP1CWcxg/wJrr/cb9EQ4/G+URh8fXEB/fK5P+aA4KS9vAHCY/+B7uj17WMzJvuGxoPTVTDuHf+YD0Y47JdtOsp1y94Nr/gDO6nAX144YpV8wXynIu4wdY87zfuJ7i8HNQHnF4fA3x8b21pJ7iOk3r6VwmP/gerqd3eD+mO/7tM0x7xric3aY6xPFoezBS3omqG7Y9QPoxx2T7bLaHOSH1CvqZa0Q/lVqY+oP5QlnOY/wAa773G7cHHH4uyiMOj68hPr63g7QH3HZoe5jH5Affw+1hC7HbuGxoPTVSDq5bC1tPIf2YY9JONuspVy+4/m/AGV3OgnyqYcoV84WynM/4ARZ8yB7XUxx+HsojDo+vIT6+d5DUU1yn6bt685n84Hu4nu4lz7s0Pyu8325HrprgylIOv+gOMLqWw08WBpjyksMv5QF/oRn8LOAvMoKfb5TvYiP4mYZ+jjODXwH8483Unwb/JUbwUynAX2oEv9rgv8wIfrqBf4IR/FKj/Z5oBL/QqP8nmdFPo3xPNoJfywD+KWb00+B/qhn+Dft/OsKXnIsA/DOM4Lsp0Mdyp+miTJ4gfRiLnIbCR3z+Axb1g7RiBMvUuI/LG+ZPn/uWIz5YB35Yy9vEGmD8TJTp6QH5xukPBnCl+dCOnoEzVp1ot1MQa7sg1gEhLG5s2wmvewR5zRPixY1/O8FaIIgVFcLSjn6srxNeC4V46etFXYq1WBDrOEGs4wWxlghiLRXEWiaEpd2jdTleJwjy2l+X43WiEC99fZIgllTfoa9PFsQ6RRDrVCEs7ejcabdgwRqy2fmudMHsfFeqaHa+K10xO9+VSZmd70rnzM53pcswVof+ENLAdQv3b3LPFenQ74JC+jHCVZZP8/nueMKH6ofu31nCcI0zfrSNLmHSWcKkE2f86F7eTrAeFsQaEsTaK4i1RxBrpyDWJkGsBwSxhgWxDnYplmRd3S2INSyExfXb3VJXJdvjIUGsbm2PDwliSbahbtX9fYJYknZCsq8dFsSS1L2kvrq1fkmOTYYFsSR1fyzYicNCWPqaPsN2wmurIK8FQrwksbS7ty7Ha6EgLynda1cXxJKsE3QuvROsqBCWdlJ1QrvtglhbBLEk65ckL6m62s22cKogL8m6KlmOUry6WV+SdZXOrXZL25a0X48JYkmOv3YJYknOKQwLYkk+K0jOPcL4HuaxFyO/iPff7BqAO+Y1gMVm+ASuASxm9MrthxXkUwlTzpgvlOVSxg+wlnm/8d5+HH4JyiMOj68hPr73Bq/g4gRTO7q3fymTH3wP9Kv39r86OjJvuGxoPTVTDuG/AQvpxxyj7SYRVC+OZ/TI1QuIG2f86Jh+KZPOUiYdruzp3rdOsPYJYu0QxBquy2Ed7FKsPYJYDwpi7RbE2iSItV8QS7INSZbjw4JYQ4JYhwSxhutyWJL1S7INSdrVY0H3DwhiSdposIXce1SC4w+Xe89JEL/xzsGyAF3g9OleHPDn/gMW9YO0YgRLOG+JoLwFPbstQ3yWoms/rGVtYnHvxpko06WOf75x+mbfBcwkzb4LmMmafRcwXYM6fyLSZ4To7mQjZZkPfZYKpB8jXE21qZMJH6of+jx0CsM1zvjRvXunMOmcwqQTZ/xov90J1sOCWEOCWHsFsfYIYu0UxNokiLVfEOuAIJak7ru1rh4SxBoWxJKsX5I2Z58g1rGg+wcEsYYFsQ52KZZk294tiDUshKWv6b7cbqmr3ToGkMSa6Lcn+m1b+o6Jfnui357ot5+Zuu/WuvqQIJakviRtjqTu7xPEkmxDkv32sCBWt45Xu7V+SY59hwWxJHV/LNiJw0JYEWf0/pxOsJYKYknNk+vrZUJY2tG9x53wmirIa6sQL+3qgljbhbD09QmOHNYzXff6mr470QnWAkGshUJY2knq6yQhXpJ1VTvJNtSt9b5b8/hMt4WSvLSb6Dvs7zu02yaEpa8l9zxI6UtfLxLktUWQl1Rfq51k/yipr27sO7R7TBBL8plvlyCW5JrOsCCW5PyE5P4c+n4b3hsW8f5z58XrdFZ4v93OXCVC0oN84Hs4/RjhKswnEaTXkxm9cufdC/IpRwg+5nMqox8oy9MZP8CCczLx+204/Kkojzg8vob4+N4fep/+HyeY2tH327iz0vE90G+/kl/3jswbLhtaT82UQzL0+22Qfswx2m4SQfWCa/9cvYC4XHnRfj9seXFYewSxDgpi7RDE2ieI9bAg1rAg1oEu5bVTEGuTINZhQazNgliPCWJJ6utBQSzJ9nhIEGtYEEvSFkqW4y5BLEmbI1knHhDEktT9UJfy2i+IJVknJMcmkv22ZDl2q/2SrF+S7XFYEEvSRktiSdav3YJYwx4WPK/g55uI93+AxIs4os966QhJD/KB7+H0Y4SrLJ/msx6n11MZvbbzfTHgCtfYD6cz3t/x0m6fINYOQaxhQayDXYq1RxDrQUGs3YJYmwSxpL6NpN2QIJZkezwkiCVZvyT1tVcQS7J+SbYhSbsqWSeGBbG6tW1LtkfJNvSwIJZkezwW6tcDgliSYwDoa6d7fni8jc8jwX44naAxP44P4QaZeBHv/wDhF3Ekx9iF0Od1QPoxRicmxvzLQ+oVdHcGwzXO+NG9K2cw6ZzBpBNn/Gjf1AnWw4JYQ4JYewWx9ghi7RTE2iSItV8Q64AglqTuu7WuHhLEGhbEkqxfkjZnnyDWsaD7BwSxhgWxDnYplmTb3i2INSyEpa/peR3dUle7dQwgidWt/bak7iXHAJI2WnI80a11daLfPnp92sSYvD2siTH50atfE+PCo1e/unFcqJ2kvrq1rj4kiCWpL0mbI6n7+wSxJNuQZN8xLIjVrc9D3Vq/JMe+w4JYkro/FuzEYSGsiDN6j1MnvO4V5LVUiJe+niqIJbk+JKmvRYK86kK8tNsuhKWvT3DksKTqhHb03eZu0L1k25Zuj1JtSF8vE8LSTrI9Hgv1i5431AnWAkGshUJY2knq6yQhXpK2UDtJG92t9b5b8/hM72sleWk3MTaxv+/QbpsQluR4QjspfelryTH5FkFeUn2tdpL9o6S+urHv0O4xQSzJOYVdgliS61bDgliS81+S+wvpeUNTkV/E+w/7fLGt0+ms8H67HblE6POGIP2YM7qvkuPT3Oc71xmt16mMXkF38xiuccaPPhvPY9KZx6QTZ/wO1OWw9gli7RDEGhbEOtilWHsEsR4UxNotiLVJEGu/IJZkG5Isx4cFsYYEsQ4JYg0LYknWL0lekuUoyUvSTkjWCclyfEAQS9Leg12FsRUdE6zwfrsduUwGxiZ4LANjqgGHH5vIpJ3IR0h6jsOP6yD9GOEqy6c5ruPKDeuHjuvmM1zjjB8tw/lMOvOZdOKMH22bnWDdL4glyWufEJa+nuTIYEnncZMg1gOCWAcFsXYLYknq65Ag1qOCWPsFsYYFsSR1v0cQa6cglmQeDwtibRbEgnk+OrbQboX3X3WHqXw2lcxnk8lK1S1WsrlaIZVzU6VMqlAuJdxUJpmv5Iop162mquW0W8kWMpVqsZBJ1UrFQs7s2CFTGHD4/lUGP5EA/AVm8JOAv9AMfgrwF5nBTwP+UjP4GcBfZgY/C/gnmMHPmT37IJEH/DPM4Dfa15lm8IuAf5YZ/Argn20Gvwr455jBrwG+awQ/6QJ+wgx+w34mzeA37GfKDH7DfqbN4DfsZ8YMfsN+Zs3gN+xnzgx+w37mzeA37GfBDH7Dfp5rBr9hP59lBr9hP88zg9+wn882g9+wn88xgp9q2M/nmsFv2M8VZvAb9vN8M/gN+/k8M/gN+3OBGfyG/bnQDH7DPlxkBr9hHy42g18C/EvM4JcB/1Iz+A37dpkZ/IZ9e74Z/IZ9u9wIfrphf64wg9+wP1eawW/Yn6vM4DfGb1ebwW+M364xg9+wny8wg9+wn9eawW+M315oBr9hn68zg9+wz9ebwW/Y5xvM4Dfs84vM4Dfs84vN4Dfs841m8Bv2+SYj+JnG+PMlZvAb9v+lZvAb9v9lZvAb9v9mM/gN+/9yM/gN+/8KM/gN+180g9+w/yUz+A37X3aaromdqpbUUkWmmM2XErVituaW0rl8qljL5SrFSiFdzWXcSqKcTZSTiVo+X8xkiuVMIZGoVQuZWr7BvcJid+Ka6wpVE3pJ1Bp2oYbwI2L88w38W4zgu412dasR/VQadvk2pmyT6Uq2VHRztVyxmK+pTjRZUf+yqtbUMsliIVUuqlpUKVWLpVS5kCxXkpVUNa9sTTVVyFarzT7rdul6k3Aber/DiN6b6wkrxfWeP/JXfxN0r7cJA86mvhOl1Ufytcr7Dd871e6OejPMncgfh39r7On/Or39XnqDKD8OSkc7yHeveL6P6LUQIek5Dr/HCdKPEa6yfJp7nHoJH6ofusepj+EaJ37a0TXvPiadPiYdDusxQaxNglj7BbGGBbEeFMTaKYi1RxBLMo+7BbG6tX4NCWIdEMQ6JIglWb8k9bVXEEuyfkm2oX2CWJJ1YlgQC/ZCDjij+0K5vjmbhr4WP3eAA7+qMzJf2K+Gwl9Ub4ajLkp+4zxNVvK5mU1cGo7yweOmKsL3GzNoB3rsR/6SYxzAHzCDnwLdT3ZG6pTmacBHV+DP/Qcs6gdpxZzRejcxPuTyhvnT9jIZ8cE68MOa3CbWAONnokz7A/KN0x8M4Mrlgz7fcPaIG39D+IEAXjj8dCZtiAs6jCE/QR0mg3SI2yKkPxXxrFRLG2+5YvUtDnFRogfQ23wS7op6Uw+0Dk72wXLI7/nkXhThYWf2mfHo9gOQp3b7AazbKvEbq93TjtoGqnPtdFn/kMwtRJk80TrkN7cQRf44/E8nNdP7iXc9BaU5NSDNQcIbh9fuivrI8NNQ3qJMmKmEI4T/pcdLl9/XvfLjdAd8Bkj8Z1Jdhjy1W5dxOVJugAl1h5atX7n0TG5y+cbMJmea3mBAPuB3mUkPuMdJWO2gjGeg+4JzXKG/wwbpxwhX4X6oMYaZQfhQ/YBt0Tqc4l2vXF2sXFBcs37jymoPUeV0dI3h4wQOwuCw2MURJccnHC127a6uj45HHaiyj3A+wat+2pxM9a4HHb56aTfgjM6zYBGVw1YZSD/mmDRTzSoznfCh+ukh+jFUhUsRZ3R1jTJpAl8oyxmMH2B5VmeE6cLhcT3G4fE1xMf3Fnr1Ke6MbnZX1kdy4Jokvgf61fV0NqmnuN7fVh/p18ekCX79AX6TA/zwkBXqAPjFULw7SLwpDKbmcOvkJp5fXcPlDd39dGd03fezRX5YFxMsHH8GwZrZAusqgoXjzyRYs1pgXUOwcPxZBGt2C6xVBAvHn02w5rTAWk2wcPw5BGtuC6w1BAvHp8fDzWuBtZZg4fj0c17zW2CtI1g4Pj0+dUELrPUEC8enR7otbIG1gWDh+PT41EUtsDYSLByfHum2uAXWXQQLx19MsI5rgXULwcLxIe4gg0X75+PR/aPRP0P6McLVVP98vDNar1g/dNlyCcM1zvhRu7WESWcJkw6HNUsQa7Yg1hxBrLmCWPMEseYLYi0QxFooiLVIEIvarVb99XX1p/8H9dcQD9ddHC6KwnB9NMbwGw9EnfDjgqsJZy5Nboy5sj7SD0/h0vEgnm6kY3I8FTuD+OExJrX7eJp2JvGbgvwgP3iM2Ufyc4d33+x0j+vi8vLTFX3u5f47TrjpQG5KN+i5dqzpYKyL6iPTGf8pF7caJh84fdNTLqCLWQG6mG0k7XTo6afZRBezDOkC6mKr5wK6xMON/Wcx4fF01S3VDWrR5HmbryveMgkFxWaI0hkk4WaQ3zN9aK0g4WaT3zC8oDwwFnaUR9B0GJc+Z0bguo+5rx332BQnaXLFxp3+FWfizw1IZ1aH6cxi0jF7yopr+BSU5qor96iK8wTpB51WF9YMQFrjdZocl7egcuZOkwvCCnsCGmCZPTmnWaZBp+jh9Ns9RQ+v3mE7N9kbS+lh0EMBU4e0WzKzmyeVDVsfIf3x2vkbducBN7SFuHHipx39agK3C6CfSYfD2ieI9ZAg1oOCWDsFsTYJYknmUbIcJfO4QxBLMo8PCGLtF8TaK4g1LIh1SBBrjyCWZJ2QbI+SbUiyTkjqa7cg1kFBLEnd7xLEktT9AUEsSX1J2sIhQSxJfXWrLZTUl6TNORbGTJJ1YlgQS0r3+pqe7N0t9V5S9/cJYknWe8k8StoJyTGApL4OC2KFeTuWe66H8NwbBdy81LHyRkGGhJN4oyBD7kUd/o0Cjf1D8rY6fRtBO7PzsalkhKRH8+iQ9GOEq3D5N+asuO1H3Lwn6G4hwzXO+NGvHnNbkxYy6cQZP9pvd4L1gCDWfkGsvYJYw4JYhwSx9ghiSdaJBwWxNgliSdYJSX3tFsSS1NcuQSxJfT0kiCVZV3cKYh0L5XhAEEtSX5L90JAglqS+urUfktSXpL2XrF+SNkeyPUrWiWFBLCnd62s6B9Mt9V5S9/cJYknWe8k8StqJbh1/HRbEgjkY7lUVukWee4ZdEJAOjr8gBBb3PAzhuVdbguZ6uFdbYO7B0CseyaDy4F6PGctcD+gtQcLRuR5s2xb5YDnkd4Lc85vrofuW7vUmskC/hvajsVuz6X5FvGeU7ovkXlfE92j9xfEhnNk8tn/aQJz41ZAf3aqPKxc+LYK6KPmN86vr61NtnESAy6Pqg9nHhI0QPwi7d6DJ44cej/EuezNzheNX9hfXm+Go48oe8qt1/uMOy57uf8W8uddx8Rw59gOu9B4tRxx/RkA6J3eYzslMOoNMvIjPf0iH3qPpcJyD5tvHmg7GAlthdu6+/fpP9YzrP92bi097pqea4ZOa8ToQdVzbAF3otpGa1cSl4cCZPdlt/HRIXxHDOsRtmzpOh6CLsDqc7rRu2zEmH1w/Qd9paLefwPGnB6Qz0GE6A0w63TYWmUX8cF2iryniujSH+OG6RNfFbkN+EeJ3O/LrJ3741HF6Ah4+MZzahjuRX7u2AY+ZbglRr8P0m9j+14jfZAbX7KtrqVSY/gWnHyNcZfk011u5V2q5ExtBd3MYrnHip92WejMc9Ysy93oCsPYIYh0UxNohiLVPEOthQaxhQawDXcprpyDWJkGsw4JYmwWxHhPEktTXg4JYku3xkCDWsCCWpC2ULMddgliS5ShpvyT1tV8Qa0gQS1Jfkm1Icjwhqa+9glgTdvXo2VUp3etrut7aLfVeUvf3CWJJ1nvJPEraid2CWN06Xr1HEAvGqxAPP+PjOWfD63LJo3nGBrfGTJ/pwZ/7D1jUj56xMcdM3gLP2AiqB3gNiq7Td3LGBj2XxfQZG3MD8o3THwzgyuVjtqBOwnz5gptbardsuTN3IK7hNtbYuzA7QE84/U7eU0mScLAe2eOMLru5PlgO+Z0k9/z2LkA9wme7wPqWnjO+OsZzxkdO4zNtZiB/HP4+9BXHa73r6c7o+gT54r76AEe2mf1yTPvz/H3Er8bkJ8JgcXPkkKd2v3CA32WiXzgATL8vHPQjfxz+5bEml28s5DEjCBO/00W/fgHrCP1OM984DOUA4cuIA3z9gmL2+uRrsg/mZlQXazEe02EwuXzFSL4ohwHCAcLfjvL1FNoghcPAb1xP7qyP5DaFScvxuYexcVzqF5Ruq7j6Gn/9gvrRukL1heP76ZTWFQi/PqCu9DMccH5puVIONEzMh8PdDAd8vF959ZrN3tcoHOLoR3X6yG9alLQI+hkcPwdq0HE2x3gcHA4crX54GXYyk8ZkH444rlYPFG+lurK6oeqjoB4C1ueTWI/DO+7zAWBLDX+NLPR7mPSrcP1m+AR+FY57X5k7whbixhk/ur4fNp2pDmrPG1av86sLuFJydSHqk36Eie+QuBHmnuOMfKeXG7vQPLf7hcoBJj9cOvEO04mHTGdWh+nMYtKhWNw4UrtqvemPwz+M7Ou3F/KYPT6Y8JkLCM+N7bk9JxCem5uYzeSRe79+jtM6baxL2h/NbZNrq7mB2YQr94wZluvF48y1r02uA0zauE9Wnc5td1XXXbV6Q+MUZoeh4ZBr2h/TMLSbmexDdSoJR4dhdNqGmrqZ5PcUhh/nOFNHuUSd1o5uSX4TaqLf82mijsM3Uaj29LEUx8WPpVAl7mbCQZqbSH5weJwmhN+M0uGGfneTfEP4dzFDvzjDCfgMkPiyXXyuCDq8xxntwO9eZ2Tesd8WFP7CejMcddxjLORJ6+LJNh5jcTlSboCJuwxctn7l8jH8GEs+1IfT2+T45wN+R5n0qC7BXzso4y0EY4X32+3IZYoRkp7j8MNKSD/mjNatiWHlFsKH6oczwwEf6rsHXWP4GwkchMFhsbsRUXJ8wnHFPo+JRx2oso9w/jKabfgzYrZw06ffF8Ucosw9OtrqZfhz6fR3mE4/kw7dHaod/aDbKmd0XsFvNYpHP762BvnRD7qtdUbnC/zWBWCuD8DcEOC3McDvLsZPc7pgapMjNcdc06AficNl59cO/LAuJlg4/haCtbUFFv1IHI6/lWBta4FFPxKH428jWNtbYNGPxOH42wlWvQUW/Ugcjl8nWEMtsOhH4nD8IYK1owXWWoKF4+8gWDtbYNGPxOH4OwnWcAss+pE4HH+YYO1qgbWBYOH4uwjW7hZY9CNxOP5ugnVfCyz6kTgc/z6CtacF1i0EC8ffQ7Dub4F1HcHC8e8nWHtbYNEPKuH4ewnWAwFY+pq+XYLjP0CwHmyBtYBg4fgQd5DBinj/Yfi1D92XG+4kQu/2h/RjhKssn+bwa58zWq9YP3RWbz/DNc744b4I++F09jPpcFj3CGJtEcTaKoi1TRBruyBWXRBrSBBrhyDWTkGsYUGsXYJYuwWx7hPE2iOIdb8g1l5BLNqXBY3r9TUs8gaN6yEetmd0eihK4uDwGMPvuSGKOG9pwXkR4TzW5wd9vZRgjfX5QV8vI1hjfX7Q1ycQrLE+P+jr5QRrrM8P+voMgoXjU5u7owXWmQQLx2/3+eHu+kisTp4fXkKwxvr8oK/PckZijfX5QV+fTbDG+vygr88hWGN9ftDXLsEa6/ODvk4QrLE+P+jrJMHq5PkhRbCCnh/2tcBKEywcfx/B2t8CK0OwcPz9BOtAC6wswcLxDxCsgy2wcgQLxz9IsA61wMoTLBz/EMF6qAVWgWDh+A8RrIdbYJ1LsHD8hwnWIwFY2l1aH4mF4z9CsB5tgXUBwcLxHyVYh53gPD7LGYmF4x8mWI+1wDqPYOH4jxGsx1tgPZtg4fiPE6xXtsB6DsHC8V9JsF7VAuu5BAvHfxXBenULrBUEC8d/NcF6TQus8wkWjv8agvXaACztbqiPxMLxX0uwXtcC6xKCheO/jmC93gnO4/OckVg4/usJ1hMtsC4gWDj+EwTrDQFY2tXqI7Fw/DcQrDe24HUh4YXjv5FgvakF1kUEC8d/E8F6cwusiwkWjv9mgvWWFliXECwc/y0E660tsC4lWDj+WwnW21pgXUawcPy3Eay3t8B6PsHC8d9OsN4RgKVdtT4SC8d/B8F6ZwtelxNeOP47Cda7WmBdQbBw/HcRrHe3wLqSYOH47yZY72mBdRXBwvHfQ7De2wLraoKF47+XYL2vBdY1BAvHfx/Ben8LrBcQLBz//QTrAy2wriVYOP4HCNYHW2C9kGDh+B8kWB9qgXUdwcLxP0SwPtwC63qCheN/mGB9pAXWDQQLx/8IwfpoC6wXESwc/6ME62MtsF5MsHD8jxGsj7fAupFg4fgfJ1ifaIF1E8HC8T9BsJ5sgfUSgoXjP0mwPtkC66UEC8f/JMH6VAuslxEsHP9TBOtPWmDdTLBwfIg7yGBFvP+w/vRpdF9uvSediJD0IB/4Hk4/RrjK8mmuP33aGa1XrB+6/vQZhmuc8aNzjp9h0vkMkw6HtVUQa5sg1nZBrLog1pAg1g5BrJ2CWMOCWLsEsXYLYt0niLVHEOt+Qay9glgPCGLtE8TaL4h1QBDroCDWIUGshwSxHhbEekQQ61FBrMOCWI8JYj0uiPVKQaxXCWK9WhDrNYJYrxXEep0g1usFsZ4QxHqDINYbBbHeJIj1ZkGstwhivVUQ622CWG8XxHqHINY7BbHeJYj1bkGs9whivVcQ632CWO8XxPqAINYHBbE+JIj1YUGsjwhifVQQ62OCWB8XxPqEINaTglifFMSic46t9sm93LsO2icH8fC8E33FMEri4PAYw28fXhRxbrUf7xWEcyf78YoEq5P9eCWChePXCdZQC6x5BAvHh7jce3Ar6yP9VqF49B2G1ciPvlu3BvndQ/zwe3B0Xnod8ttC/NYjv63EbwPy20b8NiK/7cTvLuRX967xe3DwfiTo6GLv/gDJG9TBFd5vt0PHfS2N6hGXW8Tnv+OMnmPXjtoA/KWMCEnnHsF0MNaF9af/Qx3F9ZceP3AvSYfeo+ng+Pf6YMGr2drBO5e4XveR8Nd6Za+xf0COCuD2Jq9C964IyCvEhTpF7doK77fbmUsA/nYz+Kkg+4vzRNsg1l079QunFXMctl9ZIaS7oLxh/rQe4v4gzL7xbW1iDTB+Jsp0a0C+OZvLceXy4dc2cTpBp3NuD+CFwwf1z6DDOvIT1GEySIdcHz+W0zlBb4tIOPplUW6sQ7Ec8nsRuRd1+NM5Ods24MMT0m1lx3F8CBd0hEUYu8Glw3GGdPD5Avi00TXkXXmod/jID/xey3zkj8Pvn9nEXO9hcu/d+LWVCEoPn01Aj4qB9PyOilntw28T6vfoSYWrmTzPD+AMmPj8B8wZzmGgHLaScZehPpIdd0Fa0wlfWj40L1yZ0Hq3mdGDn261w+MUPI7B4Xe2OU7B9ZuOUzAniMs961E9cOkE9ZObQ6YT6zCdGJNOp+MQLh2OM32m0g7bk4PEnkC9w20Lx4X34PtI+C3InjwcYE/o/hQ6dqI2ltoTSM/PntD6CeEfD7An3Nj86ro/Z8DE9gRzpvYEwr+W2BND4yfWnkBaXH85xeH14Tjh+sspjB5M95dTSDpbBdPBWNBWuLEctT/tjq1xfDqW9Wuv75rKp8m1V1x3+0j4C1F7fS9pr7i+g865ekP7qK1MurTNOM7o5zPtgmzZVh+ssH0UhP9oQB8V9KyhXdCzdNCcIw6HwwTN/0UD0sD1Ft+HsTHuO1eTsNtI2K0BYf2eG/U1nPpu9tk+70JbqDujHfgNMZzBbwcKf329GY66KPmN83Tkq/ELm7g0HOWD9TTkg8nZC3p6OPzsYXC3E1xsA6i+4Jwt2v6/6rUF3f4/P5XHo/VEuxd7eGafX/MJWr7Y0fKl+qGOK9+6d63Ld9GiJi4NR9PEZbiD+GGbTc92w7YeMLTunyJjgm5rS2NpL+3ok2svnD7pGgHXd2J99hGM6GAzzLdIfYcwtL/QDtoPtFnv54ixH1futC1+D/U9tyzi0w9qb47D2wWsB3om45DDc+Hy3Ghnnp6gPuI2Jlcf0432vZNwxmkPG0o7QtJzHH6edxiphPIB3jHGr7cDrplELpfMpiuZWimbz2SqEYIPXOk9OkfJnQUxnQkPut5tRNepCtiAaL2JvwvpVbte5DdM/PqQH3DUbej2RSP57zLEP4z+cfpxJvzF9Wa4dsoyzqRDnzk6wdo6RqyZzsg2wPWFeGxD+0I8fsHngC5BHQZnF4NsnQczyu7jfFI7uJjYuiEUR7AOpbnxKLV1Ow2lHdbWQfqDjn/Zxhi/TmxdJZNOpGuFTKlSS1UruVrEGd0nRJl71NZx9XYaE96wrXA5W0ftWS/y20n8sK0DjpytM9Mvptww+sfpx5nw1NaFLcs4kw61dZ1gbR0jFtg6PA4a8q45W0fHqduZ/GBbR5/LTiA2yczR9/wcIbWpmK92+Bl6O9IT1S/FwffwuBnHoXM2EH45GrefOsjzgzxcyfDj9hThfJ056B9uOxNOD+NhHHVLdcMLby2uq1ZeWC2vq26IOjw9mkWaffo45ZBw2vWSexvIbzp9s4rgQBcc9stX8B9jcUWHsWnXC/ZQm7CNxIStJmmtgDgdOu7RkXa1ZpbxkqEfKyD9mDO6ypnYPsJNbWL90O7RzLJE0tUfvqRT39rdWh+tG8oD6gt3HH7E5z/kl96j3QSui7TeBJlAP5N1JTJZzxlshqc2IMyWrTBL8fgeDl8jfnjpLBKAT6dBLkTt+CkyFYqHOpCPxkcnkZ9kO9M8NqEpJlqf8DDKr/5zn2+A8EFbybSDpYagrUVc3cJ1CeoIV84Qh1sOHyRc2136H2TSMd2mBkl+cD2mQ7x2lx65+ttqCe1Gnzbpt4TmIn8cPoOW0F5KyhPHx3o+kq9602+c2kyy3TbDlUNQm2m1ZR90yC2xvqg+0o9rM5xead1ZxXDg+jmu7kC4MOMHzE+ujBKhxw+Q/niNH1aH1Cvo514z+nHD2AjOrnHLnNTW47bPPZZwy3C4n6CPcXd5jT1oS0FQ2+GWxo9s/yOPK6bHQUHtYazpYCz4bAt8/Q2eJepoDLVt0D8+fKqlH8XhtiPQ/OA6hPuGnaRvwMskQcvy9NnndzOamLvH2Neb3ObXyr7TT+Dg+H7j0CkML319h3cNZQxTJIdQGR/weQzXDpfPI6R8sC3kygfS5h7vIS7GpRwfRxwPB7Q9zPFVPuH09UpndDhqixyHH4fQMsTTE1x4ui0Awr8u5Hge6oPZsUmCHc/j8qdjk7D9EdUTDo8xwAbFSXiqQ+2gXnwE1Yu3kfbN2dGxtmG/caSf7Tc8bVgIO0aB9GOOyTFTc4zCfaIvqE5sY/hX6v7hW9UhCK/NPrXzcYQF6eJXxbaTe7SPChrTaIdtz8cHeQycP25cBMfTY4wwtr/d+szlqRvaTZh6zaUTNGbaLJgObs/0NSxDr9alQfd1xJMbI9NtbUMoD1GCwYWn840Uf4iEh/i9Dr/NFtoD7fd+i2z250nfWw/Io3bwOcYIwynKhKFbOmH5qN+H8zWEM4T/Iuqr6bZ17tmljjDpVn0I/xWEST8Qj5eow9jRnUx4vFRW96657dM7STy8XEfLnMOmS+Yczg6CQ/PZg+7FGWxuyVjLCu+326EDPFhS7UVp7GL49JHw/0Hq8X1Ep0E607KbSRcffxgn6e4m6eo6tH/RSEzghp8HcLnTMqHjVMrzFuIP4b+P2vN3Sb+H+2vcP/7IZ8yNnx+GA7juZLjiNrOpPtIfwv830tehRTxXzAdzPXrzhvzYfMS8R32kfjj7wb0C0a794Jb0txM/3BdT+8vNDQb1MbgcuPB0+ySE/w3zbBU036jxfxswb0HnADajPAT1U62Wvf84yOP6vfZ1S31kfiH8j9A8R880Pm3tcBvsndZe2hf7pP0WlPYkDzNojkVy/MeVFd5SQcslaF4vzsSnrzKYeL0Jp8n1z3Ss3+7rTTi+36v64K+d4fFs6GdXSD/G6MTEsyv3bBm01lJnwt8bEH6ICc+VG352xbbVIeniZ9chci/IFreyC8e3aRfw3DEOvxnZhWXELmBe9PU1bDNmOTwXxwkuozgTnx5TZOq5cBbJz70B+Wl3nRXHH69XPGeRdPzqjUvqzVhfYb4J1ZtUQL2ha5LcGjRXBmHm4IPKYHXIdLZ0mE7Y1z+fyXXqAqE6dSmqUxeTOsWtMz5T9bxNMB1urof2W1S/2A/SofeCxkl+20kxB13G10/j0wxbbyC8i+rNi0PUG64M/I5AwumO156c8bKHQVjc2BvCc2PboDFY2PUA7rVLqNtmXzsJv58E0o8RrrJ8muNdbo6gzuhuqtOc+yhW1yeS+Qur5XWb12yghQGAcWekkocIIIR3yG8aT5PqJWHuZdLQDp8TgitSnMSnA2qKH4ZTq7Ct/LlGWHf4fDpOuEaI47d75uEQ8sfh13gGL+w5DXV0r51zGrb6cI8yeYj5xKO6586muCIgzxD+7oA8b2uR54tJnv3OW8O/abgok4fJDr+pIugsmdnOSO7t1iccf7wGK7NJOn6d+07Subc6e+VW5I/DH4c3B5HOnRt8m86/35lMOF+3ojB+Z4P0Mpja0RdEIPwBL++GJ37Yd52C3g/CG+UPTWutm6Ayb5wrhsr8kRBlHtR+uLPGgmyF1QOZRNUNU8dx+tYPZL4ZGankIQII4R3ym8YLGsjQsH6NutOBDMfJL2y7Axn8BFAnYdvdMYLjQzizu6mSo3Y041WdIZSm30GHeIdF0BMc3X1F8WkHgF/W5HRHd1hA+LejQcwji56+5spqjg8/xwlXVjj+eO3umUPSMTGLqx2d0RjvwbpfHXS961aDpI+12WHihwQc/jPxJuaTpMMMu4sszEwtrfOOE26GP6i9hW0/VEe9DKZ2dAAF4b9KBlBm3mzNuEdv1S4TuvOnAzpuV0WM8evosJ5cLeFms7lULVnMVzNZ2kcCV3ovzIrecUx4szNGafawnjrSq3a9yG878etDfsCRO8Ciboh/GP3j9ONMeHrgbLuzxhJYcOgE97B+tGxZ2A9XQPh/C5jQ4A5Qxv1W0FvQW0g87kBo7ahN1G6F979VTaq1cJAelM8khgt9MwjCfhvp5bFFI/Pit/On1ye/OG8Og+GnO5oGd4jHbc5IbttCcOMmnjDGZh+eGmO8dqBw6SzuMJ3FTDomV75wmq3GY79oc0XqrnrTH4d/DxqP/ZqMx7i3jiA9bmIVj4WojaQ772gYam8g/O9Ru2r1wQCcz6B6FvaDAY0DU6c//f9oTmjRPPc6zd292D5eVh+ZBwj/RS8PWv9909vDfL4PZhJhTm4T83IfzBMR5hTvmquPc52R6bX7ljiOj3fdYi7C5dv4aNJaM/iND+ysYXSB8wTpd/oWME5rvN5a5/IWVM7443F0ZZrDWtMm1gDjZ6JMVwfkG6c/GMCVywcdV3DpzGV0AuHXBfDC4aEN47oPcUGH+KN8gjpMBpU3/kggpD+WjyaB3uaRcPSjSVj3a32wHPJ7HrkXdfiPJh05gcbrz7l5k6k+nIEDvUfrP45P678Zm5mrcDulwdGxGOVIXZT8xrx1eb91ZhOXhsMYtB77fYCUs7l+GNxcbqt2rx1ejIAFz/UbVq+rXrPutruKG6oX3VVdtYGpv5NJ/mi9oyfRrSVh8fwsDkcXM9eQ3xvJ77sYPtRRnWA3yITzc63ax6noeiztA8cPmr9c0mE6S5h0grBOZbCC7PcSJvyxYr9PJOHgmasT+30iuednv7m6YuKNaYqFn59g0wluy3SM/iLyPGRm7FNIgX3HthN0BmmvM5R2hKQH+sb3cPqDDB/gHWP8OpmfTuZTiUReLaFX3bRbrLhBbRnfo21/PRP+dCY86HqjGV2zByyvR3rVrhf5rSN+fcgPOHLz02bsUyGU/nH6cSY8nS8JW5Yc1sVjxIL5aWzjoW2Pl20ya1PaH0/S0x/wfAzdyFVHWHgunTpuHAr5PfKGaYhxKHcKEZ0LXcPkI6gvDXr25Z41zc5njF9Z4bZHHVdWkN92ywqXB/A2a5vGT4fY5lDH6RDyq3X44zZ0iOsanZPHtpZ+kLlb9Bshfnid8KJ6Mxx1rXT4uTZ0yM3rR53RelrFYNHntzLDB/J5lzOSPy4/7eh6II5/F8Ha3AKLbpbG8cO8+YKxriJYQWuyW1tgXUOwuI3rgLWtBdYqguV3qjatVxzWaoLFfYgOsOotsNYQLG5NHrCGWmCtJVg4/hDB2tECi552iOPvIFg7W2CtJ1hBp68Mt8DaQLBw/GGfeNi+aTfI3IO2bvaDIom2P7TFPf+YWBvg9M6Nc0F3uxiuccYP99vYD6ezi0mHw1otiLVFEGu9INZdglibBbHuFcTaKoi1TRBruyBWXRBrSBBrhyDWTkGstYJYGwgW92zN2bapTnMN5Mg6wAXFNes3rqw6xOHxJKSBf2/0ST/OxHcCsHCcoLxwX8uA8GB//U7EpXtHIPxfefOU+NSmoPjahTmF1dBabzJsv0rX3E3tV6D6x/oLepmImz+KM350TmJVyHQk6rh2F9X59CNMfKcFFvzm1phwWzqeYGwkfOk9aiNwfAjHpbOkw3SWMOkEYR3PYEF47hkpaI0p6FRUQ6c2NdaYuGdW7jlrLGtMoLdFJBxdY+KeXSmWQ34vIvdarTHhMl3rwxPSbVVXcPygOrmqw3RWMelQLL8XtOlaFoT/NVnLwrqXq1/5VND7RWbf88iHXsvyO50O844xfp2sZdXySbecqlXdTKpUKruVIJvR7kkfJzLhx+OD7Ec41Jv4eJ5Su17kt5X49SE/fII4XcsyYwfzbhj94/TjTHg6fmv3xEQJLFjLwn0JtO3xsk1mbUr3rmXhPT3trI/g8qBrWXcx+Qjqs/G9oLK6KyCdkztM52QmnUEmXsTnP6RD79F0OM7ccwx+f2B6vBkHtxP8/gCOu7He9MfhX43eH5gZsLeKzgnRNoHroHa03eNTbsP07xB+nseJe3+AewdqY92fM6QR9n1OCL/Y42C2n+ffHwh6v4zORbb7fhn3Tq7ZPOaq3Ps34Di7Rve615Ef3bszhPzWEz8850Sfd3civwjxw3PwG4kfN5cLfruR32rih09yx3WUOs4240OAbpnVxKXhHJImrjf0nVzuXXZuv+Ap6Br7AVd6j9Y3HH+tTzxqRwzvTUwYbtON/f/cu5U4T3Tszq0LhelfcFrjtW7D5S1orxNe96DrFhzWljaxBhg/E2W6PiDfnE3guHL5oM/zXDs7hdEJhN8awAuHn86kPd7zNZwOpeZrQG9nkHD0nQ5cB7f4YDnk9xnknt98Tav3QC+L85zDnssB4XegcdwV6JrOZWKsO52Rfnciv3u8a8P7+QrcvArV3T0obb8vRlL+1LXas/fkGPfsYW4YE5ffJhTGb63jJjTO/cZCHjPi8GN7OtaGOhH2XV0If3PAWBvC9Prka40P5gZUF4s+dd1hMLl8rSP5ohzWEg4QvoryBetIjuOw/eyd6Ped9ZHc1jNpOT73aF+w3scvKN1WcfX13eia6+tpfd1EwsM6pZ9OaV2B8KsC6gr3LlTQXmnKgYZZ58NhHcNB9xNTPP/y6jWbfZaWetE1Nc9cUdIiWM3g+DlQg84eNAeKA7+Dqh+3LOf43KPFAHHxmXeV6srqBr+1tx4CtsonsR6HdxPrsA035nXYdQzXOONHx4th0xnrOiytC3f6pB9h4jskboS5p51uLHsnPX3NPYvSuY92n0W5xkGx/M7iqNab/jj8HmSP6Bf81iIeHCbsWYXw3Lg46MDQVs+XkD7okntOCUqb2/cL4be2yZVb68Fj/vWEK+a3rU2uF48z17VtcvVrl9CHKSN9213VdVet3lDFTYXScMj1ALlHw9Bt4Ot8qE4l4ei0Nz26iPabtE/awPDjHGcaKJeo09rR87wfR030ez5N1HGCtzVx2/DxkPsy8sjFLWEFVcegoT13tjXGoMcEQfgnAkzT9hb5pk2izoTnPvDBbU2HuNwy6/h82NytcB9PxDroq4fPL6efISZ8HYWhx3kMIT+6LIvrC522xV0YPht7Oql/3JGLQXkL2soHXPuYvGl3S73pj8N/MKD+7WA4cMelQvidTHg8vV/3rrnXBiAuV//wK0fa9SI/wfpX5eof1gGtf0H55fTDbaPHSxxQvnESHusK/LgPxHL2r+5d46PNuOXtiM9/4ErvBW0tuLI+Mh1THzOCZUFqL7mhnL52nZHhd6J0OXtJw4Oe8VQLV359JPznUBvbT+oX7qfx9OPfxfm0cfvewnClaf8nmub5B2J/uOEbPTL3y4j7qxb5x6d9Cx4D0SM7/I5GxPrH+cRlTu0YhP8XxPO1SMfaYVuCp9G160V+grak1m5fxtnaoL6sla2l/RWup37fr8BYWOd+jxXcx9kxHh3jfZuZ7uMe++iHije3yT3s2HALysfHyBGNXL8VVFac3Y8z8XeEwNoekN+diDMXHtsJHP7HjO4pZh+THzq2wOF/hjB/0CbmrT6YvwgYj3D9Zx3do22Ee02E+1g597rgLuKHudN+cxilT8PeTtLnXm90mHSdAL60z23Fl9p28Js64+n/ui453vUAwRO2i6mgsjyNyU/Ysmx8N4bJP8WCeL3O6PrKtaFhRl+TZvCYfW1ixjwc3L9yY52V9WbaU0nanA3BdpHawC0MLzzm4Pppv88OzET8ob0GbdU12u8mqi7X72Jd0H6Xe8YO+l5QnQmP7S8dw+Pwt9dH+oX5phROZyz92iHSrwUdFx0036Cv55Pwde83tvFYF1Xkj8OfwNQZwBxiOASVB1f3h1AY4MO99o6fm47Erzf9jmZ9DRoncvrZ3oF+aH3lxj1cfaWvw3LTsWHrKz7Ceiepr9xWaq4s6fwJp6c6k2+qp36f8IBH+9Asqst+4yrMIehVi7DzA1wfN+zwaeO2iXVCP6QL4c8Lac/HZ04mkeDaB9YrbR9BOtSu3TEi6CzodWmufewkftxcaxi7q11Q24G4+GPK3DN4mE8DBM0vBj2Xc7Yewl8ZYOvrDIcgW9+qTdNXG7DtgLhHb06Ar8v1ZpZC2fp6gH46sfX0mZvbetzKdl8QUP/85nkw19UBeasz4blxV7trG0ez7MdzbYOWPa4XtO/k1r4428DNz9Dx1ljHm9rRb0V7P33Hm3QOFMKvbHO8GVQPrR5vjqEecvo5muNNzgbh+Ug3xKfvgupf0PpWnQnfrg2KMrxwX8y9RqvdCu+/26ELWpMx+7kxNxMh6YE+8D2cfozRoyCfRFC5cp8vMvs5OTetzRSt+9rdWh+tGz+7EyHxYS1Mu2sQDt2uzX1SU7en+8lcEzcOxHEhDToOPIDmzh4kmNzrcWHHv/j1xeMDnh3psVJ1Js2gz7oNoXS48IBH19cfCXg+5GwlV+8gPPc8uYPhHLS+TtPm9gtwfSmEf1VXPR8mE0d7zb7uXYdZs8d1kK4DcX0Rbhe0DXBjLq694k/WcW2LHqPJrdsCFn1m1A7WY2m7DGMr4EhKaive1eYz4wx0r91xMW0z3DNjUNpcGQXZDFxugDdqT06AzRhCcbhnQqpTCP+RAJ1ydihIp63sUN27DmOH6gwW1indJsrN0wXpFMJ/KoQdDqtTCP+ZAJ1yOgrSaVg7E2bur85gYZ3SLc3cmnKQTiH8XwfolDv2oI44UJ1C+L89ijrFeabHxdaRHz3ihtq7mE+8eADmkA8m3Mfxgo4B5sqSs2m0LL8SUJZcvoZC5muHUL52tJkvCP81Q/na7JOvzW3ma6hFvjaTfEH4b4bIl98eKjr3D+G/FXJsd6zMmdE9VLhubCZ+3P6loDoxluebXvJ8E3TkCP6cctDcGt2j9dOQdWB89oTzdQDPT9I6EPRaiHa0DnDjbu5opzgTHp6TuTrg91lpnM5Y6sAfB0eGM7W3Fh9NhfONnyPwHMU1JPwQSpdrizS893PE3lrc3uj+k0Z47/VSbm+t36v9/TP5tP3aCp3TgPALZjYxB7xr7nV+uv81aN8/9x4J1jNttxB+GtJDULvFn+TVrhf5mW63uH6Fsd1BcyFDTPg6CgM642w3tc/c8bjckVlcO6efSsFzQoB7ZF/DYGv+3FwyhB/r+Oc4VC/CPPdgPSV8ME9A9X7pzJH5rztNB/uddLjlM2XSPpmp54DJPR8EvULY6vkA+AQ9c9F807JaTuwCziNt+xAv7HgU+9XRNR6Pwn0cj9vbS3XY7wQ/29PnhwRTz8Lsfagz/ML2i3XEtZ/oOWjdhxsjBNWTsGMEbg4Nr1sdiV9v+gFHw3OkyXZtcVB+Of3UmfBh9kRSXWGdYKygtecgW8wdz6Pryo1eYXBrtJtD5A3fo2OooHkT4HcZait03zzX/weN2yH8FQF2sc7kIai+Dzn+eebqO24LQwHxuHVOnNYK77/r1jpykB7YrUkMF7/+8jqkx8cW8Vwjo/h25ri+M0L0ROdRZNJOuhGSnuOMflagfRPX36wQ4dNck+XmpOvoHl2T3WmET6KG12Rx/cVrstw7Hbi+cHMX+HnkZjI24mwAtqfnIH8cvoLGZUUfTMdpv5/Fe7zeNXUkbpCt0K7T/TPce67cWIruDebe16FjHL93k6rIH4dfiWxD0DuGwMvs3vHaUd8bS/e/4r2xfs+1GAvXhTBrZ0HvNEH4uwPGoUH7c7e2yX07w522c9p2biZjVJzmlhBpdrI/dz7yx+GHxnHcMLE/d3R4bMPa2Z+L60vdGcnZz3Yf9Gw39/52mM9vBq11B51/oq8XIH8c/uGA+tct55+AngzXv+TRXu+gaxq4btK1kKC9mdxnhnT9W+PVP5N6zOXdxpgWyhAfQ49dL/LH4d/i1ckYygf87+2AZy1XTNRSxVoxU6xU0uUiPVZeOygzfcyUrg9PzGzqDPQkrTPtAL/PDH7jvd9elNcokydIH+pSDwof8fnvOPwzC6QVI1jCeUsE5Q3zp3MFvYQPXPth9baJNeDjt0Im340yjQbkm6bvF55rA3C/PwAfhwe7jutwP9HFJDO6SAaVWz9KE9Ify7HZ8HsxCUc/c4b13eeD5ZDfi8m9qMMfm03t0qAzOt8Qx7BNCX2cKKQfc4y2h4Yd6CN8/NouPk5w5epixTvlk5o8WnRYnRiOZpsWXaNbJPdodegh8WCox3WhlGeEweBUQL9QH2HS50xJ1Cddx2lWV2o+WmHBdTSAix9GhGAMBmBMNJ2JpsO4iaYTrulIj8aT+Xy2kCy56VylXKukU61G49Lpl0vZUrpaKmcT6Wwq7VbaeRqgow381B1l9NdHwn8nYAWqJwBTO3qSKYT/fsCTPDcq4vIZxgxgPtOd0fWKPkGMV33KFfOlQrmQLqazbtnNZdspT27kGgmhkz4GO87E7wuBhct4Q31keBjB9jvBT219JPyvAnaf9KM4gHVXvTVnXA/wkwH9SByE/y3i8ASZXcF6oF0vHrULdnXlCEnPcfiuF9KPOUaHAglaHsDHr34ZfpIqRQg+5jOJ0Q+U5WTGD7BgxgnbNBx+EsojDo+vIT6+N+B96C1OMLWDU1AjjF+UuQf6PdLGZo3MGy6biM9/wKX3qF3AuqG2EttpvEI5bdbIvOD2zo1RwH7QtnjcrCbmDO+aG8fQ8qO2n9p8v3Gen72i/SKEn+tx4j6eQvtFnE/KEafXy6SrHbVXEH6Rx8HwIwD7UUu/2TecP913Bc20BLXfoBkvaAv9PuEBr4+EPwGVGe1jJqM4UYYXHctA+JMRJh3LDDD54tob3I8x4QeYfE13RtsliMutSoDuDZ9kW+ZWJbAO++qt9TOpA/1AHYiT8FhXnG2bRNJp9WhJV3G5WTRsC7nxGx0z4PS5/hXfo3Yax4dwXDpUn5MC0uHsFNfuOD3SNnJeQLvjxnb4A8CTfDiEHdtB+BWIw5sCxna4L3verGCu1K7hZywc/jLUl11E+jJa9tpx4/Io8cNlCTrC9rafweXsBq0TXJvE4elYG9pYv094PJ7C4a9m6sR0Z3S7jfqkh/nhe0FtI+aDxZWndnRsAuGvD7D5Uxh+UYYfhJ/KhJ+CwgAfTjdTHT5tnB9cnvQD4hD+JUx+uH4Er5Bo14v8BPsR9useWK+0HwnSoXZU54NMeKxLyF+chMf659roFOKH051MOLR6hqJ9DDd+wjaKmy7GOgCeA0x+5cqunIiQ9CB/+B5OP+aMrvMmnlnD1hHQz6AZ/bhBdXCQ0Q/wmWaEj5uCuhJn0gau8OY8tis4/CDSIQ6PryE+vreFPLtOR/EAP078tKPPy9gvytzrOUpYcQYL6w3KVLfjtUQX9EtZ3H/ApfcoR1yeUOeDbMRY08FYMI7i2pOWFd5vtyOXSkI+pjH5gLRxvZJrO5lcWFsH6ccco205EVSHsX6g3Li2D3Hjzug6fG+9Ga5V/cbpcFiHuhRrWBDrAUGs/YJYkvraI4j1oCDWbkGsTYJYknncJ4glyWuHINawIJZkOe4UxJJsQwcFsSTLUbKuPiyINSyIdUAQ61FBLMl63602RzKPhwWxNgtiPSaIJakvybGJZP3q1nGhZL3v1rHckCDWXkGsY2Es1631XnJsMtGntYfVrWO5brWFkmM5SVsoWY6S+urW8dc9gljdOv7aJYgl2bYl25CkviT7Ick21K26l7RfkvNyw4JY3Vq/JMe+3TrG7Ma+Q1/TNSuJvmO6Dza+Dlob5tKJMJy5NeUehDHgjM6v5Loy4M80hA/5nsHoCucJ0qdrzODP/Qcs6gdpxQiWcN4SQXkLWovG6+5YB35YM9rEGmD8TJRpPCDfOP3BAK5cPgYFddIniEX36nHtn1u/hfAzmfBcPZnOpA1xoWxnIT/Bsk0GlS22EZD+WN56B73dQMLBVyx6nNFtY4YPlkN+30DuRREeduNl3+lv2FuD9/TCfhRuD5GWFd5vtyOXTQbZVrP9TDYVIemBTh2iN0h/vGx3kA3Tju7BCGPDtNtab4brxO5o94gg1n5BrGFBrB2CWIcEsYYFsXYKYm0SxJKsE0OCWJJ14n5BrGFBrG6tEw8KYu0TxOrWti2pe0l97RLEkszjXkGsYUEsyXq/WxBLst7fJ4glWScOC2INC2JNjL+eGTZasq+tC2IdC7bwMUEsKZujr+mzdie8HqrLYUm2IUkbLdmndeu4sFv7tG59tpLUvWQbktSXpI2e6Dvs7zu02yWIJWkLDwhiTcwpHL02JKl7yTw+KojVrc9DkrrfI4jVrfOFkuOcCTtx9MYTE3bi6Om+W+1EmPEXPveQnmfMreMD1swWWBcTLBx/JsGa1QLrKoLF7WeAeLN90sFna+A9GLOZtDl8wOD2cWhZ4f12O3K54gCTDzn8ZAXWw+egfEe8/5D2XHRfbu0+Hfq8VUg/RrjK8mnuJZhL+FD90L0E8xiuceKn3fZ6Mxz1izL3egKw9gliHRLEGhbE2iSIdZ8g1pAg1kFBLEl9SeZRihdnZ7ulrh4QxJJs25J14kFBrAn7NWG/TOZRUvc7BLEk6/1DgliSbbtb26Okje7WvlayHHcKYh0L/dCxkEdJXpJ2dVgQS3K8Sp/bu6V+DQtiPSKItUcQS3Js0q192kR7PHp57NZ++1h4TpO00XTv2DOx3u8XxOrWuY6HBbGGBbGgPdL3ArVb4f13O3KpNMxF47WTiDMyXTwWEZw3r0ZIeqAjfA+nHyNchfk05vG5tRysnx6iHzPrHG4lQvAxn7mMfrh1BTqOnO/9xutYOPxclEccHl9DfHzvK95Ch6Sd1O9b/72H20YbSJZriVSmmsu42WI6U8mmkpVkzq2kM7VEIp9IFtL5VKpWTucr+WSqlswly4PO6HKnbcBQGafDtgG6lmWoTQauZc1myqjdtaw7681w3dT/wveIwpxTb6YupEpjrQumz6nn6kLQOfVh68K2ejNcp+UnOaaWfJbcK4g1LIjVrXN0kmP9bp2j69Z1gQcEsSSfGyTXK46FNb9uXIPXbmId+OjpfmId+OjpfpcglmS979Z1zQk7cfR0L5nHRwWxJMcTw4JYkro/LIg10Ybaw6oLYk20oaOne8lnd8lnZHiHgs4habfC++925pIDTLpC2GnAni+P3TiDdkHn2BV6A7AXyvOuAfYiBjuRSiUUnVyiVqmlMrlCspTIprLZWrqWy+bTlVomXazkqol0MZUsVHNuLZGvqhnrVDmXrRUq5WwDe7E471QG5unw97jx99SLXuWEeo+/lx4lcfV1D/LH4T87t4lZ8a4HEa6DMLQbIHgRR3I+M+lGSHqOw8+vQvoxwlWWT3N+tYfwofqh86tRhmuc+Gm3pd4MR/2izL0grD2CWAcFsXYIYu0TxHpYEGtYEOtAl/LaKYi1SRBrqEt5HRLEkqz3krwkdb9XEEuyHCV1v0sQSzKPhwWxNgtiPSaIJamvBwWxurVtDwtiwXgC3uvG48epzkg/PHaaQvx6kR/GwH6YX28APxy/1ycezQeMf/uJ/wrvt9uZSwD+ZDP4je9CTGJ0hfME6cN4tg+Fj/j8ByzqB2nFCJa07oLyhvnTejAJ8aHfj+CwJrWJNcD4mSjT/oB84/QHA7hy+eglOuHaWYTRCdyfHMALh5/OpA1xQYcDyE9Qh8kgHeK2COmP5ZsaoLclJBycxdHjjK6Dk3ywHPJ7CbkXRXjYTScYnB2l7dmvfOM+8bUbDEhnkIkH+ZuCOC5B/pMD8htl7lGOOD6E49KJdJhOhEmHYnFzNNpV601/HP6L3ryMzsO3F47EXMrwC2qLy5jwS1EY4MPpBuIOMmlHfP5DOo4TXIeWojDUTi0TTGcZCtNH0jlBMJ0TUJipJJ0TBdM5EYWZguLp3ychP1zPwJaejvzlbGmyCPlc7ox24HcGuvd4vcmDuij5jXnr9vDWRU1cGo6meTLyO4P4nYL8ziR+pyK/s4jfacjvbOJ3OsNnrOWMy+pkn3xJpIN1dApJ5xTBdLC+TyXpnCqYDi47KKsBZ3TZHa36j8sW/M5EfrSsz0J+tHzORn5Up+cgP7w3mjquvYGedHv7yxDt7VjXL1cvwU3ot+k3Vv3ifo26Cf02/cLodyw6/EMbfS4uK8gTjG8h/kneYrh+7lk6b2R8/KxJ3/84DvldSfyOZ/w0/u+8BWwY32I90GcM3A9FmXtBzxin+mD1IqwBhAXnHvaR8Od7+jBbJ7O5oDELpL3cUNph+nac/iDDB3jHGL/eDrjWynk35WazlWo2XcqkaxFndNuNMvfoc9cZTHjuG4ag6zPN6DrZ+KZxvYmPx8La9SK/5cSvD/kBR13vb180kv8ZhviH0T9OP86EvwrloZ2yNImF7YEE1qQxYs10RrYnbHMM94sFzgaB49p8nPjhOjeD+OH2RL9jjftMPPdGXat+cd7iJi4NR/OB+4flPpjQF5yE/KEv6yNhX4D60KtIH4qfD19QH+mHn8MgHY1x67zmfZwO1x9rt9KHV5X0X2bmHNIVbkxF+68zDKUdtv+icw6YD/COMX6d9F+lRC1VdUuldLJUyWSz2aD+CN+j/deZTHju3FzQ9VlmdF3i+i88X6NdL/KjfRvuv4Aj13+Z6X/TpTD6x+nHmfB3oDy0U5Zg27lxE2crbq+P9MPzP3hMfStp42bGickSN3foEP643Gj/gOsk7R/wsxHtH/CzZ7v9A+ii3f4B20mcJ4zZi+5xNr6PhL8b9REbSR+B+3RIW4f7DSlbrCfBsq1RXTuMTlx0r905Y+Dd7pwxrssu8cPtNUH8cJkliR+uhynidzbDh/53nHBzn7is/J6dJNLhxt1cW+00Hc4+Un1LpIPLDsrKbL/WXv3HZQt+CeRHyzqJ/Gj5pJAf1Wka+c1D19Rx7Q33re3MuR2r+sX7NKib0G/Tb6z6xf0pdRP6bfqF0e9YdNjOnDEuK5ynTsY+nyDjGDPPgq47k+QLpzUxhpoYQ/mlMzGGeub3QficPuom+qCm31j1i+cyqZvQb9NvYgw12h0LY6iwcz1hx1ovrD/9n461/oDmmX43z5/XaSjtumccJ8ZIE2Mkv3QmxkgT80zYTfQxE/NM2HWDfnHfSt2Efpt+3TBGwmXV7jyT39hnBRnHHM15JkN1pMqNIahucf1pdwyFy3Os73ecQ/xMjq8wn7GOBXBZjdf7Hc/UsZrZPRzt1X9ctpz9pGUtYT/bnWfC+zjb6YOOVf22O880Vv3idI4l/bY7hgI9dcn7HV2l37A6HOv7HbiO0j4Xz/VAODzXQzFwGmbLKPx3jSD9mGOyTTbPrjiN8KH6gf5vqtN8x+WW6oZrNpZW3la+vLp5/fmrKtcU1224rbjy/EplXXX9epwbnMIgk1taW2gYuI4z9zHG8ha5gBMPpjujS3k5wTqjBdbFBIsbeQDWmS2wriJY3OgC4p3lkw4Ow83wYD5nteBzTd2fz1kE6+wWWKsIFo5/NsE6pwXWaoKF459D4rk+6eAw2Bq6TNocPq23iRac19RHcsa8EgQr2QJrLcHC8ZMEK9UCax3BwvFTJF7aJx0cBvekaZROhLnH8Vlf9+eTJliZFlgbCBaOnyFY2RZYGwkWjp8l8XI+6eAwWXQ/h9KJMPc4PnfV/flA3DA9HOYq2KOEfisB0h+vHq6VXukpMXmGa5zxw30I9sPp5Jl0OKzlglhnCmKdIYh1liDWOYJYriBWQhArJYiVFMRKC2KBTQSbhst1FkmHGyOcE5AOjk+fFHC8iM9/SIfeo+lwnLmZNHya9hfmN+PgOohPasJxoS/qI+E/v7CJ+SUPE3TJPSlBH4DrlpzNTWUh37hvdYhOcP+zAF1Txz01Au92Z2pxGdG+Erf/PPHD7blA/HCbOpf4pRg+Y61fuKzGqx7TGWtXMB1uHEz1LZEON0bmxpi4nWA/SIfeCzpZiM7Y+7X/H83n0/Rr/zD26yPhP4na/0/IShAebwq28Rxtx9hxYyi6E6SA/Gh9Phf50Tr4LOSHy5Y6zm6ALtqdbcJ9HeSpm/SrXburXVgXY7Wh1E7iNk3tJC4rPzuJy5frQzq1BbisJmxo+HRw2UFZGR5DtG1fssRP0r6A33nIbyG6pq7VmKWd1YJjVb/Y5lI3od+m31j1S+ensJPULy7HZ6p+w+oQdNHu+APX0TzCp30ADofHkH7z3A6DQXFovwh57mHiwteuuLnu2SQNbr4d36N90GyGb1CfarZ9P336OU4P8oHv4fRjjE5MzHOmQuqVG9umiM6xH51r4+bz00w6HBa1S9zYa8AZ3cYE9ZUOW36QfozRg4ny49aTZjN6HY/67VfObgCfjBk+jRPYuPUabv5Pn7TS7zi+41daJ/3WdeCeX9ngtOn6ctBaX6oFFl1f9suDXxlhLLq+zOmgj/ht8CbltA5vWjAyDKyLrkRhXupdBz23GV57Ct2m6dqTmWf44LUnrB9cZyc5wXUHl53fuvzZTF5pXT6rBSdal9vdA4CxaF0O2gPgtsCidRnHp+MCbKvpzq80kx/wyzD8dB1fs8Af3w3ATwTgpwLwg3YW4/nGNPHD85oZhL8pAD/oZPqzAvDPZvApJtgNvH/nZOIHYe/1MI48Z3gnVw04JvveVIqbr3dInrGNbXeuDXh3srOcljFujxnih9sXfe7hbIPpObDx2lk+Xju+aXs4SzAdzjaafTu1vfrP2SJsz2hZ476Vlg8eB1Cd+u2xoI5rb/ht2KO/M7f79Yv3nVDXatfuhH5b67fdN8vGql8zJ2B2l37D6hCfgDnWt/MgT3rXM7whfEt1w+XVzTcUV95WKW64bfWqa6trN1bXb+glsCf70IHftGuCKoJxnAC62vUQv9OIPxyW2uPwDqqNmSkp88Mq4N3usIorYm7oRIdVuPulw6owW0swn7EOD3BZneaTL4l0sI7Ge7hD9S2RDreVu5seK3DZcmaTljU2m7R8sNmkOsXd0mJ0TV2rx5h2uqVjVb/tHlw0Vv2aOdy++/Xb7rAKf8Dv6L9w2l36DatD/FLpWA+Gon0uHvPABx3A7zgUj36c63jkhw+Uoh9bwlMES52RfkuR3zLvuo/wmuXt9Rgg4YTrQ4VOvUEaOO1TDaUdpl/lygDzAd4xxq+Tj0kkq6Vytlispco1t1ysHXmJEuMDV3qPfkyCe8lxGhPesF0tQnvBH5Ogr0f2Ir9TiV8f8sM2jX5MwtDjdjGM/nH6cSb8FSgP7ZRlnEkHt+92sODDFHiqG9q22faWzHNjdnDUZmrX7rMR8G732Qh/dJ1+pAPbPfoSeKcfucV8wtgi7YLqRK9PviTSwTpaRtJZJpgO1vd4f3zX8GEQbdV/rt+hH9rDfniqnpZP2I9Ytnsg3FgPgzhW9bsUXVMnqd+lyO9Y0i8eN1PH6Xepdz1Rf5t+2C5S16qOtvNstBT5QZ4mxh8T4w+/dCbGH898+z0fXVM3Mf5o+o1Vv+1+zH1Cv905vpsYfzTDSI4/KPc+JuwS4gdhH0KvI3/cu57ujO67TnBG+i1BficSv6UMJ/BbxnCKkDTw6zAQXrtqfWQeIPwrPd5al69dxGP2+GDCFlVunm+pd2/A+9+L/OTqbzmheW9CdQDr9Eh+6yPzhPvzKBOezqWewoTH9RV0xL0efxLBWspgnYDuwVwhp0/geDT0iTlSfZ7UIk9Un5z+sZ6WetfcmOk4gnUcg7UU3QvSJ3A8GvpcijhSfZ7YIk9Un5z+T0RhQEdxZ7SujydYnD6XoXt0Lhvi9zPhMV4fCf8RZHOeWjiSH7abSwn3JQw2tr0RgoHzEWPyMUj8cFyNW5w7ErfV0W60bLhXePA6J9Rt7pgOiGv49dK2j7Chx1twx1SBH371lK7p4ldP6WsD+NVTegwfdq1ePQ0zvoqQdACX2ipaZ05mOOKjTrhXo+irhYmQaUL4Vkcd0vrH1Vf8Wk1Q/aPHXkE8PL7A/OmRLRD+K6itf9u75uwx6MmsPXarnD3GeqX2OEiH2rXb5kFn3FEdSeKH6wttdyczmPioLWzT4H9Ha9OVSjWRTuQK+Wo6XSlk6AcSsC6mGEg/nSnmysVcIlFIJ6rpxLinX85kS2VFwq0mjqhjvNPPVEp5N5csFirlbCWVKY93+tVSupArFcoZt+IWEoVUq/R1O3vCC2RyblC7O+tP/4e+sh/Fl3w1F/AnEX5C+AnQU58zWk+Q9mQjeavVwpQDTj9GuArruvFK6WTCh+qH7mUZMKOfqn5lFeoetvn9jG4oj0mEY8wQR65fBU7cfhvgocN8lryC2GOIo9k2WmvsLcNjQ3wUXYTMcUDZ4HENrvc9yB+H71/UxOz1rqcjXIgPdmoK8p/E+MNvKK8eJiy+pr+BO9UrDg91st8nr/0krxB+qpc/ze3rM3lMrD/Mq8cHczrC/DZ5fsPPakFtHsJPYcLjNgZ8pjuj2+YUEg9zH3BGOnyPK58ICUv7YOincDy/3wMMjh+HyQwO9zw9QLjiNGl90I4+80SZdHCbwn3+AJO+YP+Q4fpKcODXT/KL/XDeb6w3w1HHPWNCnnR+f0ieaXA4yodra5JjI7jfh+7TdKMkbD8Ji/tzqrM+AY5xJp1+gjspgH+E4PQy8QYdvj1y/8PyjTB8ub6m03Qw1k31kengcsZ9Wob0adiOR5m4d9eb/jj8uahPy4fs06gtwXl4Sb15j9psOo6lbZLOfdC+i4bB/TgO/1ym76L2AWPpe+eHGCNw4z46RigifV5I9MmNAaY7o3VD6/AASQuPj6F/oTq4AvG4bJF/WqDXwYA86ntXLeLDYQ44HMXg+k7A4No1xJvO8KJtj9qO/oA0uP6MS6OP+HVaPly/jcca3BiG88f9OU6H3uthwrcaf8R8sDncfgaHs/OTiV+E8aM2DOcX2zA6NuGeybBt5NqdX9kFjb057mHGVf0B3Dn9YTskPZfj5t2EW85larVEJVsspVvN5cD9SfWR+TryH93rQ/nSbjIOT/wGkF9vfWT6Me93L0oHYwGPPhJ+Aypr7fpRHIgfZ9LvJ+mP4M3cw3WNYkWZexBel+mdHkcTc3TJTCFfLJTcRLKWTKby2VblyukJzx1oB7rGZdHP5K2PhN+C+pxtZB2mj0lPh9sXEC7i8/8IBnOvtz7yHldGuO5CeEg7Vh/NEfymIL8+ks5U7zfWF8YCHn0k/F5Sd3F9g/hxJv3JJP0RvJl7tO5OYcJPYcLr8tlJ7BHOu/Tc35E0CT6+R7ntM9iusulsIp8v5svZcq2QLpfGfe2hkK0VUqlSIlWoVAuJ7LjP/adTpVqipub/UzU3lU+M+9pH0U2qNZ9SKZOoFguF2rjnP5FI1LLpUj5bTqopxnFfe0nXcsVsLedmkpV0NVkpjnf6xVy1kM6mkuVUrVDMu/nxTr9UyZbdQipRKRZzbi6bH8vaE50j0Q7mqOj8yIox8iQu9DGdDTvtjB7LmlhTiRI+VD9wTeemcFxuHQ7O4YkwflHmXs84YwXN15ierwxbFyD9mGO0biaC9Bpl9ErnAHFc+qynHS2/PiYdbk7fFiyIrx03h3tbfaQfLmOqU9resR+3jkVtXNC8SNB8E/CCZ29uLhXnhc5pfJ68h29m7dV1qb2naWG+MO7G+tDuKpIHCP9d9JzyBTJXwK0fcPrsIX7cnBq39kTLoTGuRnmYHJAHCP9PzFoatxYM+TG8xyrN7bHCa1j4uUFL0PqddnTueCoTfgoKQ+eZpiI/2n659o91Tueh8dwSDY/x6Nz6U6iM6J5XXK9jhDvOO52DijLpBq37aS6/J23W0F6ZHLfOBm6Q0Ru1pbidUHtJ909gP1wPsA6oi5LfWBdH1goWN3FpOHCSdgK/O3OEX300r6PRbvG8M2233Do9Dt/OOr120L/FndFlSes31xe002a0u4Kkx6054Dbj1+9yYyJqL3qZvGhH+9ZGeLIfh66vrfB+ux06rm+l+5UM7fHKcutH4AaZfFMbgdsPtRF0LIL9uP3+YW0E6KJdG8GNGzn7QW0Et67KtQHaPrj1kKB1L+65Cc4oixBMxwle1+DWjFs9n9M9ANoZrvuhn88h/ZhjtM9sPJO1Wj+idT1o/w/Xx0aIH05nMpMOh9UjiEXfG8XlQeuCobmR0M/nkH7MGa1TE3WBa3MRRq/cXE2YPdMRxq/d+ZVuxwqaAwxT7lw6tP7jdHD/PmKfzuKRcSAeft7DcenzHoT/4OImZt675t47pnujcf5XeP/d9lya3jD87F/knh8dou8pTJ4jTHiuPwfe7Z7fgvvzKcQP9w9TiR/uywaJH7aJ04ifqbrb55MviXS4PX5B/f1Y0+H2T3DPn52mg8uO7kni+rOx9o3ccwjXN2Lbcv1iPk1sW3Dca+pNfxz+jci2vJg8gxiaG8/T+o9du/MBtD5j20DrIJ4Xou/0YNdqD3A7Z1DgujeA8Gm7xGkaHge3pX/t2j0jC3i3a2Nxmxwgfrguxohfp7YZ85GwFUFz+p2mg8OM11lc491nGJ6rbNv+0D6m3flIzv5QneL2gcfE1LWax2znjKFjUb/UJlMnqd8IyccK77fbmet6/bY7Jodw7erX0NxAV+k3rA5BFxLjE/yeB7cPnXseh/BBawQ4PW4cDXG79Rmz3XZAx5/TkB+tM9ORH9YJda2eads5A4V7TsHh6L71CMMRP4sEzQPDfW5+p49JM4gjNzcaVF+59Vpuvp3WU+6ZCvP3e6Z60tNHq/V50JPhdb4Mt86H9dpHOAXpULt22zzdN8S9q8vNVdBnYW7dDc+zSe9DzCXLmWIqU3DL1UyumM212ofYWHevN8MJlmMS0oXyijpNe9Bbb3KC9KHO4b3lEA64Dpjh6gJX2IsObQinifPSQ8LTa/rux9fQ/AfOI+QD38P4EJ7bB4/fDwCO3DsTU+rtYU0mWJM6wAJe3LsBk8bIi8PqJ1jtvPPyea9s/Nb+/ObLv0HmtLj3WoPmyyH8z9Gc1lOkb5Jclw2aC+T2f9F9I0Hv+DlO8LwnnR/B8XC/wo1HV3i/3c5c6DU0SD/mGB3XJYL6I27MAPqZYoZPGvhw+9e4ctZnzkxzRpcZ5gdY3Dik3X0CdB9NmH0CuL7jM06CziHh3qfm5n1ou3ec4DEi3dv5G9Tu496BkUHvgXLtl7Z7bl8J+PntK/Er86Ax1CATnnvOgLRxnRgMgTUpIO1pTPjBgLQxLxyXpu1Xd7mxMOjmaIyF8T41OhYO2nuqXRhdcuUYJ+Gx7rh2HDROnkL8uHl0rh1D/cXthRtr4z2w0EfD2a74HWrHkbfpuP1J4+fddA7bYQP8U4bnqhKG32lyod5dWG/iB72/EEG6hDi6zUE919fTURztLkLYEeJ3MZOuyTyrOpExvP6ZnMXwx2esaB3BdzKiDt+nwjV35gsO7zD3IgwO1S0uxxXe/0QqlXDdSi5Rq9RSmVwhWUpkU9lsLV3LZfPpSi2TLlZy1US6mEoWqjm3lshXq7lMqpzL1vQxljWa156AvA0GcBxk8ov1Z7IPyeWbz7bQf+FnW+x6kT8OD2dZS89X1HLFRC1VrBUzxUolXW753iic12y5DS+Olw03ZA+yhvddszacW9+NknA0jvYPsvMm+zpslw3pKW1430UK9Bb0fIPT73RdH6cVc4zW4URQ3oL2b3LnLgVh9beJdTTL1O+suiNh6k2/HuLXi/z6iR9+PsHvJixF4fz6Rm4/ymX1JsYZCA++12NyLRtstymbod0sx38cAffwfCw3Two65+bTx+Oco+Xe724+5+hE73qK0xzD4m8P+LWRHmc0HjdXS/cGGWrPSeDKrVNy+071s/0c73r9htXrqpetumhTtbxxw22rV11QLN9adYijm8EiKPN+HTPOKIcRRfE5Z8OgGD4scrQHxTd515YPisvjNSg2tIksY/pFSMC9qN7E5xo41GGYiMDXwAnCXIrCXOoT5jIU5jIURjtucA38aMeOeXAd+yXEDxu0S4kftjN4QACGDU9IQEf3/HqTe4T4XY78xmnSpng0J22grV1QN5M24F9oBj8BHfZ5qBxphx1xRpajyQE1Ts9x+Aebbn1JUw8IZnnX5eLKldesu+2u4obqxRtXlfWYAGcBw/YwWaTdOYShw4II+d1DftPhAn2e7GNw/eLTe0GmK+Lz32HiO87o5zkcj+6l6xFIx/TcObdWEyVpd/t5+ZQ/dVzdwO/KPA/h0nCUDy6HfoSP88GVF/e8zZ3zwpluuG/j2QdhywPPE7RTHn7zF7Rt0jUgW+flz/d+H+1HENwVT3dG190I8ePeAYZw2LZz83EwZOGG844j1432ET6Xef91Xq8jnLl5giijqzBdM84vN68wKUTaWF8X1vm0+x3eDuE9bDj8Nd5/nf8Xeddcvxclfj0MNtcmIY/PxG/jtfttwGfIOlfJ8nWu3MQ6V2s3DutcmfF4hPOzpRPrXBPrXEdjnQumq47SOldpYp2rGX5inetpN7HORRSAM8phTKxz+bt2HzLhW12WD4rz4zUoNr3pyND8NTso5gxOO+tcl6Awl6Aw2gUNnLnJ24uIH25LdH0LGytIVxvgGU7zGuq94Q49fzQ7dOh4wCBr47zUu161esNttc0XrVq7sbqxWrlmY2nlbWVYfLhArUc4xNFBd4T8DruY0Ov4OxwvgvLQ7bbae3f7qNvqxsu63v85jry+XGSrZ5vBd7nDweega0iX9knarfD+ux06wIN6wC2Q0IW2xiCS8IvI80s4xHELWOBgnXE2ugf6/H8oUkYcUgEHAA==","debug_symbols":"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1A2ry5JUkyVOKVU3TNcNM3XDbN0wqhvm6ob5umGhblisG1aXJbouS3Rdlui6LNF1WaLrskTXZYmuyxJdlyW6Lkt0XZaYuiwxdVli6rLE1GWJqcsSU5clpi5LTF2WmLosMXVZYuuyxNZlia3LEluXJbYuS2xdlti6LLF1WWLrssTWZQnVZQnVZQnVZQnVZQnVZQnVZQnVZQnVZQnVZQnVZYmryxJXlyWuLktcXZa4uixxdVni6rLE1WWJq8sSV5clvi5LfF2W+Los8XVZ4uuyxNdlia/LEl+XJb4uS3xdloS6LAl1WRLqsiTUZUmoy5JQlyWhLktCXZaEuiwJdVkS67Ik1mVJrMuSWJclsS5LYl2WxLosiXVZEuuyJNZlSarLklSXJakuS1JdlqS6LEl1WZLqsiTVZUmqy5K63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96pPea9q/YagT6cywkyzZt/TTKZlvw3Jb+TIdFHILJ4wVThwrnDRUOGe97V7h6LHCMWOFY8cKh8YKx40Vzlh35TjWXTmOdVeOY92V01h35TTWXTmNdVdOY92VU+u78sszrm7xuMHi8YPFEwaLJw4WTxoqHpN/gmtupevXMGO0K8Rzc+hqD9+HP3cvuL2JbvEmpsWbWJY3sf7xJt4e3iTzi7xot42BrDru+6Ty26mqfc81ZR+/vU/mK34aPH638/fO2uf4nfD4vfD4g/D4o/D4k+z4tRIevxYevxEe/+jrbyl+4euvFr7+auHrrxa+/mrh668Wvv4a4euvEb7+GuHrrxG+/hrh668Rvv4a4euvEb7+GuHrrxG+/lrh668Vvv5a4euvFb7+WuHrrxW+/lrh668Vvv5a4euvFb7+kvD1l4SvvyR8/SXh6y8JX39J+PpLwtdfEr7+kvD1l4Svv074+uuEr79O+PrrhK+/Tvj664Svv074+uuEr79O+PrrhK+/Xvj664Wvv174+uuFr79e+Prrha+/Xvj664Wvv174+uuFr79B+PobhK+/Qfj6G4Svv0H4+huEr79B+PobhK+/Qfj6G4Svv1H4+huFr79R+Pobha+/Ufj6G4Wvv1H4+huFr79R+Pobha+/Sfj6m4Svv0n4+puEr79J+PqbhK+/Sfj6m4Svv0n4+ptkr79WyV5/rZK9/lole/21w+9/VYpf9vprhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf0XC978i4ftfkfD9r0j4/lekZK+/JHz/Kxp+/6vHS/uQ9DH+3MVb1D76xwtH9zXX0ddqzrmOvq5zznX0GoBxrsPv18U519FrC865Dl6HuOTiY67m9VwppC0OijbuF5sUs2HrsEdtab/a2vTFZvAapysbAptTNoPXZsGR+bo6eOVfs7F2u9bSIejcpc67LWQX1OHiX/Xfc8wp7a+sVPx29R3j4CWiFIyDV59SMA5e2ErBOHjNLATj6Nv3ScE4eKUvBePgJkIKxsH9hhSMBIwcGOFiWDDCxbBghIthwQgXw4IRLoYD4+iboErBCBfDghEuhgUjXAwLRgJGDoxwMSwY4WJYMMLFsGCEi2HBCBfDgXH0raSlYISLYcEIF8OCES6GBSMBIwdGuBgWjHAxLBjhYlgwwsWwYISL4cA4+ob8UjDCxbBghIthwQgXw4KRgJEDI1wMC0a4GBaMcDEsGOFiWDDCxXBgHP1YEykY4WJYMMLFsGCEi2HBSMDIgREuhgUjXAwLRrgYFoxwMSwY4WI4MI5+OJQUjHAxLBjhYlgwwsWwYCRg5MAIF8OCES6GBSNcDAtGuBgWjHAxHBhHP2JPCka4GBaMcDEsGOFiWDASMHJghIthwQgXw4IRLoYFI1wMC0a4GA6Mox9UKgUjXAwLRrgYFoxwMSwYCRg5MMLFsGCEi2HBCBfDghEuhgUjXAwDRjf6cc9SMMLFsGCEi2HBCBfDgpGAkQMjXAwLRrgYFoxwMSwY4WJYMMLFcGAc/RB6KRjhYlgwwsWwYISLYcFIwMiBES6GBSNcDAtGuBgWjHAxLBjhYjgwGrgYFoxwMSwY4WJYMMLFsGAkYOTACBfDghEuhgUjXAwLRrgYFoxwMRwYLVwMC0a4GBaMcDEsGOFiWDASMHJghIthwQgXw4IRLoYFI1wMC0a4GA6MBBfDghEuhgUjXAwLRrgYFowEjBwY4WJYMMLFsGCEi2HBCBfDghEuhgOjg4thwQgXw4IRLoYFI1wMC0YCRg6McDEsGOFiWDDCxbBghIthwQgXw4HRw8WwYISLYcEIF8OCES6GBSMBIwdGuBgWjHAxLBjhYlgwwsWwYISL4cAY4GJYMMLFsGAc3MW45OKGMepUwBjidrGNh7BJqVzYZLZANIWHQjHmXlpHtb20To+Ljc9FbZXZsWt6YLc6F0jUnr6ujuYgkomUuZqCsl9XU/iVIttrO/8l6eCOCpJ+LilB0tkkHdxpQtLPJR3c9ULSzyUd3IFD0s8lHbwbAEk/l3TwzgQk/VjSOHiXBJJ+LungHRtI+rmk6B5NJym6R9NJSpB0NknRPZpOUnSPppMU3aP3JCWdtpemaAqSOqX3J6CKwmOOG3U0eHpQRw+mA/WENkkP6uhk9KCOZkMP6ugH9KBOoN6BOlx1D+owvj2ow5v2oA5v2oP6UN70V0heDWXc7iEN5WruIQ1V8t9DGqoevodE44U0VCV1D2moMuMe0lBr8D2koRaoe0jj3b31eHdvPd7dW49399bj3b31eHfvsc64v4c03t17rLPX7yGNd/ce60zw3yGNdb72PaTx7t5jnft8D2m8u/dY5xHfQxrv7j3WObn3kMa7e491fus9pPHu3mOdK3oPaby791jnXd5DGu/uPdY5jPeQxrt7j3U+4D2k8e7eY51bdw9pvLv3WOep3UMa7+491jlf95DGu3uPdf7UPaTx7t5jnYt0D2m8u/dY5/XcQxrv7j3WOTL3kMa7e491vsk9pPHu3mOdu3EPaby791jnQdxDGu/uPdY5BfeQxrt7j7V//j2k8e7eY+3rfg9pvLv3WPuN30Ma7+491j7Y95DGu3uPtT/zPaTx7t5j7Rt8D2m8u/dY+9neQxrv7j3WfqL3kMa7e4+1n+M9pPHu3mPtp3cPaby791j7md1DGu/uPdZ+UveQxrt7j7Wfzz2k8e7eY+2ncg9pvLv3WJtl3EMa7+491jYL95DGu3uP9QP9e0jj3b3H+mn3PaTx7t5j/Sj4HtJ4d++xfk56D2m4u3cY77eWYbzfWobxfmsZxvutZVDD3b3DeL+1DOP91jKM91vLMN5vLcN4v7UM4/3WMoz3W8sw3m8tw3i/tQzj/dYyjPdbyzDeby3DeL+1DOP91jKM91vLwPQDIhUeIelwCOn3m3z+Y5f7MFs3jOqGubphvm5YqBsW64alqmGf/xjgPkzXDavLEqrLEqrLEqrLEqrLEqrLEqrLEqrLEleXJa4uS1xdlri6LHF1WeLqssTVZYmryxJXlyWuLkt8XZb4uizxdVni67LE12WJr8sSX5clvi5LfF2W+LosCXVZEuqyJNRlSajLklCXJaEuS0JdloS6LAl1WRLqsiTWZUmsy5JYlyWxLktiXZbEuiyJdVkS67Ik1mVJrMuSVJclqS5LUl2WpLosSXVZkuqyJNVlSarLklSXJakqS6JSdcN03TBTN8zWDctmCfl92LdjcR7DXH6Yfgwz6r9e9wRu7/11cbSPbWpv7YjMtSluDY2Uvl97D8ePFU4YK5w4VjhpqHDyDyf6haPHCseMFY4dKxwaK5yx7sp6rLuyHuuurMe6K+vWd+X9mD6tlHmOx6jB4tGDxWMGi8cOFg8NFs/H9+b7MF83LFQNY9oF7+Wjvsi0r13hTWyLN6EWb+JavIlv8SY83wAg/XgTlw5v8tmT8HtIcbyQ0nAhMe349kFIpNN2Lg2Z50xi2u+NMSAzWkDNv7lVWgDbb/VWjMgNF5EfLqIwXERxuIjSaBG13+StGJEeLiIzXETD3bPdcPfsDvu7OaW213aUSq+d3P7SKerDBOhrAn7wCcRkt6uV/T6BjEM2erfIxpWuvj2T3L5qensWZwpXW2e2Akf7x7Uqd63R6cFPpW9X37EHYO+BPQJ7D+wJ2Dtg77A7I7DfsGtg74HdAHsP7BbYe2AnYO+BfXS/Nyl2uNQu2OFSu2CHS+2CHS61B/YAl9oFO1xqF+xwqV2ww6V2wU7A3gM7XGoX7HCpXbDDpXbBDpd6BXYT0xa1PX7jZMcOl9oDe4RL7YIdLrULdrjULtjhUrtgJ2DvgR0utQt2uNQu2OFSu2CHS+2CHS61B/YEl9oFO1xqF+xwqV2ww6V2wU7A3gM7XGoX7HCpXbDDpXbBDpfaBTtcagfsScGldsEOl9oFO1xqF+xwqV2wE7D3wA6X2gU7XGoX7HCpXbDDpV6BPegNiAlWZbDDpfbAruFSu2CHS+2CHS61C3a41C7YCdh7YIdL7YIdLrULdrjUHthN+3t7tNtkrdK28Nouue2kjKjS4+obpXv8Tnj8Xnj8Yez4vduPNfLOZuKPwuNPsuO3Snj8Wnj8Rnj8Vnj8g6+/xfgHX3+L8Q++/hbjF77+WuHrrxW+/pLw9ZeEr78kfP0l4etv+4MNmeMXvv6S8PWXhK+/JHz9JeHrrxO+/jrh668Tvv66wdffQ//Qx5CJf/D1txi/nP5zPn45/ed8/IOvv8X4B19/i/EPvv6W4veDr7/F+Adff4vxD77+FuMffP0NjranxcErf4w/82TZbtdaOgSdu9T5/ahkF9Th4l81ynPMt6fae8wqfrv6jnHw28gYGK1K23fO7Tce2avDHnHYr6Qv3mHw2950vAe/TU/He/BlZTreWAbb8ibwbsp7cJs/He/B2xLT8R68jTId78HbPtPxhr9syjvCX7blDX/Zljf8ZVve8JdteRN4N+UNf9mWN/xlW97wl215w1825Z1GrwdN9Hv0h/Nps7z1jdwWR/CHH0bb7BNytf0u2pH6du2dzOiVWz8yBDInZEavhvqRGb1u6Udm9AqjH5nRa4F+ZEbvCnci45UavX/bj8zondZ+ZBaugf2228/NehWuJeM2jPR7g5+D6bhzXHcli/vFx+/a5q811mwXGyIxGzLp9JDxAO9rQ6ab+uuu1lBfqXUrEqiv9LpVF9RXet3KEuorvW71DPWVXrdLDvVVhw22of446q/7tAPqK73uEx2orzR6fSurj17fyuqj17ew+ga9vpXVR69vZfXR61tZffT6VlafoP7C6qPXt7L66PWtrD56fSurj17fyuqj1zex+iZuPyM1Vpln9Uc/5BDqX6o+en0rq49e38rqo9e3svoE9RdWH72+ldVHr29l9dHrW1l99PpWVh+9voXVH/1Adah/qfro9a2sPnp9K6uPXt/K6hPUX1h99PpWVh+9vpXVR69vZfXR61tZffT6Flbfode3svro9a2sPnp9K6uPXt/K6hPUX1h99PpWVh+9vpXVR69vZfXR61tZffT6JlY/6A2eCVY9q+/R61tZffT6VlYfvb6V1Uevb2X1CeovrD56fSurj17fyuqj17ey+uj1raz+ur2+ZLY5JucK1zoV9oPPtTrmytdZ5mHdrhkvx3X7T7wc1+3k8HJcuCcS7XaxUr60PGq/L4/GBinLY2k720CQf2X5F+6KQH4VFm6LQH4VFu6LQH4VFm6MQH4VFv4WFORXceGvQUF+FRf+HhTkV3HhL0JBfhXR9VtafoL8K8uPrt/S8qPrt7T86PotLT+6fkvLj67fyvIndP2Wlh9dv6XlR9dvafnR9VtafoL8K8uPrt/M8pc2vUno+i0tP7p+S8uPrt/S8qPrt7D8t4lD/pXlR9dvafnR9VtafnT9lpafIP/K8qPrt7T86PotLT+6fkvLj67f0vKj67ey/Bpdv6XlR9dvafnR9VtafnT9lpafIP/K8qPrt7T86PotLT+6fkvLj67f0vKj67ey/AZdv6XlR9dvafnR9VtafnT9lpafIP/K8qPrN7P8haPutEHXb2n50fVbWn50/ZaWH12/leW36PotLT+6fkvLj67f0vKj67e0/AT5V5Z/Kt/vDe3yh6KiSW1Xm+Rs4WpSassWUnRMrftZ6JqmWkY/ImmV0nsgscjdmv2TRKSlfJIKO2Rqmmodhf4f6z/VQgr9P9Z/qudn0P9j/ad6gAb9P9Z/3Uoa+v/Sf6pHaND/Y/2neoYG/T/V3031EA36f6z/VE/RoP/H+qP/t7b+6P+trT9B/6X1R/9vbf3R/1tbf/T/1tYf/b+19Uf/b2n9Pfp/a+uP/t/a+qP/t7b+6P+trT9B/5n1L+2f4dH/W1t/9P/W1h/9v7X1R/9vbf3R/1ta/4D+39r6o/+3tv7o/62tP/p/a+tP0H9p/dH/W1t/9P/W1h/9v7X1R/9vbf3R/1ta/4j+39r6o/+3tv7o/62tP/p/a+tP0H9p/dH/W1t/9P/W1h/9v7X1R/9vbf3R/1ta/4T+39r6o/+3tv7o/62tP/p/a+tP0H9m/UsnaSX0/9bWH/2/tfVH/29t/dH/W1t/9P9W1t8o9P/W1h/9v7X1R/9vbf3R/1tbf1pXf63iFoh2oXA1hbQFQpHU4Wr7RXLhThozyYV7UswkF+7uMJNcuE+iw07SmBJJo/2+ThobpKyThX1yb/8f9F9Zf71wnwT63/RfuE8C/W/6L9wngf43/Rfuk0D/m/4E/ZfWf+XuDvS/zQr6L63/yp006H8TGvovrT/6f0vrb9D/W1t/9P/W1h/9v7X1R/9vbf0J+i+tP/p/a+uP/t/a+qP/t7b+6P+trT/6f0vrb9H/m1r/wj45xqL/t7b+6P+trT/6f2vrT9B/af3R/1tbf/T/1tYf/b+19Uf/b2390f9bWn9C/29t/dH/W1t/9P/W1h/9v7X1J+i/tP7o/62tP/p/a+uP/t/a+qP/t7b+6P8trb9D/29t/dH/W1t/9P/W1h/9v7X1J+i/tP7o/62tP/p/a+uP/t/a+qP/t7b+6P8trb9H/29q/Uvn5Hn0/9bWH/2/tfVH/29t/Qn6L60/+n9r64/+39r6o/+3tv7o/62tP/p/S+sfBvf/LrlNpBB1QX8b4q5oPIRNSuXCtjZsUd8u36+OMXMx2U1PigceTn1hHNxGS8FIwMiBcXBTJwXj4N5ICsbBLYYUjINX6qNgdG6bofM5jIMXvEIwxsGfGw+DMagNY0gZjIM/fpWCES7mPYxpW2K8shmMcDEsGAkYP8SodQYjXAwLRriYtzD6sAHxUWUwwsWwYISLeQ9j3IL2iTIY4WI4MCa4mLcw3p68bGHomMEIF8OCES7mU4zGZzDCxbBgJGDkwAgX8x7GtAUdVW6lhothwQgX8xbGuH+oY3alhothwQgX8x5GazeMZJ4wWgUXw4IRLuZTjE5lMMLFsGCEi3kLY9LbtSlTfltFwMiBES7mPYx2A5JIZzDCxbBghIt5D+P+HZ7kcx9quBgWjHAxn2IMz60Jq+FiWDDCxbyFUSu3faXsFmimANfwMUwgF3YyZLZANB1+kJYFaXXcQFqdHhcbn4v6Vks+5nj4TuTtPpoNW21fErLhUFL9uvouEkGk8UVa2IXJEWlhjydHpIUdpByRFvanckRa2P2KEcks7K3liLSwc5cj0sJdATkioeMgQCSCSOOLhI6DAJHQcRAgEjoOAkRCx0GASOg4jC+SRcdBgEjoOAgQCR0HASKh4yBAJIJI44uEjoMAkdBxECASOg4CRELHQYBI6DiMLxKh4yBAJHQcBIiEjsMlIhmzX02xIFLU/nGAjHpcnT8ShoLafkxOQT/2NrDOf0mK/sR0khIknU1S9D6mkxSdkukkRV9lNkkdvKM4SfeNDm9/+oykqHilSRrV9qtzul2ekZQgaXdJRznYVKeH6odzYbeDTa1DLY1keTtZUKUjWd5OFtT/SJa3kwXPd5EsbycLnjMjWd5NFo+eBZLl7WTBc3cky9vJguf/SJa3kwV9ViTL28lCSBYky7vJgg4ukuXtZEEHF8nydrKgg4tkeTtZ0MFFsrydLOjgIlneTZaADi6S5e1kQQcXyfJ2sqCDi2R5O1nQwUWyvJ0shGRBsrybLOjgIlneThZ0cJEsmzLGPlQnk0kWdHCRLG8nCzq4SJZ3kyWiz4JkeTtZCMmCZPlSJuhNRhOsyiQL3BCS5e1kgRtCsrydLHBDSJa3kwVuCMnydrLg+yxIlneTJeH7LEiWt5MFfRYky9vJgu+zIFneThZ8nwXJ8nayEJLlrWQxZtucz9oYC8ki5ksHCT3ZpeVHl3Vp+dE3XVp+dEKXlh+9zYXlv4GB/CvLj/7j0vKjo7i0/OgRLi0/Qf6V5UfXb2n50fVbWn50/ZaWH12/peVH129l+TW6fkvLj67f0vKj67e0/Oj6LS0/Qf6V5UfXb2n50fWbWX4T06ajVSYjP7p+S8uPrt/S8qPrt7L8Bl2/peVH129p+dH1W1p+dP2Wlp8g/8ryo+u3tPzo+i0tP7p+S8uPrt/S8qPrt7L8Fl2/peVH129p+dH1W1p+dP2Wlp8g/8ryo+u3tPzo+i0tP7p+S8uPrt/S8qPrt7L8hK7f0vKj67e0/Oj6LS0/un5Ly0+Qf2X50fVbWn50/WaWv3CUExG6fkvLj67f0vKj67ey/A5dv6XlR9dvafnR9VtafnT9lpafIP/K8qPrt7T86Pq9Jz/ZXX6KuiC/1Wq/WtOBXxZfoA22Dv5wcchcfLPqX9d6Z4+X3tVEE28mNdGTk6XmLow/LBC7mmixCVNTbTjU82fTo2P2ppo6PdQ0BTWd2ssVpygc1bxTR6OqB3X0h3pQR1umB3UC9Q7U0YToQR3evwd1ePQe1OGle1CH5+1APcCb9qAOb9qDOrzpBdQppbhTd+m/XnbVbp3NrYt9s0/qWSIY2eElIkg0ukSwyMNLBD89vEQw38NLBKc+vESw9aNLFNEDGF4iNAyGlwjdhbEkss8SobswvEQEiUaXCN2F4SVCd2F4idBdGF2ihIquQiJfkEjT/i1sTTa+lsgr2l7aq6ReX6xvV2xX3/52/llRFICzKUpQdDJFUV7Opiiq0dkURfE6m6J4kiZa0fSsKB68zaWoU3hON5uieKw3m6LoGc2mKHpGkylqVl5HVTxR9I5m5QWpgGblO3sBzVS3yOhoRxNUCY1W29YvWh8maXXuatL7dmxEj2uzr3zhRm86PYRR6dvVdz0Jek6l51QtdehppmqoQ08zVTsdepqpmunQ00zVSoeedqoGAPS0U3UtoKedqtUCPS36Q3PpSdBzKj3RH5pLT/SH5tIT/aG59ER/aC490R+aSk9Cf2guPdEfmktP9Ifm0hP9obn0JOg5lZ7oD4nS08TtC9DGKpPRE/2hufREf2guPdEfmktP9Iem0tOhPzSXnugPzaUn+kNz6Yn+0Fx6EvScSk/0h+bSE/2hufREf2guPdEfmktP9Iem0tOjPzSXnugPzaUn+kNz6Yn+0Fx6EvScSk/0h+bSE/2hufREf2guPdEfmktP9Iem0jOgPzSXnugPzaUn+kNz6Yn+0Fx6EvScSk/0h0TpGfRG2gSrMnqiPzSXnugPzaUn+kNz6Yn+0FR6RvSH5tIT/aG59ER/aC490R+aS0+CnlPpOVd/KO0vnQwV9LT7K9MhjPwBrNlLNaUviFM1ZZLdPhSkfAliNHq7OhqnC6nbcaOtOFWjZVKNpmqeTKrRVA2ROTVKUzU5JtVoqsbFpBpN1YyYVKOpGgyTakTQaHiNpmoETKoR+gzja4Q+w/gaoc8wvkboM4yukVfoM4yvEfoM42uEPsP4GqHPML5GBI2G1wh9hvE1Qp9hfI3QZxhfI/QZumtU+IGkV+gzDK+RRp9hfI3QZxhfI/QZxtcIfYbxNSJoNLxG6DOMrxH6DONrhD7D+BqhzzC+RugzDK+RQZ9hfI3QZxhfI/QZxtcIfYbxNSJoNLxG6DOMrxH6DONrhD7D+BqhzzC+RugzDK+RRZ9hfI3QZxhfI/QZxtcIfYbxNSJoNLxG6DOMrxH6DONrhD7D+Bqhz9Bdo8LGwd6izzC8RoQ+w/gaoc8wvkboM4yvEfoM42tE0Gh4jdBnGF8j9BnG1wh9huE1ckPVdfeQhipj7iH1XbVtKZN13JNTR4qP5DRf8Tvh8Xvh8Qfh8Ufh8SfZ8XslPH4tPH4jPH4rPH7h668Xvv564euvF77+euHrrxe+/gbh628Qvv4G4etvEL7+BuHrb2i+/lptt5OSrU6q8NrGmm22hqjULhKz+WfwwN4DewD2HtgjsPfAnoC9A/aogL0Hdg3sPbAbYO+B3QJ7D+wE7D2ww6V2wQ6X2gU7XGoX7HCpXbDDpfbAnuBSu2CHS+2CHS61C3a41C7YCdh7YIdL7YIdLrULdrjUK7CXtr9IcKldsMOldsAeFFxqF+xwqV2ww6V2wQ6X2gU7AXsP7HCpXbDDpXbBDpfaBTtcahfscKk9sGu41C7Y4VK7YIdL7YIdLrULdgL2HtjhUrtgh0vtgh0utQt2uNQu2OFSe2A3cKldsMOldsEOl9oFO1xqF+wE7D2ww6V2wQ6X2gU7XOoV2Asb0QcDl9oFO1xqD+wWLrULdrjULtjhUrtgh0vtgp2AvQd2uNQu2OFSu2Bv71KNsRt2E00Ju/Y7dmODFOyFnwOH9seyA/sv7AnYO2Bvf3g6sP/CroG9B3YD7D2wW2DvgZ2AvQd2B+w9sHtg74EdLrULdrjULtjhUntgd3CpXbDDpXbBDpfaBTtcahfsBOw9sMOldsEOl9oFO1xqF+xwqV2ww6Vegb30swIPl9oFO1xqF+xwqV2ww6V2wU7A3gM7XGoX7HCpXbDDpXbBDpfaBTtcag/sAS61C3a41C7Y4VK7YIdL7YKdgL0HdrjULtjhUrtgh0vtgh0utQt2uNQe2CNcahfscKldsMOldsEOl9oFOwF7D+xwqV2ww6V2wQ6X2gU7XGoX7HCpV2AvbdGW4FK7YIdL7YIdLrULdrjULtgJ2Htgh0vtgh0utQt2uNQu2OFSu2Dv4FLTdrG1h63Bf732r5CiMuOFZMcLiVqHRMpur03KlT4vr66+T8BJn4AfewI+uu0e5GPQh1e+hx9khx9lh58GDz+pbUnyyYQ/w9dKdvhadvhGdvhWdviDr7yl8Adfd0vhj77qFsIffdUthD/6qlsIX/aqa2Svukb2qmtkr7pG9qrb/hR63vBlr7pG9qprZK+6Rvaqa2Svulb2qmtlr7pW9qprh191aW9TJfcc/vCr7uvwh191X4c//Kr7OvzhV93X4Q+/6r4M/+pjJO9v0vz2Zm4f6q+LrdK28Nouufh1dbi5//3qXw9Zny62IW4X23gIm5TKhU37EceawuNBbIy5l9bxcHry4amtzz78U8bsV1Pcr7Zajfys2artebqxWn+7+p4shGRBsrybLA7JgmR5N1k8kgXJ8qVM4Yc5sf3xiEgWuckSkSxIlneTJSFZkCxvJkv7AzSRLHKTRSNZkCzvJotBsiBZ3k0WdHCRLG8nCyFZkCzvJgs6uEiWt5MFHVwky9vJgj5L/2TR/pEsKhbkp5C2sG9/PiKx7uuLBB7dEGmSxv1uQUciD0nRsxAn6b4jAkVrMpKiszCdpPD/00lKkHQ2SeGlp5MUjnc6SfHNInGSqrBLalRGUnz/ZzpJ0T2aTdKA7tF0kqJ7NJ2k6B5NJym6R9NJSpB0MknzxxXcZriPeoSvk/4aRDWDXM2gbCfE6S3hnLHfBuUy6LE5c4yH3XLj1zuEy98hXv4O6eJ3SEpd/g768ncwl7+Dvfwd6PJ3cJe/g7/8HcLl73D1Zzrld0J1+74OjsLT7TLld8B0Yd8MglRmUKx5p/wtZ19/nafnQflNCl3clj+XbGaQrhlkagbZmkFUM8jVDPI1g/Ifhb0+cSmnU6wZlCoGWfV6kFeZOeW3rXIh7YNiZlA2I7ze6HmbMoNs4Z1yn6f8xkiFD2F+O6LSoJqPe37zF23cNiltfAYF6bphpm6YrRtGdcNc3TBfNyzUDYt1w1LVMHeSJTHsww5f7HwM0+VhPjPM1A2zdcOoblg+S272bRtmczee/NeXy8NC3bBYNyxVDct/NbM8TNcNM3XDTnTzu9w2ZFaZ/OM9/ajxtKPMJyCcIEn7542UywzT5WGZj2kwdcNs3TCqGxaqhsU8yWMjxurMMF03LE+SvNqH+cxNIX9M++3ax9xCZhFOJ3Pbvwp/awRlcjLpumGmblg+SyjR/glQublR3TBXN8zXDQsnn+5dN2cyH9MU64aliiCDUqpumK4bZuqG2Yr75G0Y1Q1zdcN83bBUcecKStfcuW7DdN0wUzUs5P2a2abmns+ECyp/Ty4N0jWDTM0gWzOIaga5mkG+ZlCoGRRrBtVkRH4lc2krrvzh0cpjkK4ZZGoG2ZpBVDPI1QzyNYNCzaBYMyh9PkgrVTNI1wwyNYPy9/THQ7jbs8XMsJN7enFY/p5+cyrbsOMjv8cwUzfM1g2jumH5tVj7HYmOOSQnFjU9/FjKvVuqGmZU3TBdN8zUDbN1w6hu2EkNZdSjGAqZYb5uWKgbFuuGpaph+T50eZiuG5bPEvcwjS6mzDBbN4zqhrm6Yb5uWKgbFuuGpaphdNa32odZk/m8kakbZuuGUd0wVzfM1w0LdcNi3bBUNcypumF1WeLqsuSkB273x7e3D3LmFnTSAy8Oc3XDfN2wUDcs1g1LVcN8XYHh6woMX1dg+LoC4+RXS69Pjr/917wA/tFL9SH3bqlq2EnHvThM1w3LCxDC9vsvHZLJDLN1w6humKsb5uuGhbphsW5Yqhp28jShOEzXDavLkliXJbEuS2JdlsS6LIl1WZLvZOn0WBaTyQ1LVcPyPSYT9fa9JhP944aX/6pwtHvnNdrDM6P81YVv6N5CsuOFROOF5MYLyY8XUhgvpDheSGm0kEy+p9o3JD1eSMPdvY3iuHub/TuekXQoXf3h7mv7+Tl0655lJkDSJ+CkT8BLn0CQPoEofQJJ+AS0kj4BLX0CRvoEpK/EWvpKrKWvxFr6Sqylr8Ra+kpshl8HXu7GfJvA6HehkiMz7e9Co2yertNjowb1/HzbGA80Z2gC0JyhiUBzhiYBzQkaq4DmDI0GmjM0BmjO0FigOUNDQHOGBtXwKRpUw6doUA2fokE1fIoG1fAZGkI1fIoG1fApGlTDp2hQDZ+iIaA5Q4Nq+BQNquFTNKiGT9GsWw3f2ng7GjIZNOtWwyU0bt1quIhm3bqmiGbdFarwgzzj1l2himjWXaGKaNZdoUpo/LorVBHNuv2aIpp1+zVFNOvWNUU0BDRnaNbt1xTRZKthq/YfQFt12NMrP1mtvd5/na29KcExZt8N7VatP7b+sre/70EFjqDcY99a7Q9HZwjvleR3zQCcO5wEOKdw8jugAM4djgacczgGcM7hWMA5h0OAcw7HAc45HA8453BQIb+Agwr5BRxUyOdwIirkF3BQIb+Agwr5BRxUyC/gEOCcw0GF/AIOKuQXcFAhv4CDCvkFnJUr5NvsNzhWZb49lVaukItwVq6Qi3BWrpCLcFaukItwCHDO4axcIRfhrFwhF+GsXCEX4axcIRfhoEI+hWMVKuQXcFAhv4CDCvkFHFTIL+AQ4JzDQYX8Ag4q5BdwUCG/gIMK+QUcVMjncDQq5BdwUCG/gIMK+QUcVMgv4BDgnMNBhfwCDirkF3BQIb+Agwr5BZyVK+TCr3KtWblCLsJZuUIuwlm5Qi7CWblCLsIhwDmHs3KFXISzcoVchLNyhVyEs3KFXIKz8NFHdj8e0dwaohk0624eVkSz7uZhRTQLb4pacOMLH31URLPu5mFFNOtupVtEs+5WukU0C2/2XkKz8GbvBTQLH31URLNuNVxEs241XESDavgUTfu65rPD60Pa0Nz+fEx3O7zedjhq5rMJxD0Tbn+mzATi6BMwdp+ANZkJJOET6HC4CvMEtPQJGOkTsNInQKNPQIV9AkZlJuCkT2D0lbg4geFX4tIEhl+JSxMYfiUuTMAPvxKXJjD8SlyYQH5HoEBbRIH8s4nI73fyMDXJxcwgWzOIaga5mkG+ZlCoGRRrBmV10mo/bkIr756GUf4X2+Vhum6YqRtm64ZR3TBXN8zXDQt1w2LdsLos0XVZkv/Jyut7B+V/ypH221QyuUEVtwHKf4G79E6xZlCqGJT/ImxpkK4AYUzNIFszKK+T3zIihUwa5b+AVhrkawaVbtfZQbEGRKoYlP9WTGlQTUbYmoywNRlhaz651tUM8jWDQs2gTzPi9i/968r8722i2su/w0f+VyH4dKmnrfbzzh4vvcWVv91xvXj86YvHbWdKH+OfL55+/OJqW3LUn5Hnb7MsL377h/l1IWXT1e2H9bpweAuyv6LKt+FfDwmfD4mfD0kfDrn9y/66Mn8X93Z7HBHV496qbfotjf98SPh8SPx8SPp4SP7e/XpI9s4dzT7k8P3QbYj5fIj9fAh9PsR9PsR/PiR8PiR/44q7h07p25DM4ze/3ddtoP96GOj7y6dLXz7/zQC+l9fXvry59uXttS9P1768u/blPePLR/v08uHal4/Xvny+Ojfbl9aTDX/eR/LPDF8P0Z8PMZ8PsZ8Poc+HuM+H+I+H5A9HfT0kfj7kc/XD5+qHz9UPn6ufP6DP7FbE+PBn8uePrXs9xH0+JP90K2zdDZOePpX5g79eD4mfD0kfD8kfnfR6iP5wyO1fBC9xu2v89snZgRQ2z+YNHQbq28DbP//ff/z3v/3jP/39X/7jNuTXf/0///rP//m3f/vXr3/+5//3v7f/8k///re///1v/+sf/ve//9s//8v//D///i//8Pd/++df/+0v6ut//vvN6Zm/BuXs//jt3P/77UFP+OvtYYn7H7/dzu2/3x7wBGXir//+awAFH/9KIfwe8HuE8ul2RdAP8//rOkN/NWk3jr9e6vZGZLaXcfqvzu+W6vf/5dVfvdteNYa/xrTnyvlw93hD/Vdz+7/+68bo/wc=","names":["deposit_private"],"brillig_names":["discover_new_messages","decompose_hint","store_in_execution_cache_oracle_wrapper","call_private_function_internal","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","directive_invert"]},{"name":"withdraw_private","hash":"4796589960319892356","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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7vHrLT7u8eutEe7x613K7/HrXXF/x9/9rmKl+PWe1nCPX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWiL/7XcVK8Stff7vfVawUv/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvErX3+731WsFL/y9bf7XcVK8Stff7vfVawUv/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvErX3+731WsFL/y9bf7XcVK8Stff7vfVawUv/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvErX3+731WsFL/y9bf7XcVK8Stff7vfVawUv/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvErX3+731WsFL/y9bf7XcVK8Stff7vfVawUv/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvErX3+731WsFL/y9bf7XcVK8Stff7vfVawUv/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvHrXn9997uKleLXvf767ncVK8Wve/31i+711yveVewev+711yveo+sev+711yve8ep3/Io3prrHr3z9Vb7/lVe+/5VXvv+V733/q+DyFn9aXOGlf7SxXNpmmPPna+9cOl/Xm3HpvF5oxqXzOuQ8Lu83aPS9bzDWDEzvO5e1A9N5SdYOTOe1XjswnReR7cD4vsGk/aV98iUwMbiPi2MM+7Xefky180JWcqqd16aSU+283Hwz1Xv8nZeFxfg7r95K8Xe+Pd1q/LpdbMKBPe98e7py/H2XLOX4+64syvF75fH3vaqX4+97qS7H3/f6W46/7/W3HH/f6+9z/NbYr/F3vj1dOX496+9x/HrW3+P49ay/x/HrWX+P4+98/Y0m7henfBB/5+tvMf7O199i/J2vv8X4O19/S/F3vj1dOf7O199i/J2vv8X4O19/i/F3vv4W41e+/na+PV05fuXrb+fb063JLdvFOaTCS/u8T/b5q0zJHlxr47IdZ2yjfVS24YNL5+t6Ky6db6fXjkvndYgQl/tcO69ZROfaeX0jOlc/0Vw7r5tE59p5jSU6187rsR/N9dZy2y726WCuI9VupbmOVI8V5tr5lomycx2pbirNdaS6qTTXkeqm0lz9RHMdqW4qzXWkumld97opHdRNnW8zKTvXoeqmwlyHqpvez7XzrS5l5zpU3VSY61B1U2GuQ9VNhbn6ieY6VN1UmOtE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vejak14nphdde9LrvPTydO1JrxPTi6496XVietG1J71OTC+69qRXfXrFp/TKB6dyeE96kV7npRdde9LrxPSia096VaeXN/vG49Hbgz0mPF170uvE9KJrT3qdmF507Umv89JrpWtPep2YXnTtSa8T04uuPel1YnrRtSe96tNreU6vgxPRVk96kV7npRdde9LrxPSia096VaeXTY/dCb1bS9d7Z/br/eGGTStdftLxunR06yMdV1O8Pq178D7FdJC+PEUgfa9L39U/0jccOV+eOpCObe6mR+kYeEpBOnaUjjzVIB07SkeegpCOHaUjT01Ix+vSMYZHOmb75048eNKX9L0sffPjbnpruR+kI09xSMcmd9PjdOSpD+nYUTry1Id07CgdeYpDOnaUjjzFIR0vS0dv4iMdnftzJx556kP6Xpe+7ulu6g92Xo889SEd29xND9ORpz6kY0fpyFMf0rGjdPSkI+nYTzryFId0PCUd7+nFUxnS68T04ikL6XVievHUhPSqT6/1kV42HWwvGXkKQnqdl16JpxSk14npxVMH0uvE9OIpAul1YnrxVID0OjG9POlFep2XXnTtSa8T04uuPel1YnrR9yK9atMr5LA/0g455q/plel7kV7Vd6/lIfzt73CQXvS9SK8T04u+F+l1YnrR9yK96muvvDyllz1IL096kV7npRd9L9LrxPSi70V6nZhefFuV9Doxvfi2Kul1YnrRtSe9TkuvsNC1J71OTC+69qTXienlSS/Sa9fGuLxpY5IvXB192F779mc+SC66XiTXaclFz4vkOi256HiRXLXJFcymeww2HiQX/S6S67TkottFcp2VXIZeF8l1WnLR6SK5TksuT3KRXJXJtaYtS+KaD5qoBrdIctUmV8xb0DE5c5BcuEWS67Tkwi2SXGcll8UtklynJRdukeQ6Lbn4LSPJVZtcaTV7ch2c5h4sv2QkuU5LLk9ykVxnJRff5yK5Tksuvs9Fcp2WXHToSa7TkosOPcl1WnLRoSe5zkouR4ee5DotuehzkVy1yfX8fa6jDr3zJBfJdVZy0eciuU5LLvpcJNdpyUWfi+SqTq6wfysixPQ1uTzfiiC5apMr7vxiNP4guXCLJNdpyeVJLpLrrOTCLZJc1TVXjo/kWg+SC7dIcp2WXLhFkuus5Fp5tkhyVddc+1GMtz8Paq6VX/+QXNXJ9fTr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xNZlia3LEluXJbYuS2xdlri6LHF1WeLqssTVZYmryxJXlyWuLktcXZa4uixxdVni67LE12WJr8sSX5clvi5LfF2W+Los8XVZ4uuyxNdlyVqXJWtdlqx1WbLWZclalyVrXZasdVmy1mXJWpcla12WhLosCXVZEuqyJNRlSajLklCXJaEuS0JdloS6LAl1WRLrsiTWZUmsy5JYlyWxLktiXZbEuiyJdVkS67Ik1mVJqsuSVJclqS5LUl2WpLosSXVZkuqyJNVlSarLklSXJbkuS3JdluS6LMl1WZLrsiTXZUmuy5JclyW5Lkvqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73al70XvP+DUOTvTkY9iJL9i39TM7207CjrXyFDgq5hRP7Cif1FU7uKpxXve1W4Zi+wrF9heP6Csf3Fc7aVzh93ZVTX3fl1NddOfV1V8593ZVzX3fl3NddOfd1V85X35XfnnF1i2ftLJ7QWTyxs3hSZ/HkruKxx09w7a10/RhmrVkL8dwc+rKHH+Jfdy+4vYm54k3sFW/iRN7EhcebBPf0Jge/yEtu2xjILc/7Pi3H26ku+55ri3v89j7bj/h95/GvO/+wOvc1/lV5/EF5/FF5/El5/Fl3/GZRHr9RHr9VHn/v628pfuXrr1G+/hrl669Rvv4a5euvUb7+WuXrr1W+/lrl669Vvv5a5euvVb7+WuXrr1W+/lrl669Vvv465euvU77+OuXrr1O+/jrl669Tvv465euvU77+OuXrr1O+/nrl669Xvv565euvV77+euXrr1e+/nrl669Xvv565euvV77+rsrX31X5+rsqX39X5evvqnz9XZWvv6vy9XdVvv6uytffVfn6G5Svv0H5+huUr79B+foblK+/Qfn6G5Svv0H5+huUr79B+fobla+/Ufn6G5Wvv1H5+huVr79R+fobla+/Ufn6G5Wvv1H5+puUr79J+fqblK+/Sfn6m5Svv0n5+puUr79J+fqblK+/Sfn6m5Wvv1n5+puVr79Z+fqbla+/Wfn6m5Wvv1n5+puVr79Z9/rrFt3rr1t0r79u0b3+uu73vyrFr3v9dcr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK979yyve/csr3v3LK97/yyve/8sr3v/LK97/yyve/8ovu9dcr3//Kd7//1eOlQ8zmOf6ji7eoQwqPF07rx1x7X6sl59r7ui45195rAMG5dr9fl+Rce68tJOfaeR2y5jU95mrfz9XHvMXhk0v7xTanw7BN3KN2fr/aufzBpvMapykbD5uXbDqvzeLq7cfVMSzhPRvntmudfwr66NI1rFvIa1yeLv5V/32NOef9lZclfbr6jrHzElELxs6rTy0YOy9stWDsvGZWgrH37fu0YOy80teCsXMToQVj535DC0YPRgmMuBgRjLgYEYy4GBGMuBgRjLgYCYy9b4KqBSMuRgQjLkYEIy5GBKMHowRGXIwIRlyMCEZcjAhGXIwIRlyMBMbet5LWghEXI4IRFyOCERcjgtGDUQIjLkYEIy5GBCMuRgQjLkYEIy5GAmPvG/JrwYiLEcGIixHBiIsRwejBKIERFyOCERcjghEXI4IRFyOCERcjgbH3Y020YMTFiGDExYhg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","names":["withdraw_private"],"brillig_names":["discover_new_messages","decompose_hint","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","store_in_execution_cache_oracle_wrapper","directive_invert"]},{"name":"_deposit","hash":"1147036195536073192","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"951653053333916160":{"error_kind":"string","string":"Deposit cap exceeded"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5235018679007078561":{"error_kind":"string","string":"Invalid asset or market id"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"16022896159229267359":{"error_kind":"string","string":"Function _deposit can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_deposit"],"brillig_names":["_deposit"]},{"name":"withdraw_public","hash":"10349998466658153284","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["withdraw_public"],"brillig_names":["withdraw_public"]},{"name":"borrow_private","hash":"12134532834982461289","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"7b3djjM7cqZ7L33cB8mf5M/cymBg2B7vQQMNe2B7NrAx8L1vfUuVKdWqlFjFLzLJIJ+TRn29mFLweUPJeCMl8v/+5X/+yz/9n//1D3/71//n3/7jL//tv//fv/z93/75H//zb//2r7d//d+/GP/H//cf//sf//XXP//jP//x3//zL//Nrj7+9S//8q//8/ZnMPa//vqX/+dvf/+Xv/w3syz/9devo61fttE2PEZHczDYLXn9GOxMSO8HmzWbbfTtb/sYbpM/Gh/WtA0PMe6j3XL46i64bbQ3y6fR/+OvfzEraF6hCaB5hSZ2jma1DzQhFNBYY8MWifHrb6JJoHmFJoPmBRq7gOYVGnOIxifzQOMKaLwx/mO0N+vjLYL/4x3s6e/gjt7BOOv3W7hzaSm8x2282YevDxFyPBicc95y5/Zqxj9HdKSYX58kS+ufJ+C1T2A9nkBa9jdxz4n9awK/LjusAbzfPzx+TY+1dHVHmeG2j473jyxa7R8vH899+XTuy+fff/ldNB///PJuOfflzbkvb3//5W3exqYvL+9+++VXs6X+6vPzy38dGpPZbtExRVu6/bvHR9E9RW7y0UIU/HZPcCH558G/pulHmWb0m5i3e4758zTXOdQMc6gZO55miNtoG637c+THC0ZY9sjj07J9GLkxad3Y3P5Oj4DWeJgw+wLjojEde16XYfOKjV9g85KNgc1LNrZ3Nu18r3ewecnGw+YlmxU2L9kECTZ5j99klwts4na39O6pTrx56V/hRIFwsn9IlXN4H47Ja95v3zmYT22Sn3dVfNI+gXz9BKJd9gmkp77B4QTyui/O5mltviX3r/DX47orub1xkH2ctLZYDWxesrG9s2m3RqwONi/ZeNi8ZLNKsBGrLdYgEE7LpXmN2ieQrp+AWG1x+9c//fvf/v73v/2vf/j0Varl1/+YF89k87I3f5dPz9L+eGRhXjxnLV3lqq7yVVetVVeFqqti1VWp6qpcc9XxA7jiVVW54apyw1XlhqvKDVeVG64qN1xVbriq3HBVueGrcsNX5Yavyg1flRu+Kjd8VW74qtzwVbnhq3LDV+XGWpUba1VurFW5sVblxlqVG2tVbqxVubFW5cZalRtrVW6EqtwIVbkRqnIjVOVGqMqNUJUboSo3QlVuhKrcCFW5EatyI1blRqzKjViVG7EqN2JVbsSq3IhVuRGrciNW5Uaqyo1UlRupKjfSYW64ZfeIbsnx6ar1fpWvumqtuipUXRWrrkpVVx3mhjPL9t1aZ23+dNVREyiEvVH66UvTR9/kudnxj8Gre9L0/iU7kxeBeNL+MOGWj6kQzxriNnoNz9/6C/eATG8B2d4Ccr0F5HsLaO0toNBbQLG3gFJvAeW+ArJLZ3dqu1x/p45+W/jWuPrngA6a1+v+rVG7RvN+cNobxSk+LZL+8FdIt+bV3hRfHy/sj767atOjpPo09A+CFoK/SdBB8DcJegj+JsEVgr9JMEDwNwlGCP4mwQTB3ySYIfh7BM0Cwd8kiCf5XYJ4kt8liCf5XYIegr9JEE/yuwTxJL9LEE/yuwTxJL9LEE/ymwQtnuR3CeJJfpcgnuR3CeJJfpegh+BvEsST/C5BPMnvEsST/C5BPMnvEmzhScyDYHoPxaT9G6wmP++fdvjSxuf955vr095sH98RcstEczUTzdVONFc30Vz9RHNdJ5prmGiucaK5ponmOlHd5Ceqm/xEdZOfqG7yE9VNfqK6yU9UN/mJ6iY/Ud3kJ6qb/ER10zpR3bROVDetE9VN60R10zpR3bROVDetE9VN60R10zpR3bROVDeFieqmMFHdFCaqm8JEdVOYqG4KE9VNYaK6KUxUN4WJ6qYwUd0UJ6qb4kR1U5yobooT1U1xoropTlQ3xYnqpjhR3RQnqpviRHVTmqhuShPVTWmiuilNVDelieqmNFHdlCaqm9JEdVOaqG5KI9VNNodtrm55OoLzFZnodzLm6bXTUSRh2c5+DPbp547pj5MpbB6pJGuIcaRqryHGkQrJhhhHqlEbYvRglMA4UmXdEONIRXtDjCP5gYYYR7IaDTHiYgQwugUXI4IRFyOCERcjgnEkF3ObTdwx5lIgxkS7v7jJy9OrG3s2dg/2FthHckmKsI/kqhRhH8mFKcI+kmtThH0kl6cHuxnJFSrCPpKLVIR9JNepCDsutQl2D/YW2HGpTbDjUptgn9il2mXdIjH2NuMCdnuT6WO4NekJSkpHo+Oyj4728d2+cMc+sUttiX1il9oQu53YpbbEPrFLbYl9YpfaEvvELrUldg/2FtgndqktsU/sUltix6U2wY5LbYIdl9oC+1BH+inCPrNLdSnt2L0vNX5t2GOxIayP0dkdxWLs9uK3hxrPo83RaBf3yF12n0b/IdPMrlaRTDO7YEUyeWTSINPMLluRTDO7ckUyzeziFck0s+tXJNPMXQI9Mg114O3AMtGFUCETXQgVMtGFUCGTRyYNMtGFUCETXQgVMtGFUCETXQgVMtGF0CDTUMfHDywTXQgVMtGFUCETXQgVMnlk0iATXQgVMtGFUCETXQgVMtGFUCETXQgNMgW6ECpkoguhQia6ECpkoguhQiaPTBpkoguhQia6ECpkoguhQia6ECpkoguhQaZIF0KFTHQhVMhEF0KFTHQhVMjkkUmDTHQhVMhEF0KFTHQhVMhEF0KFTHQhNMiU6EKokIkuhAqZ6EKokIkuhAqZPDJpkIkuhAqZ6EKokIkuhAqZ6EKokIkuhAaZMl0IFTLRhVAhE10IFTLRhVAhk0cmDTLRhVAhE10IFTLRhVAhE10IFTLRhVAgk1/oQqiQiS6ECpnoQqiQiS6ECpk8MmmQiS6ECpnoQqiQiS6ECpnoQqiQiS6EBpkMXQgVMtGFUCETXQgVMtGFUCGTRyYNMtGFUCETXQgVMtGFUCETXQgVMtGF0CCTpQuhQia6ECpkoguhQia6ECpk8sikQSa6ECpkoguhQia6ECpkoguhQia6EBpkcnQhVMhEF0KFTHQhVMhEF0KFTB6ZzpHJ+nVHmEoy+bzLtC5L/ioTXQgVMtGFUCETXQgVMtGFUCETXQgNMnm6ECpkoguhQia6ECpkoguhQiaPTBpkoguhQia6ECpkoguhQia6ECpkoguhQaaVLoQKmehCqJCJLoQKmehCqJDJI5MGmehCqJCJLoQKmehCqJCJLoQKmehCaJAp0IVQIRNdCBUy0YVQIRNdCBUyeWTSIBNdCBUy0YVQIRNdCBUy0YVQIRNdCA0yRboQKmSiC6FCJroQKmSiC6FCJo9MGmSiC6FCJroQKmSiC6FCJroQKmSiC6FBpkQXQoVMdCFUyEQXQoVMdCFUyOSRSYNMdCFUyEQXQoVMdCFUyEQXQoVMdCE0yJTpQqiQiS6ECpnoQqiQiS6ECpk8MmmQiS6ECpnoQqiQiS6ECpnoQqiQiS6EAplu/x8yaZCJLoQKmehCqJCJLoQKmTwyaZCJLoQKmehCqJCJLoQKmehCqJCJLoQGmQxdCBUy0YVQIRNdCBUy0YVQIZNHJg0y0YVQIRNdCBUy0YVQIRNdCBUy0YXQIJOlC6FCJroQKmSiC6FCJroQKmTyyKRBJroQKmSiC6FCJroQKmSiC6FCJroQGmRydCFUyEQXQoVMdCFUyEQXQoVMHpk0yEQXQoVMdCFUyEQXQoVMdCFUyEQXQoNMni6ECpnoQqiQiS6ECpnoQqiQySOTBpnoQqiQiS6ECpnoQqiQiS6ECpnoQmiQaaULoUImuhAqZKILoUImuhAqZPLIpEEmuhAqZKILoUImuhAqZKILoUImuhAaZAp0IVTINHMXIixmlyk+B34o0+0lzQ7lWaYXoqZlEzWaXBptl7yNtjZ+Gv2HTDN3IRTJNHMXQpFMHpk0yDRzF0KRTDN3IRTJNHMXQpFMM3chFMk0cxdCj0xx5i6EIpnoQqiQiS6ECpnoQqiQySOTBpnoQnQhk3duG+1T6ZFK8PZjcAgPSV04mmV+PKxZnsI4HhzMPjrYdSmMNtGEjfft7+xKr5533iGbp1xMB4PT7dHSx+Bkg30e/Efe0pYhbzXmLX0q8lZj3tK4I2815i2dTPJWYd4mWrvkrca8pddN3mrMW5r/5K3GvOVpCHmrMW89eUveKsxbnpeRtxrzludl5K3GvOV5GXmrMW95XkbeasxbnpeRtwrzNvO8jLzVmLc8LyNvNeYtz8vIW415y/My8lZj3nrylrxVmLc8LyNvNeYtz8vIW415y/My8vbxwnaNe96m0kubFPaof/3tP43/I7t4qkV2nZddPHsiu87KrrDwhIjsOi+7eI5Ddp2XXTxtIbvOyy6eiZBd52WXJ7vIrtOyi+cLZNd52cVTALLrvOyiV092nZdd9OrJrvOyi1492XVadhl69WTXedlFr/6k7Ir7d1Nuf34e/Qd42tiNwNPhbQTeA74NePqCjcDTMmsEnm5SI/A0WhqBpwfRBrzFnjcCj3NtBB7n2gg8zrUReA/4NuAndq7Oxa2HbJxfbQGluQWzt3pNio8f5oVD8IvdwVv7NPYP7BP71pbYJ3atLbFP7Fn9Eve4vfGxgD0sj5/+hsfYtN5BTuxBRUG6iT2lLMiJPaIsyIk9nyzIiT2cLEgPSBmQE3ssWZATuyZZkBP7IFmQOBshkDgbGZAeZyMEEmcjBHJmZxN83kGG4pearYsbSevyU7c+5R833fzMPqghdg/2Fthn9lgNsc/syBpin9m/NcQ+s9triH1mb9gO+zqzk2yIfWbf2RA7LrUJdlxqE+we7C2w41KbYMelfhu7N/uWDd4vn7D/gRLnKYYSNymGEocohTLg+sRQ4uTEUOLOxFDiuMRQelBKocQZiaHE7YihxO2IocTtiKHE7UihjLgdMZS4HTGUuB0xlLgdMZQelFIocTtiKHE7YihxO2IocTtiKHE7UigTbkcMJW5HDCVuRwwlbkcMpQelFErcjhhK3I4YStyOGErcjhhK3I4UyozbEUOJ2xFDidsRQ4nbEUPpQSmFErcjhhK3I4YStyOGErcjhhK3I4QyLrgdMZS4HTGUuB0xlLgdMZQelFIocTtiKHE7YihxO2IocTtiKHE7UigNbkcMJW5HDCVuRwwlbkcMpQelFErcjhhK3I4YStyOGErcjhhK3I4USovbEUOJ2xFDidsRQ4nbEUPpQSmFErcjhhK3I4YStyOGErcjhhK3I4XS4XbEUOJ2xFDidsRQ4nbEUHpQSqHE7YihxO2IocTtiKHE7YihxO1IofS4HTGUuB0xlLgdMZS4HTGUHpRSKHE7YihxO2IocTtiKHE7YihxO1Io16HcjvM7ShdDaXRIG0l3azY+gTR3NEO5F1k0Q7kRWTRDuQtZNB40r9AMVf3LohmqmpdFM1R1LotmqGpbFs1Q1bMomkA1/BIN1fBLNFTDL9FQDb9E40HzCg3V8Es0VMMv0VANv0RDNfwSDdXwKzRjncUui4Zq+CUaquGXaKiGX6LxoHmFhmr4JRqq4ZdoqIZfoqEafomGavgVmrHO6pZFQzX8Eg3V8Es0VMMv0XjQvEJDNfwSDdXwSzRUwy/RUA2/REM1/ArNWGc5y6KhGn6Jhmr4JRqq4ZdoPGheoaEafomGavglGqrhl2iohl+ioRp+gSaNddavLBqq4ZdoqIZfoqEafonGg+YVGqrhl2iohl+ioRp+iYZq+CUaquFXaMY6C1YWDdXwSzRUwy/RUA2/RONB8woN1fBLNFTDL9FQDb9EQzX8Eg3V8Cs0Y50VKouGavglGqrhl2iohl+i8aB5hYZq+CUaquGXaKiGX6KhGn6Jhmr4FZqxzpKURUM1/BIN1fBLNFTDL9F40LxCQzX8Eg3V8Es0VMMv0VANv0RDNfwKzVhnDcqioRp+iYZq+CUaquGXaDxoXqGhGn6Jhmr4JRqq4ZdoqIZfoqEafoWGs+heo6EafomGavglGqrhl2g8aF6hoRp+iYZq+CUaquGXaKiGX6KhGn6FhrPoXqOhGn6Jhmr4JRqq4ZdoPGheoaEafomGavglGqrhl2iohl+ioRp+hYaz6F6joRp+iYZq+CUaquGXaDxoXqGhGn6Jhmr4JRqq4ZdoqIZfoqEafoWGs+heo6EafomGavglGqrhl2g8aF6hoRp+iYZq+CUaquGXaKiGX6KhGn6FhrPoXqOhGn6Jhmr4JRqq4ZdoPGheoaEafomGavglGqrhl2iohl+ioRp+gSZzFt1rNFTDL9FQDb9EQzX8Eo0HzSs0VMMv0VANv0RDNfwSDdXwSzRUw6/QcBbdazRUwy/RUA2/REM1/BKNB80rNPNWw94t9mO0d2v4hOYgEh83JGY1T5Gko7jDkj4GB/v0ymm9Q5+3zm4Ifd4KviH0eb1BQ+jzuo520Cc+TbAh9HmdUkPo83qwhtDndXcNoXugXw8dR9oAOo60AXQcaQPoONIG0MdypGkb7bxdP43+NdnBTtIsTHYsB1aY7FjOpzDZsRxHYbJ+psmOVWEXJjtWZVuY7FgVZWGyY1VyhcnOVEENdvpiYbIzVVCDnZBYmOxMFdRgpxgWJjtTBTXYSYOFyc5UQQ12GmBhsjNVUIOd2FeY7EwV1GCn6hUmO1MFNdjJd4XJzlRBDXY6XWGyM1VQg50gV5jsTBXUYKe8FSY7UwU12ElshcnOVEENdlpaYbIzVVCDnWhWmOxMFdRgp44VJjtTBTXYyWCFyc5UQQ12eldhsjNVUIOdsFWY7EwV1GCnYBUmO1MFNdhJVYXJzlRBDXaaVGGyM1VQg534VJjsTBXUYKcyFSY7UwU12MlJhcnOVEGNdbqRd4/JFn8TaOL2uz27PF7ZJncwNu08ksuFsXknnvPnsX8AH6qKUwB8rJOYNAAfqprVAHyoiloD8KGqeg3APcCvBT6Uu9EAfCiHpQH4UC5PA3Cc5sXAcZqXAjfLWMec+bRvsJS8KRG3ad8yyTn/GG2Wo9deza7mmpZPo+8kx/KQLUmOZQ5bkhzL9bUk6SEpRHIsn9aS5FgGrCXJsZxVS5JjWaaWJMfyQg1JjnV4XVOSeBwpkngcKZJ4HCmSHpJCJPE4UiTxOFIk8ThSJPE4UiTxOEIkxzrQrilJPI4USTyOFEk8jhRJD0khkngcKZJ4HCmSeBwpkngcKZJ4HCGSYx3V1pQkHkeKJB5HiiQeR4qkh6QQSTyOFEk8jhRJPI4USTyOFEk8jhDJsQ5TbEoSjyNFEo8jRRKPI0XSQ1KIJB5HiiQeR4okHkeKJB5HiiQeR4jkWMedNiWJx5EiiceRIonHkSLpISlEEo8jRRKPI0USjyNFEo8jRRKPI0RyrAOJm5LE40iRxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHESI51pHhTUnicaRI4nGkSOJxpEh6SAqRxONIkcTjSJHE40iRxONIkcTjCJFMeBwpkngcKZJ4HCmSeBwpkh6SQiTxOFIk8ThSJPE4UiTxOFIk8ThCJDMeR4okHkeKJB5HiiQeR4qkh6QQSTyOFEk8jhRJPI4USTyOFEk8jgxJs+BxpEjicaRI4nGkSOJxpEh6SAqRxONIkcTjSJHE40iRxONIkcTjCJE0eBwpkngcKZJ4HCmSeBwpkh6SQiTxOFIk8ThSJPE4UiTxOFIk8ThCJC0eR4okHkeKJB5HiiQeR4qkh6QQSTyOFEk8jhRJPI4USTyOFEk8jhBJh8eRIonHkSKJx5EiiceRIukhKUQSjyNFEo8jRRKPI0USjyNFEo8jRNLjcaRI4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE4wiRXPE4UiTxOFIk8ThSJPE4UiQ9JIVI4nGkSOJxpEjicaRI4nGkSOJxhEgGPI4USTyOFEk8jhRJPI4USQ9JIZJ4HCmSeBwpkngcKZJ4HCmSeBwhkhGPI0USjyNFEo8jRRKPI0XSQ1KIJB5HiiQeR4okHkeKJB5HiiQeR4hkwuNIkcTjSJHE40iRxONIkfSQFCKJx5EiiceRIonHkSKJx5EiiccRIpnxOFIk8ThSJPE4UiTxOFIkPSSFSOJxpEjicaRI4nGkSOJxpEjicWRI2gWPI0USjyNFEo8jRRKPI0XSQ1KIJB5HiiQeR4okHkeKJB5HiiQeR4ikweNIkcTjSJHE40iRxONIkfSQFCKJx5EiiceRIonHkSKJx5EiiccRImnxOFIk8ThSJPE4UiTxOFIkPSSFSOJxpEjicaRI4nGkSOJxpEjicYRIOjyOFEk8jhRJPI4USTyOFEkPSSGSeBwpkngcKZJ4HCmSeBwpkngcIZIejyNFEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeI5IrHkSKJx5EiiceRIonHkSLpISlEEo8jRRKPI0USjyNFEo8jRRKPI0Qy4HGkSOJxpEjicaRI4nGkSHpIfouktzF/jPZutYXRxsf9tVfzFHc6mmVY0sfgYMPT2PVDI9xT/xrhy/rXCMfXv0Z4yf41wqV2r1HE//avEc66f43w7P1rRDegf408GnWvEX2G/jWiz9C/RvQZ+tdo4j6D2wMxYXEF6tYuy8do691nje4kJ+4GyJJME3t2YZITO2thkhP7X2GSE7tUYZIekkIkJ3Z8wiQn9mXCJCd2T8Ik8ThSJPE4QiQzHkeKJB5HiiQeR4okHkeKpIekEEk8jhRJPI4USTyOFEk8jhRJPI4MSbfgcaRI4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE4wiRNHgcKZJ4HCmSeBwpkngcKZIekkIk8ThSJPE4UiTxOFIk8ThSJPE4QiQtHkeKJB5HiiQeR4okHkeKpIekEEk8jhRJPI4USTyOFEk8jhRJPI4QSYfHkSKJx5EiiceRIonHkSLpISlEEo8jRRKPI0USjyNFEo8jRRKPI0TS43GkSOJxpEjicaRI4nGkSHpICpHE40iRxONIkcTjSJHE40iRxOMIkVzxOFIk8ThSJPE4UiTxOFIkPSSFSOJxpEjicaRI4nGkSOJxpEjicYRIBjyOFEk8jhRJPI4USTyOFEkPSSGSeBwpkngcKZJ4HCmSeBwpkkN5nLTuJPPiP43+Y7ZxKB9SnO1QXqE426Hq+eJsh6q5i7P1U812qNq1ONuh6svibIeqAYuzHapOK852qlpqrDPPi7OdqpYa6+zw4mynqqXGOoO7ONupaqmxzrIuznaqWmqsM6GLs52qlhrrbOXibKeqpcY6o7g426lqqbHO+i3Odqpaaqwzc4uznaqWGuvs2eJsZ6ql/FhnuBZnO1Mt5cc6C7U425lqKb/4qWY7Uy3lxzqbszjbmWopP9YZl8XZTlVLjXVWZHG2U9VSY525WJztVLXUWGcXFmc7VS011hmAxdlOVUuNdZZecbZT1VJjnUlXnO1UtdRYZ7sVZztVLTXWGWnF2U5VS4111lhxtlPVUmOd2VWc7VS11FhnXxVnO1UtNdYZUsXZTlVLjXUWU3G2U9VSY51pVJztVLXUWGcDFWc7VS011hk7xdlOVUuNdVZNcbZT1VJjnfmSzbrPNpRGm5g+BtunHXBscgdj084juVwYm9MWcs6fx96JD1XPqSA+VE2pgvhQdW2OW9je+KUw2kZnN+QxP4+OR8xvrDbo1oRPo+8kh6qZm5Icqh5vSXKss2aakhzKRzQlOZRHaUpyKP/TlKSHpBDJsTxTS5JjeaGWJPE4UiTxOFIk8ThCJMc6a6YpSTyOFEk8jhRJPI4USQ9JIZJ4HCmSeBwpkngcKZJ4HCmSeBwhkmOdY9OUJB5HiiQeR4okHkeKpIekEEk8jhRJPI4USTyOFEk8jhRJPI4QybHOl2pKEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeI5FjnvjUliceRIonHkSKJx5Ei6SEpRBKPI0USjyNFEo8jRRKPI0USjyNDch3rPMamJPE4UiTxOFIk8ThSJD0khUjicaRI4nGkSOJxpEjicaRI4nGESI51TmpTkngcKZJ4HCmSeBwpkh6SQiTxOFIk8ThSJPE4UiTxOFIk8ThCJMc6v7gpSTyOFEk8jhRJPI4USQ9JIZJ4HCmSeBwpkngcKZJ4HCmSeBwhkmOdK96UJB5HiiQeR4okHkeKpIekEEk8jhRJPI4USTyOFEk8jhRJPI4QSY/HkSKJx5EiiceRIonHkSLpISlEEo8jRRKPI0USjyNFEo8jRRKPI0RyxeNIkcTjSJHE40iRxONIkfSQFCKJx5EiiceRIonHkSKJx5EiiccRIhnwOFIk8ThSJPE4UiTxOFIkPSSFSOJxpEjicaRI4nGkSOJxpEjicYRIRjyOFEk8jhRJPI4USTyOFEkPSSGSeBwpkngcKZJ4HCmSeBwpkngcIZIJjyNFEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeIZMbjSJHE40iRxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHkSEZFjyOFEk8jhRJPI4USTyOFEkPSSGSeBwpkngcKZJ4HCmSeBwpkngcIZIGjyNFEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeIpMXjSJHE40iRxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHESLp8DhSJPE4UiTxOFIk8ThSJD0khUjicaRI4nGkSOJxpEjicaRI4nGESHo8jhRJPI4USTyOFEk8jhRJD0khkngcKZJ4HCmSeBwpkngcKZJ4HCGSKx5HiiQeR4okHkeKJB5HiqSHpBBJPI4USTyOFEk8jhRJPI4USTyOEMmAx5EiiceRIonHkSKJx5Ei6SEpRBKPI0USjyNFEo8jRRKPI0USjyNEMuJxpEjicaRI4nGkSOJxpEh6SAqRxONIkcTjSJHE40iRxONIkcTjCJFMeBwpkngcKZJ4HCmSeBwpkh6SQiTxOFIk8ThSJPE4UiTxOFIk8ThCJDMeR4okHkeKJB5HiiQeR4qkh6QQSTyOFEk8jhRJPI4USTyOFEk8jgzJuOBxpEjicaRI4nGkSOJxpEh6SAqRxONIkcTjSJHE40iRxONIkcTjCJE0eBwpkngcKZJ4HCmSeBwpkh6SQiTxOFIk8ThSJPE4UiTxOFIk8ThCJC0eR4okHkeKJB5HiiQeR4qkh6QQSTyOFEk8jhRJPI4USTyOFEk8jhBJh8eRIonHkSKJx5EiiceRIukhKUQSjyNFEo8jRRKPI0USjyNFEo8jRNKP5HG82Ud7k8On0ffZjuRDyrMdySuUZztSPV+erZ9qtiPVxeXZjlS7lmc7Un1Znu1INWB5tiPVacXZDnWeenm2U9VSQ51LXp7tVLXUUOd7l2c7VS011DnZ5dlOVUsNdd50ebZT1VJDndtcnu1UtdRQ5x+XZztVLTXUOcLl2U5VSw11Hm95tlPVUkOda1ue7VS11FDnw5ZnO1UtNdQ5q+XZTlVLDXVeaXm2U9VSQ537WZ7tVLXUUOdnlmc7VS011DmU5dlOVUsNdZ5jebZT1VJDnYtYnu1UtdRQ5wuWZztVLTXUOX3l2U5VSw113l15tlPVUkOdG1ee7VS11FDnr5VnO1UtNdQ5ZuXZTlVLDXUeWHm2M9VSaahztcqzHaqW8sZts41mOZjtULVUcbZD1VLF2fqpZjtULVWc7VC1VHG2Q9VSxdkOVUsVZztULVWa7VDn95RnO1UtNdQ5OOXZTlVLDXWeTHm2U9VSQ53LUp7tVLXUUOeblGc7VS011Dkh5dlOVUsNdd5GebZT1VJDnVtRnu1UtdRQ5z+UZztVLTXUOQrl2U5VSw11HkF5tlPVUkPt61+e7VS11FD745dnO1UtNdQ+8+XZTlVLDbVfe3m2U9VSY+17XpztVLXUWPueF2c7VS011r7nxdlOVUuNte95cbZT1VJj7XtenO1UtdRY+54XZztVLTXWvueF2eYGHdYQt9FrSO55tveIGmTb8uC/hK8R+cOIrNuEcC6mQkQu5GUbnZbnH3jEjzdZr3iTcMWbxCveJF3xJvmCN3nhy4XfxFzxJvaKN3FXvMkVn3h/xSfeX/GJ91d84v0Vn3h/xSd+veITv17xiV+v+MSvV3zi1ys+8esVn/j1ik/8esUnfr3iE79e8YkPV3ziwxWf+HDFJz5c8YkPV3ziwxWf+HDFJz5c8YkPV3ziwxWf+HjFJz5e8YmPV3zi4xWf+HjFJz5e8YmPV3zi4xWf+HjFJz5e8YlPV3zi0xWf+HTFJz5d8YlPV3zi0xWf+HTFJz5JfOJT3EfnxRy8SbriTfIFb5KXK97EXPEm9oo3cVe8ib/iTVbhNzH24E0kPvFpf/zjsl0+vcnX0Wl/xJLc4wmL/fWM5svY2w3pY2zOn8feg4+ag0+ag89qg7fLsmgO3mgO3moO3mkO3msOftUcvN4V9ha83hX2FrzeFfYWvOYV1vS9woZtrLmtSAfR973ElqLve40tRd/3IluKvu9VthR938tsKXqJdTbbuEe/xkL0779jeIsodhdR6i6i3FtEdukuItNdRLa7iFx3EfnuIlq7i6i7e7bt7g5pr79Dvv2mul2c6y6i6z9r0T4isvFrRGt3EYXuIordRZS6i6jBp9+HPaLVP0f0dbD1eyDWe/8lfL/oDt/oDt/qDt/pDt/rDn/VHX7QHX7sPHybHuF/Lch80h1+76vu+/DXzlfddd1qHrsG935wuD2u/xgcbv3Vr3PtfIn+yVzXHPPbuXa+nq9779eu0bwfnJbthZN/+qG1Xz6m2vnaLzlVP89UO68pJKfaef0hOdXOaxXBqYbeV9afTHXd+o4phk9TPXhh47aYrVkfL+zt0eC0LXlu+TT0jrD3BVsBwpHqgEYIR6ovGiH0IPxdhCPVQ40QjlRnNUI4Uv3WCGHn/S4NCDvvuSlAGHEnv40Qd/LbCHEnv40Qd/K7CNOsWbhkuyN8+qrUIcKUtiA+/Tj48IXN7b23V779HZ++gp3TB/NZ07Ylcw/zy5nPattbMp/V57dkPmtjoCXzWTsJLZnP2npoyDzP2qtoyXzW5kZL5vjQ65njQ69n7mF+OXN86PXM8aHXM8eHXs8cH3o9c3zo1czNgg+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzA0+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzO3+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17O3OFDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfPeTzAdkjk+9Hrm+NDrmeNDL2eu6gzF9H5wDNvYGD9RvM9UU3b93kz9NDNt4egfB9SvheDfvfQ9/qA8/qg8/qQ8/qw7/ibnR0rGb7qO3y9uO0DZLzkXXtr5vVhwPj2FvX7cbZucs9hutm6q2fqpZtt33SA9276rDOnZ9l2TSM+27wpGerZ91zvCs419V0fSs52qlop6a6l7/Hqro3v8Xnn8eiuYe/x6a5J7/HqrjHv8ndcNZm8oemd84aXT4rdmu3vM1SZ3MDan7YVz/jz2zqXzCqMVl9R5LdKMS+dVSzMundc3zbh0Xjc14+Lhcsil8zqvGZfO68dmXDqvS5txod495kK9e8glU+8ec6HePebiO+ditn6kN/agH5B7rzNK8fdeD5Ti733dLsXf+/pair/3dfB9/Hbpfb0qxd/7ulKKv/d+Ryn+3vsSpfh1r7920b3+2kX3+msX3euvXXSvv3ZRvv4a5euvUb7+GuXrr1G+/jbZ318yfuXrr1G+/hrl669Rvv4a5euvVb7+WuXrr1W+/lrl62+TfY0l41e+/lrl669Vvv5a5euvVb7+OuXrr1O+/jrl669Tvv422c9RMn7l669Tvv465euvU77+OuXrr1e+/nrl669Xvv565euvV77+euXrr1e+/nrl669Xvv565evvqnz9XZWvv6vy9XdVvv422XNQMn7l62/nOwmW41e+/na+k2A5fuXrb+c7CZbjV77+9r43YDF+5etv7/v3FeNXvv72vsdeMX7l62/v++AV41e+/va+V10xfuXrb+/7yRXjV77+9r6fXDF+5etv7/vJFeNXvv52v59cKX7l62/3+7OV4le+/na/31kpfuXrb/f7h5XiV77+dr8fVyl+5etv9/tbleJXvv52v19UKX7l629Wvv5m5euv8v2vrPL9r6zy/a+s8v2vrPL9r6zy/a+c8v2vnPL9r5zy/a+c8v2v3KJ7/XXd73912r6iYRtrlsV+GnwHM+1G1yUw0+50XQIz7VbXJTDT7nVdANP95mXNwOg9xeQev97TRu7xe+Xx661q7vHrLT7u8eutEe7x613K7/HrXXH/iL/7XcVK8es9reEev/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvErX3+731WsEH/3u4qV4le+/na/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKleJXvv52v6tYKX7l62/3u4qV4le+/na/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKleJXvv52v6tYKX7l62/3u4qV4le+/na/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKleJXvv52v6tYKX7l62/3u4qV4le+/na/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKleJXvv52v6tYKX7l62/3u4qV4le+/na/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKleJXvv52v6tYKX7l62/3u4qV4le+/na/q1gpfuXrb/e7ipXiV77+dr+rWCl+5etv97uKleLXvf767ncVK8Wve/313e8qVopf9/rrF93rr1e8q9g9ft3rr1e8R9c9ft3rr1e849Uf8SvemOoev/L1V/n+V175/lde+f5Xvvf9r4LLW/xpcYWX/tHGcmmbYc6fx965dL6uN+PSeb3QjEvndch5XN5v0Oh732CsGZjedy5rB6bzkqwdmM5rvXZgOi8i24HxfYNJ+0v75EtgYnAfg2MM+1hvP6baeSErOdXOa1PJqXZebr6Z6j3+zsvCYvydV2+l+Dvfnm41ft0Gm3Bgzzvfnq4cf98lSzn+viuLcvxeefx9r+rl+Pteqsvx973+luPve/0tx9/3+vscvzX2a/ydb09Xjl/P+nscv5719zh+Pevvcfx61t/j+Dtff6OJ++CUD+LvfP0txt/5+luMv/P1txh/5+tvKf7Ot6crx9/5+luMv/P1txh/5+tvMf7O199i/MrX3863pyvHr3z97Xx7ujW5ZRucQyq8tM/7ZJ+/ypTswVgbl+04Yxvto7INH1w6X9dbcel8O712XDqvQ4S43Ofaec0iOtfO6xvRufqJ5tp53SQ6185rLNG5dl6P/Wiut5bbNting7mOVLuV5jpSPVaYa+dbJsrOdaS6qTTXkeqm0lxHqptKc/UTzXWkuqk015HqpnXd66Z0UDd1vs2k7FyHqpsKcx2qbno/1863upSd61B1U2GuQ9VNhbkOVTcV5uonmutQdVNhrhPVTZ1vD/purvf49dZC9/j11jd/xN/59qDl+PXWIff49dYW9/j7rhfCsmyBBBfMQfxeefx9r+vl+Pteq8vx973+luPve/0tx9/3+luKf+18e9By/H2vv+X4+15/y/HrXn/XRff6u3a+PWg5ft3r79r59qDl+HWvv2vn24MW4+98e9By/MrX3863By3Hr3z97Xx70HL8ytffzrfxLMevfP3tfFvMcvzK19/ON5ksx698/e18y8Zy/MrX3843QCzHr3z97XyrwnL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18/8Fy/MrX3873HyzHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18/8Fy/MrX3873HyzHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18/8Fy/MrX38738yvHr3z97XwvvXL8ytffzve8K8evfP3tfG+6cvzK19/O95Arx698/e18r7dy/MrX3873ZCvHr3z97XzvtHL8ytffzvc4K8evfP3tfC+ycvzK19/O9wwrx698/e18b69y/MrX38734CrHr3z97XyvrHL8ytffzve/KsevfP3tfP+rcvzK19/O978qx698/VW+/9WqfP+rVfn+V6vy/a9W5ftfrcr3vwrK978Kyve/Csr3vwrK978Ki+71Nyjf/yoo3/8qKN//Kijf/yoo3/8qKN//Kijf/yoo3/8qKN//KvS+/5VP2+CwGnsQf+frr4s7/9uFhZdOi/8YnNzjrHCb3MHYnLYXzvnz2DuXztf1Zlw6rxeacem8DmnGpfP6phWX3vcta8al83qsGZfO67xmXDqvH5tx8XA55EK9e8yFeveYC/XuMRfq3WMu1LuHXHrfJ7AZl2nr3bCNNctiD8BMW/CWwExb8ZbAeMAcg5m25i2BmbboLYHpvIpZU97A3J7AFF7arHlx23TXbNw+Ptxn2/sefm9me4+/8xWhGH/fN+4Y4zY4xqca7vilbQzrx2gbo3t+6ftk+74ZC0+27xus8GT7bhUIT7Zv/y882b6XQ9nJdr6jofBk+7bfwpPtu8756WSz3SabnqqKfbJ9F0XCk/UzTXakCsrZZSuOnbXx62RHqqCKkx2pgipOdqQKqjjZkSqo22SXd5PtfE/EH07Wm22083b5OtmR1tniZEdaZ4uTHWqdLU12qHXW5bRP1izvX3rNcbt1rzkf3M2GWpR/QiYs+30+LAeFaOd7T16TM8dkhlruvdtrG7+a3/s0db5f5jVkDnOm8504f0pmf3TnfE5fJztWiViY7FglYmGyfqbJjlUiPia7Pj0V3yc7VIlYmuxQVV9pskMVcqXJDlWbuUcgq4nvX9qEtNXzJvqnH8P65Y6m881If4gm7j/9dTG73ytbO9/m9EQyJRPY+Qaq1+TMMRk/FJn9pd2fHkod3GiWvH/hzLjl4EYzVN2UrN/R5MJL+2UL2tvPd+ADjI+WhLm17/bRbsc4VEXWDuNQtV47jENVke0wDlWfNsPY+cbEajAOZQnaYRzKP/wIo9vsg3+e4Q5mKPsgCabzHy3J/gSl922chWfb+Y/qhWfb+U/lhWc700/HYu/bTwvPtvMfqwvPVu/PAmtmq/dHhDWz9WPN1vnHbFf7NNvj0fZpdPjCZrDKS5TNYHWaKJvBqrofsPFm97/ePj2G3MgMVgEKkhmsWpQj0/vG6g3JDFaFCpIZrGIVJDNYdStIxkPmBZl56+ASmXmr4BIZauBXZKiBX5EZrQZ+5RIPXjvt38iM7ulHRy9eO6dtkjeMT4ex3Pj/QbL3TfUVkRytxpYheWczWpUtyWa0Ovttx+vFpulm34nRWZsLszVp2TbtMck8s8mHs10es13C82zvEcXrI7KPiL5uhhBfbBTeMqLcW0QvNsduGZHpLiJ7fUQ+PO4sha98W7/f4qz3/mv4Tnf4Xnf4q+7wg+7wo+7wk+7ws+rw/dJ5+DY9wv9akHmjO/zeV91C+J2vuuu61Tx2Db/3Q8ToO1+ifzLXwk8Lo+98PV+N2+caC/uipP2E4eSfYv74HnT0na/9klPtvE6QnGrnNYXkVDuvPwSnunZeq0hOtfeV9SdTXbcwUgyfpnrwwsY9OudPW1792k7i6+DHr+mXT0PvCHtfsBUgHKkOaIRwpPqiEcKR6pZGCEeqh9ogjCMVHz9BuDyOCzBPj8QOEaa0BZFN8UfNt/feH/+lGJ/OScvpg3nn3Z0hmXfekhqS+azVfkvmHuaXM5/VT7RkPqsBacl8VsfSkvmsFqcl85F6z0qYJ3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ57xodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZp5WvCh1zPHh17PHB96PXN86PXMPcwvZ44PvZ45PvR65vjQ65njQ69njg+9nLnBh17PHB96PXN86PXM8aHXM/cwv5w5PvR65vjQ65njQ69njg+9njk+9HLmFh96PXN86PXM8aHXM8eHXs/cw/xy5vjQ65njQ69njg+9njk+9Hrm+NDLmTt86PXM8aHXM8eHXs8cH3o9cw/zy5njQ69njg+9njk+9Hrm+NDrmeNDL2fe+wG3QzLHh17PHB96PXN86PXMPcwvZ44PvZ45PvR65vjQ65njQ69njg+9nPlQh5drYY4PvZ45PvR65vjQ65l7mF/OHB96PXN86PXM8aHXM8eHXs8cH3o584APvZ45PvR65vjQ65njQ69n7mF+OXN86PXM8aHXM8eHXs8cH3o9c3zo5cwjPvR65vjQ65njQ69njg+9nrmH+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczT/jQ65njQ69njg+9njk+9HrmHuaXM8eHXs8cH3o9c3zo9czxodczx4dezjzjQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxodczx4dezxwfejXzvOBDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OXODD72eOT70eub40OuZ40OvZ+5hfjlzfOj1zPGh1zPHh17PHB96PXN86OXMLT70eub40OuZ40OvZ44PvZ65h/nlzPGh1zPHh17PHB96PXN86PXM8aGXM3f40OuZ40OvZ44PvZ45PvR65h7mlzPHh17PHB96PXN86PXM8aHXM8eHXs7c40OvZ44PvZ45PvR65vjQ65l7mF/OHB96PXN86PXM8aHXM8eHXs8cH3o58xUfej1zfOj1zPGh1zPHh17P3MP8cub40OuZ40OvZ44PvZ45PvR65vjQy5kHfOj1zPGh1zPHh17PHB96PXMP88uZ40OvZ44PvZ45PvR65vjQ65njQy9nHvGh1zPHh17PHB96PXN86PXMPcwvZ44PvZ45PvR65vjQ65njQ69njg+9nHnCh17PHB96PXN86PXM8aHXM/cwv5w5PvR65vjQ65njQ69njg+9njk+9HLmGR96PXN86PXM8aHXM8eHXs/cw/xy5vjQ65njQ69njg+9njk+9Hrm+NCLmbtlwYdezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45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EleXJa4uS1xdlri6LHF1WeLrssTXZYmvyxJflyW+Lkt8XZb4uizxdVni67LE12XJWpcla12WrHVZstZlyVqXJWtdlqx1WbLWZclalyVrXZaEuiwJdVkS6rIk1GVJqMuSUJcloS5LQl2WhLosCXVZEuuyJNZlSazLkliXJbEuS2JdlsS6LIl1WRLrsiTWZUmqy5JUlyWpLktSXZakuixJdVmS6rIk1WVJqsuSVJcluS5Lcl2W5LosyXVZkuuyJNdlSa7LklyXJbkuS+p6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdqXvRe8/4NQ5O9ObjsRZbsW/qZnO2ny4628hU6KOQWTuwrnNRXOLmrcF71tluFY/oKx/YVjusrHN9XOGtf4fR1V0593ZVTX3fl1NddOfd1V8593ZVzX3fl3NddOV99V357xtUtnrWzeEJn8cTO4kmdxZO7isceP8G1t9L14zJrzVqI5+bQlz38EP+8e8HtTcwVb2KveBMn8iYuPN4kuKc3OfhFXnLbxkBued73aTneTnXZ91xb3OO399l+xO87j3/d+YfVua/xr8rjD8rjj8rjT8rjz7rjN4vy+I3y+K3y+Htff0vxK19/jfL11yhff43y9dcoX3+N8vXXKl9/rfL11ypff63y9dcqX3+t8vXXKl9/rfL11ypff63y9dcpX3+d8vXXKV9/nfL11ylff53y9dcpX3+d8vXXKV9/nfL11ytff73y9dcrX3+98vXXK19/vfL11ytff73y9dcrX3+98vV3Vb7+rsrX31X5+rsqX39X5evvqnz9XZWvv6vy9XdVvv6uytffoHz9DcrX36B8/Q3K19+gfP0NytffoHz9DcrX36B8/Q3K19+ofP2NytffqHz9jcrX36h8/Y3K19+ofP2NytffqHz9jcrX36R8/U3K19+kfP1NytffpHz9TcrX36R8/U3K19+kfP1NytffrHz9zcrX36x8/c3K19+sfP3NytffrHz9zcrX36x8/c2611+36F5/3aJ7/XWL7vXXdb//VSl+3euvU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VTvv+VU77/lVO+/5VXvv+VV77/lVe+/5VXvv+VX3Svv175/le++/2vHi8dYjbP8R8N3qIOKTxeOK0fc+19rZaca+/ruuRce68BBOfa/X5dknPtvbaQnGvndcia1/SYq30/Vx/zFodPLu2DbU6HYZu4R+38Ptq5/MGm8xqnKRsPm5dsOq/N4urtx+gYlvCejXPbWOefgj4auoZ1C3mNy9PgX/Xf15hz3l95WdKn0XeMnZeIWjB2Xn1qwdh5YasFY+c1sxKMvW/fpwVj55W+FoydmwgtGDv3G1owejBKYMTFiGDExYhgxMWIYMTFiGDExUhg7H0TVC0YcTEiGHExIhhxMSIYPRglMOJiRDDiYkQw4mJEMOJiRDDiYiQw9r6VtBaMuBgRjLgYEYy4GBGMHowSGHExIhhxMSIYcTEiGHExIhhxMRIYe9+QXwtGXIwIRlyMCEZcjAhGD0YJjLgYEYy4GBGMuBgRjLgYEYy4GAmMvR9rogUjLkYEIy5GBCMuRgSjB6MERlyMCEZcjAhGXIwIRlyMCEZcjATG3g+H0oIRFyOCERcjghEXI4LRg1ECIy5GBCMuRgQjLkYEIy5GBCMuRgJj70fsacGIixHBiIsRwYiLEcHowSiBERcjghEXI4IRFyOCERcjghEXI4Gx94NKtWDExYhgxMWIYMTFiGD0YJTAiIsRwYiLEcGIixHBiIsRwYiLEcC49n7csxaMuBgRjLgYEYy4GBGMHowSGHExIhhxMSIYcTEiGHExIhhxMRIYez+EXgtGXIwIRlyMCEZcjAhGD0YJjLgYEYy4GBGMuBgRjLgYEYy4GAmMFhcjghEXI4IRFyOCERcjgtGDUQIjLkYEIy5GBCMuRgQjLkYEIy5GAqPDxYhgxMWIYMTFiGDExYhg9GCUwIiLEcGIixHBiIsRwYiLEcGIi5HA6HExIhhxMSIYcTEiGHExIhg9GCUw4mJEMOJiRDDiYkQw4mJEMOJiJDCuuBgRjLgYEYy4GBGMuBgRjB6MEhhxMSIYcTEiGHExIhhxMSIYcTESGAMuRgQjLkYEIy5GBCMuRgSjB6MERlyMCEZcjAhGXIwIRlyMCEZcjATGiIsRwYiLEcHYuYtZ85o2jMnkAsaYtsEuPYXtl+UobG+3QIyPD4VSOnppk5btpU1+DLbhKGq32B278Q/szhwFkkzwH6OTfRLJJn8w2sfFfYz28VeKbK+9hg9JO3dUSPpzST2SjiZp504TSX8uaeeuF0l/LmnnDhxJfy5p590AJP25pJ13JpD0x5KmzrskSPpzSTvv2CDpzyWlezScpHSPhpPUI+loktI9Gk5SukfDSUr36HuSepO3l/bJFiRdF7M/AV18fMxxo06DpwV1ejANqGfaJC2o08loQZ1mQwvq9ANaUPdQb0AdV92COsa3BXW8aQvqeNMW1Lvypr9CCktXxu0eUleu5h5SVyX/PaSu6uF7SL6/kLqqpO4hdVVm3EPqag2+h9TVAnUPqb+7t+nv7m36u3ub/u7epr+7t+nv7t3XGff3kPq7e/d19vo9pP7u3n2dCf5HSH2dr30Pqb+7d1/nPt9D6u/u3dd5xPeQ+rt793VO7j2k/u7efZ3feg+pv7t3X+eK3kPq7+7d13mX95D6u3v3dQ7jPaT+7t59nQ94D6m/u3df59bdQ+rv7t3XeWr3kPq7e/d1ztc9pP7u3n2dP3UPqb+7d1/nIt1D6u/u3dd5PfeQ+rt793WOzD2k/u7efZ1vcg+pv7t3X+du3EPq7+7d13kQ95D6u3v3dU7BPaT+7t597Z9/D6m/u3df+7rfQ+rv7t3XfuP3kPq7e/e1D/Y9pP7u3n3tz3wPqb+7d1/7Bt9D6u/u3dd+tveQ+rt797Wf6D2k/u7efe3neA+pv7t3X/vp3UPq7+7d135m95D6u3v3tZ/UPaT+7t597edzD6m/u3df+6ncQ+rv7t3XZhn3kPq7e/e1zcI9pP7u3n39QP8eUn93775+2n0Pqb+7d18/Cr6H1N/du6+fk95D6u7uHfv7rWXs77eWsb/fWsb+fmsZl+7u3rG/31rG/n5rGfv7rWXs77eWsb/fWsb+fmsZ+/utZezvt5axv99axv5+axn7+61l7O+3lrG/31rG/n5rGfv7rWUU+gHREh8hmfgU0h9v8vMfu9wvc3WX+brL1rrLQt1lse6yVHdZrrrs5z8GuF9m6i6ryxJflyW+Lkt8XZb4uizxdVni67LE12XJWpcla12WrHVZstZlyVqXJWtdlqx1WbLWZclalyVrXZaEuiwJdVkS6rIk1GVJqMuSUJcloS5LQl2WhLosCXVZEuuyJNZlSazLkliXJbEuS2JdlsS6LIl1WRLrsiTWZUmqy5JUlyWpLktSXZakuixJdVmS6rIk1WVJqsuSVJcluS5Lcl2W5LosyXVZkuuyJNdlSa7LklyXJbkuS3JVlqRlqbvM1F1m6y5zdZcdZokP+2WfjsV5XLYeX2Yel9nlv973BG7v/TE4ucc2tbd2xMHYnLaGRs6fx97DCX2FE/sKJ/UVTu4qnOOHE+3CMX2FY/sKx/UVju8rnL7uyqavu7Lp665s+rorm6vvyvsxfWZZ7Nd47NJZPKazeGxn8bjO4vGdxfPje/P9slB3Way6TGgXvLeP+pLQvnaFN3FXvIm/4k3WK94kXPEmMt8A8ObxJmt+epOfPQm/h5T6Cyl3F5LQjm8/CMmbvJ1L4+3XTBLa700wINtbQJd/c6u0AF6/1VsxorW7iEJ3EcXuIkrdRZR7i+j6Td6KEZnuIrLdRdTdPXvt7p7dYH+3dVm21159Lr12XveXzsk8TcB/TCB0PoGU3TZ6cZ8ncOCQrdktsl1Lo2/PJLevmt6exdnCaLfarcAx4TF2ORprTX7wW/Kn0XfsEewtsCewt8Cewd4Ae4PdGcF+w27A3gK7BXsL7A7sLbB7sLfA3rvfGxQ7LrUJdlxqE+y41CbYcaktsEdcahPsuNQm2HGpTbDjUptg92BvgR2X2gQ7LrUJdlxqE+y41DOw25S3qN3zN0527LjUFtgTLrUJdlxqE+y41CbYcalNsHuwt8COS22CHZfaBDsutQl2XGoT7LjUFtgzLrUJdlxqE+y41CbYcalNsHuwt8COS22CHZfaBDsutQl2XGoT7LjUBtjzgkttgh2X2gQ7LrUJdlxqE+we7C2w41KbYMelNsGOS22CHZd6BvZoNiA2uuUAOy61BXaDS22CHZfaBDsutQl2XGoT7B7sLbDjUptgx6U2wY5LbYH9+KSlU7Ent03WLcYVXnvN63ZSRlryY/SN0j3+VXn8QXn8se/4w7ofaxRWdxB/Uh5/1h2/W5THb5THb5XH75TH3/n6W4y/8/W3GH/n628xfuXrr1O+/jrl669Xvv565euvV77+euXr7/UHGwrHr3z99crXX698/fXK11+vfP1dla+/q/L1d1W+/q6dr79P/cOQ4kH8na+/xfj19J+P49fTfz6Ov/P1txh/5+tvMf7O199S/KHz9bcYf+frbzH+ztffYvydr79x9dvT4hiW8Bz/wZNlt411/inoo6Fr2I9KXuPyNPhXjfI15ttT7T3mJX0afcfY+W2kD4xuydt3zt0nHoej4x5x3Ef6D96x89vecLw7v00Px7vzZWU43iyD1/L28L6Ud+c2fzjenbclhuPdeRtlON6dt32G442/vJR3wl9eyxt/eS1v/OW1vPGX1/L28L6UN/7yWt74y2t54y+v5Y2/vJR37r0etCns0T+dT3vI29zIbXHE8PTDaHf4hHzZfhe9+uXT2DuZ3iu3dmQ8ZF6Q6b0aakem97qlHZneK4x2ZHqvBdqR6b0r3IhMWJbe+7ftyPTeaW1HZuIaOGy7/dysV2Gst+uG0f+xwc+T6bhznHclS/vg5+/aHo+1zm6DrfdqNmQy+SHjE7yPDZlu6s+7WqP+ssxbkaD+YuatulB/MfNWlqi/mHmrZ9RfzLxdctRfGmywjfr9qD/v0w7UX8y8T3RQfzH0+mZWn17fzOrT65tYfUuvb2b16fXNrD69vpnVp9c3s/oe9SdWn17fzOrT65tZfXp9M6tPr29m9en1Day+TdvPSK1b7Ff1ez/kEPVPVZ9e38zq0+ubWX16fTOr71F/YvXp9c2sPr2+mdWn1zez+vT6ZlafXt/E6vd+oDrqn6o+vb6Z1afXN7P69PpmVt+j/sTq0+ubWX16fTOrT69vZvXp9c2sPr2+idVf6fXNrD69vpnVp9c3s/r0+mZW36P+xOrT65tZfXp9M6tPr29m9en1zaw+vb6B1Y9mg2ejW76qH+j1zaw+vb6Z1afXN7P69PpmVt+j/sTq0+ubWX16fTOrT69vZvXp9c2s/ry9vmy3OeZ1LYxdl7gffG6W51z5OMs8zts1k+U4b/9JluO8nRxZjhP3RJLbBi9LKC2PJuzLo3VRy/JY2s42euSfWf6JuyLIv8SJ2yLIv8SJ+yLIv8SJGyPIv8SJvwWF/Eua+GtQyL+kib8HhfxLmviLUMi/JLp+U8vvkX9m+en6TS0/Xb+p5afrN7X8dP2mlp+u38zyZ7p+U8tP129q+en6TS0/Xb+p5ffIP7P8dP1Glr+06U2m6ze1/HT9ppafrt/U8tP1m1j+28SRf2b56fpNLT9dv6nlp+s3tfwe+WeWn67f1PLT9Ztafrp+U8tP129q+en6zSy/oes3tfx0/aaWn67f1PLT9Ztafo/8M8tP129q+en6TS0/Xb+p5afrN7X8dP1mlt/S9Ztafrp+U8tP129q+en6TS2/R/6Z5afrN7L8haPujKXrN7X8dP2mlp+u39Ty0/WbWX5H129q+en6TS0/Xb+p5afrN7X8Hvlnln8o3x+s3+WPRUXzso22eXWF0X5Ztmzxi39OrftZ6MYPtYz+iKRbFrMHkorcnd0/Sd4bLZ+kwg6Zxg+1jqL/j/UfaiFF/x/rP9TzM/T/sf5DPUBD/x/rP28ljf6/9B/qERr6/1j/oZ6hof9P9V+HeoiG/j/Wf6inaOj/Y/3p/82tP/2/ufX36D+1/vT/5taf/t/c+tP/m1t/+n9z60//b2r9A/2/ufWn/ze3/vT/5taf/t/c+nv0H1n/0v4Zgf7f3PrT/5tbf/p/c+tP/29u/en/Ta1/pP83t/70/+bWn/7f3PrT/5tbf4/+U+tP/29u/en/za0//b+59af/N7f+9P+m1j/R/5tbf/p/c+tP/29u/en/za2/R/+p9af/N7f+9P/m1p/+39z60/+bW3/6f1Prn+n/za0//b+59af/N7f+9P/m1t+j/8j6l07SyvT/5taf/t/c+tP/m1t/+n9z60//b2b97UL/b2796f/NrT/9v7n1p/83t/5+Xv3NkrZAzBoLo33MWyA++eVptPsgOXEnTZjkxD0pYZITd3eESU7cJzFxJ2ltiaQ1YV8nrYta1snCPrm3/w/9Z9bfTNwnQf+b/hP3SdD/pv/EfRL0v+k/cZ8E/W/6e/SfWv+Zuzvof5sV+k+t/8ydNPS/CY3+U+tP/29q/S39v7n1p/83t/70/+bWn/7f3Pp79J9af/p/c+tP/29u/en/za0//b+59af/N7X+jv7f0PoX9smxjv7f3PrT/5tbf/p/c+vv0X9q/en/za0//b+59af/N7f+9P/m1p/+39T6e/p/c+tP/29u/en/za0//b+59ffoP7X+9P/m1p/+39z60/+bW3/6f3PrT/9vav1X+n9z60//b2796f/NrT/9v7n19+g/tf70/+bWn/7f3PrT/5tbf/p/c+tP/29q/QP9v6H1L52TF+j/za0//b+59af/N7f+Hv2n1p/+39z60/+bW3/6f3PrT/9vbv3p/02tf+zc/6953USKyRT0dzHtiqansP2yHIXtXNyivg3fR6d0MNi7TU+fnnisywfGzm20FowejBIYOzd1WjB27o20YOzcYmjB2Hml3gvGdd1muIYjjJ0XvEowps6fG3eDMS4bxpgPMHb++FULRlzM9zDmbYkJizvAiIsRwejB+EOMxhxgxMWIYMTFfAtjiBuQkJYDjLgYEYy4mO9hTFvQIfsDjLgYCYwZF/MtjLcnL1sYJh1gxMWIYMTF/BSjDQcYcTEiGD0YJTDiYr6HMW9Bp+VopcbFiGDExXwLY9o/1OlwpcbFiGDExXwPo3MbRm+/YHQLLkYEIy7mpxjX5QAjLkYEIy7mWxiz2cbmg/LbLR6MEhhxMd/D6DYg2ZsDjLgYEYy4mO9h3L/Dk8PRhxoXI4IRF/NTjPFra8IZXIwIRlzMtzCaZd2+UnYL9KAAN/gYIZATOxlvt0CMf/pB2iFIZ9IG0pn8GGzDUdS3WvIxx6fvRN7uo4dhL9uXhFx8Kql+jb6L5BGpf5EmdmF6RJrY4+kRaWIHqUekif2pHpEmdr9qRLITe2s9Ik3s3PWINHFXQI9IdBwUiOQRqX+R6DgoEImOgwKR6DgoEImOgwKR6Dj0L5Kj46BAJDoOCkSi46BAJDoOCkTyiNS/SHQcFIhEx0GBSHQcFIhEx0GBSHQc+hfJ03FQIBIdBwUi0XE4RSRr99E+FURKJjwOkFkeo4+PhPFx2X5M7qN57G3g1vAhKf2J4ST1SDqapPQ+hpOUTslwktJXGU3SFe+oTtJ9o8Pbn+FAUipebZKmZfvVub8NP5DUI2lzSXs52NTkh+pP58JuB5u6lVqaZPl2slClkyzfThbqf5Ll28nC812S5dvJwnNmkuW7yRLoWZAs304WnruTLN9OFp7/kyzfThb6rCTLt5PFkywky3eThQ4uyfLtZKGDS7J8O1no4JIs304WOrgky7eThQ4uyfLdZIl0cEmWbycLHVyS5dvJQgeXZPl2stDBJVm+nSyeZCFZvpssdHBJlm8nCx1ckmVTxrqH6t4eJAsdXJLl28lCB5dk+W6yJPosJMu3k8WTLCTLhzLRbDLa6JaDZMENkSzfThbcEMny7WTBDZEs304W3BDJ8u1k4fssJMt3kyXzfRaS5dvJQp+FZPl2svB9FpLl28nC91lIlm8niydZvpUs1m6b8zmXUiFZ1HzpINOTnVp+uqxTy0/fdGr56YROLT+9zYnlv4FB/pnlp/84tfx0FKeWnx7h1PJ75J9Zfrp+U8tP129q+en6TS0/Xb+p5afrN7P8hq7f1PLT9Ztafrp+U8tP129q+T3yzyw/Xb+p5afrN7L8NuVNR7fYA/np+k0tP12/qeWn6zez/Jau39Ty0/WbWn66flPLT9dvavk98s8sP12/qeWn6ze1/HT9ppafrt/U8tP1m1l+R9dvavnp+k0tP12/qeWn6ze1/B75Z5afrt/U8tP1m1p+un5Ty0/Xb2r56frNLL+n6ze1/HT9ppafrt/U8tP1m1p+j/wzy0/Xb2r56fqNLH/hKCfv6fpNLT9dv6nlp+s3s/wrXb+p5afrN7X8dP2mlp+u39Tye+SfWX66flPLT9fve/J7t8vvkynI78yyjzb+id8hvug32CaGp8HxYPDNqn+MDat7HnpXkybeSGrSk9Ol5i5MeFogdjVpsSlTc9lwLF8/m4GO2TfVNPmhpi2ouS57ubIuPj6readOo6oFdfpDLajTlmlB3UO9AXWaEC2o4/1bUMejt6COl25BHc/bgHrEm7agjjdtQR1vegJ1n3Paqa/5v9521W6dza2LfbNPy1eJMLLdS+SRqHeJsMjdS4Sf7l4izHf3EuHUu5cIW9+7RIkeQPcS0TDoXiK6C31J5L5KRHehe4k8EvUuEd2F7iWiu9C9RHQXepcoU9FVSBQKEhm/fwvbeJfeSxQWv710WPLyfrC5jdhG3/5ew1dFKQBHU9Sj6GCKUl6OpijV6GiKUryOpihP0lQrmr8qyoO3sRRdF57TjaYoj/VGU5Se0WiK0jMaTFE78zq6pBeK3tHMvCAV0Mx8Zy+gGeoWmVa/o4lLCY1Ztq1fjHmapDNHo73Zt2Pz/jH28JVP3OjN5IcwS/40+q6nR8+h9ByqpY6edqiGOnraodrp6GmHaqajpx2qlY6ebqgGAHq6oboW6OmGarWgp6M/NJaeHj2H0pP+0Fh60h8aS0/6Q2PpSX9oLD3pDw2lp6c/NJae9IfG0pP+0Fh60h8aS0+PnkPpSX9IlZ42bV+Atm6xB3rSHxpLT/pDY+lJf2gsPekPDaXnSn9oLD3pD42lJ/2hsfSkPzSWnh49h9KT/tBYetIfGktP+kNj6Ul/aCw96Q8NpWegPzSWnvSHxtKT/tBYetIfGktPj55D6Ul/aCw96Q+NpSf9obH0pD80lp70h4bSM9IfGktP+kNj6Ul/aCw96Q+NpadHz6H0pD+kSs9oNtI2uuVAT/pDY+lJf2gsPekPjaUn/aGh9Ez0h8bSk/7QWHrSHxpLT/pDY+np0XMoPcfqD+X9pbP1BT3d/sr+KYzjA1gPhxqfPyAO1ZTJbvtQ+CWUICZrttHJrqaQug032kpDNVoG1Wio5smgGg3VEBlTozxUk2NQjYZqXAyq0VDNiEE1GqrBMKhGHo2612ioRsCgGtFn6F8j+gz9a0SfoX+N6DP0rlFY6DP0rxF9hv41os/Qv0b0GfrXyKNR9xrRZ+hfI/oM/WtEn6F/jegzNNeo8APJsNBn6F4jQ5+hf43oM/SvEX2G/jWiz9C/Rh6NuteIPkP/GtFn6F8j+gz9a0SfoX+N6DN0r5Glz9C/RvQZ+teIPkP/GtFn6F8jj0bda0SfoX+N6DP0rxF9hv41os/Qv0b0GbrXyNFn6F8j+gz9a0SfoX+N6DP0r5FHo+41os/Qv0b0GfrXiD5D/xrRZ2iuUWHj4ODoM3SvkafP0L9G9Bn614g+Q/8a0WfoXyOPRt1rRJ+hf43oM/SvEX2G7jVau6rr7iF1VcbcQ2q7artSJpu0J6dJPj2S037EvyqPPyiPPyqPPymPP+uOPyzK4zfK47fK43fK41e+/gbl629Qvv4G5etvUL7+BuXrb1S+/kbl629Uvv5G5etvVL7+xsvXX2fcdlKyM3kpvLZ1dput9b7ULlKz+WcMYG+BPYK9BfYE9hbYM9gbYE8L2FtgN2Bvgd2CvQV2B/YW2D3YW2DHpTbBjkttgh2X2gQ7LrUJdlxqC+wZl9oEOy61CXZcahPsuNQm2D3YW2DHpTbBjkttgh2Xegb20vYXGZfaBDsutQH2uOBSm2DHpTbBjkttgh2X2gS7B3sL7LjUJthxqU2w41KbYMelNsGOS22B3eBSm2DHpTbBjkttgh2X2gS7B3sL7LjUJthxqU2w41KbYMelNsGOS22B3eJSm2DHpTbBjkttgh2X2gS7B3sL7LjUJthxqU2w41LPwF7YiD5aXGoT7LjUFtgdLrUJdlxqE+y41CbYcalNsHuwt8COS22CHZfaBPv1LtVat2G3yZawm7Bjty5qwV74OXC8/lh2sP/CnsHeAPv1h6eD/Rd2A/YW2C3YW2B3YG+B3YO9BfYV7C2wB7C3wI5LbYIdl9oEOy61BfYVl9oEOy61CXZcahPsuNQm2D3YW2DHpTbBjkttgh2X2gQ7LrUJdlzqGdhLPysIuNQm2HGpTbDjUptgx6U2we7B3gI7LrUJdlxqE+y41CbYcalNsONSW2CPuNQm2HGpTbDjUptgx6U2we7B3gI7LrUJdlxqE+y41CbYcalNsONSW2BPuNQm2HGpTbDjUptgx6U2we7B3gI7LrUJdlxqE+y41CbYcalNsONSz8Be2qIt41KbYMelNsGOS22CHZfaBLsHewvsuNQm2HGpTbDjUptgx6U2wd7ApeZtsHNPW4P/eu1fIaXF9heS6y8kf3VIfnHba/tlLX1e3o2+T2DVPoHQ9wRCWrd7UEjRPL3yPfyoO/ykO/zcefh52ZakkG38c/hm0R2+0R2+1R2+0x1+5ytvKfzO191S+L2vuoXwe191C+H3vuoWwte96lrdq67Vvepa3auu1b3qXn8KvWz4ulddq3vVtbpXXat71bW6V12ne9V1ulddp3vVdd2vun5vU+X1a/jdr7rvw+9+1X0ffver7vvwu19134ff/ar7Nvyzj5G8v8nltzd7+1B/DHaLcYXXXvOaPkbHm/vfR/96yPplsItpG+zSU9h+WY7C9vsRx8bHx4PYlI5e2qSn05OfntqGw4d/i7X7aJ/20c4sPT9rdsv2PN06Yz6NvieLJ1lIlu8my0qykCzfTZZAspAsH8oUfpiTrj8ekWTRmyyJZCFZvpssmWQhWb6ZLNcfoEmy6E0WQ7KQLN9NFkuykCzfTRY6uCTLt5PFkywky3eThQ4uyfLtZKGDS7J8O1nos7RPFhMeybKkgvw+5i3s25+PSNz68UWCQDdEm6Rpv1v4ZyIPSelZqJN03xHBJ2cPJKWzMJyk+P/hJPVIOpqkeOnhJMXxDicp3yxSJ+kSd0ntciAp3/8ZTlK6R6NJGukeDScp3aPhJKV7NJykdI+Gk9Qj6WCSHh9XcJvhftUjfJPNx0W+5qK15qLDTshqtoRbrft00VEGPTZnTulpt9z08Q7x9HdIp79DPvkd8rKc/g7m9Hewp7+DO/0d/OnvsJ7+DuH0d4inv8PZn+l8vBPquu/rsPr45XaZj3fAXOO+GYRfDi5KNe90fMvZ1981+K8XHW9SuKZt+VuzO7jI1Fxkay5yNRf5movWmotCzUXHH4W9PlnzkU6p5qJccZFb3l8UloM5HW9btca8X5QOLjrMiGA2esHlg4tc4Z2OPk/HGyMVPoTH2xGVLqr5uB9v/mLsuk3K2HCAwpu6y2zdZa7uMl932Vp3Wai7LNZdluouy1WXrS+yJMX9sqcvdj4uM+XLwsFltu4yV3eZr7vsOEtu9m27zB3deI6/vly+LNZdluouy1WXHX81s3yZqbvM1l32Qrewy+3iwSpz/HjPPGo8s/qDT0B8gSTvnze/rAeXmfJlBx/TaOsuc3WX+brLYtVl6ZjkcyPGmYPLTN1lxyR9WPbLwsFN4fiY9tvYx9ziwSKcX8xt/yr8rRF0kJPZ1F1m6y47zhKf/f4JWI7m5usuW+suC3WXxRef7l231R58THOquyxXBBmXZam7zNRdZusucxX3ydtlvu6yte6yUHdZrrhzxcXU3Llul5m6y2zVZfHYr9ltauvXM+HicnxPLl1kai6yNRe5mot8zUVrzUWh5qJYc1GquagmI45XsjVvxVV4erTyuMjUXGRrLnI1F/mai9aai0LNRbHmolRzUf75RWZZai4yNRfZmouO7+mPh3C3Z4sHl724pxcvO76n35zKdtnzI7/HZbbuMld3ma+77HgtNmFHYtIRkhcWNT/8WD56t1x1mV3qLjN1l9m6y1zdZb7ushc1lF0exVA8uCzUXRbrLkt1l+Wqy4770OXLTN1lx1myPkzjmvLBZa7uMl932Vp3Wai7LNZdluouy1WX+Vd9q/0yZw8+b97WXebqLvN1l611l4W6y2LdZanuslx12brUXVaXJWtdlrzogbv98e3tg3xwC3rRAy9ettZdFuoui3WXpbrLctVloa7ACHUFRqgrMEJdgfHiV0vvT46//ddjAcKjlxri0bvlqstedNyLl5m6y44FiHH7/ZeJ2R5c5uou83WXrXWXhbrLYt1lqe6yXHXZi6cJxctM3WV1WZLqsiTVZUmqy5JUlyWpLkuOO1kmP5bFbI8uy1WXHfeYbDLb95psCo8b3vFXhZPbO6/JPT0zOh5d+IbuLSTXX0i+v5DW/kIK/YUU+wsp9RdS7i0ke9xTbRuS6S+k7u7edpG4e9v9O57Jm1ga/cPd1/bzc/yte3YwAa99Aqv2CQTtE4jaJ5C0TyArn4BZtE/AaJ+A1T4B7Sux0b4SG+0rsdG+EhvtK7HRvhLb7teBt7sx3ybQ+12o5Mjs9XehXjZPN/mxUcPy9fm2tQE0r9BE0LxCk0DzCk0GzQs0bgHNKzQGNK/QWNC8QuNA8wqNB80rNFTDL9FQDb9EQzX8Eg3V8Es0VMOv0Hiq4ZdoqIZfoqEafomGavglGg+aV2iohl+ioRp+iYZq+CWaeavhWxtvR+PtAZp5q+ESmnXeariIZt66pohm3hWq8IM8u867QhXRzLtCFdHMu0KV0IR5V6gimnn7NUU08/ZrimjmrWuKaDxoXqGZt19TRHNYDbtl/wG0W5729DqerDHB7L/ONsGW4Fi774Z2q9YfW3+529/3oKJEUOtj31oTno7OUN4rOd41Azh3OBk4L+Ec74ACnDscA5zXcCxwXsNxwHkNxwPnNZwVOK/hBOC8hkOF/AYOFfIbOFTIr+EkKuQ3cKiQ38ChQn4Dhwr5DRwPnNdwqJDfwKFCfgOHCvkNHCrkN3BmrpBvs9/guOXg21N55gq5CGfmCrkIZ+YKuQhn5gq5CMcD5zWcmSvkIpyZK+QinJkr5CKcmSvkIhwq5Jdw3EKF/AYOFfIbOFTIb+BQIb+B44HzGg4V8hs4VMhv4FAhv4FDhfwGDhXyaziGCvkNHCrkN3CokN/AoUJ+A8cD5zUcKuQ3cKiQ38ChQn4Dhwr5DZyZK+TCr3KdnblCLsKZuUIuwpm5Qi7CmblCLsLxwHkNZ+YKuQhn5gq5CGfmCrkIZ+YKuQRn4qOP3H48or01RA/QzLt5WBHNvJuHFdFMvClqwY1PfPRREc28m4cV0cy7lW4Rzbxb6RbRTLzZewnNxJu9F9BMfPRREc281XARzbzVcBEN1fBLNNfXNT87vD7mDc3tz8d0t8PrXYOjZn42gbRnwu3PfDCB1PsErNsn4OzBBLLyCTQ4XEV4Akb7BKz2CTjtE/C9T2CJ+wTscjCBVfsEel+JixPofiUuTaD7lbg0ge5X4sIEQvcrcWkC3a/EhQkc7wgU/RZR9OGriTje7+RhavKaDi5yNRf5movWmotCzUWx5qJUc9GhTmbZj5swS1i/XOaPf7FdvszUXWbrLnN1l/m6y9a6y0LdZbHuslR3WV2WmLosOf7Jyvt7hz/+KUfeb1PZHl1UcRvwx1/gLr1TqrkoV1x0/EXY0kWmAoS1NRe5mouOdQpbRuR4kEbHX0ArXRRqLirdrg8vSjUgcsVFx9+KKV1UkxGuJiNcTUa4mk+uW2suCjUXxZqLfpoRt3+ZXyOPf2+Tlr38e/rI/yoEvwwNfqv9wuqeh97iOr7dSb14+t0XT9vOlCGlP794/u0XX7YlZ/lz5Me3WZEXv/3D/hroD9N13Q/rXePTW3j3K6rjNvz7S+LPL0k/vyT/8JLbv9wfuX14oY8b52D904XmduHtn//vP/773/7xn/7+L/9xu+TXf/0///rP//m3f/vXj3/+5//3v7f/8k///re///1v/+sf/ve//9s//8v//D///i//8Pd/++df/+0vy8f//PebOvavcVnd//jj0/bfb+Ys/vVmcNb/8UeEt/9+M2VxsenXf/91gY8h/dXH+McFf1yxhHwbEc3jA/trnPV/tXkX+9dL3d7I2+1lVvPXNTww/HGF+au9/V//dZvk/w8=","names":["borrow_private"],"brillig_names":["discover_new_messages","decompose_hint","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","directive_invert"]},{"name":"_compute_borrow_rate","hash":"14396636064676253584","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"asset","type":{"kind":"struct","path":"asset::Asset","fields":[{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"loan_to_value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"oracle","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_borrowable","type":{"kind":"boolean"}},{"name":"optimal_utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"under_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"over_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"deposit_cap","type":{"kind":"integer","sign":"unsigned","width":128}}]},"visibility":"private"},{"name":"utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"precision","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"17134621154673181869":{"error_kind":"string","string":"Function _compute_borrow_rate can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VYy27TQBT1M42TVq1gwwp2bNjYseO4G1RQQ5q+EAKxAQlN/BAV5aEWEMt8Oh2YKx9uZ1pVsSM8UjVj3+Nzz33M2I1t/R2Dqz9brT24xwdh9tQcrjaiBrnCNnXaHdHpdESn2xGdXkd0+h3R2euIzo2O6Ox3RGfQoE4bdA6uLZR4eRDKQ0ZuYLk5ZOPJosqEBZpAB5p7n9RMeAfsDR5gUcD8NsmfhUmF8bagPw4U57AdfkH8m+3whxuKZ39Z82Ms5NdV83RZ53IKz/iAmQFmBhjkOQDMgYFnDpi5AXMImEMD5ggwRwbMMWCODZgTwJwwzJZa4wbdVxiyOWCbMpsLthfM5oFtxmw+2A6YrQe2ObNtgO2Q2fpgO2I23E/HzIbnCOVHcj206vUjq35GjlOFw9xRz7dx5lydCWVg/Zvzps+0+wb9cgxVHt6qa7m/dtRa/Pz88lv+tSifFcVFeXmJvcT35U3jLpybd+B8wDlPf5yfn1Vn5cX019nl92vcWxpuWjuWPjauC3E4dOeuHHtqDlcbfz4qMYbHapa1ew852eY5eV1+KcqL/6l0FgvFt8zHPA/7iZpl2B/UesvSl0w3y+Fq7lFZda+3Jr/nd26I1dbETvEHTA/mhvBzNctjdsQ4bfa8iZOwDnD5GkzANBA+VbOsz8LA6cBzqIteAVQDj+nbU9fhioP8Uh94oMfT6PEZ/imLi3LhavKBPITva/wGDIN++8yvvC4ZXlffAbuHeIrFVN+BIfbnoGFh4DTlwTZoRj89wLgMr+vJnoaf+56B5o9qrduHNvC/MWjF3sWakQ7dq7yN3qXYsIdcjR6ei1csLupNrJmt4aH7nsYv9jc/FzzmV9e7zi0aqC91NcOeoJptazjomSFo9Ja1vanPrUlW/0/sLutc4Oe0xfz7DP9OXeP+pXmV38CqiYiqWFRiLIoiycU9xm9BPoct+F+UURlXVRWXIqnSau3+yyIX6WSUxeM4TBJRrNv/KMvS3dEiTCZFXhVJvG7/aZJGWSayPM2r3SRfrNt/MhaTXEyiaDeJyiQa3+b/N2+7b5UQGQAA","debug_symbols":"vddta8IwEAfw79LXvsgld8ndvsoYo2odhVKl6mDIvvvS0QfNWnWH+EYSuZ/5m6ShOWXrYnn8eC/rzXafvbyesmq7yg/lto690/ciWzZlVZUf7+dfZ6b9cPa3fr/L67a7P+TNIXsBZ5EWWVGv27ZjE39jU1ZF7JnY/ltvrO3LDdqhWsJEMYoJXTEK+KHY00QxI3JXzOjxvPhtkTn3mPQifTmAPC89PiY98TD3fGPugUKfHrxz19MLOeyKJbo0PT06PdiL9O0Y/gljhCeMwZNjgIjrkTUAN8Ygw6Yrj02+sfUI+vxMzqSLJ5OBYogwBnLhRqAHPgto7pghJxeBWgY6ZnVs8rixAW1/fsS2GxeG3K9ClSKV8ioVZhTBoMiYRJGZVnF1B8VCqQKVsirlVArnFA1KrEsVqZRXqaBSrFKiUd6oFKjUzN4QG0blJVVOpVClSKXu2RshfSr93N6AcE2xSolGBaNSoFIzq0wynoce0x0VUKVIpbxKBZVilRKNYqNSMKd4VGevop2yKoX/31HfsfeZN2W+rIrubrU51quzq9bha1ckt65ds10V62NTtPev8eoF7QyxXwjEMND+8Rg3vmnEQeJAPw==","names":["_compute_borrow_rate"],"brillig_names":["_compute_borrow_rate"]},{"name":"liquidate_public","hash":"16153650548698769490","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debt_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"user","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debt_to_cover","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"1VzdbtpMEH0XrrnY+dnZ2b7Kp08VSUiFhEhEkkpV1HevTTEmAeN2ywzemwhHM5wz9h6fAQ/7PntY3r19+7raPD69zL789z5bP90vXldPm+bo/ed8drddrderb1+P/z0L7R+kXfzL82LTHr68Lravsy9AyHE+W24e2tekoXmPx9V62RyF5vVpfEDswgPjITqnM8GcQ9oHcwY5BEs8E6zMug9WFj4O/n8+Q74O+5y7cIDsxz5eh33Uw7nXkXMPMXXsQYgus8+ReB+cm7zP7OXa7AE/sG8xkgOGnsUImvslnaHPimS8KvIAHw09H5TLfIQ6BIn9Vc7SAlCwBgBrALQGIGsAtgaI1gBiDZCsAdQawFrJbK1ktlYyWyuZrZXM1kpmayXzNZSMAl0PhXLUKzTt4A4jOWCoA0a2x4jBAQMcMNABgxww2AEjOmA46Dw66Dw66Dw66Fys3Vus3Vus3Vus3Vus3Vus3Vus+3Cx7sPFug8X6z48WSs5WSs5WSs5WSs5Obh0cnDp5ODSycGlk4NLJweXVoduXB26cXXoxtWhG1cHnauDztVB5+qgc7V2b7V272zt3tnavbO1e2dr987WfXi27sOzdR+erfvwbK3kbK3k5vGfOQKYIzgYNQTyAGEPkOgBIh4gyQNEPUAc+nKA4AECHiAeigcPxYOH4sFD8WBt5wDJHEHNEcwdHc0dHc0dHdEcgcwR2BwhmiOYaxrNNY3mmjafP4OrDKCBhm44ERT0BMNc1eZDaGA+hQbmY2hgPocG5oNoYD6JBn80ipZpRBHC0kWL9EOxvMfI9hh/NJD2rxhwDYzG9g+D0I25xT783Ng0BYZ9NIX4Ybx3RwmnR4mmR4mnRylOj5JMj1KaHiWdHqV8C0q5iyZMHyidee8AqaeC9PmHBxBD9RVA9RVg9RVQ9RXcwqhIuv6Q6OhXXAMVJKIDlRRPK7iFrzF1b07MaawCDYcmLyiFkwpuYYMM0FegYxVkiD2VqCcVpOor0OoryLVXIKH6CqD6CrD6Cqj6Crj6CmL1FVTvyVK9J0v1nizVe3Kq3pNT9Z6cpuUHO0rTusHvKE3rjr2jdItbcMTuWSHF0Y+mzZOSfrsQRjqpQKuvINdegYbqK4DqK7jOhwpS7lECHlewQ2EXlOiCIh4oA3PczIcsjv21R/n9WHVgOPtyFg4MXI9lQVEWFmVRUdb5VdcPDTZfCvTfuvI+KZYkSUlSLkgaGDO9+LQdB8ZGR5JSCT0tSSo5EQMzhSNJUJKEJUlUklSyYLFkwWLJgsWSFTEw63Z57Q2Mr11OGphIG0mCkqQSEVKJCAdmu0aSYkmSlCSlv0362Rx9X2xXi7v1cr+v5ePb5v5om8vXH8/LTztePm+f7pcPb9tlu/dlv+1le26QwxxzbMi0RWOWOcXQWmG7GEB1Dpnaw/YyQ+bmUBoODY9f","names":["liquidate_public"],"brillig_names":["liquidate_public"]},{"name":"public_dispatch","hash":"15796637203358491633","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"951653053333916160":{"error_kind":"string","string":"Deposit cap exceeded"},"1602191554767750373":{"error_kind":"string","string":"Function _borrow can only be called internally"},"1840251649407153602":{"error_kind":"string","string":"Insufficient borrowed amount"},"2830029349304997821":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"4270187767586857285":{"error_kind":"string","string":"Function _compute_total_collateral_value can only be called internally"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5235018679007078561":{"error_kind":"string","string":"Invalid asset or market id"},"6787403583199288031":{"error_kind":"string","string":"Insufficient balance"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8945853978429536226":{"error_kind":"string","string":"Function _compute_collateral_debt_value can only be called internally"},"10435052277855889085":{"error_kind":"string","string":"Function _withdraw can only be called internally"},"12348881442450494403":{"error_kind":"string","string":"Function _compute_utilization_rate can only be called internally"},"13135008234568508716":{"error_kind":"string","string":"Function _repay can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14434150440419769526":{"error_kind":"string","string":"collateral >= debt"},"14687457983715723088":{"error_kind":"string","string":"Asset is not borrowable"},"15333773746166717806":{"error_kind":"string","string":"Insufficient collateral"},"16022896159229267359":{"error_kind":"string","string":"Function _deposit can only be called internally"},"16523063005220065570":{"error_kind":"string","string":"Function _liquidate can only be called internally"},"17134621154673181869":{"error_kind":"string","string":"Function _compute_borrow_rate can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["public_dispatch"],"brillig_names":["public_dispatch"]},{"name":"add_asset","hash":"11834025396239255184","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"oracle","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"loan_to_value","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"is_borrowable","type":{"kind":"boolean"},"visibility":"private"},{"name":"optimal_utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"under_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"over_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"deposit_cap","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["add_asset"],"brillig_names":["add_asset"]},{"name":"get_total_deposited_assets","hash":"5683334450854991164","is_unconstrained":true,"custom_attributes":["utility","view"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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6HGzYuhxs2LocbNS6ANuVgw9blYMPW5WDD1uVgy9nxm98xt6l2Lt6JhX8u62sPoE3txRTu1O26Kc2m22RTm1e2yLcmo32Bbl1O6uKco4tVtri3Jq99UW5dRuqi3Kqd1RW5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKhNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKjNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKgttphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxHKvOB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFsuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mEsiy4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4nZaoTS4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4na+i9K7xX4c7V2In1DujMSnFYkJ5mkkeW/ccckfB0f79Mk5/BbJ4qM6EAmH1oFIeL8ORMJVdiCSRyT9IuGEOxAJj92BSLj3DkQiF+hAJBIH/SI5EocORCJx6EAkEocORJo7ccjr0c7b8Ono33A8cI7hzO2wK3DmdrYVOHM7ygqcuZ1cBc7cDuocjp/buVTgzO0YKnDm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","names":["get_total_deposited_assets"],"brillig_names":["get_total_deposited_assets"]},{"name":"repay_public","hash":"6617397857723808533","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"1Z3dTuNIEIXfJddcdP11V8+rrEYIGAZFiggKsNIKzbuvnYmdMDHxbsfHct+gmHTV+TA+Xe24Gj5WPx7v359u188/t6+rb399rDbbh7u39fa5Ofr4dbO63603m/XT7em3V6H9wrIf//py99wevr7d7d5W30hY7Wb1+PyjfS0emhw/15vH5ig0r8/HB+ZueFDuR+c0MFhzSIfBmin2g6MNDHZVPwx2jXo6+PvNinUa+py74UR5Pnqbht68P/c+cu7JUkdPUeQyfTbRw+DcxP1JH6emJ/5E32qkGTR8SINTkEMMJ6Y+xmRAwIKHw+DmpY9cE0YdvJuEP89qHqZh62nULtNMeIVKGKSJlnuawJdpLv+4QmgBRgsIWkDRAoYWiGiBhBZwtEAGCyjayYp2sqKdrGgnK9rJer2TOVI/OJ7U/GZZt1eIcIUEV3C4QkYrWIArEFyB4QoCV1C4AtzTBve0wT1tcE/b9Z6O0i21ox1vvXJs08eATU/Y9IxNL9j0ik1v2PQRmz5h0zs2Pda1CevahHVtwro2watvglffBK++CV59E7z6Jnj1TfAVtcNX1A5fUTt8Re1wTzvc0w73tMM97diq7Niq7NiqnLFVOWOrcsZW5YxdS2fsWjpj19IZu5bOWNdmrGsz1rXNsztw/ut9Sx66J6Lk5GcKDP4JBJxfwfkNnD+C8ydwfgfnBzuYwA4mAucH+5fA/iWwfwnsXwL7l8D+JbB/ady/0UcqWMgxdiUsZD92fNi+G4Y4zKBBM2jw9RoNaN8tRXzadzPUWyVB6TBagn3qu9kDydKAdGlAtjSguDSgtDQgXxpQXhiQhPmBcjdamuSnQEPzKKXQz6MsesZPlfNz5fxSOb9Wzj9/UZLYrQFFThq6v+BPIj1/snP++WuYSndGRTWN8Xs4ruP8rKWNZP6Sp0RHfh/jz31HXvPa/IzfK+fPdfNrqJyfKufnyvmlcn6tnN8q54+V81def7Xy+quV11+rvP5a5fXXKq+/tqT5fw+0pAl9D7SkGXoPNP+Ua9w9lxcbveVs7mmO+4GV5Yw/180fQ+X8VDk/V86vE/CL61Hj9Knn78dz0WbQiDNopBk0hudTp+5vbrDLyGPlCf8mAH2xp8JD6HF0rLv1dLB/Oj+twhfbKqZUILgCX69wuQeYvthgMamE4iUMLxHxEgkv4XiJDJfwgJcgvATe3Y53t+Pd7Xh3+/Xuvth15Qmc38H5MzZ/DuD8BM7P4PwCzq/g/AbOD/ZvBvs3g/2bsf7lEMD5CZyfwfkFnF/B+Q2cP4LzJ3B+B+cH+5fA/iWwfwnsXwL7l8D+JbB/CexfAvuXwP4lsH8ZfkfMTHgJxksIXkLxEoaXiHiJhJdwvAT88y4WvLsF727Bu1vw7hZwpRZwpRZwpRZwpRZwpRZwpVbwSlvBK20Fr7QVvNJWsH913L8+9jA3ar+dIcbjbgY9KES4QoIr+PUKU26xY80LA7KwNCBaGhAvDUiWBqRLA7KlAcX5gSbcWciWKuf3yvlz3fwxVM4/f1Gacmctx/lr2JQ7aznOX/Km3BnAUSvnt8r5Y+X8qXJ+r5w/182fQuX8VDk/V85fef39D73hy+avvP6myutvqrz+psrrry9p/t8DLWlC3wMtaYbeA80/5U65s5DdKuePlfOnyvm9bv48xS3D5d2inGkGDZ5BQ+AaMtwaTap9lNrxd9584vE7KhZFpaIoL4rKJVHDjcSjUYPXGx1bcSjy8bNTPQRxSZCUBMWSoOHzd/G5uAz3cY4FaQHecAvhWFDJiRhu8xsL8pKgXBAkoSSo5IKVkgtWSi5YKbkixAquPYklQakkyEuCSkyoJSZUKgnikiApCdL/G/SrOfr7bre+u988vjYx7Zvvzw9v6+3z4fDtn5funfvderNZP92+7LYPjz/ed4+3m+1D+94qtF9acdF005TPBqa9zjTITVMJvrf/UaQ55Gw3EkJ72J5HCdQcSsPQcPwL","names":["repay_public"],"brillig_names":["repay_public"]},{"name":"_withdraw","hash":"1964877185147257566","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5235018679007078561":{"error_kind":"string","string":"Invalid asset or market id"},"6787403583199288031":{"error_kind":"string","string":"Insufficient balance"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"10435052277855889085":{"error_kind":"string","string":"Function _withdraw can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"15333773746166717806":{"error_kind":"string","string":"Insufficient collateral"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1d3Yuk2Vk/9dnTNV1d1dMzO5PRvyCK1FdXVytCh53N7mbdbLLBD5CA1dXVcWCTXWZnQxQM5UUkCIIg3igB8UpBEQ14IwYMiCBeCIFEBcGbgIkQkIiseKFzZt6n+9e/+r2n37fqPTXVPX2geavqnPf5Os95zvOc85zTJfesVJ/8leCzLzU3X6zNYfLsLFe6BcLqxKSzdEnoLF8SOiuXhM5qJDrPDS5PtO84L5SqSy/G3J2NZ8/N5HsZ6gsUbHeT8BYJf9TZ620K/gqkv7+ZwKzHgb9n8DfiwO8Y3DdnZ/CRF6uvJM+3ZmeyfAve8brWTD6XzpqcwrW6MtR9kuoqbh621aHOforqUM8/ndTdePK3484+/2jyeZNojKFvyGfR/bUr6C8Db768PDuTh+Htd4aDwXS/N+32u+NO7+BotNcZ7B0NR91Rd2+0d9wb9fvT0WC0f3B0sN856A760+7J3kH/JMFrsB/MovDVN/ivAHxXoNwM/sfj0H8K/9XZvOw7SxaD/Voc2Zza4NfjyOYU/icKl81wZLDfKB72scH+meVh9/iHm+6ZXfpuYtjMlm2coTo3xvHp3JmtxN/MDrQFLBtXhudGgXgQ1quEZ7MAPGZTG1B3mDw7y5Vem+hEPFsJj76Mv/j5t96bvHs8/djx8aPp+++XiK+GoF+VPDBv5oB5j2F+8oN33nl48nD66JUvPXz/8RzsLQHbPped5o3pwnZYaoTjx5On15P/qJ7R3GKaPzP9wvH00TqJ1hErNUHTTaqztt3k6dn+AQ1zFqkvm4K2As3wIMuwQ/wNwWuR00KJ8Bk9LB9Ts6abV117t011vpgpKom6ivitvGJYTTfPP+sC8lpkWJFVFwx/w0XVzW5IrjeFXE12TUFrm+p84f5rCjxNgecywTI3hceJwVdPw8O/pekvjs2QLVsUj7KroXGyKB6EZSEB61QReBCWuWA2treh7jB5dpYrXYPdAtqKG6fdjsmo7eaL1e0A7i2quwV1rEe7UMd9fxvqmlR3B+q24TOXCn1HOfk5+j9hjuZ2Vl50+VbhM5ci5Nty8/JFG4+yqQo8vtg4q1H7d5On9SHKscilAOwDR7heJP1ZREd+rHYGl9tZUTqyRXVtwYfV7Qg+1DzXojqcm9pUh37RDtUhL7iEw/NQxc33nS3JtFz6/MjfOUbxJc1/rabA4zFk7b+SPH1fHUNfKXp8iezHZo5prv3Y1cAK+Z6bbp7X5xHTGP6Gi6qb3ZBcVaxoslNzX9vNz3Pcfy2BpyXwXCZYHNPE8M3VfBYj1lDzbYwYzReOaVoF4lG+lo1tnHcL9Gu67LtgUb4L+7BZfRfuH/R9W1T3EtSF1iiVz2Nyyht3xFmLy+83snxR9ixflD3LF2XP8kXZ1+AzFyVfk1PeuKMh6DE7puIO9LHYZ7L230ye6xB3vAj6s4iO5Ik7GoIPFXfcpDoVd6m5qEF1OH9w3IG+C8cdaKcve9zxT8lzTeKOgyxzJ+K/jjuuYV1VWLH3G0x/I++PjoyPOtBlfrT/7YeAtwQ019yZ7OqC7hq1/3b1DOZ/J7+1qA3LgO1qhdr7wjYbaWmQDCPt6fZCelUW9LQEr+wbqJgv7jrqMz4Qn/GBvyH+hpu3pzHsu4ql1XhlfwzfbYu6rZXIdXE/sSTaX7SW/LkMPh3bLsafJnMcdw9mz54tQbO9G1lf90pEu6IV8St/dYdkotYMIscwmced4W/ElWs3JFe1hqXiGfbLsa69Erl2e0wXFhVn5Y2lMNU6z7hD/dslWUTq02FJyCLLWMG+uUV8hMbKrTh8ZB4rhn9VY0XJNTRWdgWtbVG3sxK5dvtMF5Yi1h2M7rxjBfXvNskiUp/ul4QssowV7Jtd4iM0Vnbj8JF5rBj+VY0VJdfQWLktaG2LulsrkWt3wHRhCa2hZx0rRnfesYL6h/iz6DKv27UEPU16D+mIHKdm1mXO4411hK9E+JRcnQvbfc7DUL5I5Ngkt91HeXIpMjZBPbpNbXENwn/HmL9Gddb27dIZHe8mjfLkzof4xhJ5bjrNdbwdB34/i41G/Gr9qJTyNFhcx/NPpGOlwfkH6ed1ubQYIQ3Wbk5Ykf2A0z5tBfhWdl7RqviwfQ01dyD8NBpCeRH11cvrdIzdiQP/tD9uC1kgT4Z/2XwGxLUqH0/xFupn5eOFYN3OCWtd7WZW37ZGfMTRze6Q8zywWN1d+M3W363uHtBVp/c+EnjvPryX1182Wfi5/VEOHwP17C7VoeyNJ57bfTlMnp0Fy353OO0cHJ/aHMyvKbBf91XfsTyw7/L2gdHt++BrOfoA9djwq3kE+2OReUStXajxeYfo5d9Cc7zxW5nN021HbatQV6Td9XL/Q8oRwDFcm52vQz2oJ3VtqmPZpNnil4QsWm5+jPH6DeKJsR+ndAT1wPBvubO+O40DXh6/846jwhc34Z0T/L3k5gPlOyAkFu5uCg5VTGAGB4tnxpg8O2P8wWTyJKh5+d33fqXkNI38uyoe9l2G/fb08QePvnA8fjz+zMNfnTKYVgr4igCv1lXQh2G9DfkCpn9oT+1d0797RM9h8r2zXOmF7AbqvOG/QKy+11iTdoFdNqMvQZ0jFpXGlOm7bf/be60APPwcWaz9kApgNyN+fDqnXWODZ65xJBfx1DW+J+gPubPID/KZButeTljKHWI8u4AjNAXysstfJIL2ruAfJ59V2gdP72XBVznAV9oSlf9T6WEhk6FS11eRepHGtzqeJW+SeHv6xemjx47KRaZDrQJnNR2+W62LmYWq06pi5oVV5S8TOJFXkmXGMGffPocV7oVvqli3Fe7rmyqub6rgFSt89/pU17wsSylPw8O/pekvjs2QLVsUj5orQuNkUTyhmypWfarLl8Pk2VmujNYt4yl0soT1CEMM7nt0F/lEE0Y8mPnE5aIMqzwnxtblRB7LF2UfynJg+WY9kZf3poq8J/JUBiWvEJlsqgKPLzbOatT+v8j/i5RBJv0/zhx5EfRnER3Jc2JMZVqrrEIOv9SpODXP8akwnJs4+xT9Is62y3tiDPuOTx+o+ZG/c9zjS5r/mvfEWCMBen1ThR6ALF+jh+VzVf3YkO+5imx9xGd84G+If1U3VSi5hm6qyHK6xBfuv7bA0xZ4LhMsjmli+OZqPrtqN1W0C8SjfK11PWmR13fh/kHft011GHeoTS4rRcYdcdbi8vuNLN8ibgJh+aLs895UYXLKG3eUBT1mx1TcgT4W+0zW/tWk0TrEHS+C/iyiI3nijrLgQ8UdnPGu4i41F4XmD4470HfhuAPt9GWPOz4r4g6diPD43Ufjzz3ZqRofl1LoZP3gdiFbjjSp9nZTal7ayhlp20ppl8Xvxltci95aZJqU3234V+V3bxM9LJ9QDGbvhnzFyHI9UT6vI5rVGkhW+2d0L3Nygufs56B/gxdJ/3y5LGsAyD/rwrqtAUTSzeAawLaQ6/UawHzdqtYAVhGbY7+HxsmieBDW814D8OUweXaWK4N1PZ2edw2B+17tXapseYwruKi5HU/D51lfuAzrN6EYkOWbdf0m775m3vUbFR/y+oLJpirw+GLjrEbt/4TWFyKdWpPrC3z66UXQn0V0JM/6wo7gI7SGoE5ChOKXPGsI6Bfx6bHQ+oLyfbHveH1BzY/8ndcEfEnzX6sp8HgMWftvBvY1n4MfmzmmufZjVwMr5HvGzenIHtMY/lWdwFVyVbEirw3ju203P89x/6lbwnYEnssEi2OaGL65ms9ixBpqvo2VQ8kxzU6BeJSvtW5xB/uwWX2XUM4k31CIcUfeNcVF4444a3H5/UaWL8qe5Zs1Z5Lli7LPu69pcsobd4Ru4lRxB/pY7DNZ+/9bo7jjRdCfRXQkT9yhch9V3LFNdaFbXNT+hJo/0nImEb6y05c97riTdCDGHes252xQHertDapDvd2kOrR7HIPjkdI3ZufrPgLvqbndykXz0T/n2ONC3eQbVdRtDire4eOvOI7xZoA8+8Rp8zG3S7MZyp5Zm3W9LTJSvkzwti6UTygPPnSjztZK5Jr/tkieTx3xjwXpXub2b74t0mjwsq2J9rzHzjcVHSbfO0sW1oEq0KNyBmvU/qcq5/myMV9x8/4SwimRXBAv2tAtwnuH8Po++b36eVntFiyr/tHBeDI+k9XtC3jk27VuAQ9KthVqfxtk4tz8eOS51Np/DGTytUQmeW5gDI0LLC3BQz2FB+fCVwK0xft8i02kW+K6kW/J6fOYQFkgT2k3Y1m9ehosrjNcq7pqQ/EW6mcc22wTFayXcsKKe8vXWZ/eCfCtfB9Fq+KjtBI+8t1W5ovFDcon5Vvo7gfe+xF4D+XFRc3DeANanlvocHzcozrUQeOJZe/LYfLsLFj6485Bd39/P+4VPt0D7h8n5HFfyDRrHxjdeW+hQxtr+NUNUsvaBHVNU0XguUv08m8Vd153EJfxi7fQof3xpQp1RdpddQsdjtPa7Hwd6kE9qWu7+THMNkjJXV171HLpct8UeIqOp7iPVF8b/mi30HEweReExAboTgoOVUxgZTc/QPPeQoc0OPGZYee8he5WCviKAM9zoiPyWG9D4970D+0p2/H7RM9h8r2zXOmF7AbqvOFf4BY6vs9QXW7H76RpTJm+21aSvXcrAA8/RxZrP6QC2M2IH5/OadfY4JlrHMlFPHWN7wv6Q1MX8oN8psG6nxOWcnkYzx3AwaEK4qm581bldxKBe1fwN5PPLTdveXiaUaa7FOBLucr2WS19h0yGOrayqlvoFN9qO3mJW+jYdKC4yinvpJkO363WxZFP0uW+R5lXoNO8Gi7Ku8UTcX9QP4PL7ZgelC3fZR0nI6m7x8PZCbrShksWWeDpmK/nkAXqheHPswoVohNLy83Ll1ehlElQ2VpqFWo7gOf2knjUrmjkm3Fy6YsvHLmj68ERf9aVgrwRP96M82jB3SteiUHTzvcV4/8oOUyenQXLsD86Go0Hk8i7mbl3P1DHuVy0g5gn4kc9NvwtQQP2B/dBRfwWOsFST3kP6UFcKoMvLZvzaZvZPN3PI+LHgLM2O1+HesARf2jFXmW2ql1AZQ9RFownhvukdAT1wPBHi/h50mqDkNImkisW8ddTwIci/rSsSNbbimjP+of2dEU7Rr2Q3UCdN/wLRPzbwC6b0VCEvkjEXw/Aw8/P8981pf3LRXw6pyP+Vf9LJrUpFDo8nJaUkAbrTk5Yyh1iPNuAIzQFcsT/PYj4/y0Q8fP0XhJ8lQJ88fv4OWsCvnI77N1V/DvlNL7V2F4i4mfTgeIKDfW0iP97FPHH+a+B+T3YLHneaqJT3q3xtEzEz3vPkSL+3HJSZjIki0Uj/npAFtj+MHl2Fiy9g+O98ah3Evk/tkaXs9GdN6JCvcKFWqYBzXfsBc3I5rOfxdSHpjyrV0+DxXV8jiz2mcKsUajKKefpcdGzfggr8nm+4H9LRVnzWYIsZyl5LCwjE184zz1rX7XcfP+ss8thOYuQgz1+/HBSRKyMps1/b7gzUXF3tVJwqBJyX9YsVm6kgA/FymkWDHvOuWxaqHp9VWs1oXUlxL9ArNwEdtMGW1GxciMADz+v6t/gKhXAbual9osmPYO3qklPxfpZt0zY2C/z74t5kmkG8DQBR8XNW7e0WLmfZHJ7R/mjyWcVK28TPmXASwG++H38nPXiAqMLTdaKHIPgxKXG9hKxMpsOFFdoqKfFytbFm25efM8zNmlSnbqLSU10Km4xnoqIlXlIGU7ufj6viHJt0ntNQav/XHM6TlK4G0QfwmD1xLM7FYFbrQfEOLtjfOAZmm1BT43av1Y9z2sbZFFz6eOCTQriZdOAeFuEF8/ulAhHGg18tkb1UTlAs/Feh/bYhk24tX8TaP4rohnfUTTXU2jOeo+2tf800PCNuoaZppMsN9wpzSLnMtBcE3xxX1v7nwv0dfkCGvismOpr9X/ZSkRT3Wnd4LNl1v4XRV9X3LxMjR6XwDLbxudYf/7Rw8dTR4UnF77IoyLaYWHj6uDzpiC2wHk68+VM9lvDzXdgDJ+yQvSwfMokO6XAnArkCy8C5E1RiA2r6eb5Z12Is3if/XImw99wUXWzG5JrRcjVZNcQtLapzhfuv4bA0xB4LhMsvpwJZVlKeRoe/i1Nf3FshmzZoniUHQqNk0XxICxbM2CdKgIPwjIHgf9hsi+HybOzXBlG/sdlxxxvY1EbHpxyqPaF1UIx9z1eDNGgurSD6lxUcJT3YqJNgadA+U74EgIsaq2D5avWEpTsWb4oe5Yvyj7vhbMmp7wXP1UFPSWCWRV0+WLjrEbtf5+C/UhjRF78xJdqVOPgPmq6edtipSn4Zv1B3WL94bVFrEPdUsvmVpSOmCzyXvxUFXxYHQchWMf97oua56pUh/3J/4AT5wK+MArnAL74Sfm+2He8kKLmR/7OQZkv7GcYb9UUeDyGrN2fQ5DFFz+ti03ki59Qb/niJ9RbvvhJbU6yTfTlE7PzdTj+816Uh/Yyz8VPqH+8eKgu91KxFF/mhuMY127zXPyE+prGQ8hmGC018a7p3Qb8XvS6NtOkYiTD33DzfR4jRtogelg+HCPdELS2Rd2K5Jp7jso7hozuvBc/qfm6JGhQi168iGU0pC1i2bs1av+twCJWiWiwsvQiFgc8JdEOi+84dRzThKZW9usEAw0O04Hv5jU4iJPxKdzK4DzlYXZWbzxGPjNy4Dv9b2CHhmVUA7xolJ2b33Bzbl7h1M3POMnxAgo6/k2qwwHCQV1Z4MH+57NmOAnZu/63HyafY8p9f/RsR+YprQl823niUoV6bP/9ZNDyJGaT7+GCdJ7sj7sn/fHJeG98fDyYjNVtDSavmxHwH0270/7JyUl/Oh6cDE9Wjv+gc9yZdCa94bh/1BseHV+E34+f79JGvVostroNotM+48SIv+PE+8rs2bNG7T+kIHOT8B8uKAsuKsjcJB42gAc1Dh/MzvNg7W8lCu7b/m9AnoZbyZMTE26QHLAO6eZ+wF3QCsFSPJxmASQ8+LbfoV1vtO3GT2TbPlC2Heddtu3qP52qhWBrvyXaY0BmMlP2u0awagIWyvx1otVkWBftER7vQDahj/6lfp4+1OsG0Y68s0NbEXitDnVrE2j+KAWykTZdTu9IQDtiRTnrJarDcRLaCOHFGdSDvAt4eNIiz+JMEXai6s7jW5dxazh94XGrNnCwPY/bi8a5bU603Xxfsn6ruSDPmPHldcKH+mJ9g2OG510VsBsP/r2fqJ3Bw35E+47vPpid1WP7j8Mc1U0+t5y2Z1infE2llzxHKb1U8xfrPfZ9SB/UAqS1i+xLDEIbX5EX9zJvRBv+htP27rAYerqhcak2+CNvJgyMnlDWG9LjY7ZtN99nSB9mntlvbC9Q9mxnVKaWmn/ZzihbgmsJylcvESxlJ9S4U4kEaFfMzrHv+wbYlSOyKxuEA+vQPrBd4XGLdajH7Psqnw79MJ5LlI4oP09tkjQzwNoI4FZ36TQDuEP/wYKPnig9Vj6BySayT7CnfAK0F+wThHxzX7LIUvWjSiDndRocxzweEW9oQ4ttg9qcxfHCPgCOR/QBil4v6PSOJ8Np78mSzv6w2zvItV5QIr6dm1949YU35FCGFXoPZYjt0jKbFW61aGww1MJ1zPWYwWg8HO1NOge9SWc4GnfzyPeqJCWxbcf+Yfut1kHLATwqs/gif/rLNY0zbZ7kTWJr/xsw7/16LZ1H3mjneRppLgX4UePmpqDrq2Idx3wuXlM6TL53liunh7XURpvyYUr0Hdujz8BzYFnAUr4Gy1ytEShfg9vljUXw/c0MsJR/8Bzn6ad3cP1rhjU3NYfXZ+dlgT5IlpgttI4Vsg/KR1XzKe6TfBnGiNlbNQfxXKPmmND8p9qa/+7LxgzenZ218+Xm7DxcbOPcebv6lBeou5kB1s0ArM0ArEZGWCHcSGuV4G8l3+sp8DepfTP5XoX2G4KeGsH/U7Df36idb2Mw/wzafJ3W8mqAg/tuG+tEexwP3N549Tj/GtZZfWkBnqLtdxrdqAuGX8mglPJEWPib4WoQrKJtWpF9EoK1nRGWyRP713/++9X0dY95KDs9zgz/qX2OQ8+p7rVmYZka/iJ0z3CtSvcUbyHdw/asewpWKyMsk6fSt2YcGfTZrrsUGSB+/I7tEUaV2m8T/b7gPMPzkpIj4kR4vrRF+0agvX3H3AiE0YB6bP8diCV82YF37H3Vtzsp9JZS8KfJA9srvfK68480F9ahnfVRWjyLPqPhXsWaMOJzTq+ZG/6Gm/dhY6yZZ13nUkm7nDSNa4CcvKzWJpsCz6pgqQRl1gXk9Xnsnxj+houqm92QXLeEXFWSNq9h4noo91/eO9wvAyw+yMfr4eppePi3NP3FsRmyZYviSVuzTxsni+JBWLYuxjpVBB71X7Ej32jY4YMIWNThLE78VwfjrA5vCuD+yfrf3/PmkuANinkO20U6LHWicmwd8Yv5sSxflD3LF2XP8kXZs3zT7nrnouSLB6kWPWzHBwiNhqyH7az9XVqrjXSTpcyD5IuPXgT9WURHFj1s16S6uuBD3aSY5uMhfDV/cF66yj1XdpoP212U08F7e1XBV4z/OfKs7O0zLhtTah+Vv/NBPV/MJ+GDsL+VvPR0L5bGafGH0oc9o3UrwBfzbG2/ArT24tM6WIbWXwNah/FpHS5D6wdA60+CUoX0zxc77Mg69XmA99PxeT9ahvcp0PqxHLy/MdO8fxbgPYjO+35nGd5/Fmh9LT6t/WVofZPoixRDSx+C86GMXnXo3Bf2g6z9p5JGeGCa88BLgFvlgXOsrPLJVB640epJ+N16Mfz8whXj55euGD+/fMX4ee+K8fOlK8bP7Irx89Urxs9vrxk/TarDd1TeGF/moXKmmkQL0hgjD3I4GHZHo/FoMpycHAwmR6s+F7s37XeP+gcHnf5kejA+PlnkXGxabirWOTefR4SwVR5xJQUWnkFFOjkP39r/Efl+kdZwpO9XTeEB5YG5Ww9mz56hS3qa4j1rF/niz8wXmZzuAzvdr4fF0NPNKle2O1VBq8qdZVuGPKaNixBNSl9fxPzv3mg0POgddQb7x5OT40F/1XbveDCZjLon45Ph/njveDi9CL+tDeJ+Pue2WW4d5tthe863s/Z/C3H038Hc9rStwOebfDvQrpTyfApD/Fadnf8N89pUfqW1P90Hns3TaHWYN1UjPJYPgfJCWEYH5yd+K+Fd5Xfa+22B/wbhV/ma+FuWfE2V3+nJ+4eExlXlUdUJPv7GtJnuxBhXk73h0WSwN+5Mu/5rb9Xj+gnq/cl4v9s9GHSng+5e1nFtY9GX63zjZ2VV+cb/Dvbvf+rn2xjM70ObH2SwkUZTUfnGH4IP6ct1vnHustb5xh+CftWSQPE63/g633gV+casb+uab4x2Hec/e5dt9u7GeThKXjiH2Vx0mrMHdQ2qw9zfLaL31myeXoTVInpvEb029yqdbwv8WfKhQ/nFO6L9jmjvdWWLZFoX72L/mky9r/P/Vn24FTApAQA=","debug_symbols":"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","names":["_withdraw"],"brillig_names":["_withdraw"]},{"name":"_borrow","hash":"10849207798355343169","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"1602191554767750373":{"error_kind":"string","string":"Function _borrow can only be called internally"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14687457983715723088":{"error_kind":"string","string":"Asset is not borrowable"},"15333773746166717806":{"error_kind":"string","string":"Insufficient collateral"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_borrow"],"brillig_names":["_borrow"]},{"name":"_compute_total_collateral_value","hash":"5406095720403625163","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"4270187767586857285":{"error_kind":"string","string":"Function _compute_total_collateral_value can only be called internally"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_compute_total_collateral_value"],"brillig_names":["_compute_total_collateral_value"]},{"name":"compute_total_deposited_assets","hash":"17653211887319463285","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"deposit_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["compute_total_deposited_assets"],"brillig_names":["compute_total_deposited_assets"]},{"name":"get_total_borrowed_assets","hash":"8026617118609794729","is_unconstrained":true,"custom_attributes":["utility","view"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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6HGzYuhxs2LocbNS6ANuVgw9blYMPW5WDD1uVgy9nxm98xt6l2Lt6JhX8u62sPoE3txRTu1O26Kc2m22RTm1e2yLcmo32Bbl1O6uKco4tVtri3Jq99UW5dRuqi3Kqd1RW5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKhNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKjNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKgttphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxHKvOB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFsuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mEsiy4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4nZaoTS4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4na+i9K7xX4c7V2In1DujMSnFYkJ5mkkeW/ccckfB0f79Mk5/BbJ4qM6EAmH1oFIeL8ORMJVdiCSRyT9IuGEOxAJj92BSLj3DkQiF+hAJBIH/SI5EocORCJx6EAkEocORJo7ccjr0c7b8Ono33A8cI7hzO2wK3DmdrYVOHM7ygqcuZ1cBc7cDuocjp/buVTgzO0YKnDm7tQrcOiQT+B44BzDoUM+gUOHfAKHDvkEDh3yCRw65GM4gQ75BA4d8gkcOuQTOHTIJ3A8cI7h0CGfwKFDPoFDh3wChw75BA4d8jGcSId8AocO+QQOHfIJHDrkEzgeOMdw6JBP4NAhn8ChQz6BQ4d8AocO+RhOokM+gUOHfAKHDvkEDh3yCRwPnGM4dMgncOiQT+DQIZ/AoUM+gUOHfAxn8re4V+DQIZ/AoUM+gUOHfALHA+cYDh3yCRw65BM4dMgncOiQT+DQIR/DmfzN3xU4dMgncKbukL17wKnuqWHSuu+FXR6fbLPbOTZvPLIrlWPLplApn4/9LdDUXXoPAnkE0i3Q1G6lB4Gmdkw9CDS1a+tBoKmdYw8CTe1e9Qt04z21he5Coal9fBcKESZoV4g0QbtCfmqF8rbJbfamppDN27a1zvnH0WYXSTCb+iEvn46+k587J5AkP3cAIEl+bmcvSX5uyy5Jfm4vLkjezO2xJcnP7Z0lyc/tiSXJz+11Jcl7yAuRx8NKkcfDSpHHw0qRx8NKkcfDCpG3eFgp8nhYKfJ4WCnyeFgp8h7yQuTxsFLk8bBS5PGwUuTxsFLk8bBC5B0eVoo8HlaKPB5WijweVoq8h7wQeTysFHk8rBR5PKwUeTysFHk8rBB5j4eVIo+HlSKPh5Uij4eVIu8hL0QeDytFHg8rRR4PK0UeDytFHg8rRD7gYaXI42GlyONhpcjjYaXIe8gLkcfDSpHHw0qRx8NKkcfDSpHHwwqRj3hYKfJ4WCnyeFgp8nhYKfIe8kLk8bBS5PGwUuTxsFLk8bBS5PGwQuQTHlaKPB5WijweVoo8HlaKvIe8EHk8rBR5PKwUeTysFHk8rBR5PKwQ+YyHlSKPh5Uij4eVIo+HlSLvIS9EHg8rRR4PK0UeDytFHg8rRR4PK0S+4GGlyONhpcjjYaXI42GlyHvIC5HHw0qRx8NKkcfDSpHHw0qRx8PKkL+BhLwQeTysFHk8rBR5PKwUeQ95IfJ4WCnyeFgp8nhYKfJ4WCnyeFgh8gYPK0UeDytFHg8rRR4PK0XeQ16IPB5WijweVoo8HlaKPB5WijweVoi8xcNKkcfDSpHHw0qRx8NKkfeQFyKPh5Uij4eVIo+HlSKPh5Uij4cVIu/wsFLk8bBS5PGwUuTxsFLkPeSFyONhpcjjYaXI42GlyONhpcjjYYXIezysFHk8rBR5PKwUeTysFHkPeSHyeFgp8nhYKfJ4WCnyeFgp8nhYIfIBDytFHg8rRR4PK0UeDytF3kNeiDweVoo8HlaKPB5WijweVoo8HlaIfMTDSpHHw0qRx8NKkcfDSpH3kBcij4eVIo+HlSKPh5Uij4eVIo+HFSKf8LBS5PGwUuTxsFLk8bBS5D3khcjjYaXI42GlyONhpcjjYaXI42GFyGc8rBR5PKwUeTysFHk8rBR5D3kh8nhYKfJ4WCnyeFgp8nhYKfJ4WCHyBQ8rRR4PK0UeDytFHg8rRd5DXog8HlaKPB5WijweVoo8HlaKPB5Whrxd8LBS5PGwUuTxsFLk8bBS5D3khcjjYaXI42GlyONhpcjjYaXI42GFyBs8rBR5PKwUeTysFHk8rBR5D3kh8nhYKfJ4WCnyeFgp8nhYKfJ4WCHyFg8rRR4PK0UeDytFHg8rRd5DXog8HlaKPB5WijweVoo8HlaKPB5WiLzDw0qRx8NKkcfDSpHHw0qR95AXIo+HlSKPh5Uij4eVIo+HlSKPhxUi7/GwUuTxsFLk8bBS5PGwUuQ95IXI42GlyONhpcjjYaXI42GlyONhhcgHPKwUeTysFHk8rBR5PKwUeQ95IfJ4WCnyeFgp8nhYKfJ4WCnyeFgh8hEPK0UeDytFHg8rRR4PK0XeQ16IPB5WijweVoo8HlaKPB72NeS9TeXjaO+CrRxtfNo+O5incee9WcYlfxwc7ZM0OXxoijseTtOE7x5PUxz9eJqSFYynKSnEeJp6NB1OU5KT8TQlkxlPU9Ke8TQlRxpPU3Kk4TTN5EjjaUqONJ6m5Ejf1tRtAzFxcRWVrF2Wj6Otd581vZMn7ZEi7yEvRJ7kRIo8+YYUeVIIKfJkBVLkcfRC5Au+W4o87liKPB5WijweVoq8h7wQeTysFHk8rBR5PKwUeTysFHk8rAx5t+BhpcjjYaXI42GlyONhpch7yAuRx8NKkcfDSpHHw0qRx8NKkcfDCpE3eFgp8nhYKfJ4WCnyeFgp8h7yQuTxsFLk8bBS5PGwUuTxsFLk8bBC5C0eVoo8HlaKPB5WijweVoq8h7wQeTysFHk8rBR5PKwUeTysFHk8rBB5h4eVIo+HlSKPh5Uij4eVIu8hL0QeDytFHg8rRR4PK0UeDytFHg8rRN7jYaXI42GlyONhpcjjYaXIe8gLkcfDSpHHw0qRx8NKkcfDSpHHwwqRD3hYKfJ4WCnyeFgp8nhYKfIe8kLk8bBS5PGwUuTxsFLk8bBS5PGwQuQjHlaKPB5WijweVoo8HlaKvIe8EHk8rBR5PKwUeTysFHk8rBR5PKwQ+YSHlSKPh5Uij4eVIj+1h81hI18W/+noOx0PnRM6U3vBKp2p/VqVztSeqkpnat9TpTO1N6nRyVP7hyqdqXv8Kp2p+/AqHXrlMzoeOid06JXP6NArn9GhVz6jQ698Rode+YROoVc+o0OvfEaHXvmMDr3yGR0PnRM69MpndOiVz+jQK5/RoVc+o0OvfEzHL/TKZ3Tolc/o0Cuf0aFXPqPjoXNCh175jA698hkdeuUzOvTKZ3TolU/oGHrlMzr0ymd06JXP6NArn9Hx0DmhQ698Rode+YwOvfIZHXrlMzr0yid0LL3yGR165TM69MpndOiVz+h46JzQoVc+o0OvfEaHXvmMDr3yGR165RM6jl75jA698hkdeuUzOvTKZ3Q8dE7o0Cuf0aFXPqNDr3xGh175jA698gmdud/JXaVDr3xGh175jA698hkdD50TOvTKZ3Tolc/o0Cuf0Zm6Vy4mbHRi7WiT8sfB9mkHVZvdzrF545FdqRxb8jrkUj4fe1do6n69B4XmfgdyFwpN7VtKWoftjV8qR9vk7CpRKs9Hpz2NbtenVSRr4qej7+Sn9kSi5Kf2W6LkPeSFyE/tE0XJT+1BRclP7W9Fyc/tnSXJz+2JBcnP/a5kUfJ4WCnyeFgp8nhYKfIe8kLk8bBS5PGwUuTxsFLk8bBS5PGwQuTnfleyKHk8rBR5PKwUeTysFHkPeSHyeFgp8nhYKfJ4WCnyeFgp8nhYIfJzv69blDweVoo8HlaKPB5WiryHvBB5PKwUeTysFHk8rBR5PKwUeTysEPmCh5Uij4eVIo+HlSKPh5Ui7yEvRB4PK0UeDytFHg8rRR4PK0UeDytDPix4WCnyeFgp8nhYKfJ4WCnyHvJC5PGwUuTxsFLk8bBS5PGwUuTxsELkDR5WijweVoo8HlaKPB5WiryHvBB5PKwUeTysFHk8rBR5PKwUeTysEHmLh5Uij4eVIo+HlSKPh5Ui7yEvRB4PK0UeDytFHg8rRR4PK0UeDytE3uFhpcjjYaXI42GlyONhpch7yAuRx8NKkcfDSpHHw0qRx8NKkcfDCpH3eFgp8nhYKfJ4WCnyeFgp8h7yQuTxsFLk8bBS5PGwUuTxsFLk8bBC5AMeVoo8HlaKPB5WijweVoq8h7wQeTysFHk8rBR5PKwUeTysFHk8rBD5iIeVIo+HlSKPh5Uij4eVIu8hL0QeDytFHg8rRR4PK0UeDytFHg8rRD7hYaXI42GlyONhpcjjYaXIe8gLkcfDSpHHw0qRx8NKkcfDSpHHwwqRz3hYKfJ4WCnyeFgp8nhYKfIe8kLk8bBS5PGwUuTxsFLk8bBS5PGwQuQLHlaKPB5WijweVoo8HlaKvIe8EHk8rBR5PKwUeTysFHk8rBR5PKwM+bjgYaXI42GlyONhpcjjYaXIe8gLkcfDSpHHw0qRx8NKkcfDSpHHwwqRN3hYKfJ4WCnyeFgp8nhYKfIe8kLk8bBS5PGwUuTxsFLk8bBS5PGwQuQtHlaKPB5WijweVoo8HlaKvIe8EHk8rBR5PKwUeTysFHk8rBR5PKwQeYeHlSKPh5Uij4eVIo+HlSLvIS9EHg8rRR4PK0UeDytFHg8rRR4PK0Te42GlyONhpcjjYaXI42GlyHvIC5HHw0qRx8NKkcfDSpHHw0qRx8MKkQ94WCnyeFgp8nhYKfJ4WCnyHvJC5PGwUuTxsFLk8bBS5PGwUuTxsELkIx5WijweVoo8HlaKPB5WiryHvBB5PKwUeTysFHk8rBR5PKwUeTysEPmEh5Uij4eVIo+HlSKPh5Ui7yEvRB4PK0UeDytFHg8rRR4PK0UeDytEPuNhpcjjYaXI42GlyONhpch7yAuRx8NKkcfDSpHHw0qRx8NKkcfDCpEveFgp8nhYKfJ4WCnyeFgp8h7yQuTxsFLk8bBS5PGwUuTxsFLk8bAy5NOCh5Uij4eVIo+HlSKPh5Ui7yEvRB4PK0UeDytFHg8rRR4PK0UeDytE3uBhpcjjYaXI42GlyONhpch7yAuRx8NKkcfDSpHHw0qRx8NKkcfDCpG3eFgp8nhYKfJ4WCnyeFgp8h7yQuTxsFLk8bBS5PGwUuTxsFLk8bBC5B0eVoo8HlaKPB5WijweVoq8h7wQeTysFHk8rBR5PKwUeTysFHk8rBB5j4eVIo+HlSKPh5Uij4eVIu8nJu/NdrQ3JX46+k5nZp9ZpzOzF6zTmdmv1enM7KnqdGb2PVU6YWZvUqczs3+o05m5x6/TmbkPr9Px0DmhQ698Rode+YwOvfIZHXrlMzr0yid0Ir3yGR165TM69MpndOiVz+h46JzQoVc+o0OvfEaHXvmMDr3yGR165RM6iV75jA698hkdeuUzOvTKZ3Q8dE7o0Cuf0aFXPqNDr3xGh175jA698gmdTK98Rode+YwOvfIZHXrlMzoeOid06JXP6NArn9GhVz6jQ698Rode+YROoVc+o0OvfEaHXvmMDr3yGR0PnRM69MpndOiVz+jQK5/RoVc+o0OvfEwnL/TKZ3Tolc/o0Cuf0aFXPqPjoXNCZ+pe2Ru30klm2aEzda9cpTN1r1ylM3WvXKUzda9cozP1+77rdKbulat0pu6Vq3Sm7pWrdDx0TujQK5/RoVc+o0OvfEaHXvmMDr3yCZ2p3ytcp0OvfEaHXvmMDr3yGR0PnRM69MpndOiVz+jQK5/RoVc+o0OvfEJn6veX1unQK5/RoVc+o0OvfEbHQ+eEDr3yGR165TM69MpndOiVz+jQK5/Qmfo9iXU69MpndOiVz+jQK5/R8dA5oUOvfEaHXvmMDr3yGR165TM69MondOZ+b1+VDr3yGR165TM69MpndDx0TujQK5/RoVc+plM6SN1jWo8OMbtnOvcZdNDtLw99l/hlBo0SSOvWwnAu5coMXCzLenRenj87fQzKaByU1Tgop3FQXuOggsZBRY2DShoHlTUOqigcVNB4RQ8ar+hB4xU9aLyiB41X9KDxih40XtGDxit60HhFDxqv6FHjFT1qvKJHjVf0qPGKHjVe0aPGK3rUeEWPGq/oUeMVPWq8oieNV/Sk8YqeNF7Rk8YretJ4RU8ar+hJ4xU9abyiJ41X9KTxip41XtGzxit61nhFzxqv6FnjFT1rvKJnjVf0rPGKnjVe0bPGK3rReEUvGq/oReMVvUhc0XPaji6L2RmU1ziooHFQUeOgksZBZY2DKuoGZZdl0TgoIzwoY3cGJXFFz9vjYq7Y5dOgvh6dt0emsns8MWV/PaP15dhbe/hx7K0uPx17n6ybabJ+psmGmSYbZ5psmmmyeabJlokma5aZJmtmmuxMHZSZqYNq9P6CTiY7Uwdlxuqg4nrsbZx2Z7ZjtVC12Y7VQ9VmO1YTVZmtHauLqs12rDaqNluJPqrYtM02pMpsz38jeJuB634GvvsZhO5nELufQep+Brn7GZTeZ+CW7mdgup9B9/fkRntFS85A/x3tdOeB2wx2r6b2tsi+PdhxW7F99I9hr300S1wbU2PM044UYW8zhMeLyu1Tr+ms2Tk2Fb8KkEp57kz9HppgPw725jFVu+wda01ZwVj7NMFfR9/JFMjsk9nfrQIyt/9nIHNAxkLmgIyDzAEZD5kDMgEyB2QiZA7IJMgckKEHPiJDD3xAJtADH5GhBz4iQw98RIYe+IiMh8wBGXrgIzL0wEdk6IGPyNADH5GhBz4gE+mBj8hM2wPbXNZhuOcniTYy0/bAVTLT9sBVMh4yB2Sm7YGrZKbtgatkpu2Bq2Sm7YGrZKbtgWtk0rQ9cJUMPfARGXrgIzL0wEdkPGQOyNADH5GhBz4iQw98RIYe+IgMPfABmUwPfESGHviIzLQ9cDLbMJJbdshM2wNXyXjIHJCZtgeukpm2B66SmbYHrpKZtgeukpm2B66RKdP2wFUy0/bAVTJNemCT80rG+lAhE8K2YXso4enoZe+zY1mb+PQ021+ffB+/63z8vvPxh87H/53ezLoBrwy158dKgswBmQyZAzIFMrtkzLJA5oCMgcwBGQuZAzIOMgdkPGQOyATIHJChBz4iQw98RIYe+IgMPfABGUMPfESGHviIDD3wERl64CMyHjIHZOiBj8jQAx+RoQc+IjNtD1x5ss6YaXvgGhk7bQ9cJTNtD1wlM20PXCUzbQ9cJeMhc0Bm2h64SmbaHrhKZtoeuEqGHviIDD3wARlHD3xEhh74iAw98BEZeuAjMh4yB2TogY/I0AMfkaEHPiIzbQ9c+XWJcdP2wDUyftoeuEpm2h64SmbaHrhKZtoeuErGQ+aAzLQ9cJXMtD1wlcy0PXCVTJMe+OrvQGO2/nH07u9AU1wf5kjPrzeO+WP8pe/xh6Xz8ZvOx/+d3szXxh+TX8cfS/n0LTt/k7f/ev2bNPlxdNx7B7cpfjOxi0nnByezXUbi01zD3rF+M8fBLJ+OvXNxs3Ix24/UXdrh4uGyyyXAZZdLhMsulwSXXS4ZLrtcykhclgeXUuHi7NbtOGce3Y5zu65jSZtHWZ7G7HY7qWzWMWfnK8fGTZ/o4qdjf+vzrfd5oY+cPgZ9vqXPZhduUi07HIfyC4Ich/IXghw9HJtwHMq/CHIcyu8IchzKHwlylPBTYeP4O5V/oLkPqagbUlr0DcnoG5LVNySnb0he35B2b+63YWS/Dck8XWvm+Sn0/mueIHMjkyBzQCZD5oBMgcw+mf3XPEHmRsZA5oCMhcwBGQeZAzIeMgdk6IGPyNADH5GhBz4iQw98RIYe+IBMoQc+IkMPfESGHviIDD3wERkPmQMy9MBHZOiBj8hM2wPXfj5fpu2Bq2Sm7YErZOwybQ9cJTNtD1wlM20PXCUzbQ9cJeMhc0Bm2h64SmbaHrhKhh74iAw98BEZeuADMoYe+IgMPfARGXrgIzL0wEdkPGQOyNADH5GhBz4iQw98RGbaHriyuZY10/bANTJ22h64SmbaHrhKZtoeuEpm2h64SsZD5oDMtD1wlcy0PXCVzLQ9cJVMkx746jaYoYSno3e3wYxlbeLT02zNx8/krS19j98tnY/fdD7+7/RmNg94Zag8P2adg8wBGQ+ZAzIBMgdkImQOyCTIHJDJkDkgUyCzT8YvkDkgYyBzQIYe+IgMPfARGQ+ZAzL0wEdk6IGPyNADH5GhBz4iQw98QCbQAx+RoQc+IkMPfESGHviIjJ+VTO3JujBtD1wlM20PXCUzbQ9cJTNtD1wlM20PXCMTp+2Bq2Sm7YGrZKbtgatkpu2Bq2Q8ZA7I0AMfkaEHPiJDD3xEhh74iAw98AGZRA98RIYe+IgMPfARGXrgIzJ+VjK1X5ekaXvgKplpe+AqmWl74CqZaXvgKplpe+AamTxtD1wlM20PXCUzbQ9cJTNtD1wl41uQufo70Jjt4yem+78DTdv7tlN6DOPXa3nv4w+djz92Pv7U+fgPerPHM0Q362hq49fy2nvzeO3901x3X3vvN3MczPLp2DuXMisXs/1I3aWvXI7eqTU9FwOXXS4WLrtcHFx2uXi47HIJI3FZHlxKhYuzW7fj3NOGLM7tuo4lbR5leRqz2+2kslnHnJ2vHBs3faKLn4696xPRR7U+SUCfsOnz252e61PsOtnbv93DBNjy0aqX3P8USu9TcMvS/xRM/1Ow/U/B9T8Fr3sKPpU1/fPZ5Z0JhN4nEHufgPL7cn0Cyu/K9QkovydXJ2CU35HrEzi4H9tQtgm4pwWX2wTu59mL57mL5/mL54WL58WL56WL5+WL55Wj8/LjvKf753re0Z781fN29TMuL2ktYVfi06ahy7Jr3FzcjNvz0sAS9o4udv1wV8JTQLHslXxIy/q3d/vnYyQhfszA65+BfczApq8zCN3PIHY/g9T9DHL3Myj6Z+DjNoPgn2ewc2P320Cs9/7LdPe3vR53umau6dq5pttBH9Fyun6u6XbQobScbgftTMvpdtD7/Gi6Nj+m+9UwuA4apZbTHa2rOp+uH6yrCmHbgCtEd35wXJZt4XIxX//Q/WAt2E/YhJLKKZvB+rVg3MYmmfOD87J+cPZPcaVfPtAM1tu1RONBc4RmsJ6xJZrB+suWaAbrRRuiCaN1Nj9BE9anyHKKn9DsLai5dcy3tbXHB3u7d3B+LOx9OvSOfLSGqQPkM/dhQshn7u+EkHuQvxv5zP2oEPKZ+1wh5DP3z0LIB8uTe0A+WKbdAfKI+3w7ctzn25HjPt+OHPf5buSJKv8e8qXYDfnTo8e7yHNeB1GMrXywuX33+sm3f6enbYrWB/kTfxb6NfJopF4jYh/9GpET6deIYEm/RiRR+jUiulKvUSbr0q8R4Zh+jcgZ9GtEzqBfI49G6jUiZ9CvETmDfo3IGfRrRM6gXyNyBvUaFXIG/RqRM+jXiJxBv0bkDPo18mikXiNyBv0akTPo14icQb9G5Az6NSJn0K6RX8gZ9GtEzqBfI3IG/RqRM+jXyKOReo3IGfRrRM6gXyNyBv0akTPo14icQb1GhpxBv0bkDPo1ImfQrxE5g36NPBqp14icQb9G5Az6NSJn0K8ROYN+jcgZ1GtkyRn0a0TOoF8jcgb9GpEz6NfIo5F6jcgZ9GtEzqBfI3IG/RqRM+jXiJxBvUaOnEG/RuQM+jUiZ9CvETmDeo38yH9H+fzgFNdjU/pE/U5m5Or9c2Q8ZA7I9JAImQeZymTPPvo+3x7SlZbz7SGpaDnfHlx/y/n24KAbzjf04EZbzrcHZ/f9+frFlY+D/VJK5aOd35pB5/PTsMPH3Sv00AvK0emhH5Sj46FzQmesvrA1nbG6yNZ0xuo5W9MZq0NtTWesfrYxnS7ePy9Hh175jM48vfJ9vvN0v/f5+snmO0+Hep/vPD3nfb7zdJH3+Q7WF5ptQcM74ysfnRf/cXB2DzY2u51jS14/uJTPx945DtZBSnFMg/WaYhwH60rFOA7Wv4pxHKwvFuPo4diE42B9vBjHwfyBGMfBfIcYR/xMG474mSYcM36mDUf8TBuOfjCOZl1/8Mbu5FtdvBu+5XxH68dq8x2tb6rNd7T+pjbf0fqQyny7eC91y/mOdl+vzXe0PLE239Fyv9p8/WTznay/6uL9si3nO1l/1cV7T1vOd67+KnTxPs6W852rvwpdvCey5Xzn6q/C4ieb71z9VejivXot5ztXfxW6eN9by/lO1l918R6ylvOdrL/q4v1YLec7WX/VxXubWs53sv6qi/cJtZzvZP1VF++5aTnfyfqrLt6/0nK+k/VXXbwXpOV8J+uvunhfRcv5TtZfdfEehZbznay/6mJ//5bznay/6mLf+Zbznay/6mI/9Jbznay/cn6y+U7WX7nJ+is3WX/lJuuv3GT9lZ+sv/KT9VddvCej5Xwn66+6eKdFy/lO1l8N9qaK+nwn668Ge1NFfb6T9VeDvamiPt/J+qvR3j1Rne9k/dVo74eozney/mq0dzhU5ztZfzXaexaq852svxrtXQjV+U7WX432voLqfCfrr0Z7X0F1vpP1V6O9r6A638n6q+HeV1Cb72T91XD7/9fmO1l/Ndx++rX5TtZfDbc/fW2+k/VXw+33XpvvZP3VcPun1+Y7WX813H7ktflO1l/lyfqrPFl/Ndn+7WGy/dvDZPu3h8n2bw+T7d8eJtu/PUy2f3uYbP/2MNn+7WGy/dvDZPu3h+H2b3/Ze5XieuwNgf108B0kL0JsBJI3ITYCyasQG4HkXYhNQMbhNt8XAznPW8nv853n7eH3+frJ5jtPF3qf7zzN4n2+8/R09/nO03rd5ztPh/R7vsPtcl+b7zxvX77Pd7L+arhd7mvz9ZPNd7L+arhd7mvznay/Gm6X+9p8J+uvhtvlvjbfyfqr4Xa5r813sv5quF3ua/OdrL8abpf72nwn66+G2+W+Nt/J+qvhdrmvzXey/mq4Xe5r852svxpul/vafCfrr4bb5b4238n6q+F2ua/Nd7L+arhd7mvznay/Gm6X+9p8J+uvhtvlvjbfyfqr4Xa5r813sv5quF3ua/OdrL8abpf72nwn66+G2+W+Nt/J+qvhdrmvzXey/mq4Xe5r852svxpul/vafCfrr4bb5b4238n6q+F2ua/Nd7L+arhd7mvznay/Gm6X+9p8J+uvhtvlvjbfyfqr4Xa5r813sv5quF3ua/OdrL8abpf72nwn66+G2+W+Nt/J+qvhdrmvzXey/mq4Xe5r852svxpul/vafCfrr4bb5b4238n6q+F2ua/Nd7L+arhd7mvznay/Gm6X+9p8J+uvhtvlvjbfyfqr4Xa5r813sv5qos3o7/OdrL+aaGv3+3zn6q/SRBul3+c7V3+VJtu/PU22f3ta/GTzHay/iq6s882Lq3z0j17skNcZlvL52DvHwfo2MY6D9YNiHAfrM1/H8fyFLWm0DfLFQI62874cyMFabjmQg/XyciAHMwlyIP1YIPP20T77GsgU3cfBKT2m6O0HmsGMSks0g3mPlmgGsxMnaO7zHaztr853sO68Nt/BXq8QjA/rwSbuxFODvV6hPt+xWtL6fMfqHOvz9ZPNd6yurT7fsVqx+nzH6q/q8x2rv6rPd6z+6nm+1tiv8x3s9Qr1+Y7bX+3Pd9z+an++4/ZX+/P1k813sP7qFthsB+eyM9/B+qvqfAfrr6rzHay/qs53sP6qNt/BXq9Qn+9g/VV1voP1V9X5DtZfVefrJ5vvZP3VYK9XqM93sv5qsNcrhOyW9eASc+WjfdngPD8Kne3Osb+e9P84+NeqzHZ0/OA4WN8mxXGw10HIcRysz2zE8c5msJ60KZvB+tembDxsDtkM1hc3ZTNYD92UzWD99o/Y3CL89WCfd9jM3JvX2Mzcb1fYDPbKj7ZsZu6La2xm7otrbGbui2tsPGwO2czcF9fYzNwXh7D1xXmnLx7sNSlt2UzdF1fYTN0Xn7MZ7FUtbdlM3RdX2EzdF1fYTN0XV9h42ByymbovrrChLz5mM09ffJ/vPL3ufb7z9K+/5zvY623q852nz7zPd57e8T7fsfrBuCzrQKKLZme+frL5jtW31ec7Vi9Wn+9Y/VV9vmP1V/X5jtVfVec72Ott6vMdq7+qz3es/qo+38n6q8Feb1Of72T91WCvt6nPd7L+arDX29TnO1d/lQd7vU19vnP1V3mw19vU5ztXf5UXP9l85+qv8mCvoanPd67+Kg/2Wpf6fCfrrwZ7SUp9vpP1V4O9cqQ+38n6q8Fe4FGf72T91WCv2qjPd7L+arD3Z9TnO1l/Ndj7M+rznay/Guz9GfX5TtZfDfb+jPp8J+uvBnt/Rn2+k/VXg70/oz7fyfqrwd6fUZ/vZP3VYO/PqM93sv5qsPdn1Oc7WX812Psz6vOdrL8a7P0Z9flO1l8N9v6M+nwn668Ge39Gfb6T9VeDvT+jPt/J+qvB3p9Rn+9k/dVg78+oz3ey/mqw91HU5ztZfzXYuyDq852svxrsnQ31+U7WXw32boX6fCfrrwZ7B0J9vpP1V4O9q6A+38n6q8HeKVCf72T91WB7/9fnO1l/Ndge/fX5TtZfDbaXfn2+k/VXg+15X5/vZP3VYHvT1+c7WX812B7y9flO1l8Nttd7fb6T9VeD7d9en+9k/dVg+7fX5ztZfzXY/u31+U7WX022f3uebP/2PNn+7Xmy/dvzZPu358n2b8+T7d+eJ9u/PU+2f3uebP/2PNn+7Xmy/dvzZPu358n2b8+T7d+eJ9u/vUy2f3uZbP/2Mtn+7WWy/dvL4sear8/rwTEYuzPfwforlzZ9bydWPjov/uPg7Mp2rM1u59iS1w8u5fOxd46D9W1iHAfrB8U4DtZninEcrH+V4jjavvtiHAfrt8U4DtbHi3EczB+IcfRwbMIRP9OGI36mDUf8TBuO+Jk2HPEzTTiO9p4LMY74mW9yjOuxNwR2BySGphFIHE0jkB6QbUDiaRqBxNQ0AjlYFxlyWUFGUwNpwm1VfJ1muCVg2/HxTme0dzic0LnPd7A7ZnW+Y93YUkrrwSk99ej7H21TDB9H25Tc80ff4Yx1s2oMZ6wbUGM4Y0VljeGMlX81hjNWO9IWzmBvtGgMZ6z4qTGcsfrYn8IpdoWTn7rADc5YTW9jOB44x3Bm7pCdXVZz5axNX+HM3CFX4czcIVfhzNwhV+HM3CHf4CxncAZ7Z8UP4XizHu28Xb7CmbnPqcLxwDmGM3WfU4MzdZ/jSt7gmOX8o0NJ660tlLJz9Z66KfoJybhs98G47BiTwd4N8p6a3Cc5dbvl3daL+mD+3F/3YO8zeQ/J3Zoc7E0pPyW5PSrhfMlf4cxtASpw5rYAFTgeOMdw5rYADzjh6SmqDc7UFqAGZ+quvgZn6ka9Bmfq3ts9BhJMOv9oE/PqB03yT5vD+OWOcrCXv/wQZdq2znGpuD9nYwZ7rcwLSdZCisFeWPOemtwn6acmuX20+8Mi/c6FcinbA9/GLTsXyqn73Gz9hrJUPtpvRLz9fMfZwf6I5MwtTt+Odhv2qTtoOexT9+Zy2Kfu+uWwT+0nxLAP9iKobrBPbfnksE/tD3+E3a320D/PcAM5tT1sCXKwH523/YnvaK/BakxnsE2vGtMZbCurxnTYWuCEzmiv72pMZ7DNpBrTmWdbiit05tnE4godPzcd5x90gn2is3+0fTo6fmE5eWfdlOXkfXhTlpN37T9g6c2W53j79JjFSnLyDr8hycndQCuSbhntxXSCJCd3GQ1JTu5IGpKc3L00JOkh2YgkPqcVSVxOK5J4nFYk8TitSM7ucY5SiZ3PztsvFpJ7+pH2wWffFiI/jr5hf3rZ702v3+RHeylhR+Rn91BtyN9Zzu6iWrKc3UedJMQ3Om36ULO9icBZWyp0TF7WTUpNNs8syy6d5UFnic907jNI+mdgHzP4slnZbQa5+xmU3mfQ6OVfkjMw3c/A6p+Bj48rdeUnZtZvtwzrvf86XTfXdP1c0w1zTbeDPqLldDtoOlpOt4MOpeV0O2hnGk7XddD7/Gi6Nj+m+9UwuA4apZbTHa2rqkx3sK4qhLVntiH+qY02bmz8vGzOt864sRmsXwvGbWxSZZ/JvKwfnP3TmO+/G7uhGay3a4lmsD6wJZrBesaWaAbrLxui8YP1oi3RjNbZ/ARNWIeRU/yEZueDjXusVD5tsfxrO7yvBz9231o+HXpH7kH+buQz92FCyGfu74SQz9w3CiGfuR+VQR5nbuZ+gnx5vF7SPD3isIs853UQxVQ3Kbp99/b4R07pcbwt+UOjwdLQITUaLMIdUiPcmX6NPBqp1wj/p18jDKN+jXCY+jXCkurXaOa1mk40SuQM+jUiZ9CvETmDfo3IGfRr5NFIvUbkDPo1ImfQrxE5g36NyBn0a0TOoF6jTM6gXyNyBv0akTPo14icQb9GHo3Ua0TOoF8jcgb9GpEz6NeInEG/RuQM6jUq5Az6NSJn0K8ROYN+jcgZ9Gvk0Ui9RuQM+jUiZ9CvETmDfo3IGfRrRM6gXSOzkDPo14icQb9G5Az6NSJn0K+RRyP1GpEz6NeInEG/RuQM+jUiZ9CvETmDeo0MOYN+jcgZ9GtEzqBfI3IG/Rp5NFKvETmDfo3IGfRrRM6gXyNyBv0akTOo18iSM+jXiJxBv0bkDPo1ImfQr5FHI/UakTPo14icQb9G5Az6NSJn0K8ROYN6jRw5g36NyBn0a0TOoF8jcgb9Gnk0Uq8ROYN+jcgZ9GtEzqBfI3IG/RqRM6jXyJMz6NeInEG/RuQM+jUiZ9CvkUcj9RqRM+jXiJxBv0bkDPo1ImfQrxE5g3qNAjmDfo3IGfRrRM6gXyNyBv0aeTRSrxE5g36NyBn0a0TOoF8jcgb9GpEzqNcokjPo14icQb9G5Az6NSJn0K+RRyP1GpEz6NeInEG/RuQM+jUiZ9CvETmDeo0SOYN+jcgZ9GtEzqBfI3IG/Rp5NFKvETmDfo3IGfRrRM6gXyNyBv0akTOo1yiTM+jXiJxBv0bkDPo1ImfQr5FHI/UakTPo14icQb9G5Az6NSJn0K8ROYN6jQo5g36NyBn0a0TOoF8jcgb9Gnk0Uq8ROYN+jcgZ9GtEzqBfI3IG/RqRM2jXyC7kDPo1ImfQrxE5g36NyBn0a+TRSL1G5Az6NSJn0K8ROYN+jcgZ9GtEzqBeI0POoF8jcgb9GpEz6NeInEG/Rh6N1GtEzqBfI3IG/RqRM+jXiJxBv0bkDOo1suQM+jUiZ9CvETmDfo3IGfRr5NFIvUbkDPo1ImfQrxE5g36NyBn0a0TOoF4jR86gXyNyBv0akTPo14icQb9GHo3Ua0TOoF8jcgb9GpEz6NeInEG/RuQM6jXy5Az6NSJn0K8ROYN+jcgZ9Gvk0Ui9RuQM+jUiZ9CvETmDfo3IGfRrRM6gXqNAzqBfI3IG/RqRM+jXiJxBv0YejdRrRM6gXyNyBv0akTPo14icQb9G5AzqNYrkDPo1ImfQrxE5g36NyBn0a+TRSL1G5Az6NSJn0K8ROYN+jcgZ9GtEzqBeo0TOoF8jcgb9GpEz6NeInEG/Rh6N1GtEzqBfI3IG/RqRM+jXiJxBv0bkDOo1yuQM+jUiZ9CvETmDfo3IGfRr5NFIvUbkDPo1ImfQrxE5g36NyBn0a0TOoF6jQs6gXyNyBv0akTPo14icQb9GHo3Ua0TOoF8jcgb9GpEz6NeInEG/RuQM2jVyCzmDfo3IGfRrRM6gXyNyBv0aeTRSrxE5g36NyBn0a0TOoF8jcgb9GpEzqNfIkDPo14icQb9G5Az6NSJn0K+RRyP1GpEz6NeInEG/RuQM+jUiZ9CvETmDeo0sOYN+jcgZ9GtEzqBfI3IG/Rp5NFKvETmDfo3IGfRrRM6gXyNyBv0akTOo18iRM+jXiJxBv0bkDPo1ImfQr5FHI/UakTPo14icQb9G5Az6NSJn0K8ROYN6jTw5g36NyBn0a0TOoF8jcgb9Gnk0Uq8ROYN+jcgZ9GtEzqBfI3IG/RqRM6jXKJAz6NeInEG/RuQM+jUiZ9CvkUcj9RqRM+jXiJxBv0bkDPo1ImfQrxE5g3qNIjmDfo3IGfRrRM6gXyNyBv0aeTRSrxE5g36NyBn0a0TOoF8jcgb9GpEzqNcokTPo14icQb9G5Az6NSJn0K+RRyP1GpEz6NeInEG/RuQM+jUiZ9CvETmDeo0yOYN+jcgZ9GtEzqBfI3IG/Rp5NFKvETmDfo3IGfRrRM6gXyNyBv0akTOo16iQM+jXiJxBv0bkDPo1ImfQr5FHI/UakTPo14icQb9G5Az6NSJn0K8ROYN2jfxCzqBfI3IG/RqRM+jXiJxBv0YejdRrRM6gXyNyBv0akTPo14icQb9G5AzqNTLkDPo1ImfQrxE5g36NyBn0a+TRSL1G5Az6NSJn0K8ROYN6jezIHjafH5ziemxKn6j/JuNGdo5/jszIfu3PkenBJZkHmcpkzz76Pt8eHEfL+frJ5ttDJ9xyvj10lS3n20OH1nK+Payq/GS+Yb3NmWJd5aONL2U9Ojz1grePvsPpoRWUguN76AbF4PTQEL4Kjs1pax9zKZWj3c15rZN05tGZriRHayDlSI7WmsqR9JD8LkkXy0YypyeSX4/1ZqPurUlfqI/WevdBfTQD8DPq2yxtMUvl6LzNMbvHFG12O8eWvA6jlM/H3qmPZkP6oD6zGZKjPrPLEqMeZrZvctTn9oVS1Of2kFLU5/abUtQ91AWoz+1NpajjTSWo400lqONNJajjTQWoR7zpS6jH9dgbMLuDHXMqgh13KoIdeyqC3YNdAjsGVQT71A61PFahlyp249PGMpinz857I4nLumgd7RO+HD64T+1RBblP7VIFuU/tU+W4p6mdqiD3qa2qIHcP99dw9+vBMZgd7vQzL+K+/Rw4xrzDnX7m29yD2YYdnP/E/c6SHqUZyy5eft4LS3qJdiynzrJ/eJ/aBnJjGSr3qdvXZ/8YSvnynH4Xrwgfk7yHvBD5qUNtUfLk2lLkZ3aCbnFpI19qA6n8sq2LF2T3QXJmZ9eUZBcvm9ZB0pgYNigmPm0/Z8zeNnGV33R38QrpMcnP7Bllyc/sGV9Mvt0v8Lt44TMqzexFf6pSstuHm7K4iko2pe3xrfS0HeVKfmYvKkseLypFHu/6KvJNn5fo4sXL6BS6ePkyOoUuXsCMTqGLlzCjU+jiRczoFLp4iewUOp0+pxm6eAHmFDqdPtcZungJZqc6VZ4RC1283HJU9vRlcuzpteTYe9i/7L7c8vmm0MWrJlHql1J4kl6UYp2mF6VY1+lFKZz+t5WyS9jQ29uMK0rZm7Ifh1uTn6DkvHd0Wrajk7V/1Mni9PvQiVSgD51IECR0urMnQZBj72Evxp5MQI49Ll+OPb5djj1O/GXs7fawg739e4c93lqMvcMvy7Gnv5djT5/zMvbBLyv7EPbY0+fIsafPacP+TpPOpSFNTy/SkiYJ+/dpWlM2mvb5unnhd/bBk5lLkaejliLvIf8q8s12LQieZL0HlfCmF1WKZqcPwm22pIl/bEkT//h9mi7njab31R01ot0SwOieji73d3Xd0hHYv4V92mGPN30Le2932ONOX8d+G4uNMXxivzeWuGxjiU8Ii9mdZ9oCn5xd5ehs12lmbz4de68BfDI14KmB6WuAPIAaIG2gBshIqAGSHWqAPGr6GojkYhPUQFgfh88h7dQA+dwENeC368ATwEcNkBNOVQPR7dQA+UCPNWCDW6HYW96/oyuev09dH28JiCbs6IqPH1NXvPmYuuK3h9Q14aHH1BVfPKaueN0xdcXndJlhlMeDs2Uvo074nDF1xeeMqSs+Z0hdMz5nTF3xOWPqis8ZU1f6JiW6Wh82hDlUdHUxu/XomMuOrvRNQ+pa6JvG1JW+aUxd6Zt61NW77bWg3uWd55sKv4PsUtey5f6+5J1nF4tH1751Dcuydx3mecQxdWWdbkxdWacbU1fypjF1JW8aUde4kDeNqSt505i6kjeNqSt505i6enQdUlfypjF1JW8aU1fypjF1JW8aU1fypiF1NeRNY+pK3jSmruRNY+pK3jSmrh5dh9SVvGlMXcmbxtSVvGlIXS0+R4muZnublTOh+jsOt+nq3M5z4dHic7rXtbgdXfE5Y+rq0XVIXfE5Y+qKzxlTV3zOmLqyrj6mrqyrD6mrY119TF3Jm8bUlbxpTF3Jm8bU1aPrkLqSN42pK3nTmLqSN42pK3nTmLqSNw2pqydvGlNX8qYxdSVvGlNX8qYxdfXoOqSu5E1j6orPeYuuyVZ0TXHdsD+lB25v7zIFbEsXMuFCupAJU/EymVJaD7d5cRWZissrwuKX9Dg6797Lcnncy54OTnvjKNlss1zs+cHGLGkTx3yCkj8qBrsiUTF39h72r2KfbdnYh2WHPctWr2Mf/cb+GeHKPnKX+j774LZx25BMhX1J61uUzGKebg63gd/Rc7n/Pvq4mA19eh74LvrbR243Zvvsdg+6vry+VfT22aV2tDHbrcT4VDk6lxVKMTuXvshthxog9aIGeCJr/BooxW0NwZI/FcHXg2PZZhmLqbjWfGsFPw7ONtovzjLSYVNeLywvnk+jvF5YXiwfUV6vK6/Eshfl9cLyYrmO8npheRHgUl4vLC9CasrrheXlKa+Zy+teBATgFEEiAacIEjn1+EVgFrtsVeCXSrthStweeCllmGf9MqHTBJXusnuoab9e7zLZEFUQMxHObFVQdqqApIUqiNlTBVRBJhGhCmImEqE7jJlMhCqImUfsqIKYeRKOKrgtwFIFVEEhO6QKYiE7pApiITukCmIhNaIKYiE16rIK7LLtkmLt5yq460oONKauJDtj6kpWM6KuaSF9GVNX8pQxdSUh6VNXHzZd07KjK5nHmLp6dB1SV/zrkLoa+uE+dd1+z2LdH0Zy15V+uEtdXdj+Xj+9jGPTlX54TF3ph8fU1aPrkLqyWjumrqy/jqkr/nVMXVl/HVNX1l+71NW79fkm67OrHB39+o6VGB9rP7fF951jc1iR5Fw+Hfu7Xiw5FvXyk3ohH6NeflIv5G7Uy/Ox5fEmt8WUysHhVhyrNib7ytExumUbhzM7xUhYSDGqKUZPMVKMWoqRWJZiVFOMZMkUo5piJACnGNUUI6k9xaimGFlqoBi1FKNjHYNiVFOMLJJQjGqKkRUYilFNMbICQzGqKUZPMVKMWoqRFRiKUU0xsgJDMaopRlZgKEY1xcgKDMWophhZgaEY31SMtxWWtUpukWL8WoyeFRiKUU0xsgJDMaopRk8xUozvKsYctmJ8wv0oRqIdivFdxejtdmW8jX+nGDEwFKOWYgw8KEExvqsYc1iBpBz3ipEHJSjG68Xot+3hgzfLTnl5yovyel158TAD5fXC8sLDUl7XyyttEUnIy86yWuCBA8rrheXFIwSU158or7hs5WVrPtO4xW7quOUPTnMP+EP627+jqR0fwsbQhLjs3KwjTpZy11vu2yx/lXttNMbnsA3e57SzvpJIESn3t5W7sduHOxN2rr6Jqy/lqKgcPeVIOeopR3JKylFROZJrUo5/ohyftUk75UWuSXm9sLzINSmvF5YXzwpSXq8rr8zPlyivF5YXP0iivF5YXqw6UF4vLC9yMsrrenmV7R1hoeSwU17kXpTXC8uL3IvyemF5kXtRXpfLKy7b46LRmL3ei9yL8npdeRVyL8rrheVF7kV5vbC8yL0orxeWF0/PUl4vLC9PeVFerysvUnvK62XllRd6L8rrenkZn7by2tkBKS/0XpTXC8vLU16U1+vKi96L8nphefHEBOX1wvLiiQnK64XlxRMTlNefKK/t6Gj/8DPar0dn69cqyTbax6DzRy3yeAW1qKQWDc9iUItaapEHN6hFLbXISgO1qKUWWZagFrXUoqcWqcX31KKJYXvBze3fT9W4xTqGNQ/KUVE5skZCOSoqR9ZUKEdF5cgaDOX4vnJM5lGOeaccLXEj5fi2cozZb+WYlp1nmy2JI+X4tnJM9nGzTj7ulCOhI+WoqBw95Ug56ilHckfKUVE5kjtSjorKkdyRclRUjuSOlKOicuTxb8rxfeWY46Mcn4Bv5eh4ApxyVFSOrMpQjorKkVUZyvFt5ZiXZSvHbMxOObIqQzkqKkdPOVKOesqRVRnK8X2949MDZtnY2vH2If3t39HUjg8hb0FSCKXslDurPpT7ROXOqhLlPlG5s2pFuU9U7qyKUe7zlLtn1Y1yn6jcWdWj3Ccqd1YNKfeJyp1VScp9oHLflplCXJadcveUO+Wutty3Wf4q99pojM8PgfwfP/9e7iQzlPs45R7yo9zTzhN/gWSGcp+o3ElmKPeJyp1khnKfqNx5IpJyf1+5h6df08S9cuSJRcpRUTnyRCHlqKgceeKPclRUjuS+lKOecozkspSjonIkN6UcFZUjuSblqKgceSKMcnxbOeaN9+3fYefdCtFTjpSjnnJkVYZyVFSOrMpQjorKkVUZylFRORKDU45vK8fy+LFKLNF/LcdEDE45KipHgh7K8X3lGB8365LKTjnyCAXl+K5yTNZs73S9/Tt8LcfMIiHl+L5yDO5Rjnnnh8uZRULK8Xo52pC2cszpTxx9L0Y6R4pRTTF6ipFifE8xmhwfP/O6/XvHVWcWCClHReXIAiHlqKgcWSCkHBWVI5kj5aioHFmvphz1lGNhvZpyVFSOrMhQjorKkRUZylFRObImQzm+rRyTeQifws77XIunHClHPeXIqgzlqKgcWZWhHBWVI6sylKOicmRVhnJUVI6sylCOasqxLKzKUI6KypFVGcpRUTl6ypFyfFc55mV7vWrOZtkpR5w15fi2cixPV8fi9q6OOGsl5Zi838rRfz76rhSmsxOlDH6sF6WwKr0oxbNVvSjFY0e9KOVRSolS6WFFktlRiodVelGK5zh6UYogphelyCh6UYqMohOlLH5Ki1Ll0aWXuKMUvZ8SpbJfk3qbg9tRit6vF6Xo/doodadJf9aSJj1UQ5qOtZiWNFkvaUmTHrwlTdYdvk/zdpfZaJaSKv1UXB5bVz8BzOGDvIe8EHm8oRR5vJ4UebybFHl8nhB5T9/9MvLbQxLx6dcDD/Ie8q8iHx8PSecd8vQ23ybvXLIbFB9shby5DWbbPMrk9PiZQtxdoVjWD7fJ2qdj7zrRCfWhE31THzrRZUnodGdP9i7GPpDUy7HHX8ixZxVAjj1rBnLsPexfx377bbMxZTGn/WgxaR15MU+/KV51wof3oRM+vA+d8Bhd6BTpy5ToZLe8pFibv+hED9eHTh6dutCJfq+NTneadGUtabKG0ZImKw0tadLXN6SZWA1oSZN8//s0g3nQDE+55YMmzrAlTfxbS5oemg1p4oVa0sQLtaSJF2pJEy/UkiZeqCHNjBdqSRMv1JImXqglTbzQ92nGsq15uGQ+09z5dFvWn1g5Zx6vy/5Y9cge8kLk8VhS5PFjLyN/O34j/+nZkq/HerOp5K358hxKxuf1oBL+8aJKdq8Pwj/+gGYuTzTjV5oF//h9msmZB81g/twdtuA1pcjjS6XI42FfRr5dv1I8KnWgEt74okpxZ8/zgt/9SVeZn2juPFNU8KXfpumXtI3bG/8nd4MqeE0p8vhSEfJ+WfCwUuTxsFLk8bBS5Om7X0b+bL/FG3l6m5eRP9tv8Uae3ub75J3bVjC8+8Nbm74eb1NaP/32zz/84tIvvC9cjDy9jRR5eptXkTcpum2eKfqv7Eno5dh72Iuxp6uXY0/2Lseezv517NNjl8Pbv8sf2fOe3VeyT/nBPscv7Olzvs/eP1j6YP0n9neaHpoNadKLtKRJd9GSJiv7LWmSaLekSS/bkCZvR25KkzS5JU2c0/dpRr/9BsTH7D7R/Onxd/p4J0n6HvqC9PFmr6J/A7EO3Lrl6YmFXD7Y4+Tk2OP75NjjEuXY4ynfwt7Yr+w9DlSOPX5Vjj3u9mXs3RYtWFfCJ/Y7R5+9jfemEz64D508OnWhE95aQqc7e7y1HHu8tRx7vLUce7y1GPuAt5Zjj7d+Gfvg12na8LzPy8Yeby3HHr8sx97DXow9/b0Y+0if8yr2t/Uyu33689Ebe/ocOfZT9znOb+xdipWjS1zneIPwCCXtDesd5dRtS1uUHpStUE4dlv8I5dMu6C65J0NuzAfLqcPvxiynbnYbs5w6nG7McuqwuS3LuV/A3pjl1CapMUtMTzuWuJ52LD0sm7HE97Rjie9pxxLf044lvqcdS3xPM5Zzv2y9MUt8TzuW+J52LPE97Vh6WDZjie9pxxLf044lvqcdS3zPd1n+2qn+42hvvN9hie9pxnLul4Q3Zonv+TZLk8rGsiyfWO589tmrp2/c8Ugy3PFTMtw93F/DvdUrvG8a4en0a4RX/LZG1m29j316rde+Rj6X9bN9sbZydEjrR4fyhC9/iIQJ7UAk3G0HImGb1Ytk5n7heS8iYfRfJFIJD5Fi+RKxmLnfjS5KHrP/KvJlu9Ys1u+Q95B/FXm7kfd5hzwm/mXkt2EvIe6Qx5pLkcdvS5HHRH+bvNt2G/XuDyx/dvSdPM5YiLzB7kqRx8O+hrzxadveIZjn/Vv2xh2XdYUi2qdPzuFDJfxuDyrhjXtQyaNSByrhuXtQCX/eg0r4GhUq+fXgGMxXlSw9ngqV4vrRMeYdlejxXqRSMNskg/OfVLqT95AXIk8vJkWe/kqKPOsfr7obb8O+kQ+Vu/FtsNk/Bl7++PCusayW9KETHqQLnRwrMX3oxLpNHzrN7erzerTzNnw6+k5nameRt2ctXVn8Dp2ZextvtqO9KfErnanfX367SG3PHCWz7NCZ+bpTpzNzilen42emkx5P8+VlqRydtzlm95jir1d4fD22bDfDUj4fe6c+871QjvrMCZsc9ZnTNTnqU/eTYtRnTr7EqE/99ms56lN7MjHqU3s9MepTe0gx6h7qAtTxphLU8aYS1PGmEtTxpi+hfv6OYRMwpxLYI+5UBDv2VAQ7/lQEOwZVBPvUXqn21Eac2tNU6UztPap0pvYIdpultz7v0Jm6la/RmfqF9nU6UzfGVTpT969VOlO3mVU6fmY6LqzD9v6pV94/OsZtF4P8aNit/dipaurXwrclOXUP3pTk1P36yXPEO7Z523fdmPL00WFFOXVz3xTl3C8xr/2qZu7XklfpTP17tSqdqXd/KdueCbdJ1o6+XdA/DrbL49j9SLXhOvLcLyTvQqGpf/PZhUJT7zqjQ6HKItPc72TvQ6Kpd6bpQ6KpN6XpQqK5X0zfh0RTG+o+JJra1Zdt/1dvfC1cs8mtuwXZ9Pwa6iXtihTW4O7G0n86+k5+7sRAkryHvBD5uR3+C8mbbQvxbE3cIT+3c5ckP7chlyQ/t8+WJD+3fZYjb+d+Pbwo+bnNriR5PKwUeTysFHkPeSHyeFgp8nhYKfJ4WCnyeFgp8nhYIfJzv/NdlDweVoo8HlaKPB5WiryHvBB5PKwUeTysFHk87IvIx22SOWW7Qx4PK0UeDytE3uJhX0T+Rm0lX7LZIY+HlSKPh5Uij4eVIu8hL0QeDytFHg8rRR4PK0UeDytFHg8rRN7hYaXI42GlyONhX0O+LHb5OLosLuyQx8NKkfeQFyKPh5Uij4eVIo+HlSKPh5Uij4cVIu/xsFLk8bCvIp/KSv73530hj4eVIo+HlSLvIS9EHg8rRR4PK0UeDytFHg8rRR4PK0Q+4GGlyONhv0vePd7R62yOFfImPUaSon8e9h08FlYIPA5WCLwHvAx4/KsQeOyrEHjcqxB4zKsQeLzri8CXsh5tl6Uy7Lgs65JhXMxXlSI+V4FKoWymeF8lPPGrVNreMWsXZ8+H7Tfa3j79/Nwvu1fHYh6Xx2Ifw7Ylf4iK3x5QVLz8gKJ6RB1PVDKIAUUl3xhQVLKTAUUllxlQVDKf8URNREQDikqiNKCoJEoDikqiNKCoHlHHE5VEaUBRSZQGFJVEaUBRSZQGFJVEaTxRM4nSgKKSKA0oKonSgKKSKA0oqkfU8UQlURpQVBKlAUUlURpQVBKlAUUlURpP1EKiNKCoJEoDikqiNKCoJEoDiuoRdTxRSZQGFJVEaUBRSZQGFJVEaUBRSZSGE9UtJEoDikqiNKCoJEoDikqiNKCoHlHHE5VEaUBRSZQGFJVEaUBRSZQGFJVEaTxRDYnSgKKSKA0oKonSgKKSKA0oqkfU8UQlURpQVBKlAUUlURpQVBKlAUUlURpPVEuiNKCoJEoaRHXraxN9yp9EvYtEQtSBSCQ+rxHJmm2S1jyN5ON1lc56wMuAJzkRAk+6IQSeBOJV4J3bwJfSsAV2Ja9T9MZsR7vttk3+MJykpA+jSerIHoaTlORhOEnJKYaTlFRjOEk9ko4mKUmMBknPA2JHatOBSFPHAS5v2L0Nn46+05naWdfo+KlNapXO1H7PuwedFCtHm7Te7m+rktuxNrudY/PGI7tSObZsEpXy+di7QlPbty4UmtqNdaGQRyFpheJ67A2u3ZFoarPUh0RTW6U+JJp6KbwPiab2sn1INLWh7kKiMLWrP5HoTgdXf0YHR31GZ243m9dZuuxN7eJn83aVui3gPY42u0huAdxG3sdPR9/Je8gLkZ/bfEqSn9tTvpB82H5k5kJedsjPbRUlyc/tACXJz23sBMnHuf2aJPm5vaAk+bl9piR5PKwUeQ95IfJ4WCnyeFgp8nhYKfJ4WCnyeFgh8gkPK0UeDytFHg8rRR4PK0XeQ16IPB5WijweVoo8HlaKPB72ReSL235Gv5S8Qx4PK0Q+42GlyONhX0Pe2wd5G+wOeTysFHk8rBR5D3kh8nhYKfJ4WCnyeFgp8nhYKfJ4WCHyBQ/7KvKprOTdH8j/7Oi7TjjePnTCH/ehE25ag07Gb5tmmmCexp33ZhmXdYOEaJ+kyeFDU4+mw2lKAjCepmQL42lKajGepuQho2nqF3xkh5r69eAYzI6mHk370zTaVdOYdzSl71WhaTAbkvD82Tl+6EQv24dO9Kd96ETP2YdOrNjp6Dm2Sd50CpWe4za1x1CKLWk7/kNVw2rgiKri+UZUlZXGEVVlXXJEVT2qfldV9yAfn7bBP9Dp5Og7eXIUKfIkI1LkyTpeQ97aZX21qvXO7pAnvZAiTx4hRN6SGUiRx9dLkcd7S5HHH0uR95AXIo+HlSKPh5Uij4eVIo+HlSKPhxUi7/CwUuTxsFLk8bBS5PGwUuQ95IXI42GlyONhX0Q+2PVoG8IeeTzsi8h7VzbycakcnTd+2T3w2ex2ji15nWIpn4+9K4o3Hk1RPPdginq8/GiKkhGMpijZw2iKkmmMpqhH0cEUJYMZTVGyndEUJTMaTVEyo9EUJTMaTNFAZjSaomRG3Skat99QL4vdkZTQaDhJSY2Gk9Qj6WiSkhsNJynB0XCS4kpfJGmIaZO01HdOLItbPzyUp32AP/YCivP0PPf5+snmO9jdsritnIv3lY+2Ka4DsSm554++wxnsvtMWzmDZf1s4g8XobeEMdu9vCicNFu62hTNYTtoWzmCJY1s4g/WxP4RT1td32Gz8VzgeOMdw5u6QK3Bm7pCdXcpj2OkrnJk75CqcmTvkKpyZO+QanDxzh+weP6DdhzNzn3MLStePdt4uX+F44BzDmbnPqcKZus+pwZm6z3Elb3DMcv7RoWyvdQil7Fy9p26KfkIyLtt9MC47xiRP3UFdrMldkmXqduuxQO7809tsL/11l5nTy6sk92ty5qjT3VKXjWTJX+HMbQEqcDxwjuHMbQEqcOa2AA844el5rg3O1BagBmfqrr4GZ+pG/RxOWKbuvZ3dnpIMJlU+OubVD5rknx579MsHyqlbxpS3BCcV96dsTFim7i9/QrISUoTFQ/LHNblPcurO9fHR7g+L9DsfvZTto41bdi6UU/e52W7DzqXy0X4j4u3nO87OMB6RnLnF6dvRbsM+dQcth33q3lwO+9Rdvxh2M7WfkMM+dfAvh31qyyeHfWp/+CPsbrWHPuWvnbjxgGwDkt+Pf4BU/WPjW8iHTl3oxCaBfejEJgtKdHL+odPTy3fiwdH26ej4R1Ut2/+NqCpbAI6oKrsA9qeqN5vD9fZp4XnVlG0Ax9PUo+lwmrIR4HiakuSMpympz3iakhCNpylp0nCaOrKk8TQlSRpPU3Kk8TQlRxpPU4+mSjQ9yuV3Pju77VdY5lmc/c8u2yxvBfA0y1vl3GuA3IkaIKcaqwbuqpJUjagqWZV2VX/r5PG139bJ5q2ldc5XyHu7/bjSu1DVyadHu/z0zJnJuz+B9evB8WnTn9vcPzTF13aoaVr5xZuOXzXF146nqUfT4TTFp46nKb6zR03Npmnc0RTXOZ6meM7xNOX5iA41jWvmEGP+qmng+YjxNCVHGk9TcqTxNCVHGk9Tj6bDaUqONJ6m5EjjaTq1P3V+09SlWDnau8U+VHp+ZsD8eZXOV0Tj1I5Tj0rnOXuc2kN2o9LUrrAblab2ed2o5FFJhUqnaxBxai/WjUpTu6tuVJp63V2PSueuNk69kt6NSmQPHaiUyB56UInsoQeVyB56UInsoQeVPCp1oNLUfmlxm0pLqQ3E+OjXZcDbv/PzLyntzvE25HXXids/n6Dc/n1nP7ULEmY/tbeRZZ+ndizC7Kf2IcLsp3YXwuyn9gyvZZ+2rbhs+vX2uS/sPezF2E+9tijMfuoVQ2H2+Fox9oX+/mXsY1kHfvun22FPn/My9jmvh9uyhB32HvYvYn8LSB+fbnf6+0KfI8eePkeOPX3O69gnu316/nyv/dnRd6VI+3tRirUBHUrFHLafXeWnHZvve4vGBZ/Rh06sOfShE+sTSnQqG5RYbPqiEx6/D508OnWhE9lBHzqRM/ShE5lEHzqRSPShE3mEFp0e28CU8EUnQx7Rh07kEX3oRB7Rh07kEX3o5NGpC53IIyR0urPHE72Kfe3ZtWjwOWLsLd5Fjj1+5GXsPz2r7HfY4zHk2OMb5Nh72Iuxp79/HXv7YO9qPszZsv5q1Dnj/+jDLOuNfejEemMfOuGtlejkYtl0ys/500+OvWuKZx9OU0cWMJ6mZAz9aerNdj/11nzVlOxiPE3JRMbT1KOpgKZ39mQtr2Mf08Y+5R325CevY5+3NaVUyg57MpG31P0ue3IOOfbkEWLsPX7kZexzWKd5++cee3yDHHsPezH29Pdy7OnvX8fe23P29DmvY3++z18MrI/IsWcdQ449/b0cew97MfZkad9n79yysb9RqbA3KQW3Hn/79wPLx9pJIEuTY0+PKcY+0mO+kH3KD/ZPbxFf2dNjyrGnx5RjT4Ysx97DXow9GbIcezJkOfb4Wjn2+Fox9on+/vvsl7SN2xufKuzjY2ObYJ6StPBBnu7+ZeS3o2MOO+Tp7aXIe8gLkaevlyJPV/868mYjH3fI09NLkaejlyLPOtXLyMf1MbSbY/1KPrNKJUUeDytFHg8rRR4PK0XeQ16IPB5WijweVoo8HlaIfKGf/zZ557at5I3zwVbIG5PztoplyvL89tWvRxeT1pEX83U3p0L334dOeAUlOlmzQin26xvWCs6iD508OnWhE66lD53wOFp0cmbTyZUvOuGI+tCJNcA+dGLFsAed0kIe0YdO5BF96EQeoUWnxT768vxFJ/KIPnTy6NSFTuQRfehEHtGHTuQRfehEHtGHTuQRXehkyCP60Ik8og+dPDp9Vydb7LaroS3lz/0SOxkc0cvIn/42Mhk8jhR5XIsUeXyIFHmcxevIn/0qNVm8ghR5un8p8qwvvoz86S83kmXFUIq8h7wQeTysFHk8rBR5PKwUeTysFHk8rBB5Rz//ffJxMRv59DzwXfK3jzQblBgqR9tUHu+5/8MOuHel6P+VKJXtujxms8s7SnmU6kQp/EUvSuFHtCi1EbfZpB2l8C+9KIXf6UUp/FEnSnnWBHtRijXEXpQio+hFKTKKXpTyKNWJUmQUvShFRqFFqe0HD7d/7qRJnoyiF6XIKHpRioyiE6UCGYUWpbaR35QqO0qRUfSiFBlFL0qRUWhRyudNqeB2lPIo1YlSZBS9KEVG0YtSZBS9KEVG0YtSZBSdKBXJKHpRCj+lRKm4bdt0++xSO9o7tx7ts6scHf3jVySPlS8X92ZZ8lowZnkaxv7B0YYVYLS59tG/dqbafvySs1k+HX8vR085Uo5vK0f/EP756vgoR5wx5aioHLH/lKOiciTjoBxlyjHanXIkyKEc31iO/lGOKdQ+vWy8Y3l++jDvHJzt9tnZPlX67eB7oZODUegzFHoiRqTQpyh0nhSj0KcodB60o9CnKHTW1Sj0KQrdU+gU+gyFzloghT5FobPKSKG/rdCL3QDe/h0/HX8vR9JuyvF9193yeEKtLDtPqGUSDMrxfVdH8xC+OLNTjnSllKOiqyO9I+Uo0zu6vXLkCTXKUVE58oQa5aioHHHWlKOeciw87UU5vq8c3SNgL97vlCPPZFGOisqR3JFyVFSOPN9EOSoqR085Uo56ypFVGcpRUTmyKkM5vq8ca2vWhVUZylFRObIqQzkqKkdWZShHNeWYF1ZlKEdF5ciqDOWoqBxZlaEcFZUjqzKUo6Jy9JQj5ainHMkdKcfr5Wi2o2+VudTKMVm3fXi6TWGnHMkdKUdF5UjuSDm+rxyje5RjKl/L0ZA7Uo6KypHckXJUVI7kjpSjonIkd6Qc31aObtnUSbdC2SlHTzlSjnrKkafBKUdF5cjT4JTj+8rRP5VjCDvlyKoM5aioHFmVoRwVlSOrMpSjnnK0rMpQjorKkVUZylFRObIqQzkqKkdWZSjH95Wjey7HuFOOnnKkHPWUI6sylKOicmRVhnJ8Xzluc/z177JTjqzKUI6KypFVGcpRUTmyKkM56ilHx6oM5aioHFmVoRwVlSOrMpSjonJkVYZyfF85pqdyLMtOOXrKkXLUU46sylCOisqRVRnK8W3l6M32Io/k7c4ePY5VGcpRUTmyKkM5KipHVmUoRz3l6FmVoRwVlSOrMpSjonJkVYZyVFSOrMpQju8rx+W5HP1OOXrKkXLUU46sylCOisqRVRnK8W3laPNj91vvQu1478x2vN/dgM+zikP56i1fFx7lG0z1+By2wfuc8k65s0pEuest9+Af5R73kgFWlSjfPq7We+UbWIWifDsuX1atKN+Oy5dVLsq34/JlVYzy1Vu+KT7Kt9g/n1QET7lT7mrLvTyu1rclkp3yZZWO8u3iar1fvqzqUb4dly+repRvx+XLKh3l23H5skpH+aotX2/So3yd+/NJRWRVj3LXW+7u6Wrtd95MElnVo3z7uFrvli+repRvx+XLqh7l23H5esqX8u23fFmlo3xVlO+9HFl1oxwVlSOraJSjonJkVYxyfF85hkc52ryzHXFklYty1FOOiVUoylFRObKqRDkqKkdWiShHReXIqg/lqKgcPeVIOeopR1ZlKEdF5ciqDOWoqBzJHSnHd5VjLHGrqlhS+VqOmdyRcnzb1XF5CH/7d9wpR3JHylFROZI7Uo6KypHckXJ8X+9YlqdytDvl6ClHylFPOZI7Uo6KypHckXJUVI48DU45KipHnganHBWVI6sylKOeciysylCOisqRVRnKUVE5esqRcrxajuFWHKs2JvvK0cnH9bNv/9x5gKKQOlKMaoqRzJFiVFOMJI4U47uKMZpV9xRt2ilG8kaKUU0xkjZSjEqKsSxkjRSjmmIkaaQY1RSjpxgpxjcVY8hrlaRQ7E4x4qYpxncVYyrroFN2ZqcYcdMUo5pixE1TjFqK0eCmKUY1xYibphjVFCO/paYY31WMOZitGKPbKUZ+SU0xqilGTzFSjFqKkecZKUY1xcjzjBSjmmJkBYZiVFOMrMBQjGqKkRUYilFLMVpWYChGNcVIzkgxvqsYn59n3FuBsZ5ipBi1FCM5I8WophjJGSlGNcVIzkgxvq0Y4/bUTkz5azE6ntqhGN9VjGnjl5LxO8WIm6YY1RSjpxgpRi3FiJumGN/WM5b0KMawU4y4aYpRTTHipilGLcXoWZumGN/WM26vor79c6dn9Pw6kGJ8WzE+/TrQuMrRxuewDcXnvVzSk0tSvO8q3mziVrx7KzaeXJJilLiS7hajpxgpRi3FSC5JMaopRnJJilFNMZJLUoxqipFfE1KMWooxkEt2WYzWrwitTcuno++6Etl1qauz62db592OrqRfY+rq0XVIXclk+ry/5oeufxjJXVfijTF1JSkYU1dM95i6shvOkLpGHt4bU1fypjF1JW8aU1fypjF1xb9+X9clPHS9zbjKfslbNm+fsvmcP9jjMeXY4wPl2OPVXsfeb4vTNrhP7HfGYsuqlHNPv3COd50S3qsPnfBSSnRysWw65fSk00+OvWuKjxpPUzzUeJp6NO1OU2+2+6m35qumrNWPpyk5x3iakp+8TFP3eK7UpaWiaUhrAYTyBPDD7ieili5kIpXpQaZMKNOFTGQyXchEzPIymfxj6dE/f/quTLFsa6axPLV6Zu/gbP3KO9tov6pK0DKiqh5VB1SVsGVEVYlbRlSVwGVEVclnRlSVOGdAVQt+9WWqBrstYwQbPql6Z0+n+jr2fnuoOYSdRwYL96jXsd8OtyHmHfbcSYTYh2Uh7ZdjT4Qvcb3/8d3hphRdUS9KkczrUCrmsCKMOT02hIsfOnl06kInPEkfOpGHK9GpbFBisemLTiTcfehEHtCHTmQHXehkyBn60IlMog+dSCT60Ik8QotO28JnLOGrTh6dutCJPKIPncgj+tCJPKIPncgj+tCJPEJCp9/sLZ7o2+xNstuHm7LU3jJlfFqhmGCef4K/N/L4+BMJ5unY8KETnkiJTmmzrjns6OTRqQud8ER96IQn6kMnPJEWnbYfNuS4oxOeqA+d8ERd6ORYo1WiU3y80zfv6MQabR86kUf0oRN5RB86eXTqQifyiD50Io/oQyfyiC508jP7J1se2y4vZqnp1HI9yc/sh17K/Twn9TP7G0nuM/sVSe4e7iLcZ/YTr+V+mgf7mf2BJPeZ+31J7jOvJ76Ue8U3zbw+KMg94FdluONXZbjjV2W441dluHu4i3DHr4pwj/vc0/ay+KflAJvdzhfkDXl2pXJsySuVUj4fex9M1DSYpGkwWdNgiqLBpEXTYIymwVhNg3GaBuM1DUbTFThpugKn916B43ZXXRa7M5qsajRF02jyomo0RtVorKrR7F9tfClbSxnseW+bl/WvNvunFtsvH98QX/4N6eXfkF/+DeXV31CWl3+D+fPfEFYHllP89A07Lmkpq5WxZnkc7fceUsp5fW9IMbb2wTdnuX6wXx6LqW6bqJ1lom6WifpZJlq/3qdPE72fFS+dlS6cZRbz4uuUWezLv8G9/Bv8y78hvPwb4su/Ic3xZ22WPMtEyyQTNcssEzVX7hLGXjrLXTpr9yoS7HpScI+I3i7+46R85aRy4SS7XDnJXDnJXjnJXTnJXzkpXDkpXjnpSkXsb7UQyrqgFU3YOalcOGn/R+i1k8yVk+yVk9yVk/yVk8KVk+KVk9KVk65UhLtSEf5KRRw8Q7lYu0VKce+0fO20/Tv7rZjX026f/PW0gwewqqeZa6fZa6ft33fMthZrTN5BEg4eHi5Pa+B735aunZavnVYunRaXa6eZa6fZa6ft6xbsJnfwaec0f+20cO20eO20dO20fO20cum0g9XcEB8NWy47p5lrp9lrp7lrp/lrp4Vrp8Vrp6Vrpx1cFJbtNGd3/t4O1o2qp5lrp9lrp7lrp/lrp4Vrp8Vrp6Vrp+Vrp12rknKtSg6WJ9z2w9hbu7hzCTp6m3vtNHftNH/ttHDttHjttHTttGsNRrnUYNhluXaauXbargA2mS38SDue0B5EoDFut8WY9r4tXTstXzutXDrtIMFKaQ2PbncJu3OauXaavXaau3aav3ZauHZavHZaunZavnZauXSavVYl9lqV2GtVYq9Vib1WJfZalRxsjVset8Vi905Ll0472PArmu06Ge0jRnaufJzmr50Wqqc5v3NavHZaunTafhThbFkf7XHOPE6LHyeZKyfZKyftKubc41lzl5/fxfDXHxx7/wL/6i8Ir/6C+Ge/wJtNA3+7AH/5gvTqL8gv/oJ40OiktDU6T83AelK8clK6ctLBQuhPfiJxO2LN8Z9/M/LxEwl7EGW0/IqD2KPpV5jXf4Vt+hV+2fkK9/qv8K//ivD6r4h//ivisl4Ynu/Rj69Ir/+K/PqvKC//iry8/ivM67/Cvv4r3Ou/wr/+K8Lrv+L1f9359X/d+fV/3fn1f93l9X/d5fV/3eX1f92lxd/F6a6GtrSoqNMfzNqDdPK2Lrp9xZNX/PUVv05zB+lk9TRz7TR77bSD6+/2w+fbaaGC75YeZP9IEsofDYVb/Du+JLzjS+I7viS94UvM8uo/TWdaXMNO97xzxr7+K9zrv8K//ivC678ivv4r0uu/osX95HQDNWfKy7/CLq//CvPqG6+z9vVf4V7/Ff71XxFe/xXx9V+RXv8V+fVfUV7+FQdP14Y1NQ35udOzHyf5KyeFKyftl8qSHs9C3v5d/tiRHCzJLKlsLeySTfxyWr52Wrl02sHm9dXT9i+WS3bucdrTy5rX0+y109y10/y10w50K4/XVi8lmj+edvBU71Ly40HbZflC8uCp3upp9tpp/trcwrXTDv5wSnFPgwxfTkvXTsvXTiuXTovLtdPMtdPstdMOHuJeHivlZrHPVfLXn9fUwaPDjb8kvONL4p//kvO1SHfwCHPTr8iv/4ry06/4fdrBGmH1NHPttGuXyIP1uepp/tpp4dpp8dpp6dpp+dpp5dJp+dqNNF+7kR4sdaTweHIpPW9nuPfXclv83n6Jmp6ePFq/Ir7+K9LrvyK//ivKy7/iYKmj6VeY13+Fff1XuNd/hX/9V7z+r7u8/q+7vP6vu7z+r7u8/K/bL8vrv8K8/ivs67/Cvf4r/Ou/4sd/3ffT4rXT0rXT8rXTyqXTzHLtNHPtNHvtNHftNH/ttGtVYq5ViblWJeZalZhrVWKvVYm9ViX2WpXYa1Vir1WJvVYl9lqV2GtVYq9Vib1WJe5albhrVeKuVYm7ViXuWpW4a1XirlWJu1Yl7lqVuGtV4q9Vib9WJf5alfhrVeKvVYm/ViX+WpX4a1Xir1WJv1Yl4VqVhGtVEq5VSbhWJeFalYRrVRKuVUm4ViXhWpWEa1USr1VJvFYl8VqVxGtVEq9VSbxWJfFalcRrVRKvVUm8ViXpWpWka1WSrlVJulYl6VqVpGtVkq5VSbpWJelalaRrVZKvVUm+ViX5WpXka1WSr1VJvlYl+VqV5GtVkq9VSb5WJeValZRrVVKuVUm5ViXlWpWUa1VSrlVJuVYl5VqVlEtVEpbl2mnm2mn22mnu2mn+2mnh2mnx2mnp2mn52mnXquRa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4Vr2Gq5lr+Fa9hquZa/hWvYarmWv4SB7LdsThqZ4s3Pa0T6q28aa5Wln01+n7b3yrdULpcNRpis1nKBrOFHXcJKu4WRdwymahhOPMn6p4Rhdw7G6hqPqqhwXVVfluKi6KsdF1VU5LqquynFRdVWOi66rstF1VTbvvirHbZeVZbE747HKxuOUjccrG09QNp6obDz7G6ibvO4zYu3Tax/3x2NiWh5vPUhfdi+I++u9rb+kvOFL9teSf/wlLj6+JLqnL9n5RV5268ZAbnne92nZ30512fZcW9zjt/fFfozfKB9/2PjH22rn1/HbzsfvOh+/73z8ofPxx87Hnzoff+58/KXv8Tvt99/a+Du//7rO77+u8/uv6/z+6zq//7rO77+u8/uv6/z+6zq///rO77++8/uv7/z+6zu///rO77++8/uv7/z+6zu///rO77++8/tv6Pz+Gzq//4bO77+h8/tv6Pz+Gzq//4bO77+h8/tv6Pz+Gzq//8bO77+x8/tv7Pz+Gzu//8bO77+x8/tv7Pz+Gzu//8bO77+x8/tv6vz+mzq//6bO77+p8/tv6vz+mzq//6bO77+p8/tv6vz+mzq//+bO77+58/tv7vz+mzu//+bO77+58/tv7vz+mzu//+bO77+58/tv6fz+Wzq//5bO77+l8/tv6fz+Wzq//5bO77+l8/tv6fz+W/q+/6al7/tvWvq+/6al7/tvWvq+/6al7/tvWvq+/6al7/tvWvq+/6al7/tvWjq//5rO77+m8/uv6fz+azq//5rO77+m8/uv6fz+azq//5rO77+m8/uv+v2vauPv/P7b+f5XqfP9r1Ln+1+lzve/Sp3vf5U63/8qdb7/Vep8/6vU+f5XqfP9r1Ln+1+lzve/Sp3vf5U63/8qdb7/Vep8/6vU+f5XqfP9r1Ln+1+lzve/Sp3vf5U63/8qdb7/Vep8/6vU+f5XqfP9r1Ln+1+lzve/Sp3vf5U63/8qdb7/Vep8/6vU+f5XqfP9r1Ln+1+lzve/Sp3vf5U63/8qdb7/Vep8/6vU+f5XqfP9r1Ln+1+lzve/Sp3vf5U63/8qdb7/Vep8/6vU+f5XqfP9r1Ln+1+lzve/Sp3vf5U63/8qdb7/Vep8/6vU+f5XqfP9r1Ln+1+lzve/Sp3vf5U63/8qdb7/Vep8/6vU+f5XqfP9r1Ln+1+lzve/Sp3vf5U63/8qdb7/Vep8/6vU+f5XqfP9r1Ln+1+lzve/Sp3vf5U63/8qd77/Ve58/6vc+f5XufP9r/LS9/03d77/Ve58/6vc+f5XufP9r3Ln+1/lzve/yp3vf5U73/8qd77/Ve58/6vc+f5XufP9r3Ln+1/lzve/yp3vf5U73/8qd77/Ve58/6usfv+rx0fH22LF8/j3Dl5HHXN8fHAOH3PVfq9uOVft9/WWc9XeA7Scq/Z+oeVctfcWLeeqvA8JJeTHXO35XE0ptqwDKcU9Bm5Lvs9X+75hzeervM9pPl/lfVHz+Srvo5rP1082X+X9VPP5Ku+pUvD24+gUl3g+X+fWY51/GvTeoSGGdci/Xs7yOPiXd/o65hvIbcxL/nT0HaPydq0XjMo7wV4wKm8yO8Gofc+9XjAqb4l7wai80+4Fo/IGvheMHowtMCq3G71gxMU0wYiLaYIRF9MEIy6mBUbtO5f2ghEX0wQjLqYJRlxME4wejC0w4mKaYMTFNMGIi2mCERfTBCMupgVG7fs/94IRF9MEIy6mCUZcTBOMHowtMOJimmDExTTBiItpghEX0wQjLqYFRu276PeCERfTBCMupglGXEwTjB6MLTDiYppgxMU0wYiLaYIRF9MEIy6mBUbt7yLpBSMupglGXEwTjLiYJhg9GFtgxMU0wYiLaYIRF9MEIy6mCUZcTAuM2t/o1AtGXEwTjLiYJhhxMU0wejC2wIiLaYIRF9MEIy6mCUZcTBOMuJgGGIv29+L1ghEX0wQjLqYJRlxME4wejC0w4mKaYMTFNMGIi2mCERfTBCMupgVG7W8X7QUjLqYJRlxME4y4mCYYPRhbYMTFNMGIi2mCERfTBCMupglGXEwLjNrf0dwLRlxME4y4mCYYcTFNMHowtsCIi2mCERfTBCMupglGXEwTjLiYFhi1v7G9F4y4mCYYcTFNMOJimmD0YGyBERfTBCMupglGXEwTjLiYJhhxMS0welxME4y4mCYYcTFNMOJimmD0YGyBERfTBCMupglGXEwTjLiYJhhxMS0wBlxME4y4mCYYcTFNMOJimmD0YGyBERfTBCMupglGXEwTjLiYJhhxMS0wRlxME4y4mCYYcTFNMOJimmD0YGyBERfTBCMupglGXEwTjLiYJhhxMS0wJlxME4y4mCYYcTFNMOJimmD0YGyBERfTBCMupglGXEwTjLiYJhhxMS0wZlxME4y4mCYYcTFNMOJimmD0YGyBERfTBCMupglGXEwTjLiYJhhxMS0wFlxME4y4mCYYcTFNMCp3Mb8eq14xZlMqGFNeD3b5adh+WfaG7e06EOPTQ6Gc9z7a5GX9aFMeB9u4N2q32A278Q/szuwNJJvoP47O9kkkm/3O0T4t7uNon36VyPrZIX5I6pF0NEmVuzsk/bmkyp0mkv5cUuWuF0l/LqlyB46kP5dUeRqApD+UNC6L8mQCSX8uqfKUBEl/LqnyxAZJfy4p6dFwknokHU1S0qPhJCU9Gk5S0qPhJCU9+p6k3pT1o322FUnDYrYV0MWnxxxX6gQ8AtQNGYwEdWISCeokGRLUCRskqHuoC1DHsktQx1VLUMf4SlDHm0pQx5sKULeqvOl9SKqM231IqlzNfUiqWv77kLy+IalqFu9DUtVJ3Yekqs24D0nVPfg+JFU3qN9Dcvqu3k7f1dvpu3o7fVdvp+/q7fRdvXW94/4+JH1Xb13vXr8PSd/VW9c7we9D0nf11vWu6vuQ9F29db1D+T4kfVdvXe/2vQ9J39Vb1ztn70PSd/XW9S7U+5D0Xb11vaPzPiR9V29d7468D0nf1VvXOw3vQ9J39db1rr37kPRdvXW9A+4+JH1Xb13vJrsPSd/VW9c7s+5D0nf11vUup/uQ9F29db1j6D4kfVdvXe++uQ9J39Vb1ztZ7kPSd/XW9a6Q+5D0Xb11vcPiPiR9V29d71a4D0nf1VvXnv/3Iem7euvai/4+JH1Xb117pN+HpO/qrWvv7vuQ9F29de0pfR+Svqu3rr2O70PSd/XWtQfvfUj6rt669mO9D0nf1VvXfpj3Iem7euvaj/A+JHVXb6NrP7j7kNRdvY2u/bjuQ1J39TaLuqu30bWfz31I6q7eRtd+Kvchqbt6G12bZfwekq6dJO5D0nf11rUHwX1I+q7eun69fh+Svqu3rt8934ek7+qt6xez9yHpu3rr+62l0fdbS6Pvt5ZG328tjb7fWhp9v7U0+n5rafT91tLo+62l0fdbS6Pvt5ZG328tjb7fWhp9v7U0+n5rafT91tLo+62l0fdbS6Pvt5ZG328tjb7fWppGv2la0mNIJj0N6feX/Pz3N/fT3LXT/LXTwrXT4rXT0rXT8rXTyqXTfv77hPtp5tpp16okXquSeK1K4rUqideqJF6rknitSuK1KknXqiRdq5J0rUrStSpJ16okXauSdK1K0rUqSdeqJF2rknytSvK1KsnXqiRfq5J8rUrytSrJ16okX6uSfK1K8rUqKdeqpFyrknKtSsq1KinXqqRcq5JyrUrKtSop16qkXKoSuyzXTjPXTrPXTnPXTvPXTgvXTovXTkvXTsvXTrtWJeZalZhrVWKuVYm5ViXmWpWYa1VirlWJuVYl5lqVmGtVYq9Vib1WJfZaldhrVbK/PuPjdtqn1+I8Tgv7p5nHaXb5r/NMIC/bi3rcY5vaWxyxc2zJa6BRyudj78OJuoaTdA0n6xpOUTWc/fUSueEYXcOxuobjdA3H6xqOrquy03VVdrquyk7XVdm9+6q8vabPLIv9Oh6/KBuPUTYeq2w8Ttl4vLLx/PjafD8tXjstXTqt0cZ8p0t9ttFWe5Uvce/4Ev+OLwnv+JL4ji9p81CCN48vCeXpS362En4fUtY3pKJuSI02ofvBkPwtLl6vVPZrJTXagq7hgKy2Ab39YbLaDfD9u89VRxTUjSiqG1FSN6KsbkRF24jev+9cdURG3YisuhGpu2YndddsgS3nwrKsnx18qX12CdtHl2yeJuA/JhCVTyAXtx69uM8T2HHIt2XG1SLf3GPl6FT8+qhpKsVWjnbBrg2OiY9jl71jb0t7D35L+XT0HXsCuwT2DHYJ7AXsAtgFNowE+w27AbsEdgt2CewO7BLYPdglsGv3e4Nix6WKYMelimDHpYpgx6VKYC+4VBHsuFQR7LhUEey4VBHsHuwS2HGpIthxqSLYcaki2HGpr8B+s6HrqN3zEycbdlyqAHa34FJFsONSRbDjUkWw41JFsHuwS2DHpYpgx6WKYMelimDHpYpgx6VKYDe4VBHsuFQR7LhUEey4VBHsHuwS2HGpIthxqSLYcaki2HGpIthxqRLYLS5VBDsuVQQ7LlUEOy5VBLsHuwR2XKoIdlyqCHZcqgh2XOorsCezArHJLTvYcakS2B0uVQQ7LlUEOy5VBDsuVQS7B7sEdlyqCHZcqgh2XKoEdv/+a3t262TdYlzls0MJ65sy8lIeR98o3ccfOh9/7Hz8Sff4Y9heaxSD2xl/7nz8pe/xh6Xz8ZvOx287H7/rfPzK77/V8Su//1bHr/z+Wx1/5/ff0Pn9N3R+/42d339j5/ff2Pn9N3Z+/33/iw0bj7/z+2/s/P4bO7//xs7vv7Hz+2/q/P6bOr//ps7vv0n5/fcpP4zpKdr+9c+vA7mF3+tDVbd/u8fAbckf81V+v24+337y7Tbz7ScPr8/Xp7KOw2eXd2arvHtoPFvlvUbj2SrvTNrONivvYxrPVnnX03i2ynukxrPtqKPK6WtHKPCuu7bj76jj2R1/Rx3M7vg76kl2x99Rl7E7/o76hr3xl446gd3xd3Rv3x1/R3fr3fErv/+m4Nfn71L8dcRZt+HceqzzT4PeOzTEsA45pOXp4F+pz9cx36z0NuYlfzr6jlH5ZUQHRreUNZBwn3jsHp22EaftSH/n7Rfll73heCu/TA/HW/ltZTje3Abfy9vD+628ldv84XgrjyWG4608RhmOt/LYZzje+Mu38jb4y/fyxl++lzf+8r288Zfv5e3h/Vbe+Mv38sZfvpc3/vK9vPGXb+VttfeDNsdt9Es5521u5NZxpPi01YzbXSFf1p1mgl8+HXsno71zkyPjIXNARns3JEdGe98iR0Z7hyFHRnsvIEdGeyosRsZpz2/lyGhPWuXITNwDx3X/xFBy5dhbd7Ni9L+3THwyHXeO897J8nbw87O2+8daZ9eDrffdbHFpykPGJ3jrFpfezXu3Rn3v5u1IUN/7ebsu1L/NBPUnVn/e7hn1vZ83JUd9r31be9R/qfrzrnagvtf+SgXUf6n6ZH0zq0/WN7P6ZH0Tq6/9VTKo/1L1yfpmVp+sb2b1yfpmVt+j/sTqk/XNrD5Z38zqk/XNrD5Z38zqk/UNrL7N689IrVvsV/W1v7YS9V+qPlnfzOqT9c2sPlnfzOp71J9YfbK+mdUn65tZfbK+mdUn65tZfbK+idVPZH0zq0/WN7P6ZH0zq0/WN7P6HvUnVp+sb2b1yfpmVp+sb2b1yfpmVp+sb2L1M1nfzOqT9c2sPlnfzOqT9c2svkf9idUn65tZfbK+mdUn65tZfbK+mdUn6xtY/WRWeDa55av6haxvZvXJ+mZWn6xvZvXJ+mZW36P+xOqT9c2sPlnfzOqT9c2sPlnfzOrPm/UVu86xhFA5Nixpe/G5WZ5r5f4u87DMm5q15Thv/tSW47xJTluOE2ci2a0HL0us3R5N3G6P1qVebo+V7WzD4pF/ZvknTkWQPywTxyLIf+sNkH9m+ScORpA/LBM/BYX8NzeI/DPLP/FzUMgfzMQPQiF/MKR+U8vvkX9m+Un9ppaf1G9q+Un9ppaf1G9q+Un9ZpbfkvpNLT+p39Tyk/pNLT+p39Tye+SfWX5Sv5Hlr2x6Eyyp39Tyk/pNLT+p39Tyk/rNLL8j9ZtaflK/qeUn9ZtaflK/qeX3yD+z/KR+U8tP6je1/KR+U8tP6je1/KR+M8vvSf2mlp/Ub2r5Sf2mlp/Ub2r5PfLPLD+p39Tyk/pNLT+p39Tyk/pNLT+p38zyB1K/qeUn9ZtaflK/qeUn9Ztafo/8M8tP6jey/JVX3YVA6je1/KR+U8tP6je1/KR+M8sfSf2mlp/Ub2r5Sf2mlp/Ub2r5PfLPLP9Qvj9av8mfqoqWZT3aluAqR/tlWavFL/65tD7ehZ6Guo3+iKRbFrMNJFe5O7v9JXlvevlLqu2QmYa6j6L/j/Uf6kaK/j/Wf6j1M/T/sf5DLaCh/4/1n7eTRv9f+g+1hIb+P9Z/qDU09P+p/nmoRTT0/7H+Q62iof+P9Sf/m1t/8r+59ffoP7X+5H9z60/+N7f+5H9z60/+N7f+5H9T61/I/+bWn/xvbv3J/+bWn/xvbv09+o+sf23/jEL+N7f+5H9z60/+N7f+5H9z60/+N7P+cSH/m1t/8r+59Sf/m1t/8r+59ffoP7X+5H9z60/+N7f+5H9z60/+N7f+5H9T62/I/+bWn/xvbv3J/+bWn/xvbv09+k+tP/nf3PqT/82tP/nf3PqT/82tP/nf1Ppb8r+59Sf/m1t/8r+59Sf/m1t/j/4j6195k1a05H9z60/+N7f+5H9z60/+N7f+5H9T6+/I/+bWn/xvbv3J/+bWn/xvbv39vPqbJa8DMSFVjvaprAPx2S9PR7sPkhMnaY1JTpxJNSY5cbrTmOTEOYlJG0lrayStidt90rrUy32ysk9udBPnJOgfo584J0H/m/4T5yTof9N/4pwE/W/6T5yToP9Nf4/+U+s/c7qD/tHPnEmhf/QzJ2noHz3539z6k/9NrX8g/5tbf/K/ufUn/5tbf/K/ufX36D+1/uR/c+tP/je3/uR/c+tP/je3/uR/U+sfyf+G1r+2T04k/5tbf/K/ufUn/5tbf4/+U+tP/je3/uR/c+tP/je3/uR/c+tP/je1/on8b279yf/m1p/8b279yf/m1t+j/9T6k//NrT/539z6k//NrT/539z6k/9NrX8m/5tbf/K/ufUn/5tbf/K/ufX36D+1/uR/c+tP/je3/uR/c+tP/je3/uR/U+tfyP+G1r/2nrxC/je3/uR/c+tP/je3/h79p9af/G9u/cn/5taf/G9u/cn/5taf/G9m/dOi3P+HElaRUjYV/V3Km6L5adh+WfaG7VxaR307fDs6552DvVv19PmJR1g+MCq30b1g9GBsgVG5qesFo3Jv1AtG5RajF4zKO3UtGENYZxjiHkblDW8nGI3ydWM1GNOyYkxlB6Py5ddeMOJivoexrLeYuLgdjLiYJhg9GH+I0ZgdjLiYJhhxMd/CeCO1YszLDkZcTBOMuJjvYczroGPxOxhxMS0wWlzMtzDeXPM6DJN3MOJimmDExfwUo407GHExTTB6MLbAiIv5HsayDjove3dqXEwTjLiYb2HM2x913r1T42KaYMTFfA+jcytGb79idLiYJhhxMT/FGHYSHoeLaYIRF/MtjMWsx5a99tt5MLbAiIv5Hka3Ail+Zy3G4WKaYMTFfA/j9gxPiXt/1LiYJhhxMT/FmHaiCY+LaYIRF/MtjGYJ6yNlt4HuNOAeH9MI5MROxtt1IMY//SBtF6QzeQXpTHkcbOPeqN0SH3N8eibSmWV32Mv6kJBLTy3Vr6PvInlE0i/SxC6sH5Em9nj9iDSxg+xHpIn9aT8iTex+uxEpTOyt+xFpYufej0gTpwL9iETi0IFIHpH0i0Ti0IFIJA4diETi0IFIJA4diETioF+kSOLQgUgkDh2IROLQgUgkDh2I5BFJv0gkDh2IROLQgUgkDh2IROLQgUgkDvpFSiQOHYhE4tCBSCQOLxHJ2u1onysiZRMfL5BZHkfvvxLGp2X9MblP5rG3gQvxQ1LyieEk9Ug6mqRkH8NJSlIynKTkKqNJmvGO3Um6bXR4+2fckZSOtzdJ87L+6tzfDt+R1COpuKRaXmxqykP1p/fCbi82zfTSFMu3i4UunWL5drHQ/1Ms3y4W1ncplm8XC+vMFMt3i6WQWVAs3y4W1t0plm8XC+v/FMu3i4WclWL5drF4ioVi+W6xkOBSLN8uFhJciuXbxUKCS7F8u1hIcCmWbxcLCS7F8s1iyQsJLsXy7WIhwaVYvl0sJLgUy7eLhQSXYvl2sXiKhWL5brGQ4FIs3y4WElyKZVXGuofq3u4UCwkuxfLtYiHBpVi+WyyGnIVi+XaxeIqFYvlQJplVRpvcslMsuCGK5dvFghuiWL5dLLghiuXbxYIboli+XSw8z0KxfLdYLM+zUCzfLhZyForl28XC8ywUy7eLhedZKJZvF4unWL5VLNaum/M5l3OlWLp56MCSyU4tPynr1PKTm04tP0no1PKTbc4svyOtnFp+8sep5SdRnFp+MsKp5ffIP7P8pH5Ty0/qN7X8pH5Ty0/qN7X8pH4zy+9J/aaWn9RvavlJ/aaWn9Rvavk98s8sP6nf1PKT+o0sv81l1dEtO1t1eFK/qeUn9ZtaflK/meUPpH5Ty0/qN7X8pH5Ty0/qN7X8Hvlnlp/Ub2r5Sf2mlp/Ub2r5Sf2mlp/Ub2b5I6nf1PKT+k0tP6nf1PKT+k0tv0f+meUn9ZtaflK/qeUn9ZtaflK/qeUn9ZtZ/kTqN7X8pH5Ty0/qN7X8pH5Ty++Rf2b5Sf2mlp/Ub2T5a69ySqR+U8tP6je1/KR+M8ufSf2mlp/Ub2r5Sf2mlp/Ub2r5PfLPLD+p39Tyk/p9T37vNvl9NhX5nVm2o41/4reLL/kVtknx6eC0c3D0a13F4J4PvatJiDeSmmRyfam5CROfbhCbmkRsnam5rDiWr3+bhcTsm2qa8lDTVtQMy9auhMWnZzXv1AmqJKiTD0lQJ5aRoO6hLkCdEEKCOt5fgjoeXYI6XlqCOp73/dTLgjeVoI43laCON30BdV9K3qiH8l+nqZoPZU2xffTLV4kwsuol8kikXSIssnqJ8NPqJcJ8q5cIp65eImy9dokMGYB6iQgM1EtEuqBLIvdVItIF9RJ5JNIuEemCeolIF9RLRLqgXSJLR3dBoliRyPjtKWzjXT6XKC5+/ei4lOX8YHM7Yj369u8QvypKAziaoh5FB1OU9nI0RelGR1OU5nU0RVlJ61rR8lVRFt4GU9SxTjeaoizrjaYomdFoipIZDaZomPk+uuQDRe9oZr4hVdDMfGWvoBnqEpmD39CkpYbGLOvWL8Y8TdKZvaO92bZj8/5x7O4nv3CjN1Mewizl09F3PT16DqXnUJE6eoahAnX0DEPF6egZhgrT0TMMFaWjZxwqAEDPOFRqgZ5xqKgFPSP50Fh6evQcSk/yobH0JB8aS0/yobH0JB8aS0/yoaH0TORDY+lJPjSWnuRDY+lJPjSWnh49h9KTfKgrPW1eH4C2brE7epIPjaUn+dBYepIPjaUn+dBQembyobH0JB8aS0/yobH0JB8aS0+PnkPpST40lp7kQ2PpST40lp7kQ2PpST40lJ6FfGgsPcmHxtKTfGgsPcmHxtLTo+dQepIPjaUn+dBYepIPjaUn+dBYepIPDaRnWhbyobH0JB8aS0/yobH0JB8aS0+PnkPpST7UlZ7JrKRtcsuOnuRDY+lJPjSWnuRDY+lJPjSUnoZ8aCw9yYfG0pN8aCw9yYfG0tOj51B6jpUPle2ji/UVPd32yf5pGPsvYN091PjyAXGoUKa49Y/CL7EGMVuzHp1tMJXSFdto66bRUEHLoBoNFZ4MqtFQgciYGtmhQo5BNRoquBhUo6HCiEE1GipgGFQjj0bqNRoqCBhUI3IG/RqRM+jXiJxBv0bkDOo1cuQM+jUiZ9CvETmDfo3IGfRr5NFIvUbkDPo1ImfQrxE5g36NyBnENar9QNKRM6jXyJMz6NeInEG/RuQM+jUiZ9CvkUcj9RqRM+jXiJxBv0bkDPo1ImfQrxE5g3qNAjmDfo3IGfRrRM6gXyNyBv0aeTRSrxE5g36NyBn0a0TOoF8jcgb9GpEzqNcokjPo14icQb9G5Az6NSJn0K+RRyP1GpEz6NeInEG/RuQM+jUiZxDXqLZxcCRnUK9RImfQrxE5g36NyBn0a0TOoF8jj0bqNSJn0K8ROYN+jcgZ1GuUVfV19yGpamPuQ5K9a7taJZu8FafJPj+K036MP3Q+/tj5+FPn48+dj7/0Pf6ydD5+0/n4befjd52Pv/P7b+n8/ls6v/+Wzu+/pfP7b+n7/muWvu+/Zun7/muWvu+/Zun7/muWvu+/Znn7/dcZt74p2ZmyVD7bOrvO1npfi4t62fzzNlewS2BPYJfAnsEugb2AXQC7WcAugd2AXQK7BbsEdgd2Cewe7BLYcaki2HGpIthxqSLYcaki2HGpEtgtLlUEOy5VBDsuVQQ7LlUEuwe7BHZcqgh2XKoIdlzqK7BXtr8wFpcqgh2XKoHd4VJFsONSRbDjUkWw41JFsHuwS2DHpYpgx6WKYMelimDHpYpgx6VKYPe4VBHsuFQR7LhUEey4VBHsHuwS2HGpIthxqSLYcaki2HGpIthxqRLYAy5VBDsuVQQ7LlUEOy5VBLsHuwR2XKoIdlyqCHZc6iuwVzaiNwGXKoIdlyqBPeJSRbDjUkWw41JFsONSRbB7sEtgx6WKYMelimB/v0u11q3YbbY17Le/x20kLvWCvfZz4Pe/lh3sv7AXsAtgf//L08H+C7sBuwR2C3YJ7A7sEtg92CWwB7BLYI9gl8COSxXBjksVwY5LlcCecaki2HGpIthxqSLYcaki2D3YJbDjUkWw41JFsONSRbDjUkWw41Jfgb32s4KCSxXBjksVwY5LFcGOSxXB7sEugR2XKoIdlyqCHZcqgh2XKoIdlyqA3S64VBHsuFQR7LhUEey4VBHsHuwS2HGpIthxqSLYcaki2HGpIthxqRLYDS5VBDsuVQQ7LlUEOy5VBLsHuwR2XKoIdlyqCHZcqgh2XKoIdlzqK7BXtmizFpcqgh2XKoIdlyqCHZcqgt2DXQI7LlUEOy5VBDsuVQQ7LlUEu4BLLevBzj1tDf7rs38PyVl9Q3L6huTfPSS/uPWz/RJqfy9nR98nEHqfQNQ9gZjDeg2KOZmnT74PP/U9/Nz38Ivy4ZdlvSXFYtMfh++Xvodv+h6+7Xv4ru/hK7/z1oav/L5bG772u25l+NrvupXha7/rVobf91039H3XDX3fdUPfd93Q9133/W+hbzv8vu+6oe+7buj7rhv6vuuGvu+6se+7buz7rhv7vutG9Xddv8VUJXwdvvq77vnw1d91z4ev/q57Pnz1d93z4au/654O/9Wvkbx/ydsvbza79XrrFuMqnx1KyB9Hp2we+/L+WmT9crBLeT3Y5adh+2XZG7bfXnFsfHosxOa899EmP709+WnVNu4u/i3Wbkf7vB3tzKJ5rdkt63q6dcZ8OvpeLJ5ioVi+WyyBYqFYvlsskWKhWD6Uqf0w5/2vR6RY+i2WTLFQLN8tlkKxUCzfLJb3v0CTYum3WAzFQrF8t1gsxUKxfLdYSHAplm8Xi6dYKJbvFgsJLsXy7WIhwaVYvl0s5CzyxWLio1iWXJHfp7IO+/bPx0hc+HiQoJCG9CZp3q4W/pnIQ1Iyi+4k3XZE8NnZHUlJFoaTFP8/nKQeSUeTFC89nKQ43uEk5cmi7iRd0iapXXYk5fmf4SQlPRpMUreQHg0nKenRcJKSHg0nKenRcJJ6JB1M0v3XFdxmuJ31GL4p5uMkf+WkcOWk3SQkmLXggnWfTtqroMfmzDk/7ZabP74hvfwb8su/obz6G9zy8m8wL/8G+/JvcC//Bv/ybwgv/4aX/027l/9Nu5f/Te/vhBq2fR2CT18vl/s7YIa0bQbhl52T8pVv2r/kbPffEP3Xk/Y3KQx5vf2F4nZOMldOsldOcldO8ldOCldOildO2v9T2PqTUPZ0yldOKhdOisv5SXHZmdP+tlUhle2kvHPSbkVEs9KLruyc5CrftPf3tL8xUuWPcH87otpJV/7c9zd/MTaskzI27qBI5tpp9tpp7tpp/tpp4dpp8dpp6dpp+dpp5dJp+aBKctpOe3qw83GaqZ+20+Zne+00d+00f+20/Sq52bf1NLd34dl/fLl+Wrp2Wr52Wrl02v6jmfXTzLXT7LXTDnSLm9y3y83OafskHz2eCf7rX4BfDpCU7e/NL2HnNFM/reycZq+d5q6d5q+dli6dZvZJPgcxzuycZq6dtk/Sx2U7Lcad08LBaY+5pa83YW8P5rY9Cn8LgtzOaebaafbaaftV4ovf/gKWvbn5a6eFa6fFa6elg7/uTbdgd/5Mbb52Wrk0SLdcO81cO81eO81duk7uJxn108K10+K108qlK5e/duXy165c3l45LezfOm61uibo/vOPce4n7eJ//NznFsDvnBSvnJSunJSvnFQunLR/c6qdZK6ctC/vY9HgthYSdk5z107z104L106L105L107L104rl047uMVXTzPXTrtWJfZalezfqyvXjv07ddkWqIrdO+nKZWD/vln5pv27Zu0ke+Ukd+UkfwXElcu1u3K53o/cS1wroqSdMtpP0WsnlQsn+drlevekK5fr/btx7SR35aQrFeGvVIS/UhH+yl+uv3ID91du4OHKDTxcqYiD1xRkk7f1n/joq/cfP8hu6+aye/Kh+0fXVv3DwasHRIfk9Q0p6BtS1DekpG9IWd+QirohHbwFQHRIRt+Q9F29U4urt93WjbM3qXb0D3d02Pbk9snYnQn43icQep9A7H0CqfcJ5N4nUDqfQF56n4DpfQK29wn0fifOvd+Jc+934tz7nTj3fifOvd+Ji/r7wPkOb6FovwrVHFl5/1VIy4aMt/XkdY72aS18Sz9LBM0RmgSaIzQZNEdoCmj20cRlAc0RGgOaIzQWNEdoHGiO0HjQHKGhGz5EQzd8iIZu+BAN3fAhGrrhIzSGbvgQDd3wIRq64UM0dMOHaDxojtDQDR+ioRs+REM3fIhm3m7Yugcab3fQzNsN19DYebvhKpp5+5oqmnnvUMmsOzPa5JYdNPPeoapo5r1DVdHMe4eqoXHz3qGqaObNa6po5s1rqmjm7WuqaDxojtDMm9dU0ex2w25Z1u1w3PK0f/n+ZI255agfh9/+bWtwrN32orh1649f6bvbv++DSi0GFR57YZn4tB1v51nJ/g4LwLnDKcA5hLO/YwZw7nAMcI7hWOAcw3HAOYbjgXMMJwDnGE4EzjEcOuQTOHTIJ3DokI/hBDrkEzh0yCdw6JBP4NAhn8DxwDmGQ4d8AocO+QQOHfIJHDrkEzgzd8g2r7O0btl5eirO3CFX4czcIVfhzNwhV+HM3CFX4XjgHMOZuUOuwpm5Q67CmblDrsKZuUOuwqFDPoaT6JBP4NAhn8ChQz6BQ4d8AscD5xgOHfIJHDrkEzh0yCdw6JBP4NAhH8PJdMgncOiQT+DQIZ/AoUM+geOBcwyHDvkEDh3yCRw65BM4dMgncGbukGu/yi0zd8hVODN3yFU4M3fIVTgzd8hVOB44x3Bm7pCrcGbukKtwZu6Qq3Bm7pArcNLErz5y2+sRrTNmB828m4dV0cy7eVgVzcSbop678bR40ByhmXfzsCqaebfSraKZdyvdKpqJN3uvoZl4s/cKmolffVRFM283XEUzbzdcRUM3fIjm/X3Nz15en8qK5vbPx3TXl9cngVfN/GwCeauE2z/LzgSy9glYt03A2Z0JlM4nIPBylcYTML1PwPY+Adf7BLz2CSxpm4BddiYQep+A9jtxdQLq78S1Cai/E9cmoP5OXJmAU38nrk1A/Z34ZAL/dfuP/+8//vvf/vGf/v4v/3E76df/+n/+9Z//82//9q8f//E//7//vf4v//Tvf/v73//2v/7hf//7v/3zv/yP//Pv//IPf/+3f/71v/1l+fg//z35aP+abvebG5pfXG540l9TCuH2n93v/93n2/8e8q///dcJYQn5r2GJv0/4fYYv8XZEybex3cb3/wM=","names":["get_total_borrowed_assets"],"brillig_names":["get_total_borrowed_assets"]},{"name":"_liquidate","hash":"12132574787296755951","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debt_token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"user","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debt_to_liquidate_amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"1840251649407153602":{"error_kind":"string","string":"Insufficient borrowed amount"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14434150440419769526":{"error_kind":"string","string":"collateral >= debt"},"15333773746166717806":{"error_kind":"string","string":"Insufficient collateral"},"16523063005220065570":{"error_kind":"string","string":"Function _liquidate can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_liquidate"],"brillig_names":["_liquidate"]},{"name":"get_position","hash":"18173538782436088164","is_unconstrained":true,"custom_attributes":["utility","view"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"position::Position","fields":[{"name":"collateral","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"scaled_debt","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"debt","type":{"kind":"integer","sign":"unsigned","width":128}}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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lLKSMk0pKynTlLJGZJ1RVlKmKWUlZZpSVlKmKWUlZZpSVlKmGWWNpExTykrKNKWspExTykrKNKWsEVlnlJWUaUpZSZmmlJWUaUpZSZmmlJWUaUZZEynTlLKSMk0pKynTlLKSMk0pa0TWGWUlZZpSVlKmKWUlZZpSVlKmKWUlZZpR1kzKNKWspExTykrKpERWH9OGsJ7JGtsma1qW9l1WUqYpZY3IOqOspExTykrKNKWspExTykrKNKWspEwzylpImaaUlZRpSllJmaaUlZRpSlkjss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLJWUqYpZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrKNKOsjZRpSllJmaaUlZRpSllJmaaUNSLrjLKSMk0pKynTlLKSMk0pKynTlLKSMk0o6+1/Q9YZZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrKNKOsjpRpSllJmaaUlZRpSllJmaaUNSLrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oqydlmlJWUqYpZSVlmlJWUqYpZY3IOqOspExTykrKNKWspExTykrKNKWspEwzyhpImaaUlZRpSllJmaaUlZRpSlkjss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLJGUqYpZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrKNKOsiZRpSllJmaaUlZRpSllJmaaUNSLrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oayZlmlJWUqYpZSVlmlJWUqYpZY3IOqOspExTykrKNKWspExTykrKNKWspEwzylpImaaUlZRpSllJmaaUlZRpSlkjss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLJWUqYpZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrK9HNZ8+I2WcvzxHdlvX2k26A8y/qiCOqyFkFx7exov7T1aO/Lb0f/krWRMk0pKynTlLKSMk0pKynTlLJGZJ1RVlKmKWUlZZpSVlKmKWUlZZpSVlKmCWXNCynTlLKSMk0pKynTlLKSMg0pawxhPTrWs1uEOfqvg3N+lEDIe6tsj5uPy9M09g/Objs6+7ScHO2Ky1tVlb/uTx5/ett45+aearfu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","names":["get_position"],"brillig_names":["get_position"]},{"name":"_compute_utilization_rate","hash":"9761706781939111723","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"precision","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"deposit_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]},"visibility":"private"},{"name":"borrow_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"12348881442450494403":{"error_kind":"string","string":"Function _compute_utilization_rate can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_compute_utilization_rate"],"brillig_names":["_compute_utilization_rate"]},{"name":"get_accumulators","hash":"5971836072901590717","is_unconstrained":true,"custom_attributes":["utility","view"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]},{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"7f3druw8dqUJ34uPfSD+k30rjQ+F+nEXDBh2wVX1AY2C771jv7GkiJ1LIa7NZMScJJ8Te2emGEE+Yy5pjiEF9X/+4b/903/53//9P/3zv/4///Y//+H/+r//zz/8y7/91//8v/753/719p/+z3/84z/8l3//53/5l3/+7//p+b/+h+3X/zEu/DXgf/6P//yvv/7z//xf//nf/9c//F9m88b94z/807/+t7/+neztQ/6ff/6Xf/r1n7b/+Mdvx6ccv47Omz+Ojenk0GDD16EhbI+P9fY//n//eJtO7DGd7NI+nVCup+Nd+TrUx/x9OqnLdLLfp1Py9XTittOJNn6fTu4xnWLt19HFhcp08vZ1aNpOxCqn03F52/HfDomxMh1bNvN1uNt+O/r+LX77yLeYj3yL/ci3uI98i//It4SPfEv8yLekj3xL/si3fORvP3zkbz985G8/fORvP3zkbz985G8/fORvP3zkbz985G8/fORvP3zkbz9+5G8/fuRvP37kbz9+5G8/fuRvP37kbz9+5G8/fuRvP37kbz9+5G8/feRvP33kbz995G8/feRvP33kbz995G8/feRvP33kbz995G8/feRvP3/kbz9/5G8/f+RvP3/kbz9/5G8/f+RvP3/kbz9/5G8/f+RvP3/kb7985G+/fORvv3zkb7985G+/fORvv3zkb7985G+/fORvv3zkb7984m/fbttHvqXL377bQjy+paSno8P9W+xHvsV95Fv8R74lfORb4ke+pcvfvrvdy9u/xdry27d8P/oWY+5zumVaz7cAy9ldz7zfMAzuaR7h628kC8w/H3c+b715rsw/xHTcRY7ZHUeHeF9AGXwBZht9AWb0BdjRF+BGX4AffQFh9AXE0ReQRl/A6Fdio/9KnPzeOIUU/PMCTtxFOJ60siGZ64Nz2KeR09MK/altMccja7fzxuODvT07OD8szm+H/iJu9bcOsxHX3+vMRlx/czYbcf3d5GzEPcQ/TFx/vz4bcf0GYzbi+h3RbMT1W7jZiOM5P0zc4Tk/TRzP+WnieM5PE8dzfpq4h/iHieM5P00cz/lp4njOTxPHc36aOJ7zw8Q9nvPTxPGcnyaO5/w0cTznp4l7iH+YOJ7z08TxnJ8mPoLnNA/i+RqiyccvTkyxrvLRxpd9UzsTnraD+3om04/gDqXYjODjhNiEERyXFJsRvJEUmxFcjBSbEfyGFBsPm5dsRujhpdiM0G1LsaEvfs2Gvvg1G/ril2wiffFrNvTFr9nQF79mQ1/8mo2HzUs29MWv2dAXv2ZDX/yaDX3xazb0xS/ZJPri12zoi1+zoS9+zYa++DUbD5uXbOiLX7OhL37Nhr74NRv64tds6Itfssn0xa/Z0Be/ZkNf/JoNffFrNh42L9nQF79mQ1/8mg198Ws29MWv2dAXv2RT6Itfs6Evfs2Gvvg1G/ri12w8bF6yoS9+zYa++DUb+uLXbOiLX7OhL37Fxm30xa/Z0Be/ZkNf/JoNffFrNh42L9nQF79mQ1/8ms3KffHNMe1sbhfsrUoy+YOkefrsfDaTuOWvg6N9wpfDHfvKLbcg9pW7eTnsA7w1dkrsK3sQQewr2xtB7Cs7J0HsHuwS2Ff2e4LYV7aSgthxqSLYcaki2HGpEtiHeEH5hNhXdqm3+z3pwF5qEzEm2ePDTdmePt3Yd8u0sqsdSKaVXfBAMnlkGkGmlV32QDKt7MoHkmllFz+QTCu7/oFkWjklGEemIV5Bj0xDvLcemYZ42T0yOVKIIWTyyDSCTKQQP5bJbmGfibG3FVdksjdZvw63Jj9Byfns6LQdRyf7eJb6/ii1I4UYQiZSiCFkIoUYQiZSiBFk8qQQQ8hECjGETKQQQ8hECjGETB6ZRpCJFGIImUghhpCJFGIImUghhpCJFOLnMrmcD5m8r93IsPGYi40xPI4u7hSh3T/cmfB8tDk72qVj5q64347+JWsgtZhSVlKOKWUlFZlSVlKUKWX1yDqjrKQ0U8pKqjOlrKRAU8pKajSlrKRMM8oaSZmmlJWUaUpZSZmmlJWUaUpZPbLOKCsp05SykjJNKSsp05SykjJNKSsp04yyJlKmKWUlZZpSVlKmKWUlZZpSVo+sM8pKyjSlrKRMU8pKyjSlrKRMU8pKyjSjrJmUaUpZSZmmlJWUaUpZSZmmlNUj64yykjJNKSsp05SykjJNKSsp05SykjLNKGshZZpSVlKmKWUlZZpSVlKmKWX1yDqjrKRMU8pKyjSlrKRMU8pKyjSlrKRME8rqN1KmKWUlZZpSVlKmKWUlZZpSVo+sM8pKyjSlrKRMU8pKyjSlrKRMU8pKyjSjrIaUaUpZSZmmlJWUaUpZSZmmlNUj64yykjJNKSsp05SykjJNKSsp05SykjLNKKslZZpSVlKmKWUlZZpSVlKmKWX1yDqjrKRMU8pKyjSlrKRMU8pKyjSlrKRMM8rqSJmmlJWUaUpZSZmmlJWUaUpZPbLOKCsp05SykjJNKSsp05SykjJNKSsp04yyelKmKWUlZZpSVlKmKWUlZZpSVo+sM8pKyjSlrKRMU8pKyjSlrKRMU8pKyjSjrIGUaUpZSZmmlJWUSYms1ocDYa7J6ssha9i28l1WUqYpZfXIOqOspExTykrKNKWspExTykrKNKWspEwzyhpJmaaUlZRpSllJmaaUlZRpSlk9ss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLImUqYpZSVlmlJWUqYpZSVlmlJWj6wzykrKNKWspExTykrKNKWspExTykrKNKOsmZRpSllJmaaUlZRpSllJmaaU1SPrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oayFlmlJWUqYpZSVlmlJWUqYpZfXIOqOspExTykrKNKWspExTykrKNKWspEwTynr775B1RllJmaaUlZRpSllJmaaU1SPrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oqyFlmlJWUqYpZSVlmlJWUqYpZfXIOqOspExTykrKNKWspExTykrKNKWspEwzympJmaaUlZRpSllJmaaUlZRpSlk9ss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLI6UqYpZSVlmlJWUqYpZSVlmlJWj6wzykrKNKWspExTykrKNKWspExTykrKNKOsnpRpSllJmaaUlZRpSllJmaaU1SPrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oayBlmlJWUqYpZSVlmlJWUqYpZfXIOqOspExTykrKNKWspExTykrKNKWspEwzyhpJmaaUlZRpSllJmaaUlZRpSlk9ss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLImUqYpZSVlmlJWUqYpZSVlmlJWj6wzykrKNKWspExTykrKNKWspExTykrK9HNZ42YOWdPzxE9lvX2kOaA8y/qiCPK2F0EypXa03cp+tLXpt6N/yZpJmaaUlZRpSllJmaaUlZRpSlk9ss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLIWUqYpZSVlmlJWUqYpZSVlGlJW79x+tM+1W4TR26+DY3yUgItnqyyPm4/b0zTOD47mODrasFWONsnEo6rSX/cnrz+9HLxjMU+1m08O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iQs0f613ttcrVNc7WXdeXe9cTXQwPuwHm3gST032eoX6ev1i652rc6yvd64Gr77eubq2+nrnasXq652rv6qud7LXK9TXO1d/9bxea+zJeuftr87XO29/db5ev9h65+2vztc7b391vt7J+qtk0nFwLifrnay/qq53sv6qst442esV6uudrL+qrney/qq63sn6q+p6/WLrnay/qq53sv6qut61+qs42esV6utdrL+a7PUKt/tD235wibny0b4ccJ4fhc725FibNvt1sE324bziF8fJ+jYxjpP1g2IcJ+szO3G8s/Gweclmsv61K5vJet2ubCbri7uymayH7spmsn77j9jcIvz9YJ+/s5ns1Rx92azcb9fYrNxD19is3BfX2HjYvGSzcl9cY7NyX1xjs3JfXGOzcl8cwtEX55O+eLLXpHRlM9krVfqyWbovrrBZui+usFm6L66w8bB5yWbpvrjCZum+uMJm6b64woa++DWbdfriv9Y72ett6utdp3+9r3ednvS+3nX6zPt6/WLrnasfjNu2T+TWzpmT9c7V49XXO1ffVl/vXL1Yfb1z9VfV9U72epv6eufqr+rrnau/qq93rv6qvl6/2HoX668me71Nfb2L9VeTvd6mvt7F+qvJXm9TX+9i/dVkr7epr3ex/mqy19vU17tYfzXZ623q612sv5rsNTT19S7WX032Wpf6ehfrryZ7SUp9vYv1V5O9cqS+3sX6q8le4FFf72L91WSv2qivd7H+arL3Z9TXu1h/Ndn7M+rrXay/muz9GfX1LtZfTfb+jPp6F+uvJnt/Rn29i/VXk70/o77exfqryd6fUV/vYv3VZO/PqK93sf5qsvdn1Ne7WH812fsz6utdq79Kk70/o77etfqrNNn7M+rrXau/SptfbL1r9Vdpsvdn1Ne7Vn+VJnt/Rn29i/VXk70/o77exfqryd5HUV/vYv3VZO+CqK93sf5qsnc21Ne7WH812bsV6utdrL+a7B0I9fUu1l9N9q6C+noX668me6dAfb2L9VeT7f1fX+9i/dVke/TX17tYfzXZXvr19S7WX0225319vYv1V5PtTV9f72L91WR7yNfXu1h/Ndle7/X1LtZfTbZ/e329i/VXk+3fXl/vYv3VZPu319e7WH+12P7tabH929Ni+7enxfZvT4vt354W2789LbZ/e1ps//a02P7tabH929Ni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b2n5Sf1mlr+26Y0j9VtZfk/qt7T8pH5Ly0/qt7T8pH5Ly++Rf2X5Sf2Wlp/Ub2n5Sf2Wlp/Ub2n5Sf1Wlj+Q+i0tP6nf0vKT+i0tP6nf0vJ75F9ZflK/peUn9VtaflK/f1hZflK/peUn9VtZ/kjqt7T8pH5Ly0/qt7T8pH5Ly++Rf2X5Sf2Wlp/Ub2n5Sf2Wlp/Ub2b5a6+6i6R+K8ufSP2Wlp/Ub2n5Sf2Wlp/Ub2n5PfKvLD+p39Lyk/otLT+p38ry56l8f7T+kD9VFS3bfrQtwVWO9tu2V4vf/HNpfb0LPU91Gf0jkm7bzDGRXOXu7PGX5L0Z5S+ptkNmnuo6iv5/rP9UF1L0/2P9p7p/hv5/rP9UN9DQ/0/1L+t20uj/S/+pbqGh/x/rP9U9NPT/Y/2nuomG/n+sv0f/pfUn/1tbf/K/tfUn/1tbf/K/tfUn/1tZ/7SR/62tP/nf2vqT/62tP/nf2vp79F9af/K/tfUn/1tbf/K/qfWv7J+RNvK/tfUn/1taf0P+t7b+5H9r60/+t7b+5H9r6+/Rf2n9yf/W1p/8b239yf/W1p/8b239yf+W1t+S/62tP/nf2vqT/62tP/nf2vp79F9af/K/tfUn/1tbf/K/tfUn/1tbf/K/pfV35H9r60/+t7b+5H9r60/+t7b+Hv2X1p/8b239yf/W1p/8b2r9K2/SSo78b239yf+W1t+T/62tP/nf2vqT/62tP/nf2vp79F9af/K/tfUn/1tb/4XzP7PlfSImpMrRPpV9Ij777elo90Vy4SStM8mFM6m+JMPC6U5nkgvnJCYdJK2tkbQmHtdJ69Io18naPrlh4ZwE/W/6L5yToP9Nf4/+S+u/cE6C/jf9F85J0P+m/8o5CfqnsHK6g/4prJxJoX+KKydp6J8i+d/a+pP/ra0/+d/a+nv0X1p/8r+19Sf/W1t/8r+19Sf/W1t/8r+l9U/kf2vrT/63tv7kf2vrT/43tf61fXKSR/+l9Sf/W1t/8r+19Sf/W1t/8r+19Sf/W1r/TP63tv7kf2vrT/63tv7kf2vr79F/af3J/9bWn/xvbf3J/9bWn/xvbf3J/5bWv5D/ra0/+d/a+pP/ra0/+d/a+nv0X1p/8r+19Sf/W1t/8r+19Sf/W1t/8r+V9c8b+d/a+pP/ra0/+d/a+pP/Ta1/5T15efPov7T+5H9r60/+t7b+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","names":["get_accumulators"],"brillig_names":["get_accumulators"]},{"name":"borrow_public","hash":"13180093584320903887","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"1Z3dbuo4FIXfheteeP/Y3j6vMjqq+sOpkBBUtB1pVJ13HyeHBNqmZMZkRfFNRYr3Xl9DljcO2/R99bi+f3u63ex+7V9WP/56X233D3evm/0uH73/vlndHzbb7ebp9vzXK9f8YG7Hvzzf7ZrDl9e7w+vqBwmrv1mtd4/NYzGXc/zabNf5yOXHX8c75m64U+5HpzgwWJOLx8GaKPSDgx8YbKp2HGwa9Hzwz5sVyzT0KXXDidJ89DoNvbf+3NvIuScfO3oKIpfpkxc9Dk457jO9n5qe+AN9oxFm0IhDGp6o+9s9yemV8wK+JmyYRkNPE0ZovDPXDXZmIzSeulNpXtxnmjRM47inUX+Z5vKfKw4tQGgBRgsIWkDRAh4tENACES1gaAG0kxXtZEU7WdFOVrST9Xonc6DuvRCHs5qf39a1Ch6uEOAKEa5gcIWEVvAOrkBwBYYrCFwB7mkP97SHe9rDPe2v93SQbu4O/rT0SqFNn6Dpg8OmJ2x6xqYXbHrFpvfY9AGbPmLTY10bsK6NWNdGrGvj9a4lc91dGDKyzwJY30asbyPWtxHr24j1bcT6NmJ9a1jfGta3hq22hnWtYV1rWNca1rWGda1hXWtY1yasaxPWtQnr2gRf6Cb4QjfBF7oJvtBN8IVugt+8SvCbV/lzQLwE4SUYLyF4CcVLeLxEwEtgqzM5A+fH1mciB85P4PwMzi/g/ArO78H5Azg/2L806l924XL+7NHQdZLkx3bWShL/aCS8BrsZNOh6jZykb5YiPn/phlqrxCkdR4vzH5qAWiBeGpAsDUiXBuSXBhSWBhSXBmRLA0rzA6VutHAcaUbMq5jo+nmU5XNHCYmrnJ8q5+fK+aVy/vmLkoTuPaDIWT/3N/xRpOeP/iv//DVMpTujohrH+M2d3sfZlwZkkvlLnhKd+G2MP/X90/mxty/8sXJ+q5w/1c2vrnJ+qpyfK+eXyvm1cn5fOX/l9Vcrr79aef3Vyuuvr7z++srrr1/S/N8CLWlCb4GWNEO3QPNPuZ67NlHxo0vOvCY4bQdWli/8Vjl/qps/uMr5qXL+KZYMYnrScHzO32roDBp+Bo0wg8bwfCqnLyiQGb+ggL7ZUsGBehySyzgfBocP56dVSGiFbzZWTKlAVyuMtQt9s79iUgnBSyhewuMlAl4i4iUML5HgEubwEnh3G97dhne34d1t17v7YteVBXD+CM5v4PwJmz85cH4C52dwfgHnV3B+sH8T2L8J7N8E9m+CV2R2Di9BeAnGSwheQvESHi8R8BIRL2F4Cby7Ce9uwrub8O4mbKVmUnB+D84fwPkjOL+B82PfaTM7cH4C52dwfrB/GexfBvuXwf5lsH8Z7F8G+1fA/hWwfwXsXwH7V8D+FbB/BexfAftXwP4VsH8V7F8F+1fB/lWwfxXsXx33bxj7sDj0XwSfP3s+7ZbQo0KAK0S4gl2vMOUWPta0MCDvlgZESwPipQHJ0oB0aUB+aUBhfqAJdy6yj5XzW+X8qW7+4Crnn78oTblzl8P8NWzKnbsc5i95U+484KCV8/vK+UPl/LFyfqucP9XNH13l/FQ5P1fOX3n9/Q+N4cvmr7z+xsrrb6y8/sbK668taf5vgZY0obdAS5qhW6D5p9wpdy6y+cr5Q+X8sXJ+q5s/TbFkuLwblRPNoMEzaAhcQ4YboUm1j1J/es3zHY8/UaEoKhZFWVFUKoka7hMejRq83ujUakuBT/dO9RjEJUFSEhRKgobP38XPxWW4O3MsSAvwhvsEx4JKTsRwR99YkJUEpYIgcSVBJReslFywUnLBSskVIb7g2pNQEhRLgqwkqMSEWmJCpZIgLgmSkiD9v0G/89Hfd4fN3f12/ZJjmiffdg+vm/3uePj6z3P3zP1hs91unm6fD/uH9ePbYX273T80z61c86MRF403uXxmmOY6Uyc3uRL8bP6jSD7k5G/EueawOY/iKB9KZsgc/wI=","names":["borrow_public"],"brillig_names":["borrow_public"]},{"name":"deposit_public","hash":"13467800074736080550","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"field"},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["deposit_public"],"brillig_names":["deposit_public"]},{"name":"update_accumulators","hash":"2086483995095164713","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"12348881442450494403":{"error_kind":"string","string":"Function _compute_utilization_rate can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17134621154673181869":{"error_kind":"string","string":"Function _compute_borrow_rate can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["update_accumulators"],"brillig_names":["update_accumulators"]},{"name":"sync_notes","hash":"1058966235015214508","is_unconstrained":true,"custom_attributes":["aztec::macros::functions::utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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sld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV/ciey37NwxdEXdw2osq2bf0c6X4X0472sq30YNCbsMppobzKivWGo6zNRxvazjB1nDE1nBWW8OJtoaTbA3H1lU527oqF1tX5WLrqlxsXZWLratysXVVLrauyuXTV+XTZ1zdxpOMjScbG08xNR6/LMbG44yN53gD9Vtj/3Wa926tjOeWBzyepBzT3+9ecHuT8Ik3kU+8ydrkTUJ8vEkMT29y8Iu8HLaNgcLyvO/Tcryd6rLvubaEx2/vi/8afzQ+/nXnH9cQvo8/dT7+3Pn4S9/jP/7iQ0fjd52P33c+/tD5+KXz8Vu//9bG3/n913V+/3Wd339d5/df3/n913d+//Wd33995/df3/n913d+//Wd33995/df3/n913d+/w2d339D5/ff0Pn9N3R+/w2d339D5/ff0Pn9N3R+/w2d339D5/df6fz+K53ff6Xz+690fv+Vzu+/0vn9Vzq//0rn91/p/P4rnd9/187vv2vn99+18/vv2vn9d+38/rt2fv9dO7//rp3ff9fO779r5/ff2Pn9N3Z+/42d339j5/ff2Pn9N3Z+/42d339j5/ff2Pn9N3Z+/02d339T5/ff1Pn9N3V+/02d339T5/ff1Pn9N3V+/02d339T5/ff3Pn9N3d+/82d339z5/ff3Pn9N3d+/82d339z5/ff3Pn9N3d+/y2d339L5/ff0vn9t3R+/y2d339L5/ff0vn9t3R+/y2d339L3/ffsPR9/w1L3/ffsPR9/w1L3/ffsPR9/w3m97+qjb/v+2/ofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1Xo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","names":["sync_notes"],"brillig_names":["sync_notes"]},{"name":"constructor","hash":"8402087236782975651","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"7b3bjiu7kp77Lut6XSQPyYNfxTCMtt3baKDRbbTbG9gw+t23xlBlSjUrVVRxRCYZ5HezUGMuphT8/lAy/kiJ/L9/+x//+N/+z//8r//0L//Pv/7vv/2n//x///bP//rf/+Hf/+lf/+X2r//7N+N+/7f//b/+4V9+/fN///s//Nu//+0/WZ/M3//2j//yP25/BuP+4+9/+3/+6Z//8W//ySzLf/z9y2hvjP8Y7c267KOD/4//8ve/GX/6O6xH72BsNMvHRcamsBbew9rotojc8ogox4PByaaPsSnExwv7ezyhs3hiZ/GkzuLJfcVjl+vjSevH2Lz4T/EcvHDI22Cb4uOFbQwHo43dp2psTo/RIR+MDmG7K6QlP72yOWS43xSSXc1jdDqKOma/RR1ztoXRbrX7/SY8xi6HPGzKD9C2MNq4ZRttnE2l0YvdAjHLk+S/Rv/KFEOmkClvZYolU8iUtzLFkSmaMiWasPGIbilpH3dZTMz2DzPFkylkyluZso6UKeaRKe5Z/cNMMavdqJvb2xRGkyt/s4FcIVfezJXYea64Zc+V5Au54kzaRjuTn6iHw9EPMs74x3rlzEJde5griVwhV97MlUyukCvv5YrrvVtLrvSTK733a8mVfnKl944tudJPrvTesyVX+skVT66QK2/mSu99W3Kln1zpvW9LrvSTK/RtyZV3c4W+Lbnybq7QtyVX3swVT9+WXHk3V+jbkivv5gp9W2W50u77K56+Lbnybq74kXLlFsemvkupkCuo/zc/VCcW9X+o/lC9Ve929X0ypXXCLPGxTjxN8fDrttlt38s3+WlRMfE3xaG6judRtMuyB7JY90zx6+B1p7Hmx/ebTfoNfKjW3ZnA/X5nWUL+A+BD9b9OBG7W7Wv51jwFcr9PrEN1hk6k+Gyybfo+bY17rIcum78iH6rBogP5UH2KXpCvZu8krd7W38nXoToDw6njUecEdfYf1d6WZ/8H6gzllYdTZywvu99RburYgjo+563sXJc1f6+OX/O+51Xwy/PgXxTH8rLPFEudY+P3HDfepe8phrh72RDtF4pjGdRWFMdynY0ohrFcZyuKYxnJ8yimfauBkHz4K8WxvGErimN5uFYUPRQFKI7liU6jGHPcHzYuJn4/2Cz58cWhJa9foI9rdTqGjjN6C3qydt/DzAb7h9AxUudDz3+Fju+6HnpsYNO+2yw6ms7iGdc6nNjec3/NsnGtw5UUfUuKZv3y2ZApwp3d2/Z+Md/H4xaz0XS/tfz+gz39N+1iQKLeJYpI1LtEMnbA7yCtf1oJ8u/vr0SZ6nfda0O7PnVNDpVdb8vXtjS54D4tZLeI0tJdRKa7iGTKw3Xdl+RbBfB9RDe3ui3J2XyJx3UWj+8snrWzeIJQRi+PeNa/3FnS8QLj0sNzuhzCp/f4ddmLm17Oj2/hGRsKoSW3zT6tqfBRy+vjaxZPP6MIh3fstO7R5+XJtq2/79gpXxx8WPZKOZinX2geBn9bUfekuP2d1ufht+jzojf62z/+27/90z//8z/9z//66WS25df/HG8u6nfdfV4+m4zbv8yvkcdnkKXFPhohjwsPZ+i3tTesn34C8F9eHSgm9eLpT198P1kupL/+BOT4qK8fvfh244jLXyM/PrdL5MVv/7DfyLqnecr5rRnnPdXzGr8Pypglbrl++/vpaIxf3+e6/cP9Dux48jYvmxhu+XTLtL+DOz7AqniVrbrKVV3lq65aq64KVVfFqqtS1VW55ipXlRuuKjdcVW64qtxwVbnhqnLDVeWGq8oNV5Ubrio3fFVu+Krc8FW54atyw1flhq/KDV+VG74qN3xVbviq3FircmOtyo21KjfWqtxYq3JjrcqNtSo31qrcWKtyY63KjVCVG6EqN0JVboSq3AhVuRGqciNU5Uaoyo1QlRuhKjdiVW7EqtyIVbkRq3IjVuVGrMqNWJUbsSo3YlVuxKrcSFW5kapy47jZ6Za9G+CW/OS+lvV+lau6ylddtVZdFaquilVXHeaGM8vWQXDW5k9XHVjYNTzOVTNPXwBZjs5V88k9GtiPseuHplkgnrTsjjqZVIhnDbv/XkN69AXWcPf3S28Bmd4Csr0F5HoLyPcW0NpbQKG3gGJvAaXeAursTm2X6+/Ucd9YZo2rfw7o6KGYeTyki+b7wWndwkjxaZH0h0/bzP4TZmuevhDx6xf4XwenR0n1aehvggaCf0jQQvAPCToI/iFBD8E/JLhC8A8JBgj+IcEIwT8kmCD4hwQzBP+MoMGT/ClBPMmfEsST/ClBPMmfEvQQ/EOCeJI/JYgn+VOCeJI/JYgn+VOCeJI/JGjxJH9KEE/ypwTxJH9KEE/ypwQ9BP+QIJ7kTwniSf6UIJ7kTwm28CTmQTB9D8Wk/RusJj8fl3X40sbnxxkU0T6/9O+55nnm6paJ5mommqudaK5uorn6iea6TjTXMNFc40RznahuchPVTX6iuslPVDf5ieomP1Hd5Ceqm/xEdZOfqG7yE9VNfqK6yU9UN60T1U3rRHXTOlHdtE5UN60T1U3rRHXTOlHdtE5UN60T1U3rRHVTmKhuChPVTWGiuilMVDeFieqmMFHdFCaqm8JEdVOYqG4KE9VNcaK6KU5UN8WJ6qY4Ud0UJ6qb4kR1U5yobooT1U1xoropTlQ3pYnqpjRR3ZQmqpvSRHVTmqhuShPVTWmiuilNVDelkeomm8M2V7eYpUgm+p2MeXrtdBRJWLajjMPz0Y1pvWMcqSRrhzGPVO01xDhSIdkQ40g1akOMI5W/DTF6MEpgHKlob4hxJD/QEONIVqMhRlyMCEZcjABGt+BiRDDiYkQwjuRi3LJvJOWWXArEmGj3Fzd5eXp1Y8/GPpLrUYTdg70F9pFclSLsI7kwRdhHcm2KsI/k8hRhH8kV6sFuRnKRirCP5DoVYcelNsGOS22C3YO9BXZcahPsE7tUu6xbJMbeZlzAbm8yfQy3Jj1BSelodFz20dE+vtsX7tgndqktsU/sUltin9ilNsRuJ3apLbFP7FJbYp/YpbbEPrFLbYndg70F9oldakvsuNQm2HGpTbDjUptgx6W2wD7U6YI/xe5S2rF7X2r82rDHYkNYH6OzO4rF2O3Fb93159HmaLSLe+Quu0+jf8s0s6tVJNPMLliRTDO7ZkUyeWTSINPMrlyRTDO7eEUyzez6Fck0c5dAkUwzdxX0yDTUWb0Dy0QXQoVMdCFUyEQXQoVMHpk0yEQXQoVMdCFUyEQXQoVMdCFUyEQXQoNMQ518P7BMdCFUyEQXQoVMdCFUyOSRSYNMdCFUyEQXQoVMdCFUyEQXQoVMdCE0yBToQqiQiS6ECpnoQqiQiS6ECpk8MmmQiS6ECpnoQqiQiS6ECpnoQqiQiS6EBpkiXQgVMtGFUCETXQgVMtGFUCGTRyYNMtGFUCETXQgVMtGFUCETXQgVMtGF0CBToguhQia6ECpkoguhQia6ECpk8sikQSa6ECpkoguhQia6ECpkoguhQia6EBpkynQhVMhEF0KFTHQhVMhEF0KFTB6ZNMhEF0KFTHQhVMhEF0KFTHQhVMhEF0KBTH6hC6FCJroQKmSiC6FCJroQKmTyyKRBJroQKmSiC6FCJroQKmSiC6FCJroQGmQydCFUyEQXQoVMdCFUyEQXQoVMHpk0yEQXQoVMdCFUyEQXQoVMdCFUyEQXQoNMli6ECpnoQqiQiS6ECpnoQqiQySOTBpnoQqiQiS6ECpnoQqiQiS6ECpnoQmiQydGFUCETXQgVMtGFUCETXYiTZLJ+3RGmkkw+7zKty5K/yuSRSYNMdCFUyEQXQoVMdCFUyEQXQoVMdCE0yOTpQqiQiS6ECpnoQqiQiS6ECpk8MmmQiS6ECpnoQqiQiS6ECpnoQqiQiS6EBplWuhAqZKILoUImuhAqZKILoUImj0waZKILoUImuhAqZKILoUImuhAqZKILoUGmQBdChUx0IVTIRBdChUx0IVTI5JFJg0x0IVTIRBdChUx0IVTIRBdChUx0ITTIFOlCqJCJLoQKmehCqJCJLoQKmTwyaZCJLoQKmehCqJCJLoQKmehCqJCJLoQGmRJdCBUy0YVQIRNdCBUy0YVQIZNHJg0y0YVQIRNdCBUy0YVQIRNdCBUy0YXQIFOmC6FCJroQKmSiC6FCJroQKmTyyKRBJroQKmSiC6FCJroQKmSiC6FCJroQCmS6/Tdk0iATXQgVMtGFUCETXQgVMnlk0iATXQgVMtGFUCETXQgVMtGFUCETXQgNMhm6ECpkoguhQia6ECpkoguhQiaPTBpkoguhQia6ECpkoguhQia6ECpkoguhQSZLF0KFTHQhVMhEF0KFTHQhVMjkkUmDTHQhVMhEF0KFTHQhVMhEF0KFTHQhNMjk6EKokIkuhAqZ6EKokIkuhAqZPDJpkIkuhAqZ6EKokIkuhAqZ6EKokIkuhAaZPF0IFTLRhVAhE10IFTLRhVAhk0cmDTLRhVAhE10IFTLRhVAhE10IFTLRhdAg00oXQoVMdCFUyEQXQoVMdCFUyOSRSYNMdCFUyEQXQoVMdCFUyEQXQoVMdCE0yBRm7kKExewyxefAD2W6vaTZoTzL9ELUtGyiRpNLo+2St9HWxk+jf8s0cxdCkUwzdyEUyTRzF0KRTB6ZNMg0cxdCkUwzdyEUyTRzF0KRTDN3IRTJNHMXQo9MkS6ECpnoQqiQiS6ECpnoQqiQySNTDzJ557bRPpUeqQRvPwaH8JDUhaNZ5sfDmuUpjOPBweyjg12XwmgTTdh43/7OrvTqeecdsnnKxXQwON0eLX0MTjbY58G/85a2DHmrMW/pU5G3GvOWxh15qzFv6WSStxrzltYueaswbxO9bvJWY97S/CdvNeYtT0PIW415y+Mh8lZj3nrylrxVmLc8LyNvNeYtz8vIW415y/My8lZj3vK8jLzVmLc8LyNvFeZt5nkZeasxb3leRt5qzFuel5G3GvOW52Xkrca89eQteaswb3leRt5qzFuel5G3jxe2a9zzNpVe2qSwR/3rb/9p/O/s4qkW2XVedvHsiew6L7t4QkR2nZVdYeE5Dtl1XnbxtIXsOi+7eCZCdp2XXTy5ILvOyy5PdpFdp2UXTwHIrvOyi1492XVedtGrJ7vOyy569WTXedlFr57sOi27DL36k7Ir7t9Nuf35efRv8LSxG4Gnw9sIPM3PRuA94NuAp2XWCDzdpEbgabQ0Ak8PohF47Hkb8Bbn2gg8zrUReJxrI/A410bg/bzgnYtbD9k4v9oCSnMLZm/1mhQfP8wLh+AXu4O39mnsb+wT+9aW2Cd2rS2xT+xZ/RL3uL3xsYD99qj7Y/QtWR9j03oHObEHlQU5sacUBekm9oiyICf2fLIgJ/ZwsiAn9mSyID0gZUBO7JpkQU7sg2RB4myEQOJshEDibGRAepyNEMiZnU3weQcZil9qti5uJK3LT936lH/cdPMz+6CG2Gd2TQ2xe7C3wD6zI2uIfWb/1hD7zG6vIfaZvWFD7DM7yXbY15l9Z0PsuNQm2HGpTbDjUptg92BvgR2X+jZ2b/YtG7xfPmH/jRLnKYYSNymGEocohhLXJ4Uy4OTEUOLOxFDiuMRQ4qLEUHpQSqHE7YihxO2IocTtiKHE7YihxO1IoYy4HTGUuB0xlLgdMZS4HTGUHpRSKHE7YihxO2IocTtiKHE7YihxO1IoE25HDCVuRwwlbkcMJW5HDKUHpRRK3I4YStyOGErcjhhK3I4YStyOFMqM2xFDidsRQ4nbEUOJ2xFD6UEphRK3I4YStyOGErcjhhK3I4YStyOEMi64HTGUuB0xlLgdMZS4HTGUHpRSKHE7YihxO2IocTtiKHE7YihxO1IoDW5HDCVuRwwlbkcMJW5HDKUHpRRK3I4YStyOGErcjhhK3I4YStyOFEqL2xFDidsRQ4nbEUOJ2xFD6UEphRK3I4YStyOGErcjhhK3I4YStyOF0uF2xFDidsRQ4nbEUOJ2xFB6UEqhxO2IocTtiKHE7YihxO2IocTtSKH0uB0xlLgdMZS4HTGUuB0xlB6UUihxO2IocTtiKHE7YihxO2Ioh3I7zu8oXQyl0SFtJN2tQ/YE0vxGsw7lXmTRDOVGZNEM5S5k0QzlFmTReNC8QjNUNS+LZqjqXBbNUNW2LJqhqmdZNFTDr9AEquGXaKiGX6KhGn6Jhmr4JRoPmldoqIZfoqEafomGavglGqrhl2iohl+hGetsdVk0VMMv0VANv0RDNfwSjQfNKzRUwy/RUA2/REM1/BIN1fBLNFTDr9CMdfa2LBqq4ZdoqIZfoqEafonGg+YVGqrhl2iohl+ioRp+iYZq+CUaquFXaMY6m1kWDdXwSzRUwy/RUA2/RONB8woN1fBLNFTDL9FQDb9EQzX8Eg3V8As0aayze2XRUA2/REM1/BIN1fBLNB40r9BQDb9EQzX8Eg3V8Es0VMMv0VANv0Iz1tmusmiohl+ioRp+iYZq+CUaD5pXaKiGX6KhGn6Jhmr4JRqq4ZdoqIZfoRnr7E9ZNFTDL9FQDb9EQzX8Eo0HzSs0VMMv0VANv0RDNfwSDdXwSzRUw6/QjHU2pCwaquGXaKiGX6KhGn6JxoPmFRqq4ZdoqIZfoqEafomGavglGqrhV2jGOjtQFg3V8Es0VMMv0VANv0TjQfMKDdXwSzRUwy/RUA2/REM1/BIN1fArNJxF9xoN1fBLNFTDL9FQDb9E40HzCg3V8Es0VMMv0VANv0RDNfwSDdXwKzScRfcaDdXwSzRUwy/RUA2/RONB8woN1fBLNFTDL9FQDb9EQzX8Eg3V8Cs0nEX3Gg3V8Es0VMMv0VANv0TjQfMKDdXwSzRUwy/RUA2/REM1/BIN1fArNJxF9xoN1fBLNFTDL9FQDb9E40HzCg3V8Es0VMMv0VANv0RDNfwSDdXwKzScRfcaDdXwSzRUwy/RUA2/RONB8woN1fBLNFTDL9FQDb9EQzX8Eg3V8As0mbPoXqOhGn6Jhmr4JRqq4ZdoPGheoaEafomGavglGqrhl2iohl+ioRp+hYaz6F6joRp+iYZq+CUaquGXaPy0aLxb7Mdo79bwCc1BJD5uSMxqniJJR3GHJX0MDvbpldN6hz5vnd0Q+rwVfEPo83qDhtDndR0Noc/rZ9pBn/icwobQ5/VgDaHP6+4aQp/XNzaE7oF+PXQcaQPoONIG0HGkDaCP5UjTNtp5u34a/XuyYznB7yc72NmYhcmO5XwKkx3LcRQmO1alX5isn2myY1W2hcmOVVEWJjtWJVeY7EwV1GCnL34/2cHOUyxMdqYKarAzDwuTnamCGuxcwsJkZ6qgBjs7sDDZmSqowc73K0x2pgpqsDP4CpOdqYIa7Jy8wmRnqqAGO8uuMNmZKqjBzpsrTHamCmqwM+EKk52pghrs3LbCZGeqoAY7W60w2ZkqqMHOPytMdqYKarAzygqTnamCGuwcscJkZ6qgBjvrqzDZmSqowc7jKkx2pgpqsDOzCpOdqYIa7FyrwmRnqqAGO3uqMNmZKqjBzocqTHamCmqwM5wKk52pghrsnKXCZGeqoAY7C6kw2aEqKO8eky3+JtDE7Xd7dnm8sk3uYGzaeSSXC2PzTjznz2N/Ax+qitMAfKhKUgHwsc530gB8qIpaA/ChqnoNwIdyFhqAe4BfC3woh6UB+FAuTwNwnObFwHGaFwMfy2mmfX+l5E0JuE37jknO+cdosxy99mp2Mde0fBp9A2mWsQ5Fa0pyLG/YkuRYpq8lybHcXEuSHpJCJMfyXy1JjmWsWpIcyzG1JDmWFWpJEo8jRHKso+6aksTjSJHE40iRxONIkfSQFCKJx5EiiceRIonHkSKJx5EiiccRIjnWIXVNSeJxpEjicaRI4nGkSHpICpHE40iRxONIkcTjSJHE40iRxOMIkRzrGLimJPE4UiTxOFIk8ThSJD0khUjicaRI4nGkSOJxpEjicaRI4nGESI51UGNTkngcKZJ4HCmSeBwpkh6SQiTxOFIk8ThSJPE4UiTxOFIk8ThCJMc6SrUpSTyOFEk8jhRJPI4USQ9JIZJ4HCmSeBwpkngcKZJ4HCmSeBwhkmMddtyUJB5HiiQeR4okHkeKpIekEEk8jhRJPI4USTyOFEk8jhRJPI4QybGOI29KEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeIZMLjSJHE40iRxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHESKZ8ThSJPE4UiTxOFIk8ThSJD0khUjicaRI4nGkSOJxpEjicaRI4nFkSJoFjyNFEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeIpMHjSJHE40iRxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHESJp8ThSJPE4UiTxOFIk8ThSJD0khUjicaRI4nGkSOJxpEjicaRI4nGESDo8jhRJPI4USTyOFEk8jhRJD0khkngcKZJ4HCmSeBwpkngcKZJ4HCGSHo8jRRKPI0USjyNFEo8jRdJDUogkHkeKJB5HiiQeR4okHkeKJB5HiOSKx5EiiceRIonHkSKJx5Ei6SEpRBKPI0USjyNFEo8jRRKPI0USjyNEMuBxpEjicaRI4nGkSOJxpEh6SAqRxONIkcTjSJHE40iRxONIkcTjCJGMeBwpkngcKZJ4HCmSeBwpkh6SQiTxOFIk8ThSJPE4UiTxOFIk8ThCJBMeR4okHkeKJB5HiiQeR4qkh6QQSTyOFEk8jhRJPI4USTyOFEk8jhDJjMeRIonHkSKJx5EiiceRIukhKUQSjyNFEo8jRRKPI0USjyNFEo8jQ9IueBwpkngcKZJ4HCmSeBwpkh6SQiTxOFIk8ThSJPE4UiTxOFIk8ThCJA0eR4okHkeKJB5HiiQeR4qkh6QQSTyOFEk8jhRJPI4USTyOFEk8jhBJi8eRIonHkSKJx5EiiceRIukhKUQSjyNFEo8jRRKPI0USjyNFEo8jRNLhcaRI4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE4wiR9HgcKZJ4HCmSeBwpkngcKZIekkIk8ThSJPE4UiTxOFIk8ThSJPE4QiRXPI4USTyOFEk8jhRJPI4USQ9JIZJ4HCmSeBwpkngcKZJ4HCmSeBwhkgGPI0USjyNFEo8jRRKP8x5Jb2P+GO3dagujjY/7a6/mKe50NMuwpI/BwYanseuHRh6NutcIX9a/Rji+/jXCS/avES61f43wv91rFHHW/WuEZ+9fI7oB/WtEn6F/jTwada8RfYb+NaLP0L9GE/cZ3B6ICYsrULd2WT5GW+8+a3QnOXE3QJjkxJ5dlmSa2FkLk5zY/wqTnNilCpOc2EsKk/SQFCI5sS8TJjmxexImiceRIonHkSKJxxEimfE4UiTxOFIk8ThSJPE4UiQ9JIVI4nGkSOJxpEjicaRI4nGkSOJxZEi6BY8jRRKPI0USjyNFEo8jRdJDUogkHkeKJB5HiiQeR4okHkeKJB5HiKTB40iRxONIkcTjSJHE40iR9JAUIonHkSKJx5EiiceRIonHkSKJxxEiafE4UiTxOFIk8ThSJPE4UiQ9JIVI4nGkSOJxpEjicaRI4nGkSOJxhEg6PI4USTyOFEk8jhRJPI4USQ9JIZJ4HCmSeBwpkngcKZJ4HCmSeBwhkh6PI0USjyNFEo8jRRKPI0XSQ1KIJB5HiiQeR4okHkeKJB5HiiQeR4jkiseRIonHkSKJx5EiiceRIukhKUQSjyNFEo8jRRKPI0USjyNFEo8jRDLgcaRI4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkRzK46R1J5kX/2n0fbZD+ZDSbONQXqE426Hq+eJsh6q5i7Mdqi4uztZPNduh6svibIeqAYuzHapOK852qlpqrDPPS7Md61zy4mynqqXGOt+7ONupaqmxzskuznaqWmqs86aLs52qlhrr3ObibKeqpcY6/7g426lqqbHOES7OdqpaaqzzeIuznaqWGutc2+Jsp6qlxjoftjjbmWopP9Y5q8XZzlRL+bHOKy3OdqZayi9+qtnOVEv5sc7PLM52plrKj3UOZXG2U9VSY53nWJztVLXUWOciFmc7VS011vmCxdlOVUuNdU5fcbZT1VJjnXdXnO1UtdRY58YVZztVLTXW+WvF2U5VS411jllxtlPVUmOdB1ac7VS11FjnahVnO1UtNdb5VMXZTlVLjXXOU3G2U9VSY52XVJztVLXUWOcOFWc7VS011vk9xdlOVUuNdQ5OcbZT1VJjnSdTnO1QtVQ26z7bUBptYvoYbJ92wLHJHYxNO4/kcmFsTlvIOX8eeyfuIX4x8aFqShXEh6prc9zC9sYvhdE2Orshj/l5dDxifmO1QbcmfBp9JzlUzdyU5FD1eFOSQ9X6LUmOddZMU5JDeZSmJIfyP01JjuWtWpL0kBQiOZYXakkSjyNFEo8jRRKPI0USjyNEcqyzZpqSxONIkcTjSJHE40iR9JAUIonHkSKJx5EiiceRIonHkSKJxxEiOdYZOU1J4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE4wiRHOvsqqYk8ThSJPE4UiTxOFIkPSSFSOJxpEjicaRI4nGkSOJxpEjicYRIjnWmXFOSeBwpkngcKZJ4HCmSHpJCJPE4UiTxOFIk8ThSJPE4UiTxODIk17HOemxKEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeI5FhnsDYliceRIonHkSKJx5Ei6SEpRBKPI0USjyNFEo8jRRKPI0USjyNEcqyzkZuSxONIkcTjSJHE40iR9JAUIonHkSKJx5EiiceRIonHkSKJxxEiOdaZ5U1J4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE4wiR9HgcKZJ4HCmSeBwpkngcKZIekkIk8ThSJPE4UiTxOFIk8ThSJPE4QiRXPI4USTyOFEk8jhRJPI4USQ9JIZJ4HCmSeBwpkngcKZJ4HCmSeBwhkgGPI0USjyNFEo8jRRKPI0XSQ1KIJB5HiiQeR4okHkeKJB5HiiQeR4hkxONIkcTjSJHE40iRxONIkfSQFCKJx5EiiceRIonHkSKJx5EiiccRIpnwOFIk8ThSJPE4UiTxOFIkPSSFSOJxpEjicaRI4nGkSOJxpEjicYRIZjyOFEk8jhRJPI4USTyOFEkPSSGSeBwpkngcKZJ4HCmSeBwpkngcGZJhweNIkcTjSJHE40iRxONIkfSQFCKJx5EiiceRIonHkSKJx5EiiccRImnwOFIk8ThSJPE4UiTxOFIkPSSFSOJxpEjicaRI4nGkSOJxpEjicYRIWjyOFEk8jhRJPI4USTyOFEkPSSGSeBwpkngcKZJ4HCmSeBwpkngcIZIOjyNFEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeIpMfjSJHE40iRxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHESK54nGkSOJxpEjicaRI4nGkSHpICpHE40iRxONIkcTjSJHE40iRxOMIkQx4HCmSeBwpkngcKZJ4HCmSHpJCJPE4UiTxOFIk8ThSJPE4UiTxOEIkIx5HiiQeR4okHkeKJB5HiqSHpBBJPI4USTyOFEk8jhRJPI4USTyOEMmEx5EiiceRIonHkSKJx5Ei6SEpRBKPI0USjyNFEo8jRRKPI0USjyNEMuNxpEjicaRI4nGkSOJxpEh6SAqRxONIkcTjSJHE40iRxONIkcTjyJCMCx5HiiQeR4okHkeKJB5HiqSHpBBJPI4USTyOFEk8jhRJPI4USTyOEEmDx5EiiceRIonHkSKJx5Ei6SEpRBKPI0USjyNFEo8jRRKPI0USjyNE0uJxpEjicaRI4nGkSOJxpEh6SAqRxONIkcTjSJHE40iRxONIkcTjCJF0eBwpkngcKZJ4HCmSeBwpkh6SQiTxOFIk8ThSJPE4UiTxOFIkR/I43uyjvcnh0+jfs/Uj+ZDybEfyCuXZjlTPl2c7Us1dnq2farYj1a7l2Y5UX5ZnO1INWJ7tSHVaebZT1VJDnXlenu1UtdRQZ4eXZztVLTXUGdzl2U5VSw11lnV5tlPVUkOdCV2e7VS11FBnK5dnO1UtNdQZxeXZTlVLDXXWb3m2U9VSQ52ZW57tVLXUUGfPlmc7VS011Bmu5dlOVUsNdRZqebZT1VJDnSlanu1UtdRQZ3OWZztVLTXUGZfl2U5VSw11VmR5tlPVUkOduVie7VS11FBnF5ZnO1UtNdQZgOXZTlVLDXWWXnm2U9VSQ51JV57tVLXUUGe7lWc7VS011Blp5dlOVUsNddZYebZT1VJDndlVnu1MtVQa6uwr743bZhvNcjDboWqp4myHqqWKsx2qlirO1k8126FqqeJsh6qlirMdqpYqznaoWqo426FqqdJshzpjpzzbqWqpoc6qKc92qlpqqDNfyrOdqpYa6uyU8mynqqWGOoOkPNupaqmhzvIoz3aqWmqoMzHKs52qlhrqbInybKeqpYY6o6E826lqqaHOOijPdqpaaqgzA8qznaqWGmrv/fJsp6qlhtrDvjzbqWqpofaCL892qlpqqD3Vy7OdqpYaa9/z4mynqqXG2ve8ONupaqmx9j0vznaqWmqsfc+Ls52qlhpr3/PibKeqpcba97w425lqqdyg5xjiNnoNyT3P9h5RA/7Lg/8SvkbkDyOybhPCuZgKEbmQl210Wp5/4BE/3mS94k3CFW8Sr3iTdMWb5Ave5IVTFX4Tc8Wb2CvexF3xJld84v0Vn3h/xSfeX/GJ91d84v0Vn/j1ik/8esUnfr3iE79e8Ylfr/jEr1d84tcrPvHrFZ/49YpP/HrFJz5c8YkPV3ziwxWf+HDFJz5c8YkPV3ziwxWf+HDFJz5c8YkPV3zi4xWf+HjFJz5e8YmPV3zi4xWf+HjFJz5e8YmPV3zi4xWf+HjFJz5d8YlPV3zi0xWf+HTFJz5d8YlPV3zi0xWf+CTxiU9xH50Xc/Am6Yo3yRe8SV6ueBNzxZvYK97EXfEm/oo3WYXfxNiDN5H4xKf98Y/Ldvn0Jl9Hp/0RS3KPJyz21zOaL2NvN6SPsTl/HnsPPmoOPmkOPqsN3i7Lojl4ozl4qzl4pzl4rzn4VXPwelfYW/B6V9hb8HpX2FvwmldY0/cKG7ax5rYiHUTf9xJbir7vNbYUfd+LbCn6vlfZUvR9L7Ol6CXW2WzjHv0aC9F//x3DW0Sxu4hSdxHl3iKyS3cRme4ist1F5LqLyHcX0dpdRN3ds213d0h7/R3y22+q28W57iK6/rMW7SMiG79GtHYXUeguothdRKm7iBp8+n3YI1r9c0RfB1u/B2K991/C94vu8I3u8K3u8J3u8L3u8Ffd4Qfd4cfOw7fpEf7Xgswn3eH3vup+H/7a+aq7rlvNY9fgvh8cbo/rPwaHW3/161w7X6J/Mtc1x/ztXDtfz9e992vXaL4fnJbthZN/+qG1Xz6m2vnaLzlVP89UO68pJKfaef0hOdXOaxXBqYbeV9afTHXd+o4phk9TPXhh47aYrVkfL+zt0eC0LXlu+TT0jrD3BVsBwpHqgEYIR6ovGiH0IPxThCPVQ40QjlRnNUI4Uv3WCGHn/S4NCDvvuSlAGHEnf4wQd/LHCHEnf4wQd/KnCNOsWbhkuyN8+qrUIcKUtiA+/Tj48IXN7b23V779HZ++gp3TB/NZ07Ylcw/zy5nPattbMp/V57dkPmtjoCXzWTsJLZnP2npoyDzP2qtoyXzW5kZL5vjQ65njQ69n7mF+OXN86PXM8aHXM8eHXs8cH3o9c3zo1czNgg+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzA0+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzO3+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17O3OFDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfPeTzAdkjk+9Hrm+NDrmeNDL2eu6gzF9P3gGLaxMX6ieJ+ppuz6s5n6aWbawtE/DqhfC8F/99L3+IPy+KPy+JPy+LPu+JucHykZv+k6fr+47QBlv+RceGnn92LB+fQU9vpxt21yzmK72bqpZuunmm3fdYP0bPuuMqRn23dNIj3bvisY6dn2Xe8Izzb2XR1Jz3aqWirqraXu8eutju7xe+Xx661g7vHrrUnu8eutMu7xd143mL2h6J3xhZdOi9+a7e4xV5vcwdicthfO+fPYO5fOK4xWXFLntUgzLp1XLc24dF7fNOPSed3UjIuHyyGXzuu8Zlw6rx+bcem8Lm3GhXr3mAv17iGXTL17zIV695iL75yL2fqR3tiDfkDuvc4oxd97PVCKv/d1uxR/7+trKf7e18Hv47dL7+tVKf7e15VS/L33O0rx996XKMWve/21i+711y6611+76F5/7aJ7/bWL8vXXKF9/jfL11yhff43y9bfJ/v6S8Stff43y9dcoX3+N8vXXKF9/rfL11ypff63y9dcqX3+b7GssGb/y9dcqX3+t8vXXKl9/rfL11ylff53y9dcpX3+d8vW3yX6OkvErX3+d8vXXKV9/nfL11ylff73y9dcrX3+98vXXK19/vfL11ytff73y9dcrX3+98vXXK19/V+Xr76p8/V2Vr7+r8vW3yZ6DkvErX38730mwHL/y9bfznQTL8StffzvfSbAcv/L1t/e9AYvxK19/e9+/rxi/8vW39z32ivErX3973wevGL/y9bf3veqK8Stff3vfT64Yv/L1t/f95IrxK19/e99Prhi/8vW3+/3kSvErX3+735+tFL/y9bf7/c5K8Stff7vfP6wUv/L1t/v9uErxK19/u9/fqhS/8vW3+/2iSvErX3+z8vU3K19/le9/ZZXvf2WV739lle9/ZZXvf2WV73/llO9/5ZTvf+WU73/llO9/5Rbd66/rfv+r0/YVDdtYsyz20+A7mGk3ui6BmXan6xKYabe6LoGZdq/rApjuNy9rBkbvKSb3+PWeNnKP3yuPX29Vc49fb/Fxj19vjXCPX+9Sfo9f74r7O/7udxUrxa/3tIZ7/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexQvzd7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf9/rru99VrBS/7vXXd7+rWCl+3euvX3Svv17xrmL3+HWvv17xHl33+HWvv17xjle/41e8MdU9fuXrr/L9r7zy/a+88v2vfO/7XwWXt/jT4gov/aON5dI2w5w/j71z6Xxdb8al83qhGZfO65DzuHy/QaPvfYOxZmB637msHZjOS7J2YDqv9dqB6byIbAfG9w0m7S/tky+BicF9DI4x7GO9/Zhq54Ws5FQ7r00lp9p5ufnNVO/xd14WFuPvvHorxd/59nSr8es22IQDe9759nTl+PsuWcrx911ZlOP3yuPve1Uvx9/3Ul2Ov+/1txx/3+tvOf6+19/n+K2xX+PvfHu6cvx61t/j+PWsv8fx61l/j+PXs/4ex9/5+htN3AenfBB/5+tvMf7O199i/J2vv8X4O19/S/F3vj1dOf7O199i/J2vv8X4O19/i/F3vv4W41e+/na+PV05fuXrb+fb063JLdvgHFLhpX3eJ/v8VaZkD8bauGzHGdtoH5Vt+ODS+breikvn2+m149J5HSLE5T7XzmsW0bl2Xt+IztVPNNfO6ybRuXZeY4nOtfN67EdzvbXctsE+Hcx1pNqtNNeR6rHCXDvfMlF2riPVTaW5jlQ3leY6Ut1UmqufaK4j1U2luY5UN63rXjelg7qp820mZec6VN1UmOtQddP3c+18q0vZuQ5VNxXmOlTdVJjrUHVTYa5+orkOVTcV5jpR3dT59qDfzfUev95a6B6/3vrmd/ydbw9ajl9vHXKPX29tcY+/73ohLMsWSHDBHMTvlcff97pejr/vtbocf9/rbzn+vtffcvx9r7+l+NfOtwctx9/3+luOv+/1txy/7vV3XXSvv2vn24OW49e9/q6dbw9ajl/3+rt2vj1oMf7Otwctx698/e18e9By/MrX3863By3Hr3z97Xwbz3L8ytffzrfFLMevfP3tfJPJcvzK19/Ot2wsx698/e18A8Ry/MrX3863KizHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18/8Fy/MrX3873HyzHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18/8Fy/MrX3873HyzHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18P79y/MrX38730ivHr3z97XzPu3L8ytff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M0/40OuZ40OvZ44PvZ45PvR65h7mlzPHh17PHB96PXN86PXM8aHXM8eHXs4840OvZ44PvZ45PvR65vjQ65l7mF/OHB96PXN86PXM8aHXM8eHXs8cH3o187zgQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxodczx4dezxwfejlzgw+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzC0+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzN3+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17O3ONDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfMVH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZB3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZx7xodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZx5wodezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5hkfej1zfOj1zPGh1zPHh17P3MP8cub40OuZ40OvZ44PvZ45PvR65vjQi5m7ZcGHXs8cH3o9c3zo9czxodcz9zC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYGH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZW3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ+7wodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZy5x4dezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5is+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzMP+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17OPOJDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfOED72eOT70eub40OuZ40OvZ+5hfjlzfOj1zPGh1zPH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+E3SFW+SL3iTF4/Mhd/Enf7RzBL3sG9/u5byev5bhPPfIp7/Fun8t8hnv0VelvPfQmI9+faHWXmx57+FO/8t/NkLb17W898inP8W8fy3SOe/RT79Lcxy/luY89/Cnv8Wh0m7rlvXdE3PlZ79uCjWXJRqLjpOlSXus/r1d/5LRZJfPOZaYt5L2OX2oPjLZabuMlt3mau77PhmudweKD0ue9qEfbtsrbss1F0Wqy5zL3TLj+3olxzMl8tekMxp25bemGX5QtL5usvWusti3dxS3WUvPjg5u6cg179e5pe6y0zdZbbuMld3ma+7bK277PiDcxuaH5fZ5yz5+89z6ng/Lek3SVe8Sf7zN/n+WWQ+fkIo+xbm/LewP32L+2Wu7jJfd1ndLfLF87niZbHuslR3Wa66LCx1l5m6y2zdZXULaahbSF886ojrfmON8flnqkefFhuX/RtG0dovb5FPf4sXjzpE38Kc/xb2/Ldw57+FP/8t1vPfIpz/FvH8tzj/0x3P/3Sn8z/d6fxPdzr/053O/3Sn8z/d6fxPdzr/053O/3SnH3+675flqsvyUneZqbvM1l3m6i7zdZetdZeFusti3WV1WZJrsmRdlqXuMlN3ma27zNVd5usuW+suC3WXxbrLUt1ldVli6rLE1GWJqcsSU5clpi5LTF2WmLosMXVZYuqyxNRlia3LEluXJbYuS2xdlti6LLF1WWLrssTWZYmtyxJblyWuLktcXZa4uixxdVni6rLE1WWJq8sSV5clri5LXF2W+Los8XVZ4uuyxNdlia/LEl+XJb4uS3xdlvi6LPF1WbLWZclalyVrXZasdVmy1mXJWpcla12WrHVZstZlyVqXJaEuS0JdloS6LAl1WRLqsiTUZUmoy5JQlyWhLktCXZbEuiyJdVkS67Ik1mVJrMuSWJclsS5LYl2WxLosiXVZkuqyJNVlSarLklSXJakuS1JdlqS6LEl1WZLqsiTVZUmuy5JclyW5LktyXZbkuizJdVmS67Ik12VJrsuSut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZoXvde8f8PQZG8OLnuRJfuWfiZn++myo618hQ4KuYUT+won9RVO7iqcV73tVuGYvsKxfYXj+grH9xXO2lc4fd2VU1935dTXXTn1dVfOfd2Vc1935dzXXTn3dVfOV9+Vvz3j6hbP2lk8obN4YmfxpM7iyV3FY4+f4Npb6fpxmbVmLcRzc+jLHn6If9294PYm5oo3sVe8iRN5ExcebxLc05sc/CIvuW1jILc87/u0HG+nuux7ri3u8dv7bD/i953Hv+78w+rc1/hX5fEH5fFH5fEn5fFn3fGbRXn8Rnn8Vnn8va+/pfiVr79G+fprlK+/Rvn6a5Svv0b5+muVr79W+fprla+/Vvn6a5Wvv1b5+muVr79W+fprla+/Vvn665Svv075+uuUr79O+frrlK+/Tvn665Svv075+uuUr79O+frrla+/Xvn665Wvv175+uuVr79e+frrla+/Xvn665Wvv175+rsqX39X5evvqnz9XZWvv6vy9XdVvv6uytffVfn6uypff1fl629Qvv4G5etvUL7+BuXrb1C+/gbl629Qvv4G5etvUL7+BuXrb1S+/kbl629Uvv5G5etvVL7+RuXrb1S+/kbl629Uvv5G5etvUr7+JuXrb1K+/ibl629Svv4m5etvUr7+JuXrb1K+/ibl629Wvv5m5etvVr7+ZuXrb1a+/mbl629Wvv5m5etvVr7+Zt3rr1t0r79u0b3+ukX3+uu63/+qFL/u9dcp3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yivf/8or3//KK9//yivf/8ovutdfr3z/K9/9/lePlw4xm+f4jwZvUYcUHi+c1o+59r5WS86193Vdcq691wCCc+1+vy7JufZeW0jOtfM6ZM1reszVfj9XH/MWh08u7YNtTodhm7hH7fw+2rn8wabzGqcpGw+bl2w6r83i6u3H6BiW8D0b57axzj8FfTR0DesW8hqXp8G/6r+vMee8v/KypE+j7xg7LxG1YOy8+tSCsfPCVgvGzmtmJRh7375PC8bOK30tGDs3EVowdu43tGD0YJTAiIsRwYiLEcGIixHBiIsRwYiLkcDY+yaoWjDiYkQw4mJEMOJiRDB6MEpgxMWIYMTFiGDExYhgxMWIYMTFSGDsfStpLRhxMSIYcTEiGHExIhg9GCUw4mJEMOJiRDDiYkQw4mJEMOJiJDD2viG/Foy4GBGMuBgRjLgYEYwejBIYcTEiGHExIhhxMSIYcTEiGHExEhh7P9ZEC0ZcjAhGXIwIRlyMCEYPRgmMuBgRjLgYEYy4GBGMuBgRjLgYCYy9Hw6lBSMuRgQjLkYEIy5GBKMHowRGXIwIRlyMCEZcjAhGXIwIRlyMBMbej9jTghEXI4IRFyOCERcjgtGDUQIjLkYEIy5GBCMuRgQjLkYEIy5GAmPvB5VqwYiLEcGIixHBiIsRwejBKIERFyOCERcjghEXI4IRFyOCERcjgHHt/bhnLRhxMSIYcTEiGHExIhg9GCUw4mJEMOJiRDDiYkQw4mJEMOJiJDD2fgi9Foy4GBGMuBgRjLgYEYwejBIYcTEiGHExIhhxMSIYcTEiGHExEhgtLkYEIy5GBCMuRgQjLkYEowejBEZcjAhGXIwIRlyMCEZcjAhGXIwERoeLEcGIixHBiIsRwYiLEcHowSiBERcjghEXI4IRFyOCERcjghEXI4HR42JEMOJiRDDiYkQw4mJEMHowSmDExYhgxMWIYMTFiGDExYhgxMVIYFxxMSIYcTEi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","names":["constructor"],"brillig_names":["get_contract_instance_internal","decompose_hint","lte_hint","discover_new_messages","notify_created_nullifier_oracle_wrapper","directive_invert"]},{"name":"_repay","hash":"12661382094530085377","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5235018679007078561":{"error_kind":"string","string":"Invalid asset or market id"},"6787403583199288031":{"error_kind":"string","string":"Insufficient balance"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13135008234568508716":{"error_kind":"string","string":"Function _repay can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_repay"],"brillig_names":["_repay"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Lending::_withdraw_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_withdraw_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::compute_total_deposited_assets_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::compute_total_deposited_assets_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"deposit_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]}}]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":128}}]},{"kind":"struct","path":"Lending::_compute_utilization_rate_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_compute_utilization_rate_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"precision","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"deposit_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]}},{"name":"borrow_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]}}]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":128}}]},{"kind":"struct","path":"Lending::borrow_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::borrow_private_parameters","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::borrow_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::borrow_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::_compute_collateral_debt_value_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_compute_collateral_debt_value_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":128}}]},{"kind":"struct","path":"Lending::liquidate_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::liquidate_public_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debt_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"user","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debt_to_cover","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"Lending::_borrow_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_borrow_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::_deposit_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_deposit_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::update_accumulators_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::update_accumulators_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::_compute_borrow_rate_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_compute_borrow_rate_parameters","fields":[{"name":"asset","type":{"kind":"struct","path":"asset::Asset","fields":[{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"loan_to_value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"oracle","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_borrowable","type":{"kind":"boolean"}},{"name":"optimal_utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"under_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"over_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"deposit_cap","type":{"kind":"integer","sign":"unsigned","width":128}}]}},{"name":"utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"precision","type":{"kind":"integer","sign":"unsigned","width":128}}]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":128}}]},{"kind":"struct","path":"Lending::add_asset_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::add_asset_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"oracle","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"loan_to_value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"is_borrowable","type":{"kind":"boolean"}},{"name":"optimal_utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"under_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"over_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"deposit_cap","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"Lending::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::constructor_parameters","fields":[]}}]},{"kind":"struct","path":"Lending::withdraw_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::withdraw_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::_compute_total_collateral_value_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_compute_total_collateral_value_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":128}}]},{"kind":"struct","path":"Lending::repay_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::repay_public_parameters","fields":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"nonce","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::repay_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::repay_private_parameters","fields":[{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"nonce","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"on_behalf_of","type":{"kind":"field"}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::_liquidate_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_liquidate_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debt_token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"user","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debt_to_liquidate_amount","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"Lending::_repay_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_repay_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::deposit_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::deposit_private_parameters","fields":[{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"nonce","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"on_behalf_of","type":{"kind":"field"}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::deposit_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::deposit_public_parameters","fields":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"nonce","type":{"kind":"field"}},{"name":"on_behalf_of","type":{"kind":"field"}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::withdraw_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::withdraw_private_parameters","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"PriceFeed"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000a"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Lending"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"market_assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"market_assets_list","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"market_assets_list_len","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"scaled_deposited_assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"scaled_borrowed_assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"scaled_total_deposited_assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"scaled_total_borrowed_assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"deposit_accumulators","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"borrow_accumulators","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}}]}}]}],"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"UintNote"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"UintNote"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]}]}},"file_map":{"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"25":{"source":"//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n","path":"std/meta/expr.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"46":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n","path":"std/slice.nr"},"52":{"source":"use dep::aztec::hash::pedersen_hash;\nuse std::ops::{Add, Sub};\n\n// Utility used to easily get a \"id\" for a private user that sits in the same\n// \"space\" as the public users.\n// It help us to have a single mapping for collateral that have both public and private users.\npub fn compute_identifier(secret: Field, on_behalf_of: Field, self: Field) -> Field {\n    // EITHER secret OR on_behalf_of MUST be set. But not both\n    assert(!((secret == 0) as bool & (on_behalf_of == 0) as bool));\n    if (secret != 0) {\n        pedersen_hash([self, secret], 0)\n    } else {\n        on_behalf_of\n    }\n}\n\npub fn covered_by_collateral(\n    collateral_price: u128,\n    borrow_price: u128,\n    loan_to_value: u128,\n    collateral: u128,\n    increase: u128,\n    decrease: u128,\n) -> u128 {\n    let price_precision = 1000000000 as u128;\n    let ltv_precision = 10000 as u128;\n\n    let collateral = (collateral + increase) - decrease;\n\n    let collateral_value = (collateral * collateral_price) / price_precision;\n    let debt_covered = (collateral_value * loan_to_value * price_precision) / (borrow_price * ltv_precision);\n\n    debt_covered\n}\n\npub struct DebtReturn {\n    debt_value: u128,\n    static_debt: u128,\n}\n\nfn div_up(a: u128, b: u128) -> u128 {\n    let div = a / b;\n    if div * b < a {\n        div + (1 as u128)\n    } else {\n        div\n    }\n}\n\npub fn debt_updates(\n    interest_accumulator: u128,\n    static_debt: u128,\n    increase: u128,\n    decrease: u128,\n) -> DebtReturn {\n    assert(interest_accumulator > (0 as u128));\n    let accumulator_precision = 1000000000 as u128;\n\n    let current_debt_value = (static_debt * interest_accumulator) / accumulator_precision;\n    let new_debt_value = current_debt_value.add(increase).sub(decrease);\n\n    // static_debt_increase = amount / accumulator\n    // rounding up new debt.\n    let static_debt_increase = div_up(increase * accumulator_precision, interest_accumulator);\n    // rounding down repayment.\n    let static_debt_decrease = (decrease * accumulator_precision) / interest_accumulator;\n\n    // We need to allow repaying of the entire debt as well etc. This is very prone to failing\n    // if you try to repay exact due to time diff between sim and execution.\n    let new_static_debt = static_debt.add(static_debt_increase).sub(static_debt_decrease);\n\n    DebtReturn { debt_value: new_debt_value, static_debt: new_static_debt }\n}\n\npub fn debt_value(static_debt: u128, interest_accumulator: u128) -> u128 {\n    let accumulator_precision = 1000000000 as u128;\n    div_up(static_debt * interest_accumulator, accumulator_precision)\n}\n","path":"/home/jean/work/noir/comet/contracts/src/helpers.nr"},"53":{"source":"mod asset;\nmod position;\nmod helpers;\nmod accumulator;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Lending {\n    use dep::aztec::prelude::{AztecAddress, Map, PublicMutable};\n\n    use crate::asset::Asset;\n    use crate::helpers::{compute_identifier};\n    use crate::position::Position;\n    use dep::price_feed::PriceFeed;\n    use dep::token::Token;\n    use crate::accumulator::Accumulator;\n    use dep::aztec::macros::{\n        functions::{initializer, internal, private, public, view, utility},\n        storage::storage,\n    };\n    use dep::aztec::protocol_types::traits::{FromField, ToField};\n\n    #[storage]\n    struct Storage<Context> {\n        market_assets: Map<Field, Map<AztecAddress, PublicMutable<Asset, Context>, Context>, Context>,\n        market_assets_list: Map<Field, Map<u64, PublicMutable<AztecAddress, Context>, Context>, Context>,\n        market_assets_list_len: Map<Field, PublicMutable<u64, Context>, Context>,\n        scaled_deposited_assets: Map<Field, Map<AztecAddress, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, Context>,\n        scaled_borrowed_assets: Map<Field, Map<AztecAddress, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, Context>, // static debt\n        scaled_total_deposited_assets: Map<Field, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>,\n        scaled_total_borrowed_assets: Map<Field, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, // static debt\n        deposit_accumulators: Map<Field, Map<AztecAddress, PublicMutable<Accumulator, Context>, Context>, Context>,\n        borrow_accumulators: Map<Field, Map<AztecAddress, PublicMutable<Accumulator, Context>, Context>, Context>,\n    }\n\n    #[private]\n    #[initializer]\n    fn constructor() {}\n\n    #[private]\n    fn repay_private(\n        from: AztecAddress,\n        amount: u128,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        asset_address: AztecAddress,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        // docs:start:private_call\n        let _ = Token::at(asset_address).transfer_to_public(from, context.this_address(), amount, nonce).call(&mut context);\n        // docs:end:private_call\n        let _ = Lending::at(context.this_address())\n            ._repay(AztecAddress::from_field(on_behalf_of), amount, market_id, asset_address)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn repay_public(amount: u128, nonce: Field, owner: AztecAddress, market_id: Field, asset_address: AztecAddress) {\n        let _ = Token::at(asset_address).transfer_in_public(context.msg_sender(), context.this_address(), amount, nonce).call(&mut context);\n        let _ = Lending::at(context.this_address())._repay(owner, amount, market_id, asset_address).call(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _repay(owner: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == asset_address, \"Invalid asset or market id\");\n\n        Lending::at(context.this_address()).update_accumulators(market_id, asset_address).call(&mut context);\n\n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / borrow_accumulator.value;\n\n        assert(scaled_user_borrowed_amount >= scaled_amount, \"Insufficient balance\");\n        scaled_user_borrowed_amount_loc.write(scaled_user_borrowed_amount - scaled_amount);\n\n        let scaled_total_borrowed_asset_loc = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address);\n        let scaled_total_borrowed_asset: u128 = scaled_total_borrowed_asset_loc.read();\n        scaled_total_borrowed_asset_loc.write(scaled_total_borrowed_asset - scaled_amount);\n    }\n\n     #[private]\n    fn borrow_private(secret: Field, to: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let on_behalf_of = compute_identifier(secret, context.msg_sender().to_field(), context.msg_sender().to_field());\n        let _ = Lending::at(context.this_address())\n            ._borrow(AztecAddress::from_field(on_behalf_of), amount, market_id, asset_address)\n            .enqueue(&mut context);\n        // TODO: find a fix to transfer_to_private\n        let _ = Token::at(asset_address)\n        .transfer_in_public(context.this_address(), to, amount, 0)\n        .enqueue(&mut context);\n    }\n\n    #[public]\n    fn borrow_public(to: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let _ = Lending::at(context.this_address())._borrow(context.msg_sender(), amount, market_id, asset_address).call(\n            &mut context,\n        );\n        let _ = Token::at(asset_address)\n        .transfer_in_public(context.this_address(), to, amount, 0)\n        .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _borrow(owner: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n\n        assert(asset.is_borrowable, \"Asset is not borrowable\");\n\n        let total_collateral_value: u128 = Lending::at(context.this_address())._compute_total_collateral_value(market_id, owner).call(&mut context);\n        let collateral_debt_value = Lending::at(context.this_address())._compute_collateral_debt_value(market_id, owner).call(&mut context);\n\n        let borrow_price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n        let min_collateral_for_borrow = (amount * borrow_price * 10000 as u128) / (asset.loan_to_value * 1000000000 as u128);\n\n        assert(collateral_debt_value + min_collateral_for_borrow <= total_collateral_value, \"Insufficient collateral\");\n        \n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / borrow_accumulator.value;\n        scaled_user_borrowed_amount_loc.write(scaled_user_borrowed_amount + scaled_amount);\n\n        let scaled_total_borrowed_asset_loc = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address);\n        let scaled_total_borrowed_asset: u128 = scaled_total_borrowed_asset_loc.read();\n        scaled_total_borrowed_asset_loc.write(scaled_total_borrowed_asset + scaled_amount);\n    }\n\n    #[private]\n    fn withdraw_private(secret: Field, to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let on_behalf_of = compute_identifier(secret, context.msg_sender().to_field(), context.msg_sender().to_field());\n        Lending::at(context.this_address())\n            ._withdraw(AztecAddress::from_field(on_behalf_of), to, amount, market_id, collateral_asset)\n            .enqueue(&mut context);\n        // TODO: find a fix to transfer_to_private\n        let _ = Token::at(collateral_asset)\n        .transfer_in_public(context.this_address(), to, amount, 0)\n        .enqueue(&mut context);\n        // let _ = Token::at(collateral_asset)\n        // .transfer_to_private(to, amount)\n        // .call(&mut context);\n    }\n\n    #[public]\n    fn withdraw_public(to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let _ = Lending::at(context.this_address())\n            ._withdraw(context.msg_sender(), to, amount, market_id, collateral_asset)\n            .call(&mut context);\n        let _ = Token::at(collateral_asset)\n        .transfer_in_public(context.this_address(), to, amount, 0)\n        .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _withdraw(owner: AztecAddress, to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(collateral_asset);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == collateral_asset, \"Invalid asset or market id\");\n        \n        Lending::at(context.this_address()).update_accumulators(market_id, collateral_asset).call(&mut context);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(collateral_asset);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        let scaled_user_deposited_amount_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_asset).at(owner);\n        let scaled_user_deposited_amount: u128 = scaled_user_deposited_amount_loc.read();\n        let user_deposited_amount = (scaled_user_deposited_amount * deposit_accumulator.value) / 1000000000 as u128 ;\n        assert(user_deposited_amount >= amount, \"Insufficient balance\");\n\n        let total_collateral_value: u128 = Lending::at(context.this_address())._compute_total_collateral_value(market_id, owner).call(&mut context);\n\n        let collateral_debt_value = Lending::at(context.this_address())._compute_collateral_debt_value(market_id, owner).call(&mut context);\n\n        let collateral_price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n        let withdraw_amount_value = (amount * collateral_price) / 1000000000 as u128;\n\n        let total_collateral_value_after_withdraw = total_collateral_value - withdraw_amount_value;\n\n        assert(collateral_debt_value <= total_collateral_value_after_withdraw, \"Insufficient collateral\");\n\n        let scaled_withdraw_amount = (amount * 1000000000 as u128) / deposit_accumulator.value;\n        scaled_user_deposited_amount_loc.write(scaled_user_deposited_amount - scaled_withdraw_amount);\n\n        let scaled_total_deposited_asset_loc = storage.scaled_total_deposited_assets.at(market_id).at(collateral_asset);\n        let scaled_total_deposited_asset: u128 = scaled_total_deposited_asset_loc.read();\n        scaled_total_deposited_asset_loc.write(scaled_total_deposited_asset - scaled_withdraw_amount);\n    }\n\n\n    #[public]\n    fn liquidate_public(market_id: Field, collateral_asset: AztecAddress, debt_asset: AztecAddress, user: AztecAddress, debt_to_cover: u128) {\n        let _ = Lending::at(context.this_address())._liquidate(market_id, collateral_asset, debt_asset, user, debt_to_cover).call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _liquidate(market_id: Field, collateral_token: AztecAddress, debt_token: AztecAddress, user: AztecAddress, debt_to_liquidate_amount: u128) {\n        Lending::at(context.this_address()).update_accumulators(market_id, collateral_token).call(&mut context);\n        Lending::at(context.this_address()).update_accumulators(market_id, debt_token).call(&mut context);\n\n        let scaled_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(debt_token).at(user);\n        let scaled_borrowed_amount: u128 = scaled_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(debt_token);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let borrowed_amount = (scaled_borrowed_amount * borrow_accumulator.value) / 1000000000 as u128;\n\n        assert(borrowed_amount >= debt_to_liquidate_amount, \"Insufficient borrowed amount\");\n\n        let total_collateral_value: u128 = Lending::at(context.this_address())._compute_total_collateral_value(market_id, user).call(&mut context);\n        let collateral_debt_value = Lending::at(context.this_address())._compute_collateral_debt_value(market_id, user).call(&mut context);\n\n        assert(collateral_debt_value > total_collateral_value, \"collateral >= debt\");\n\n        let debt_asset_loc = storage.market_assets.at(market_id).at(debt_token);\n        let debt_asset: Asset = debt_asset_loc.read();\n        let debt_asset_price = PriceFeed::at(debt_asset.oracle).get_price(0).view(&mut context).price;\n        let debt_to_liquidate_price = (debt_to_liquidate_amount * debt_asset_price) / 1000000000 as u128;\n\n        let collateral_asset_loc = storage.market_assets.at(market_id).at(collateral_token);\n        let collateral_asset: Asset = collateral_asset_loc.read();\n        let collateral_asset_price = PriceFeed::at(collateral_asset.oracle).get_price(0).view(&mut context).price;\n        let collateral_amount_to_liquidate = (debt_to_liquidate_price * 1000000000 as u128) / collateral_asset_price;\n\n        let collateral_deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(collateral_token);\n        let collateral_deposit_accumulator: Accumulator = collateral_deposit_accumulator_loc.read();\n        let scaled_collateral_deposit_amount_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_token).at(user);\n        let scaled_collateral_deposit_amount: u128 = scaled_collateral_deposit_amount_loc.read();\n        let collateral_deposit_amount = (scaled_collateral_deposit_amount * collateral_deposit_accumulator.value) / 1000000000 as u128;\n\n        assert(collateral_deposit_amount >= collateral_amount_to_liquidate, \"Insufficient collateral\");\n\n        let scaled_collateral_amount_to_liquidate = (collateral_amount_to_liquidate * 1000000000 as u128) / collateral_deposit_accumulator.value;\n\n        let debt_borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(debt_token);\n        let debt_borrow_accumulator: Accumulator = debt_borrow_accumulator_loc.read();\n        let scaled_debt_amount_to_liquidate = (debt_to_liquidate_amount * 1000000000 as u128) / debt_borrow_accumulator.value;\n\n        let scaled_user_deposited_amount_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_token).at(user);\n        let scaled_user_deposited_amount: u128 = scaled_user_deposited_amount_loc.read();\n        scaled_user_deposited_amount_loc.write(scaled_user_deposited_amount - scaled_collateral_amount_to_liquidate);\n\n        let scaled_total_deposited_asset_loc = storage.scaled_total_deposited_assets.at(market_id).at(collateral_token);\n        let scaled_total_deposited_asset: u128 = scaled_total_deposited_asset_loc.read();\n        scaled_total_deposited_asset_loc.write(scaled_total_deposited_asset - scaled_collateral_amount_to_liquidate);\n\n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(debt_token).at(user);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        scaled_user_borrowed_amount_loc.write(scaled_user_borrowed_amount - scaled_debt_amount_to_liquidate);\n\n        let scaled_total_borrowed_asset_loc = storage.scaled_total_borrowed_assets.at(market_id).at(debt_token);\n        let scaled_total_borrowed_asset: u128 = scaled_total_borrowed_asset_loc.read();\n        scaled_total_borrowed_asset_loc.write(scaled_total_borrowed_asset - scaled_debt_amount_to_liquidate);\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_total_collateral_value(market_id: Field, owner: AztecAddress) -> u128 {\n        let mut total_collateral_value: u128 = 0 as u128;\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id);\n\n        for i in 0..market_assets_list_len {\n            let market_asset_loc = market_assets_list_loc.at(i);\n            let market_asset: AztecAddress = market_asset_loc.read();\n            Lending::at(context.this_address()).update_accumulators(market_id, market_asset).call(&mut context);\n            let collateral_asset_loc = storage.market_assets.at(market_id).at(market_asset);\n            let collateral_asset: Asset = collateral_asset_loc.read();\n            let collateral_price = PriceFeed::at(collateral_asset.oracle).get_price(0).view(&mut context).price;\n            let scaled_collateral_amount_loc = storage.scaled_deposited_assets.at(market_id).at(market_asset).at(owner);\n            let scaled_collateral_amount: u128 = scaled_collateral_amount_loc.read();\n            let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(market_asset);\n            let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n            let collateral_amount = (scaled_collateral_amount * deposit_accumulator.value) / 1000000000 as u128;\n            total_collateral_value += (collateral_amount * collateral_price);\n        }\n        total_collateral_value / 1000000000 as u128\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_collateral_debt_value(market_id: Field, owner: AztecAddress) -> u128 {\n        let mut min_collateral_value: u128 = 0 as u128;\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id);\n\n        for i in 0..market_assets_list_len {\n            let market_asset_loc = market_assets_list_loc.at(i);\n            let market_asset: AztecAddress = market_asset_loc.read();\n            Lending::at(context.this_address()).update_accumulators(market_id, market_asset).call(&mut context);\n            let debt_asset_loc = storage.market_assets.at(market_id).at(market_asset);\n            let debt_asset: Asset = debt_asset_loc.read();\n            if(debt_asset.is_borrowable) {\n                let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(market_asset).at(owner);\n                let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n                let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(market_asset);\n                let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n                let user_borrowed_amount = (scaled_user_borrowed_amount * borrow_accumulator.value) / 1000000000 as u128;\n                \n                let borrow_price= PriceFeed::at(debt_asset.oracle).get_price(0).view(&mut context).price;\n\n                min_collateral_value += (user_borrowed_amount * borrow_price * 10000 as u128) / debt_asset.loan_to_value;\n            }\n        }\n        min_collateral_value / 1000000000 as u128\n    }\n\n    #[private]\n    fn deposit_private(\n        from: AztecAddress,\n        amount: u128,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        let _res = Token::at(collateral_asset)\n            .transfer_to_public(from, context.this_address(), amount, nonce)\n            .call(&mut context);\n        Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, market_id,collateral_asset)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn deposit_public(\n        amount: u128,\n        nonce: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        // docs:start:public_to_public_call\n        let _ = Token::at(collateral_asset)\n            .transfer_in_public(context.msg_sender(), context.this_address(), amount, nonce)\n            .call(&mut context);\n        // docs:end:public_to_public_call\n        let _ = Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, market_id, collateral_asset)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _deposit(owner: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(collateral_asset);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == collateral_asset, \"Invalid asset or market id\");\n        \n        Lending::at(context.this_address()).update_accumulators(market_id, collateral_asset).call(&mut context);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(collateral_asset);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        let total_deposited_assets = Lending::at(context.this_address()).compute_total_deposited_assets(market_id, collateral_asset, deposit_accumulator).call(&mut context);\n        assert((total_deposited_assets + amount) < asset.deposit_cap, \"Deposit cap exceeded\");\n\n        let scaled_user_deposited_asset_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_asset).at(owner);\n        let scaled_user_deposited_asset: u128 = scaled_user_deposited_asset_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / deposit_accumulator.value;\n        scaled_user_deposited_asset_loc.write(scaled_user_deposited_asset + scaled_amount);\n\n        let scaled_total_deposited_asset_loc = storage.scaled_total_deposited_assets.at(market_id).at(collateral_asset);\n        let scaled_total_deposited_asset: u128 = scaled_total_deposited_asset_loc.read();\n        scaled_total_deposited_asset_loc.write(scaled_total_deposited_asset + scaled_amount);\n    }\n\n    #[public]\n    fn compute_total_deposited_assets(market_id: Field, asset_address: AztecAddress, deposit_accumulator: Accumulator) -> u128 {\n        let scaled_total_deposited_asset_static = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let total_deposited_asset = scaled_total_deposited_asset_static * deposit_accumulator.value / 1000000000 as u128;\n        total_deposited_asset\n    }\n\n    #[public]\n    fn add_asset(market_id: Field, asset_address: AztecAddress, oracle: AztecAddress, loan_to_value: u128, is_borrowable: bool, optimal_utilization_rate: u128, under_optimal_slope: u128, over_optimal_slope: u128, deposit_cap: u128) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n\n        assert(loan_to_value <= (10000 as u128));\n\n        asset_loc.write(Asset {\n            asset_address,\n            oracle,\n            loan_to_value,\n            is_borrowable,\n            optimal_utilization_rate,\n            under_optimal_slope,\n            over_optimal_slope,\n            deposit_cap,\n        });\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id).at(market_assets_list_len);\n        market_assets_list_loc.write(asset_address);\n        market_assets_list_len_loc.write(market_assets_list_len + 1);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        assert(deposit_accumulator.last_updated_ts == 0);\n        assert(deposit_accumulator.value == 0 as u128);\n\n        deposit_accumulator_loc.write(Accumulator {\n            // 10**9\n            value: 1000000000 as u128,\n            last_updated_ts: context.timestamp(),\n        });\n\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n\n        assert(borrow_accumulator.last_updated_ts == 0);\n        assert(borrow_accumulator.value == 0 as u128);\n\n        borrow_accumulator_loc.write(Accumulator {\n            // 10**9\n            value: 1000000000 as u128,\n            last_updated_ts: context.timestamp(),\n        });\n    }\n\n\n    // Create a position.\n    #[public]\n    fn update_accumulators(market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let mut deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let mut borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n\n        let timestamp = context.timestamp();\n        let time_delta = timestamp - deposit_accumulator.last_updated_ts;\n\n        // Only update if time has passed.\n        if !(time_delta == 0) {\n            let precision = 1000000000 as u128; // 10**9\n            let utilization_rate = _compute_utilization_rate(market_id, asset_address, precision, deposit_accumulator, borrow_accumulator);\n            let borrow_rate_per_year = _compute_borrow_rate(asset, utilization_rate, precision);\n            // TODO: let supply_rate_per_year = borrow_rate_per_year * utilization_rate * (1 - reserve_factor);\n            let supply_rate_per_year = (borrow_rate_per_year * utilization_rate) / precision;\n\n            let new_borrow_accumulator = ((borrow_accumulator.value * borrow_rate_per_year * time_delta as u128) / 31536000 as u128) / precision;\n            let new_deposit_accumulator = ((deposit_accumulator.value * supply_rate_per_year * time_delta as u128) / 31536000 as u128) / precision;\n\n            borrow_accumulator.value += new_borrow_accumulator;\n            borrow_accumulator.last_updated_ts = timestamp;\n            borrow_accumulator_loc.write(borrow_accumulator);\n            deposit_accumulator.value += new_deposit_accumulator;\n            deposit_accumulator.last_updated_ts = timestamp;\n            deposit_accumulator_loc.write(deposit_accumulator);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_utilization_rate(market_id: Field, asset_address: AztecAddress, precision: u128, deposit_accumulator: Accumulator, borrow_accumulator: Accumulator) -> u128 {\n        \n        let scaled_total_deposited_asset = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let scaled_total_borrowed_asset = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address).read();\n\n        let total_deposited_assets = (scaled_total_deposited_asset * deposit_accumulator.value) / precision;\n        let total_borrowed_assets = (scaled_total_borrowed_asset * borrow_accumulator.value) / precision;\n        let mut utilization_rate = 0 as u128;\n        if (total_borrowed_assets != 0) {\n            utilization_rate = (total_borrowed_assets * precision) / total_deposited_assets;\n        } else {\n            utilization_rate = 0;\n        }\n\n        utilization_rate\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_borrow_rate(asset: Asset, utilization_rate: u128, precision: u128) -> u128 {\n        let mut rate = 0 as u128;\n        if utilization_rate < asset.optimal_utilization_rate {\n            // rate = base + utilization * slope1 / optimal No base for now\n            rate = (utilization_rate * asset.under_optimal_slope) / asset.optimal_utilization_rate;\n        } else {\n            // rate = base +slope1 + (utilization - optimal) * slope2 / (1 - optimal) No base for now\n            rate = asset.under_optimal_slope + (utilization_rate - asset.optimal_utilization_rate) * asset.over_optimal_slope / (precision - asset.optimal_utilization_rate);\n        }\n        rate\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_position(owner: AztecAddress, market_id: Field, asset_address: AztecAddress) -> pub Position {\n        let scaled_user_deposited_asset_loc = storage.scaled_deposited_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_deposited_asset: u128 = scaled_user_deposited_asset_loc.read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let collateral = (scaled_user_deposited_asset * deposit_accumulator.value) / 1000000000 as u128;\n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let debt = (scaled_user_borrowed_amount * borrow_accumulator.value) / 1000000000 as u128;\n        Position { collateral, scaled_debt:scaled_user_borrowed_amount, debt }\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_total_deposited_assets(market_id: Field, asset_address: AztecAddress) -> u128 {\n        let scaled_total_deposited_asset = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let total_deposited_assets = (scaled_total_deposited_asset * deposit_accumulator.value) / 1000000000 as u128;\n        total_deposited_assets\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_total_borrowed_assets(market_id: Field, asset_address: AztecAddress) -> u128 {\n        let scaled_total_borrowed_asset = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address).read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let total_borrowed_assets = (scaled_total_borrowed_asset * borrow_accumulator.value) / 1000000000 as u128;\n        total_borrowed_assets\n    }\n\n\n    #[utility]\n    #[view]\n    unconstrained fn get_accumulators(market_id: Field, asset_address: AztecAddress) -> (Accumulator, Accumulator) {\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        (deposit_accumulator, borrow_accumulator)\n    }\n}\n","path":"/home/jean/work/noir/comet/contracts/src/main.nr"},"56":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr"},"57":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"64":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"65":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"66":{"source":"use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr"},"67":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"71":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"88":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"92":{"source":"use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr"},"93":{"source":"use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr"},"96":{"source":"use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr"},"97":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"100":{"source":"use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr"},"102":{"source":"use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr"},"103":{"source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr"},"104":{"source":"use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr"},"105":{"source":"use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr"},"106":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr"},"107":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr"},"109":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr"},"110":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr"},"111":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr"},"112":{"source":"use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr"},"133":{"source":"use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr"},"136":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"139":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"140":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr"},"141":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"142":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"143":{"source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr"},"144":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"149":{"source":"use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"150":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"151":{"source":"use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"152":{"source":"use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr"},"154":{"source":"use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"156":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr"},"157":{"source":"use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"159":{"source":"use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"168":{"source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"182":{"source":"/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr"},"185":{"source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"186":{"source":"use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr"},"188":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr"},"189":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr"},"191":{"source":"use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/field.nr"},"193":{"source":"use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"204":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/jean/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr"},"221":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr"},"223":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"266":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"269":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr"},"271":{"source":"use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr"},"276":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, FromField, Hash, Serialize, ToField},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"283":{"source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"284":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"298":{"source":"use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"300":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"301":{"source":"use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"310":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"321":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"335":{"source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"339":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"340":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"356":{"source":"pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr"},"359":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"369":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/home/jean/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr"},"400":{"source":"use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr"}}}