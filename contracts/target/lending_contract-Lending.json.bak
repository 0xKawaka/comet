{"noir_version":"1.0.0-beta.4+0000000000000000000000000000000000000000","name":"Lending","functions":[{"name":"_compute_collateral_debt_value","hash":"18007086616091831467","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8945853978429536226":{"error_kind":"string","string":"Function _compute_collateral_debt_value can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_compute_collateral_debt_value"],"brillig_names":["_compute_collateral_debt_value"]},{"name":"update_accumulators","hash":"12373476758523344212","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"12348881442450494403":{"error_kind":"string","string":"Function _compute_utilization_rate can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17134621154673181869":{"error_kind":"string","string":"Function _compute_borrow_rate can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["update_accumulators"],"brillig_names":["update_accumulators"]},{"name":"liquidate_public","hash":"15801357570155137835","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debt_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"user","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debt_to_cover","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"1VxbbuNIDLyLv/3RZLPZ5FxlsRjk4QwMGE7gJAssgrn7Sh5L8sSWNdtxGeqfwApIVlnqUlEWpY/F4+r+/cf39fbp+XXx7a+Pxeb54e5t/bxttj5+Lhf3u/Vms/7x/fjfi9D+4biPf32527abr293u7fFN4osablYbR/bz9FCU+NpvVk1W6H5fBofmLvwINxHez4TLB7yIVictA/WdCbYROwQbKJyHPz3csFyHfbuXTiR3459ug77ZP2+t4l9Tyl37EljvMzeU5RDsDd5n9nrtdkT/8a+xcg3wLCzGK59jpv1OSmC14SfZ5P0kMMh8GU2Grv6moYj7NqWjwFbnrDlGVs+YssLtnzCllds+Ywtb9jyWNUKVrWCVa1gVStY1QpWtYJVrXxdtazUdUesR11A0+jtETIcweAIjkZIAY5AcASGI0Q4gsAREhwBrukE13SCazrBNa1YV1asKyvWlRXryop1ZcW6smJ7acX20ortpRXbS2esajNWtRmr2oxVbYa7b4a7b4a7b4a7b4a7b4a7r8E7aoN31AbvqA3eURtc0wbXtME1bXBNG9aVDevKjnVlx7qyY13Zsa7s2F7asb20Y3tpx/bSjlWtY1Xb3G4D1ydwfbgBU4h4CMFDJDyE4iEyHsLwEPDemijgIQgPgVc34dVNeHUTXt2EtWmiDK5v4Ppgp2awUzPYqZnB9SO4voDrJ3B9sH4ZrF8G6xc8t0VXGNwiC904HxnZCQJYweDhLQJPbxF4fIvA81sEHuAi8AQX/cEIl/qEAlS6YFIdxkblgOBohD8Y5PoqAn0doTHzfki4Ma40hJ8bKY5B6BAdQ/pt+HVPiOdGKM6NkMyNUJobIZ0boTw3QjY3Qn57Qt5FR84TQ/jNL4s5dLUDx89j+JRC5fypcv5cOf9YOf/bm1Lsn7iJ8eg5phH+Ocaef06n/G/vYRK7PRpF8hR/C30bFyyGE/63tzwhGvjbFH+n/hGs4MlO+OfK+Vvl/L1u/hoq50+V8+fK+cfK+Uvl/FPl/Cv3X63cf7Vy/9XK/TdX7r+5cv/Nczr/7wnN6YS+JzSnM/Se0O1PuYm7O3oxTV5yNvc3htdgCMcT/lY5f6+bv4XK+VPl/K9xyRBNBozj+535F4bcACPdAEPxGCOz0SJ9lqThmLP+ugE6MvJ8OYtHBpmnsqgoi4uyYlHW+fU2DOs1F/rDb6dySEolSVqS5AVJI2OdF++L88ig5kRSLqFnJUklO2Jkpm8iiUqSuCQpliSVLFguWbBcsmC5ZEWMzJ5dXnsjA2WXk0amxCaSqCSpRISxRIQjc1cTSakkSUuS8v9N+tls/XO3W9/db1aH9zM+vW8fjl7X+Pbvy+rTmxtfds8Pq8f33ap9h+Pw+sZ237CEJXtqyLRfml2XMYXWCtvFQGZL8thutoeZXJpNbTg0PP4D","names":["liquidate_public"],"brillig_names":["liquidate_public"]},{"name":"get_total_deposited_assets","hash":"8232247155210684569","is_unconstrained":true,"custom_attributes":["utility","view"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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6HGzYuhxs2LocbNS6ANuVgw9blYMPW5WDD1uVgy9nxm98xt6l2Lt6JhX8u62sPoE3txRTu1O26Kc2m22RTm1e2yLcmo32Bbl1O6uKco4tVtri3Jq99UW5dRuqi3Kqd1RW5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKhNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKjNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKgttphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxHKvOB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFsuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mEsiy4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4nZaoTS4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4na+i9K7xX4c7V2In1DujMSnFYkJ5mkkeW/ccckfB0f79Mk5/BbJ4qM6EAmH1oFIeL8ORMJVdiCSRyT9IuGEOxAJj92BSLj3DkQiF+hAJBIH/SI5EocORCJx6EAkEocORJo7ccjr0c7b8Ono33A8cI7hzO2wK3DmdrYVOHM7ygqcuZ1cBc7cDuocjp/buVTgzO0YKnDm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db2r+j4kfVdvXe9Qvg9J39Vb17t970PSd/XW9c7Z+5D0Xb11vQv1PiR9V29d7+i8D0nf1VvXuyPvQ9J39db1TsP7kPRdvXW9a+8+JH1Xb13vgLsPSd/VW9e7ye5D0nf11vXOrPuQ9F29db3L6T4kfVdvXe8Yug9J39Vb17tv7kPSd/XW9U6W+5D0Xb11vSvkPiR9V29d77C4D0nf1VvXuxXuQ9J39da15/99SPqu3rr2or8PSd/VW9ce6fch6bt669q7+z4kfVdvXXtK34ek7+qta6/j+5D0Xb117cF7H5K+q7eu/VjvQ9J39da1H+Z9SPqu3rr2I7wPSd3V2+jaD+4+JHVXb6NrP677kNRdvc2i7uptdO3ncx+Suqu30bWfyn1I6q7eRtdmGb+HpGsnifuQ9F29de1BcB+Svqu3rl+v34ek7+qt63fP9yHpu3rr+sXsfUj6rt76fmtp9P3W0uj7raXR91tLo++3lkbfby2Nvt9aGn2/tTT6fmtp9P3W0uj7raXR91tLo++3lkbfby2Nvt9aGn2/tTT6fmtp9P3W0uj7raXR91tLo++3lqbRb5qW9BiSSU9D+v0lP//9zf00d+00f+20cO20eO20dO20fO20cum0n/8+4X6auXbatSqJ16okXquSeK1K4rUqideqJF6rknitStK1KknXqiRdq5J0rUrStSpJ16okXauSdK1K0rUqSdeqJF+rknytSvK1KsnXqiRfq5J8rUrytSrJ16okX6uSfK1KyrUqKdeqpFyrknKtSsq1KinXqqRcq5JyrUrKtSopl6rELsu108y10+y109y10/y108K10+K109K10/K1065ViblWJeZalZhrVWKuVYm5ViXmWpWYa1VirlWJuVYl5lqV2GtVYq9Vib1WJfZaleyvz/i4nfbptTiP08L+aeZxml3+6zwTyMv2oh732Kb2FkfsHFvyGmiU8vnY+3CiruEkXcPJuoZTVA1nf71EbjhG13CsruE4XcPxuoaj66rsdF2Vna6rstN1VXbvvipvr+kzy2K/jscvysZjlI3HKhuPUzYer2w8P74230+L105Ll05rtDHf6VKfbbTVXuVL3Du+xL/jS8I7viS+40vaPJTgzeNLQnn6kp+thN+HlPUNqagbUqNN6H4wJH+Li9crlf1aSY22oGs4IKttQG9/mKx2A3z/7nPVEQV1I4rq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","names":["get_total_deposited_assets"],"brillig_names":["get_total_deposited_assets"]},{"name":"withdraw_private","hash":"14505465686636735980","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"H4sIAAAAAAAA/+1dB5gct3Wevb078pY8ctmrRFJdpMps33WlLIm2rGpZki25blWj2CmREsseeaQoSmwqlNzl3nuXHTvdiZ04LokTO3GsuDu24xLXuAWg5u2+e/dmdvb24bgQD9/37mYHwI8fD8ADBsBgIs4TbkXUcXqjT1xHlES9/z1KlpJ78B9f9zHhpjD3Bpl705l7M5h7c5WsJPeWMOGWMveWMfdOYe6dydxbrqTujHQR7/9K73/KzabT1Vyymkglim6yUMpn3HSmlM0n8olMPlNJ5lOpaj6dzxVKhZxbSKRT1UQtU0jV3CdcJNrEcjtyybJJnj1j55mlNzS3mUp6EVethz9612c5zeuz0XWPFwbiRb2626ekP9q8Dy5KdOB25hLLBbGiUbmymSRWh1zXpP5WCGL1CupvsiX6O0cQq09QfwOC+uNswyRkGyaj6wF03U9sQ0z9nqJkqpJBxjb0CJfNmY6cPqfJ6TOB+zONu9SwHqYJ1qvphvQw3dNDL9EBdhFhvUQcMzbGkeVZagD2ehIZB+Wc5cgaEHDxqEHCDXBHrsaDwsdD6YJYLm5BMzy9zIySDEh3h5KKnxHebJVbYCVmCnaH41khJFshrhCzvIKfbbpCnCVYIWYJVojZwuOjyUoGkB4b2PlUNVdIJCr5VMYt5LLJgmKQzWVSiVo5kSkXa5VcoZgvlKrVcilVKLipWraQySXL2VS2li5min8keIlirpap1orFSq6WUgDJTLGQyNdSbrmcr+RSqVStXC6Wcsq7XHBriXSlmk+UyuVMMl8rFFKZyh9ly9cdVeEz6WIxny3mUuVSvphKZ5KZaqZUqlay1XSqVEwkCvlqPuvWMrVUIeMms/laLlGppTOFRKlSTbtJyi/pFirlWqmWVH8yuVqhlnXTSjPpSi5RLGdrxVo+l1RJ1sq5tJsru+lqKZtMFLPJfK5cLCeSWdP5TVZq+VIh7VYz+YJbTavqmMtV3Uwql6oVq9lCMVHJZdKqTFOZqlJK3i1ls9lCOpdW5Z8sV8qjyiNZLVfy+UoiU8jmSuVMqpTPK90kq24lkc1nswmV13IpWyyWk5VULZ+pJlU+c9VqrZQsJwqqspnIb7+HdWwuCI3vZ6LrWeh6tnctyCMpnS+NN0fxnKtkHjGC0vM08+Xmk0omeS4Q4JnO5DK1YippkufCsfPM0Rvcs+18VJcXoOs56HohebZdpH4vVnKSkpPHYd7rbEGsRYLPh0ssmbeRnDdcLKi/pSfgvOFJgvpbZnjeawmyAUvR9TJ0fTKxDaeo36cqOU3J6eNgGyTnJE8RLJszDJfNGagMTkXXp6Hr00nZnKl+n6XkbCXLo80plh5ULpxbKZOPLB5fSadB+2Lph9M5BmyVNEfBftIYx+UWcFxhAcdzDHA0wfNMQ318w/UIE54u2AmsMLSAsAItIESd0Z2siYI0tYBgS4WT5jndEp5RZ5wbcKeNTjLz5xrKvHSeBRtn4jxL8twjmOfzLcmzYGNMuOOUZ7czl0gI6i9midFNOnbwTFnCM20Jz4wlPLOW8MxZwjNvCc+CJTyfYgnPp1rC82mW8Hy6JTyfYQnPZ1rCc6UlPC+whOezLOF5oSU8L7KE58WW8FxlCc9nW8LzOZbwvMQSns+1hOellvC8zBKel1vC8wpLeF5pCc+rLOH5PEt4Xm0Jz+dbwvMaS3heawnP6wzx7OZ1wReMU57dzlzihYL6m2bJetH1jh08b7CE54ss4fliS3i+xBKeL7WE58ss4flyS3gWLeFZsoRn2RKeFUt4Vi3hWbOE542W8LzJEp43W8LzFkt43moJz9WW8LzNEp5rLOG51hKe6yzhud4Snhss4bnREp6bLOG52RKet1vC8w5LeG6xhOdWS3jeaQnPuyzhuc0Sntst4bnDEp47LeFZt4TnkCU8d1nCc7clPIct4bnHEp57LeF5tyU891nC8x5LeO63hOe9lvC8zxKeByzhedASnocs4XnYEp5HLOF5vyU8H7CE54OW8HzIEp5HLeH5sCU8H7GE5yss4flKS3i+yhKer7aE52ss4flaS3i+zhKej1rC8/WW8HyDJTzfaAnPN1nC882W8HyLJTzfagnPt1nC8+2W8HyHJTzfaQnPd1nC892W8HyPJTzfawnP91nC8/2W8PyAJTw/aAnPD1nC88OW8PyIJTw/agnPj1nC8+OW8HzMEp6fsITnJy3h+WeW8PyUJTw/bQnPP7eE519YwvMvLeH5V5bw/GtLeP6NJTz/1hKen7GE599ZwvPvLeH5WUt4fs4Snv9gCc9/tITn5y3h+U+W8PyCJTy/aAnPL1nC88uW8PxnS3j+iyU8v2IJz3+1hOe/WcLzq5bw/JolPP/dEp7/YQnPr1vC8z8t4fkNS3g+bgnP/7KE5zct4fktS3h+2xKe37GE53ct4fk9S3h+3xKeP7CE539bwvOHlvD8kSU8f2wJz/+xhOdPLOH5U0t4/swSnj+3hOf/WsLzF5bw/KUlPH9lCc9fW8LzN5bw/K0lPP/PEp6/s4Tn7y3h+QdLeP7REp5/soSnBrSBZ8QSnj2W8IxawrPXEp59lvDst4TnJEt4TraE54AlPGOW8JxiCc+plvActITnNEt4TreEZ9wSnjMs4TnTEp6zLOE52xKecyzhOdcSnvMs4TnfEp4LLOG50BKeiyzhudgSnidZwvNkS3gusYTnUkt4LrOE5ymW8DzVEp6nWcLzdEt4nmEJzzMt4XmWJTzPtoTnckt4rrCE5zmW8DzXEp7nWcLzfEt4upbwTFjCM2kJz5QlPNOW8MxYwjNrCc+cJTzzlvAsWMLzKZbwfKolPJ9mCc+nW8LzGYZ49hCeKTebTldzyWoilSi6yUIpn3HTmVI2n8gnMvlMJZlPpar5dD5XKBVybiGRTlUTtUwhVfOwI4J5fuYJmOeVluQ5KpjnC8Ypz25nLvGsiJz+zozakecLBfM8PWqHrb3Ikj7hYkt4rrKE57Mt4fkcS3heYgnP51rC81JLeF5mCc/LLeF5hSU8r7SE51WW8HyeJTyvtoTn8y3heY0lPK+1hOd1lvB8gSU8X2gJz+st4XmDJTxfZAnPF1vC8yWW8HypJTxfZgnPl1vCs2gJz5IlPMuW8KxYwrNqCc+aJTxvtITnTZbwvNkSnrdYwvNWS3iutoTnbZbwXGMJz7WW8FxnCc/1lvDcYAnPjZbw3GQJz82W8LzdEp53WMJziyU8t1rC805LeN5lCc9tlvDcbgnPHZbw3GkJz7olPIcs4bnLEp67LeE5bAnPPZbw3GsJz7st4bnPEp73WMJzvyU877WE532W8DxgCc+DlvA8ZAnPw5bwPGIJz/st4fmAJTwftITnQ5bwPGoJz4ct4fmIJTxfYQnPV1rC81WW8Hy1JTxfYwnP11rC83WW8HzUEp6vt4TnGyzh+UZLeL7JEp5vtoTnWyzh+VZLeL7NEp5vt4TnOyzh+U5LeL7LEp7vtoTneyzh+V5LeL7PEp7vt4TnByzh+UFLeH7IEp4ftoTnRyzh+VFLeH7MEp4ft4TnY5bw/IQlPD9pCc8/s4Tnpyzh+WlLeP65JTz/whKef2kJz7+yhOdfW8Lzbyzh+beW8PyMJTz/zhKef28Jz89awvNzlvD8B0t4/qMlPD9vCc9/soTnFyzh+UVLeH7JEp5ftoTnP1vC818s4fkVS3j+qyU8/80Snl+1hOfXLOH575bw/A9LeH7dEp7/aQnPb1jC83FLeP6XJTy/aQnPb1nC89uW8PyOJTy/awnP71nC8/uW8PyBJTz/2xKeP7SE548s4fljS3j+jyU8f2IJz59awvNnlvD8uSU8/9cSnr+whOcvLeH5K0t4/toSnr+xhOdvLeH5f5bw/J0lPH9vCc8/WMLzj5bw/JMlPJ0eO3hGLOHZYwnPqCU8ey3h2WcJz35LeE6yhOdkS3gOWMIzZgnPKZbwnGoJz0FLeE6zhOd0S3jGLeE5wxKeMy3hOcsSnrMt4TnHEp5zLeE5zxKe8y3hucASngst4bnIEp6LLeF5kiU8T7aE5xJLeC61hOcyS3ieYgnPUy3heZolPE+3hOcZlvA80xKeZ1nC82xLeC63hOcKS3ieYwnPcy3heZ4lPM+3hKdrCc+EJTyTlvBMWcIzbQnPjCU8s5bwzFnCM28Jz4IlPJ9iCc+nWsLzaZbwfLolPJ9hCc9nWsJzpSU8L7CE57Ms4XmhJTwvsoTnxZbwXGUJz2dbwvM5lvC8xBKez7WE56WW8LzMEp6XW8LzCkt4XmkJz6ss4fk8S3hebQnP51vC8xpLeF5rCc/rLOH5Akt4vtASntdbwvMGS3i+yBKeL7aE50ss4flSS3i+zBKeL7eEZ9ESniVLeJYt4VmxhGfVEp41S3jeaAnPmyzhebMlPG+xhOetlvBcbQnP2yzhucYSnmst4bnOEp7rLeG5wRKeGy3huckSnpst4Xm7JTzvsITnFkt4brWE552W8LzLEp7bLOG53RKeOyzhudMSnnVLeA5ZwnOXJTx3W8Jz2BKeeyzhudcSnndbwnOfJTzvsYTnfkt43msJz/ss4XnAEp4HLeF5yBKehy3hecQSnvdbwvMBS3g+aAnPhyzhedQSng9bwvMRS3i+whKer7SE56ss4flqS3i+xhKer7WE5+ss4fmoJTxfbwnPN1jC842W8HyTJTzfbAnPt1jC862W8HybJTzfbgnPd1jC852W8HyXJTzfbQnP91jC872W8HyfJTzfbwnPD1jC84OW8PyQJTw/bAnPj1jC86OW8PyYJTw/bgnPxyzh+QlLeH7SEp5/ZgnPT1nC89OW8PxzS3j+hSU8/9ISnn9lCc+/toTn31jC828t4fkZS3j+nSU8/94Snp+1hOfnLOH5D5bw/EdLeH7eEp7/ZAnPL1jC84uW8PySJTy/bAnPf7aE579YwvMrlvD8V0t4/pslPL9qCc+vWcLz3w3x7CE8U242na7mktVEKlF0k4VSPuOmM6VsPpFPZPKZSjKfSlXz6XyuUCrk3EIinaomaplCquZhnymY5/8Ypzy7nbnE13vk9Lciakc59wrq7z8tqdt9gnn+hiV57hfM8+OW5HmSYJ7/y5I8TxbM8zctyfOAYJ6/ZUmeY4J5/rYleZ4imOfvWJLnqYJ5/q4leR4UzPP3LMnzNME8f9+SPE8XzPMPLMlzXDDP/21JnmcI5vmHluR5pmCef2RJnmcJ5vnHluR5tmCe/8eSPM8RzPNPLMnzXME8/9SSPM8TzPPPLMnzfME8/9ySPC8QzPP/WpLnhYJ5/oUleV4kmOdfWpLnxYJ5/pUleT5JMM+/tiTPJwvm+TeW5HmJYJ5/a0melwrm+f8syfMywTz/zpI8nyKY599bkudTBfP8B0vyfJpgnv9oSZ5PF8zznyzJ8xmCeXYE91YoqGN7fP7Zy/C5Ss5Tcr7GVpJQktT5V5JWklGSVZJTkldSUPIUJU9V8jQlT1fyDCXP9PJ7gZJnKblQyUVKLlaySsmzlTxHySVKnqvkUiWXKblcyRVKrlRylZLnKblayfOVXKPkWiXXKXmBkhcquV7JDUpepOTFSl6i5KVKXqbk5UqKSkpKykoqSqpKakpuVHKTkpuV3KLkViWrldymZI2StUrWKVmvZIOSjUo2Kdms5HYldyjZomSrkjuV3KVkm5LtSnYo2amkrmRIyS4lu5UMK9mjZK+Su5XsU3KPkv1K7lVyn5IDSg4qOaTksJIjSu5X8oCSB5U8pOSokoeVPKLkFUpeqeRVSl6t5DVKXqvkdUoeVfJ6JW9Q8kYlb1LyZiVvUfJWJW9T8nYl71DyTiXvUvJuJe9R8l4l71PyfiUfUPJBJR9S8mElH1HyUSUfU/JxJY8p+YSSTyr5MyWfUvJpJX+u5C+U/KWSv1Ly10r+RsnfKvmMkr9T8vdKPqvkc0r+Qck/Kvm8kn9S8gUlX1TyJSVfVvLPSv5FyVeU/KuSf1PyVSVfU/LvSv5DydeV/KeSbyh5XMl/Kfmmkm8p+baS7yj5rpLvKfm+kh8o+W8lP1TyIyU/VvI/Sn6i5KdKfqbk50r+V8kvlPxSya+U/FrJb5T8Vsn/Kfmdkt8r+YOSPyr5kxLdsCJKepRElfQq6VPSr2SSkslKBpTElExRMlXJoJJpSqYriSuZoWSmkllKZiuZo2SuknlK5itZoGShkkVKFis5ScnJSpYoWapkmZJTlJyq5DQlpys5Q8mZSs5ScraS5UpWKDlHyblKzlNyvhJXSUJJUklKSVpJRklWSU5JXklByVOUPFXJ05Q8XckzlDxTyUolFyh5lpILlVyk5GIlq5Q8W8lzlFyi5LlKLlVymZLLlVyh5EolVyl5npKrlTxfyTVKrlVynZIXKHmhkuuV3KDkRUperOQlSl6q5GVKXq6kqKSkpKykoqSqpKbkRiU3KblZyS1KblWyWsltStYoWatknZL1SjYo2ahkk5LNSm5XcoeSLUq2KrlTyV1KtinZrmSHkp1K6kqGlOxSslvJsJI9SvYquVvJPiX3KNmv5F4l9yk5oOSgkkNKDis5ouR+JQ8oeVDJQ0qOKnlYySNKXqHklUpepeTVSl6j5LVKXqfkUSWvV/IGJW9U8iYlb1byFiVvVfI2JW9X8g4l71TyLiXvVvIeJe9V8j4l71fyASUfVPIhJR9W8hElH1XyMSUfV/KYkk8o+aSSP1PyKSWfVvLnSv5CyV8q+Sslf63kb5T8rZLPKPk7JX+v5LNKPqfkH5T8o5LPK/knJV9Q8kUlX1LyZSX/rORflHxFyb8q+TclX1XyNSX/ruQ/lHxdyX8q+YaSx5X8l5JvKvmWkm8r+Y6S7yr5npLvK/mBkv9W8kMlP1LyYyX/o+QnSn6q5GdKfq7kf5X8QskvlfxKya+V/EbJb5X8n5LfKfm9kj8o+aOSPynRg4iIkh4lUSW9SvqU9CuZpGSykgElMSVTlExVMqhkmpLpSuJKZiiZqWSWktlK5iiZq2SekvlKFihZqGSRksVKTlJyspIlSpYqWabkFCWnKjlNyelKzlByppKzlJytZLmSFUrOUXKukvOUnK/EVZJQklSSUpJWklGSVZJTkldSUPIUJU9V8jQlT1fyDCXP1OMyJRcoeZaSC5VcpORiJauUPFvJc5RcouS5Si5VcpmSy5VcoeRKJVcpeZ6Sq5U8X8k1Sq5Vcp2SFyh5oZLrldyg5EVKXqzkJUr0t+b1d9xfrkR/f1x/21t/N1t/k1p/71l/S1l/p1h/A1h/X1d/u1Z/F1Z/c1V/z1R/K1R/h1N/41J/P1J/m1F/91B/U1B/r09/C09/Z05/w01/H01/e0x/10t/M0t/j0p/60l/R6muRH//R39bR3+3Rn8TRn9vRX/LRH8nRH+DQ3/fQn87Qn+XQX/zQH9PQJ/Vr8/B12fM6/Pb9dno+txxfaa3Pi9bn0Wtz3nWZyjr84n12b/6XF19Zq0+D1aftarPMX1UiT5/U59tqc+N1Gcy6vMO9VmC+pw+fQaePl9On92mz0XTZ47p87z0WVn6HCp9xpM+P0mfTaTP/dFn6ujzavRZMPqcFX2GiT4fRJ+9oc+10GdG6PMY9FkH+hyBP1ei33/X75br97b1O9H6fWP9Lq9+T1a/g6rf79TvTur3EvU7f/p9Ov2umn4PTL9jpd9f0u8G6fdu9BhVvy+i38XQ7znodwj0/ny9913vK9f7rPUeZr0PV+9LfVyJ3reo9/HpfW16n5fe96T3Ael9MXqfiN43ofcR6HV1vc6s1131OqRel9PrVHrdRq9j6Hl9Pc+t5331PKieF9TzZHreSM+j6HkF/Zytnzv1c5h+LtHj9J4nhgGO3mes3blO03kmQgc75q/35ep9qnrfpt7HqPf16X1uet+X3gel9wXpfTJ634jeR6H3Feh1dr3urNdh9bqkXqfT61Z6HUeva+h5fj3vreeB9byonifU82ZLlSxTcooS/dytn0P1c5l+TtF7389ScraS5UpWKDnHGe2i6Hqu93/Oty9YsP6zb70Yh5sf4Heuj1+f93/mSU/8H/B+93j/I176K73fbmcuMYBwpfHzbqE04Ix0wvxTAwjTAH4S8HvN4B/bq6zdK+oj8R2S7qD3O4J0CXHArwf5vdLzm+z5w/UW73qA4Jkod8xJWm+zGP49KG/aXVg3kXayDPgXefjOCOxEKp9NJfPZZLJSdYuVbK5WSOXcVCmTKpRLCTeVSeYruWLKdaupajntVrKFTKVaLGRStVKxkAXsi1nsVLWkoDLFbL6UqBWzNbeUzuVTxVouVylWCmqeJuNWEuVsopxM1PL5YiZTLGcKiUStWsjU8g3sVUb08kRb0e7ZRvBTGcB/jhH8ZMNWXYLwBd+TcQH/uWbwG7b8UjP4jfK9zIj+m/wv9/AdR173V5jhngL8K43gJxr8rzLDPw34z0P4EQP6udoMfqPuPN8MfqPuX2NG/zXAv9bDdxB2Ip9KJnMpPb+er7iJdKWczKvepZR2y26xnKwW0olCLZ1Mp8qVcknNxRcTNbdWLBdq+SfAAfs6I9xTjbrzAiO6TzX6rRcyunE7c40+5Xp/7DGrH7BvYLCTxVTZLdTcYiZfzFXVooqrBgu5ailfrWWTxZIaGCQriUSimlZ/ktVKulCqZBOlrFqJyZRUco0yfVHdRJkmGmOcFwvjZ4tuoZrN5gD/JcL4pVI2V1T6BPyXCuOnytlqLZVr2IOXCeMXM+laLZMqAv7LhfEzCbeaSeYadbMojF8ouZlsPt+oPyVhfDWuTVUKxcZYrSytn1LVLVcSBXhmqnj4kIZ2kHZVOG3PFSIkPccZ+UzokPRjhKv0uCxC0sN8KugePH+B7mr10VzjjB+2MdQvytyDdDislwhivVQQ62WCWC8XxCoKYpUEsaBdm21r6UY/WjOCn8oD/o1G8N0q4N9kAj/RHDvejPAdOf4N/FsQfsQA/q1m9N/AX21GP43nmts8fBPYa8zopjEGW2sGv/FcsM4MfmOMut4MfsM2bDCDXwD8jWbwG2PUTWbwG2O8zWbwG2PU283gVwD/DiP4iYZ+tiB8OduZbNi2rUbwUw38O83gN+zbXUbw0w38bWbwG/Mq283gN+zzDjP4Dfu80wx+Y+xTN4KfaTwjDxnBzzbqzy4z+I05191m8Bv1c9gMfqN+7jGD36ife83gN8YPd5vBb4wf9pnBb4wf7jGD3+i/9pvBb/Tv95rBb/Tv95nBb9i3A2bwG/btoBH8XKN/P2QGvzEHe9gMfsN+HjGD37Cf95vBb9jPB8zgN+zng2bwG/btITP4Dft21Ax+w749bAa/YX8e8fCdsWOn6A29907vF3p05hN43D4rwbGWC3uYeptZGTHfrq/70H3B56hKmPl2nH6McDUx347TAz5UP3i+Xfv1M1zjjB8tw34mnX4mnTjjN1yXwzokiLVHEOuAIJZkHu8VxNoniHWfINZeQawtgliSuh8WxDrcpVhDgliSdWJYEEuyfu0WxJJs25J1YpcglqSNfkAQa1gQS7LvgDG12bGVmx1k0gYHfpNQ2nhMRV2U/Ma89Vj1LTObuDQcuKlOc01549Y15SvWbqpudAIiaHdRnb/fbcqLEL/JIfLgOK0V+1gIxdIBPOY2SDBx3AiDxW12oZUZ67zXhwPGgLKiA+GV3m+3I5dIhckHTn+8HiI4I8E9RIB+JpnRTzJC8DGfSYx+aB2mZRdxmg25D2Hh8JNQHnF4fA3x8b1/9f7HndHtCDanRxi/KHMP9Ku5f5HkDZcNradmyiGdCFtPIf2YY7LdNOspVy+4zmzAGV3OkhuCwpQrZ9sGGD/Agg16uJ7i8JNRHnF4fA3x8b3veP/jzug6TevpAJMffA/X02941wM++Vnp/XY7crkc10/RdoD1JLnBOWw7gPRjjsl612wHXDlx9gR0F2O4xhk/OukTY9KJMenEGT86EO0E64Ag1i5BrGFBrMNdirVPEOs+Qay9glhbBLH2C2JJ1vtu1FdQP9gulnaSdfWIINbdgliSdVUyj0OCWN3ato8KYm0VxILFQzrOBHzHaY6VaH+/0vvtduSeeHbD6UE+8D2cfoxwleXTHCtxeuXGtKCfKWb00+AzheEzhdEPlOVUxg+wYK4FPzPg8FNQHnF4fA3x8b3zvQKLE0zt6DPDVCY/+B5+Zjg7MjJvuGxoPTVZDjg94I3v4fRjjsl24wbWC679Dzijy1lQP26YcsV8oSwHGT/Amub9xvUUh5+K8ojD42uIj+89ndRTXKdpPR1k8oPv4XqaI/UUlw2tp0bKIVELXU8h/Zhjst006ylXL6YwehxwRpezoH7cMOWK+UJZTmP8AGu69xvXUxx+EOURh8fXEB/fu5TUU1yn6UtN05j84Hu4nl7s4Q745Gel99vtyGXSXFnK4ecSg0w+aTvDupar16nQ7QzSjzmj64WJdjad8PGrB6C7OMM1zvjROhJn0okz6cQZP/pc0wnWsCDWFkGsXYJY+wWxhgSx9gli3SuINSyItVsQqy6IdVgIi7PPnfA6JMRLuyOCWJJt+6gglqQtlGyP9wliSZbjw4JYknVCUvdSbdsRzqNknTggiNWtdkKS14kwZpro046f7iXb4x5BLMk8PiiI1a3jCck80vUB/GwZ8f4POKPbnuBzdjVC0oN84Hs4/RjhKsun+ZzN6XU6o1fQ3QyGa5zxo8/ZM5h0ZjDpxBk/2md0gjUsiLVFEEsyj/sEse4TxDoiiCWp+6OCWBPl2B7Ww4JYknVityDWAUGsYUGsw4JYkrqXrKuSuu9W+yVZV4cFse4VxJIsR8n6JdmGJOvXIUGsIUEsyTwO1+WwJNujZB4lxxPdWo7dOpZ7UBCrW8c5kmPMifHEk6MNSdoJSV5S9Utf03nVTnjdL8RLO0ndS44Bhj0sut8N8LUzO4eWDL3Hls6hGdmD1WIOjdtbN+CMroeC+kmEKWfMF8pyJuMHWLO833hPGA4/A+URh8fXEB/fe6anlDjB1I7uCZvJ5AffA/3qPWEF78eAT35Wer/dzlyezodCGjhtrCfBehfq4wc4/Zhjst412wFXTpx9Ad3NYrjGndF1h9aHWUw6s5h0JrC6C+tqIawgGwb+2g0w8aTtLU4P8oHv4fRjjlG7kAjSK2cvQT+zzeinsUd5NsNnNqMfKMs5jB9gwcdkcX+Ew89GecTh8TXEx/fKpD+ag8LSNjCHyQ++h/ujl/SMzBsuG1pPzZRD+Hc+IP2YY7LdNOspVy+49j/gjC5nQf24YcoV84WynMv4AdY87zeupzj8HJRHHB5fQ3x8bz2pp7hO03o6l8kPvofr6a3ej+mOf/sM054xLme3qQ5xPNoejJR3ouqGbQ+Qfswx2T6b7WFOSL2CfuYa0U+lFqb+YL5QlvMYP8CCD33j9oDDz0V5xOHxNcTH93aR9oDbDm0P85j84Hu4PWwjdhuXDa2nRsrBdWth6ymkH3NM2slmPeXqBdf/DTijy1mQTzVMuWK+UJbzGT/AWuD9xvUUh5+H8ojD42uIj+8dJvUU12n6rt58Jj/4Hq6n+8nzLs3PSu+325GrJriylMMvugOMruXwk4UBprzk8Et5wF9oBj8L+IuM4Ocb5bvYCH6moZ+TzOBXAP9kM/WnwX+JEfxUCvCXGsGvNvgvM4KfbuCfYgS/1Gi/pxrBLzTq/2lm9NMo39ON4NcygH+GGf00+J9phn/D/p+N8CXnIgB/hRF8NwX6WO40XZTJE6QPY5GzUPiIz3/Aon6QVoxgmRr3cXnD/Olz33LEB+vAD2t5m1gDjJ+JMj07IN84/cEArjQf2tEzcMaqE+12C2LtFMQ6JITFjW074XWnIK95Qry48W8nWAsEsaJCWNrRj/V1wmuhEC99vahLsRYLYp0kiHWyINYSQaylgljLhLC0e6gux+sUQV4H63K8ThXipa9PE8SS6jv09emCWGcIYp0phKUdnTvtFixYQzY735UumJ3vShXNznelK2bnuzIps/Nd6ZzZ+a50Gcbq0B9CGrhu4f5N7rkiHfpdUEg/RrjK8mk+351M+FD90P07SxiuccaPttElTDpLmHTijB/dy9sJ1gOCWEOCWPsFsfYJYu0WxNoiiHWvINawINbhLsWSrKt7BbGGhbC4frtb6qpkezwiiNWt7fF+QSzJNtStur9bEEvSTkj2tcOCWJK6l9RXt9YvybHJsCCWpO5PBDtxVAhLX9Nn2E54bRfktUCIlySWdnfV5XgtFOQlpXvt6oJYknWCzqV3ghUVwtJOqk5ot1MQa5sglmT9kuQlVVe72RZOFeQlWVcly1GKVzfrS7Ku0rnVbmnbkvbrYUEsyfHXHkEsyTmFYUEsyWcFyblHGN/DPPZi5Bfx/ptdA3DHvAaw2AyfwDWAxYxeuf2wgnwqYcoZ84WyXMr4AdYy7zfe24/DL0F5xOHxNcTH917vFVycYGpH9/YvZfKD74F+9d7+V0VH5g2XDa2nZsoh/DdgIf2YY7TdJILqxcmMHrl6AXHjjB8d0y9l0lnKpMOVPd371gnWAUGsXYJYw3U5rMNdirVPEOs+Qay9glhbBLEOCmJJtiHJcnxAEGtIEOuIINZwXQ5Lsn5JtiFJu3oi6P5eQSxJGw22kHuPSnD84XLvOQniN945WBagC5w+3YsD/tx/wKJ+kFaMYAnnLRGUt6Bnt2WIz1J07Ye1rE0s7t04E2W61PHPN07f7LuAmaTZdwEzWbPvAqZrUOdPRfqMEN2dbqQs86HPUoH0Y4SrqTZ1OuFD9UOfh85guMYZP7p37wwmnTOYdOKMH+23O8F6QBBrSBBrvyDWPkGs3YJYWwSxDgpiHRLEktR9t9bVI4JYw4JYkvVL0uYcEMQ6EXR/ryDWsCDW4S7FkmzbewWxhoWw9DXdl9stdbVbxwCSWBP99kS/bUvfMdFvT/TbE/32k1P33VpX7xfEktSXpM2R1P3dgliSbUiy3x4WxOrW8Wq31i/Jse+wIJak7k8EO3FUCCvijN6f0wnWUkEsqXlyfb1MCEs7uve4E15TBXltF+KlXV0Qa6cQlr4+xZHDerLrXl/Tdyc6wVogiLVQCEs7SX2dJsRLsq5qJ9mGurXed2sen+y2UJKXdhN9h/19h3Y7hLD0teSeByl96etFgry2CfKS6mu1k+wfJfXVjX2Hdg8LYkk+8+0RxJJc0xkWxJKcn5Dcn0Pfb8N7wyLef+68eJ3OSu+325mrREh6kA98D6cfI1yF+SSC9Ho6o1fuvHtBPuUIwcd8zmT0A2V5NuMHWHBOJn6/DYc/E+URh8fXEB/f+2PvE//jBFM7+n4bd1Y6vgf67VfyGw+X7kl0nNH11Ew5JEO/3wbpxxyj7SYRVC+49s/VC4jLlRft98OWF4e1TxDrsCDWLkGsA4JYDwhiDQtiHepSXrsFsbYIYh0VxNoqiPWwIJakvu4TxJJsj0cEsYYFsSRtoWQ57hHEkrQ5knXiXkEsSd0PdSmvg4JYknVCcmwi2W9LlmO32i/J+iXZHocFsSRttCSWZP3aK4g17GHB8wp+vol4/wdIvIgj+qyXjpD0IB/4Hk4/RrjK8mk+63F6PZPRazvfFwOucI39cDrj/R0v7Q4IYu0SxBoWxDrcpVj7BLHuE8TaK4i1RRBL6ttI2g0JYkm2xyOCWJL1S1Jf+wWxJOuXZBuStKuSdWJYEKtb27Zke5RsQw8IYkm2xxOhft0riCU5BoC+drrnh8fb+DwS7IfTCRrz4/gQbpCJF/H+DxB+EUdyjF0IfV4HpB9jdGJizL88pF5BdysYrnHGj+5dWcGks4JJJ8740b6pE6wHBLGGBLH2C2LtE8TaLYi1RRDroCDWIUEsSd13a109Iog1LIglWb8kbc4BQawTQff3CmINC2Id7lIsyba9VxBrWAhLX9PzOrqlrnbrGEASq1v7bUndS44BJG205HiiW+vqRL99/Pq0iTF5e1gTY/LjV78mxoXHr35147hQO0l9dWtdvV8QS1JfkjZHUvd3C2JJtiHJvmNYEKtbn4e6tX5Jjn2HBbEkdX8i2ImjQlgRZ/Qep0543SXIa6kQL309VRBLcn1IUl+LBHnVhXhpt1MIS1+f4shhSdUJ7ei7zd2ge8m2Ld0epdqQvl4mhKWdZHs8EeoXPW+oE6wFglgLhbC0k9TXaUK8JG2hdpI2ulvrfbfm8cne10ry0m5ibGJ/36HdDiEsyfGEdlL60teSY/Jtgryk+lrtJPtHSX11Y9+h3cOCWJJzCnsEsSTXrYYFsSTnvyT3F9LzhqYiv4j3H/b5Ylun01np/XY7conQ5w1B+jFndF8lx6e5z3euM1qvUxm9gu7mMVzjjB99Np7HpDOPSSfO+B2qy2EdEMTaJYg1LIh1uEux9gli3SeItVcQa4sg1kFBLMk2JFmODwhiDQliHRHEGhbEkqxfkrwky1GSl6SdkKwTkuV4ryCWpL0HuwpjKzomWOn9djtymQyMTfBYBsZUAw4/NpFJO5GPkPQchx/XQfoxwlWWT3Ncx5Ub1g8d181nuMYZP1qG85l05jPpxBk/2jY7wbpHEEuS1wEhLH09yZHBks7jFkGsewWxDgti7RXEktTXEUGshwSxDgpiDQtiSep+nyDWbkEsyTweFcTaKogF83x0bKHdSu+/6g5T+Wwqmc8mk5WqW6xkc7VCKuemSplUoVxKuKlMMl/JFVOuW01Vy2m3ki1kKtViIZOqlYqFnNmxQ6Yw4PD9qwx+IgH4C8zgJwF/oRn8FOAvMoOfBvylZvAzgL/MDH4W8E8xg58ze/ZBIg/4K8zgN9rXOWbwi4B/rhn8CuCfZwa/Cvjnm8GvAb5rBD/pAn7CDH7DfibN4DfsZ8oMfsN+ps3gN+xnxgx+w35mzeA37GfODH7DfubN4DfsZ8EMfsN+PsUMfsN+PtUMfsN+Ps0MfsN+Pt0MfsN+PsMIfqphP59pBr9hP1eawW/YzwvM4Dfs57PM4Dfsz4Vm8Bv25yIz+A37cLEZ/IZ9WGUGvwT4zzaDXwb855jBb9i3S8zgN+zbc83gN+zbpUbw0w37c5kZ/Ib9udwMfsP+XGEGvzF+u9IMfmP8dpUZ/Ib9fJ4Z/Ib9vNoMfmP89nwz+A37fI0Z/IZ9vtYMfsM+X2cGv2GfX2AGv2GfX2gGv2GfrzeD37DPNxjBzzTGny8yg9+w/y82g9+w/y8xg9+w/y81g9+w/y8zg9+w/y83g9+w/0Uz+A37XzKD37D/ZafpmtipakktVWSK2XwpUStma24pncunirVcrlKsFNLVXMatJMrZRDmZqOXzxUymWM4UEolatZCp5RvcKyx2J665rlA1oZdErWEXagg/IsY/38C/0Qi+22hXNxnRT6Vhl29myjaZrmRLRTdXyxWL+ZrqRJMV9S+rak0tkywWUuWiqkWVUrVYSpULyXIlWUlV88rWVFOFbLXa7LNuka43Cbeh91uN6L25nrBaXO/5Y3/1N0H3e5sw4Gzq21BafSRfa7zf8L1T7W6tN8Pchvxx+LfEnviv0zvopTeI8uOgdLSDfPeK5/uYXgsRkp7j8HucIP0Y4SrLp7nHqZfwofqhe5z6GK5x4qcdXfPuY9LpY9LhsB4WxNoiiHVQEGtYEOs+Qazdglj7BLEk87hXEKtb69eQINYhQawjgliS9UtSX/sFsSTrl2QbOiCIJVknhgWxYC/kgDO6L5Trm7Np6Gvxcwc48Ks6I/OF/Woo/MX1ZjjqouQ3ztNkJZ+d2cSl4SgfPG6qIny/MYN2oMd+5C85xgH8ATP4KdD9ZGekTmmeBnx0Bf7cf8CifpBWzBmtdxPjQy5vmD9tL5MRH6wDP6zJbWINMH4myrQ/IN84/cEArlw+6PMNZ4+48TeEHwjghcNPZ9KGuKDDGPIT1GEySIe4LUL6UxHPSrW0+cbL1t7oEBclegC9zSfhLqs39UDr4GQfLIf8nk/uRREedmafGY9vPwB5arcfwLqtEr+x2j3tqG2gOtdOl/WPyNxClMkTrUN+cwtR5I/D/2xSM72fetdTUJpTA9IcJLxxeO0uq48MPw3lLcqEmUo4Qvhfebx0+X3NKz9Od8BngMR/MtVlyFO7dRmXI+UGmFB3aNn6lUvP5CaXr89scqbpDQbkA36XmfSAe5yE1Q7KeAa6LzjHFfo7bJB+jHAV7ocaY5gZhA/VD9gWrcMp3vXqtcXKhcV1GzevrvYQVU5H1xg+TuAgDA6LXRxRcnzC0WLX7sr66HjUgSr7COdTvOqnzclU73rQ4auXdgPO6DwLFlE5bJWB9GOOSTPVrDLTCR+qnx6iH0NVuBRxRlfXKJMm8IWynMH4AZZndUaYLhwe12McHl9DfHxvoVef4s7oZnd5fSQHrknie6BfXU9nk3qK6/3N9ZF+fUya4Ncf4Dc5wA8PWaEOgF8MxbuVxJvCYGoON01u4vnVNVze0N1Pd0bXfT9b5Ie1imDh+DMI1swWWFcQLBx/JsGa1QLrKoKF488iWLNbYK0hWDj+bII1pwXWWoKF488hWHNbYK0jWDg+PR5uXgus9QQLx6ef85rfAmsDwcLx6fGpC1pgbSRYOD490m1hC6xNBAvHp8enLmqBtZlg4fj0SLfFLbBuJ1g4/mKCdVILrBsJFo4PcQcZLNo/n4zuH4/+GdKPEa6m+ueTndF6xfqhy5ZLGK5xxo/arSVMOkuYdDisWYJYswWx5ghizRXEmieINV8Qa4Eg1kJBrEWCWNRuteqvr6k/8T+ov4Z4uO7icFEUhuujMYbfeCDqhB8XXEk4c2lyY8zV9ZF+eAqXjgfxdCMdk+Op2BnED48xqd3H07Qzid8U5Af5wWPMPpKfW737Zqd7XBeXl5+u6HMv999xwk0HclO6Qc+1Y00HY11cH5nO+E+5uNUw+cDpm55yAV3MCtDFbCNpp0NPP80muphlSBdQF1s9F9AlHm7sP4sJj6erbqxuUosmz9p6TfHGSSgoNkOUziAJN4P8nulDayUJN5v8huEF5YGxsKM8gqbDuPQ5MwLXfcx97bjHpjhJkys27vSvOBN/bkA6szpMZxaTjtlTVlzDp6A0V125R1WcJ0g/6LS6sGYA0hqv0+S4vAWVM3eaXBBW2BPQAMvsyTnNMg06RQ+n3+4penj1Dtu5yd5YSg+D7g+YOqTdkpndPKls2PoI6Y/Xzt+wOw+4oS3EjRM/7ehXE7hdAP1MOhzWAUGs+wWx7hPE2i2ItUUQSzKPkuUomcddgliSebxXEOugINZ+QaxhQawjglj7BLEk64Rke5RsQ5J1QlJfewWxDgtiSep+jyCWpO4PCWJJ6kvSFg4JYknqq1ttoaS+JG3OiTBmkqwTw4JYUrrX1/Rk726p95K6v1sQS7LeS+ZR0k5IjgEk9XVUECvM27Hccz2E594o4OalTpQ3CjIknMQbBRlyL+rwbxRo7B+Rt9Xp2wjamZ2PTSUjJD2aR4ekHyNchcu/MWfFbT/i5j1BdwsZrnHGj371mNuatJBJJ8740X67E6x7BbEOCmLtF8QaFsQ6Ioi1TxBLsk7cJ4i1RRBLsk5I6muvIJakvvYIYknq635BLMm6ulsQ60Qox0OCWJL6kuyHhgSxJPXVrf2QpL4k7b1k/ZK0OZLtUbJODAtiSeleX9M5mG6p95K6v1sQS7LeS+ZR0k506/jrqCAWzMFwr6rQLfLcM+yCgHRw/AUhsLjnYQjPvdoSNNfDvdoCcw+GXvFIBpUH93rMWOZ6QG8JEo7O9WDbtsgHyyG/E+Se31wP3bd0lzeRBfo1tB+N3ZpN9yviPaN0XyT3uiK+R+svjg/hzOax/dMG4sSvhvzoVn1cufBpEdRFyW+cX11fH2/jJAJcHlUfzD4mbIT4Qdj9A00eP/J4jHfZm5krHL+yX1VvhqOOK3vIr9b5Tzose7r/FfPmXsfFc+TYD7jSe7QccfwZAemc3mE6pzPpDDLxIj7/IR16j6bDcQ6abx9rOhgLbIXZufv26z/VM67/dG8uPu2ZnmqGT2rG60DUcW0DdKHbRmpWE5eGA2f2ZLfx0yF9RQzrELdt6jgdgi7C6nC607ptx5h8cP0Efaeh3X4Cx58ekM5Ah+kMMOl021hkFvHDdYm+pojr0hzih+sSXRe7GflFiN8tyK+f+OFTx+kJePjEcGobbkN+7doGPGa6MUS9DtNvYvtfI36TGVyzr66lUmH6F5x+jHCV5dNcb+VeqeVObATdzWG4xomfdtvqzXDUL8rc6wnA2ieIdVgQa5cg1gFBrAcEsYYFsQ51Ka/dglhbBLGOCmJtFcR6WBBLUl/3CWJJtscjgljDgliStlCyHPcIYkmWo6T9ktTXQUGsIUEsSX1JtiHJ8YSkvvYLYk3Y1eNnV6V0r6/pemu31HtJ3d8tiCVZ7yXzKGkn9gpidet49U5BLBivQjz8jI/nnA2vyyWP5xkb3BozfaYHf+4/YFE/esbGHDN5CzxjI6ge4DUouk7fyRkb9FwW02dszA3IN05/MIArl4/ZgjoJ8+ULbm6p3bLlztyBuIbbWGPvwuwAPeH0O3lPJUnCwXpkjzO67Ob6YDnkd5Lc89u7APUIn+0C61t6zvjKGM8ZHzmNz7SZgfxx+LvRVxyv9q6nO6PrE+SL++oDHNlm9ssx7c/z9xG/GpOfCIPFzZFDntr9wgF+l4l+4QAw/b5w0I/8cfiXxZpcvr6Qx4wgTPxOF/36Bawj9DvNfOMwlAOELyMO8PULitnrk6/JPphbUV2sxXhMh8Hk8hUj+aIcBggHCH8LytfjaIMUDgO/cT25rT6S2xQmLcfnHsbGcalfULqt4upr/PUL6kfrCtUXju+nU1pXIPzGgLrSz3DA+aXlSjnQMDEfDncwHPDxfuW167Z6X6NwiKMf1ekjv2lR0iLoZ3D8HKhBx9ka43FwOHC0+uFl2MlMGpN9OOK4Wj1QvJXq6uqmqo+CeghYn09iPQ7vuM8HgC01/DWy0O9h0q/C9ZvhE/hVOO59Ze4IW4gbZ/zo+n7YdKY6qD1vWrvBry7gSsnVhahP+hEmvkPiRph7jjPynV5u7ELz3O4XKgeY/HDpxDtMJx4ynVkdpjOLSYdiceNI7ar1pj8O/wCyr99ayGP2+GDCZy4gPDe25/acQHhubmI2k0fu/fo5Tuu0sS5pfzS3Ta6t5gZmE67cM2ZYrqvGmWtfm1wHmLRxn6w6nZtvr264Yu2mxinMDkPDIde0P6ZhaDcz2YfqVBKODsPotA01dTPJ7ykMP85xpo5yiTqtHd2S/EbURL/r00Qdh2+iUO3pYymOix9LoUrcwYSDNLeQ/ODwOE0IvxWlww397iD5hvDvZIZ+cYYT8Bkg8WW7+FwRdHinM9qB313OyLxjv20o/EX1ZjjquMdYyJPWxWNtPMbicqTcABN3Gbhs/crlo/gxlnyoD6e3xfHPB/yOMulRXYK/dlDG2wjGSu+325HLFCMkPcfhh5WQfswZrVsTw8pthA/VD2eGAz7Udye6xvDXEzgIg8Nidz2i5PiE44p9HhOPOlBlH+H8JTTb8BfEbOGmT78vijlEmXt0tNXL8OfS6e8wnX4mHbo7VDv6Qbc1zui8gt9aFI9+fG0d8qMfdFvvjM4X+G0IwNwYgLkpwG9zgN/tjJ/mdOHUJkdqjrmmQT8Sh8vOrx34Ya0iWDj+NoK1vQUW/Ugcjr+dYO1ogUU/Eofj7yBYO1tg0Y/E4fg7CVa9BRb9SByOXydYQy2w6EficPwhgrWrBdZ6goXj7yJYu1tg0Y/E4fi7CdZwCyz6kTgcf5hg7WmBtYlg4fh7CNbeFlj0I3E4/l6CdXcLLPqROBz/boK1rwXWjQQLx99HsO5pgXUNwcLx7yFY+1tg0Q8q4fgQF7DudZqOYulr+nYJjn8vwbqvBdYCgoXjQ9xBBivi/Yfh1wF0X264kwi92x/SjxGusnyaw68Dzmi9Yv3QWb2DDNc444f7IuyH0znIpMNh3SmItU0Qa7sg1g5BrJ2CWHVBrCFBrF2CWLsFsYYFsfYIYu0VxLpbEGufINY9glj7BbFoXxY0rtfXsMgbNK6HeNie0emhKImDw2MMv+eGKOK8rQXnRYTzWJ8f9PVSgjXW5wd9vYxgjfX5QV+fQrDG+vygr5cTrLE+P+jrFQQLx6c2d1cLrHMIFo7f7vPDHfWRWJ08P7yIYI31+UFfn+uMxBrr84O+Po9gjfX5QV+fT7DG+vygr12CNdbnB32dIFhjfX7Q10mC1cnzQ4pgBT0/HGiBlSZYOP4BgnWwBVaGYOH4BwnWoRZYWYKF4x8iWIdbYOUIFo5/mGAdaYGVJ1g4/hGCdX8LrALBwvHvJ1gPtMB6CsHC8R8gWA8GYGn3nPpILBz/QYL1UAusCwkWjv8QwTrqBOfxqc5ILBz/KMF6uAXW0wgWjv8wwXqkBdbTCRaO/wjBekULrGcQLBz/FQTrlS2wnkmwcPxXEqxXtcBaSbBw/FcRrFe3wLqAYOH4ryZYrwnA0u66+kgsHP81BOu1LbCeTbBw/NcSrNc5wXl8ljMSC8d/HcF6tAXWhQQLx3+UYL0+AEu7Wn0kFo7/eoL1hha8LiK8cPw3EKw3tsC6mGDh+G8kWG9qgbWKYOH4byJYb26B9WyCheO/mWC9pQXWcwgWjv8WgvXWFliXECwc/60E620tsJ5LsHD8txGstwdgaVetj8TC8d9OsN7RgtelhBeO/w6C9c4WWJcRLBz/nQTrXS2wLidYOP67CNa7W2BdQbBw/HcTrPe0wLqSYOH47yFY722BdRXBwvHfS7De1wLreQQLx38fwXp/C6yrCRaO/36C9YEWWM8nWDj+BwjWB1tgXUOwcPwPEqwPtcC6lmDh+B8iWB9ugXUdwcLxP0ywPtIC6wUEC8f/CMH6aAusFxIsHP+jBOtjLbCuJ1g4/scI1sdbYN1AsHD8jxOsx1pgvYhg4fiPEaxPtMB6McHC8T9BsD7ZAuslBAvH/yTB+rMWWC8lWDg+xB1ksCLef1h/+hS6L7fek05ESHqQD3wPpx8jXGX5NNefPuWM1ivWD11/+jTDNc740TnHTzPpfJpJh8PaLoi1QxBrpyBWXRBrSBBrlyDWbkGsYUGsPYJYewWx7hbE2ieIdY8g1n5BrHsFsQ4IYh0UxDokiHVYEOuIINb9glgPCGI9KIj1kCDWUUGshwWxHhHEeoUg1isFsV4liPVqQazXCGK9VhDrdYJYjwpivV4Q6w2CWG8UxHqTINabBbHeIoj1VkGstwlivV0Q6x2CWO8UxHqXINa7BbHeI4j1XkGs9wlivV8Q6wOCWB8UxPqQINaHBbE+Ioj1UUGsjwlifVwQ6zFBrE8IYtE5x1b75F7mXQftk4N4eN6JvmIYJXFweIzhtw8viji32o/3csK5k/14RYLVyX68EsHC8esEa6gF1jyCheNDXO49uNX1kX5rUDz6DsNa5EffrVuH/O4kfvg9ODovvQH5bSN+G5HfduK3CfntIH6bkd9O4nc78qt71/g9OHg/EnS0yrs/QPIGdXCl99vt0HFfS6N6xOUW8fnvOKPn2LWjNgB/KSNC0rlTMB2MdVH9if9QR3H9pccP3EXSofdoOjj+XT5Y8Gq2dvDOJa7XfST81V7Za+wfkKMCuL3Ja9C9ywLyCnGhTlG7ttL77XbmEoC/0wx+Ksj+4jzRNoh11079wmnFHIftV1YK6S4ob5g/rYe4Pwizb3xHm1gDjJ+JMt0ekG/O5nJcuXz4tU2cTtDpnDsDeOHwQf0z6LCO/AR1mAzSIdfHj+V0TtDbIhKOflmUG+tQLIf8XkTuRR3+dE7Otg348IR0W9lxHB/CBR1hEcZucOlwnCEdfL4APm10HXlXHuodPvIDv9cyH/nj8AdnNjE3epjcezd+bSWC0sNnE9CjYiA9v6Ni1vrw24L6PXpS4Vomz/MDOAMmPv8Bc4ZzGCiH7WTcZaiPZMddkNZ0wpeWD80LVya03m1l9OCnW+3wOAWPY3D43W2OU3D9puMUzAnics96VA9cOkH95NaQ6cQ6TCfGpNPpOIRLh+NMn6m0w/bkMLEnUO9w28Jx4T34PhJ+G7InDwTYE7o/hY6dqI2l9gTS87MntH5C+EcC7Ak3Nr+y7s8ZMLE9wZypPYHwryH2xND4ibUnkBbXX05xeH04Trj+cgqjB9P95RSSznbBdDAWtBVuLEftT7tjaxyfjmX92us7p/Jpcu0V190+Ev4i1F7fQ9orru+gc67e0D5qO5MubTOOM/r5TLsgW7bdBytsHwXhPxLQRwU9a2gX9CwdNOeIw+EwQfN/0YA0cL3F92FsjPvOtSTsDhJ2e0BYv+dGfQ2nvpt9ts+70BbqzmgHfkMMZ/DbhcJfW2+Goy5KfuM8Hftq/MImLg1H+WA9DflgcvaCnh4OP3sY3J0EF9sAqi84Z4u2/694bUG3/89N5fFoPdHuhR6e2efXfIKWL3a0fKl+qOPKt+5d6/JdtKiJS8PRNHEZ7iJ+2GbTs92wrQcMrfvHyZig29rSWNpLO/rk2gunT7pGwPWdWJ99BCM62AzzTVLfIQztL7SD9gNt1vs5YuzHlTtti99Ffc+Ni/j0g9qb4/B2AeuBnsk45PBcuDw32pmnJ6iPuI3J1cd0o33vJpxx2sOG0o6Q9ByHn+cdRiqhfIB3jPHr7YBrJpHLJbPpSqZWyuYzmWqE4ANXeo/OUXJnQUxnwoOu9xrRdaoCNiBab+LvQXrVrhf5DRO/PuQHHHUbumXRSP57DPEPo3+cfpwJv6reDNdOWcaZdOgzRydY28eINdMZ2Qa4vhCPbWhfiMcv+BzQJajD4OxikK3zYEbZfZxPagcXE1s3hOII1qE0Nx6ltm63obTD2jpIf9DxL9sY49eJratk0ol0rZApVWqpaiVXizij+4Qoc4/aOq7eTmPCG7YVLmfrqD3rRX67iR+2dcCRs3Vm+sWUG0b/OP04E57aurBlGWfSobauE6ztY8QCW4fHQUPeNWfr6Dh1J5MfbOvoc9kpxCaZOfqenyOkNhXz1Q4/Q+9EeqL6pTj4Hh434zh0zgbCL0fj9jMHeX6Qh8sZftyeIpyvcwb9w+1kwulhPIyjbqxuev5NxQ3VyvOr5Q3VTVGHp0ezSLNPH6ccEk67XnJvE/lNp2/WEBzogsN++Qr+Yyyu6DA27XrBHmoTtpmYsLUkrZUQp0PHPTrSrtbMMl4y9GMFpB9zRlc5E9tHuKlNrB/aPZpZlki6+sOXdOpbu5vqo3VDeUB94Y7Dj/j8h/zSe7SbwHWR1psgE+hnsi5HJusZg83w1AaE2bIVZike38Pha8QPL51FAvDpNMhFqB0/TqZC8VAH8tH46CTyk2xnmscWNMVE6xMeRvnVf+7zDRA+aCuZdrDUELS1iKtbuC5BHeHKGeJwy+GDhGu7S/+DTDqm29QgyQ+ux3SI1+7SI1d/Wy2hXe/TJv2W0Fzkj8Nn0BLai0l54vhYz8fyVW/6jVObSbbbZrhyCGozrbbsgw65JdYX1Ef6cW2G0yutO2sYDlw/x9UdCBdm/ID5yZVRIvT4AdIfr/HD2pB6Bf3cZUY/bhgbwdk1bpmT2nrc9rnHEm4ZDvcT9DHudq+xB20pCGo73NL4se1/5HHF9DgoqD2MNR2MBZ9tga+/wbNEHY2hdgz6x4dPtfSjONx2BJofXIdw37Cb9A14mSRoWZ4++/x+RhNz7xj7epPb/FrZd/oJHBzfbxw6heGlr2/1rqGMYYrkCCrjQz6P4drh8nmQlA+2hVz5QNrc4z3ExbiU4yOI49GAtoc5vtInnL5e7YwOR22R4/DjEFqGeHqCC0+3BUD414Ycz0N9MDs2SbDjeVz+dGwStj+iesLhMQbYoDgJT3WoHdSLD6N68VbSvjk7OtY27DeO9LP9hqcNC2HHKJB+zDE5ZmqOUbhP9AXViR0M/0rdP3yrOgThtdmndj6OsCBd/KrYTnKP9lFBYxrtsO352CCPgfPHjYvgeHqMEcb2t1ufuTx1Q7sJU6+5dILGTFsF08Htmb6GZejVujTovo54cmNkuq1tCOUhSjC48HS+keIPkfAQv9fht9lCe6D93u+Qzf4c6XvrAXnUDj7HGGE4RZkwdEsnLB/1+3C+inCG8F9AfTXdts49u9QRJt2qD+G/jDDpB+LxEnUYO7qbCY+XyureNbd9ejeJh5fraJlz2HTJnMPZRXBoPnvQvTiDzS0Za1np/XY7dIAHS6q9KI09DJ8+Ev6/SD2+m+g0SGda9jLp4uMP4yTdvSRdXYcOLhqJCdzw8wAud1omdJxKed5I/CH891B7/g7p93B/jfvHH/uMufHzw3AA190MV9xmttRH+kP4HyJ9HVnEc8V8MNfjN2/Ij81HzHvUR+qHsx/cKxDt2g9uSX8n8cN9MbW/3NxgUB+Dy4ELT7dPQvjfMs9WQfONGv93AfMWdA5gK8pDUD/Vatn7T4M8rt9rXzfWR+YXwv8YzXP0TOPT1g63wd5p7aW9yiftN6O0J3mYQXMskuM/rqzwlgpaLkHzenEmPn2VwcTrTThNrn+mY/12X2/C8f1e1Qd/7QyPZ0M/u0L6MUYnJp5duWfLoLWWOhP+roDwQ0x4rtzwsyu2rQ5JFz+7DpF7Qba4lV04uU27gOeOcfityC4sI3YB86Kvr2GbMcvhuThOcBnFmfj0mCJTz4WzSH7uCshPu+usOP54veI5i6TjV29cUm/G+grzDajepALqDV2T5NaguTIIMwcfVAZrQ6azrcN0wr7++WSuUxcK1annoDq1itQpbp3xyarnHYLpcHM9tN+i+sV+kA69FzRO8ttOijnoMr52Gp9m2HoD4V1Ub14Yot5wZeB3BBJOd7z25IyXPQzC4sbeEJ4b2waNwcKuB3CvXULdNvvaSfj9JJB+jHCV5dMc73JzBHVGd1Od5txHsboxkcxfVC1v2LpuEy0MAIw7I5U8RAAhvEN+03iaVC8JcxeThnb4nBBckeIkPh1QU/wwnFqFbeXPNcK6w+fTccI1Qhy/3TMPh5A/Dr/OM3hhz2moo3vtnNOw3Yd7lMlDzCce1T13NsVlAXmG8HcE5HlHizyvInn2O28N/6bhokweJjv8poqgs2RmOyO5t1ufcPzxGqzMJun4de67Sefe6uyVm5A/Dn8S3hxEOndu8G06/35nMuF83YTC+J0N0stgakdfEIHwh7y8G574Yd91Cno/CG+UPzKttW6Cyrxxrhgq8wdDlHlQ++HOGguyFVYPZBJVN0wdx+lbP5D5RmSkkocIIIR3yG8aL2ggQ8P6NepOBzIcJ7+w7Q5k8BNAnYRtd8cIjg/hzO6mSo7a0YxXdYZQmn4HHeIdFkFPcHT3FcWnHQB+WZPTHd1hAeHfhgYxDy564porqzk+/BwnXFnh+OO1u2cOScfELK52dEZjvAfrfnXQ9a5bDZI+2maHiR8ScPhPx5uYj5EOM+wusjAztbTOO064Gf6g9ha2/VAd9TKY2tEBFIT/ChlAmXmzNeMev1W7TOjOnw7ouF0VMcavo8N6crWEm83mUrVkMV/NZGkfCVzpvTAreicx4c3OGKXZw3rqSK/a9SK/ncSvD/kBR+4Ai7oh/mH0j9OPM+HpgbPtzhpLYMGhE9zD+vGyZWE/XAHh/yNgQoM7QBn3W0FvQW8j8bgDobWjNlG7ld7/VjWp1sJBelA+kxgu9M0gCPstpJeHF43Mi9/On16f/OK8OQyGn+5oGtwhHjc7I7ntCMGNm3jCGFt9eGqM8dqBwqWzuMN0FjPpmFz5wmm2Go/9ss0VqdvrTX8c/t1oPPYbMh7j3jqC9LiJVTwWojaS7ryjYai9gfB/QO2q1QcDcD6D6lnYDwY0Dkyd/sT/4zmhRfPc6zR392L7eEl9ZB4g/Be8PGj9901vD/O5PphJhDm5TcxLfTBPRZhTvGuuPs51RqbX7lviOD7edYu5CJdv46NJ683gNz6ws47RBc4TpN/pW8A4rfF6a53LW1A544/H0ZVpDmtdm1gDjJ+JMl0bkG+c/mAAVy4fdFzBpTOX0QmE3xDAC4eHNozrPsQFHeKP8gnqMBlU3vgjgZD+WD6aBHqbR8LRjyZh3a/3wXLI73nkXtThP5p07AQarz/n5k2m+nAGDvQerf84Pq3/ZmxmrsLtlAZHx2KUI3VR8hvz1uX9lplNXBoOY9B67PcBUs7m+mFwc7mt2r12eDECFjw3blq7oXrVhptvL26qXnx7dc0mpv5OJvmj9Y6eRLeehMXzszgcXcxcR35vJr9vZ/hQR3WC3SATzs+1ah9nouuxtA8cP2j+ckmH6Sxh0gnCOpPBCrLfS5jwJ4r9PpWEg2euTuz3qeSen/3m6oqJN6YpFn5+gk0nuC3TMfoLyPOQmbFPIQX2HdtO0BmkvcFQ2hGSHugb38PpDzJ8gHeM8etkfjqZTyUSebWEXnXTbrHiBrVlfI+2/Y1M+LOZ8KDrzWZ0zR6wvBHpVbte5LeB+PUhP+DIzU+bsU+FUPrH6ceZ8HS+JGxZclirxogF89PYxkPbHi/bZNamtD+epKc/4PkYupGrjrDwXDp13DgU8nvsDdMQ41DuFCI6F7qOyUdQXxr07Ms9a5qdzxi/ssJtjzqurCC/7ZYVLg/gbdY2jZ8Osc2hjtMh5Ffr8Cdt6BDXNTonj20t/SBzt+g3QvzwOuHF9WY46lrp8LNt6JCb1486o/W0hsGiz29lhg/k83ZnJH9cftrR9UAc/3aCtbUFFt0sjeOHefMFY11BsILWZLe3wLqKYHEb1wFrRwusNQTL71RtWq84rLUEi/sQHWDVW2CtI1jcmjxgDbXAWk+wcPwhgrWrBRY97RDH30WwdrfA2kiwgk5fGW6BtYlg4fjDPvGwfdNukLkHbd3sB0USbX9oi3v+MbE2wOmdG+eC7vYwXOOMH+63sR9OZw+TDoe1VhBrmyDWRkGs2wWxtgpi3SWItV0Qa4cg1k5BrLog1pAg1i5BrN2CWOsFsTYRLO7ZmrNtU53mGsixdYALi+s2bl5ddYjD40lIA//e7JN+nInvBGDhOEF54b6WAeHB/vqdiEv3jkD4v/HmKfGpTUHxtQtzCquhtd5k2H6Vrrmb2q9A9Y/1F/QyETd/FGf86JzEmpDpSNRx7S6u8+lHmPhOCyz4za0x4bZ0MsHYTPjSe9RG4PgQjktnSYfpLGHSCcI6mcGC8NwzUtAaU9CpqIZObWqsMXHPrNxz1ljWmEBvi0g4usbEPbtSLIf8XkTutVpjwmW63ocnpNuqruD4QXVyTYfprGHSoVh+L2jTtSwI/xuyloV1L1e/8qmg94vMvueRD72W5Xc6HeYdY/w6Wcuq5ZNuOVWruplUqVR2K0E2o92TPk5lwo/HB9mPcag38fE8pXa9yG878etDfvgEcbqWZcYO5t0w+sfpx5nwdPzW7omJEliwloX7Emjb42WbzNqU7l3Lwnt62lkfweVB17JuZ/IR1Gfje0FldXtAOqd3mM7pTDqDTLyIz39Ih96j6XCcuecY/P7A9HgzDm4n+P0BHHdzvemPw78KvT8wM2BvFZ0Tom0C10HtaLvHp9yG6d8h/DyPE/f+APcO1Oa6P2dII+z7nBB+scfBbD/Pvz8Q9H4ZnYts9/0y7p1cs3nMVbn3b8Bxdo3uda8jP7p3Zwj5bSR+eM6JPu/uRn4R4ofn4DcTP24uF/z2Ir+1xA+f5I7rKHWcbcaHAN04q4lLwzkkTVxv6Du53Lvs3H7BM9A19gOu9B6tbzj+ep941I4Y3puYMNymG/v/uXcrcZ7o2J1bFwrTv+C0xmvdhstb0F4nvO5B1y04rG1tYg0wfibKdGNAvjmbwHHl8kGf57l2dgajEwi/PYAXDj+dSXu852s4HUrN14DeVpBw9J0OXAe3+WA55PcKcs9vvqbVe6CXxHnOYc/lgPC70DjuMnRN5zIx1m3OSL/bkN+d3rXh/XwFbl6F6u5OlLbfFyMpf+pa7dl7bIx79jA3jInLbwsK47fWcQMa5359IY8ZcfixPR1rQ50I+64uhH9pwFgbwvT65GudD+YmVBeLPnXdYTC5fG0g+aIc1hMOEL6K8gXrSI7jsP3sbej3bfWR3DYyaTk+92hfsNHHLyjdVnH19R3omuvraX3dQsLDOqWfTmldgfBrAuoK9y5U0F5pyoGG2eDDYQPDQfcTUzz/8tp1W32WlnrRNTXPXFHSIljL4Pg5UIPOHjQHigO/g6oftyzn+NyjxQBx8Zl3lerq6ia/tbceArbGJ7Eeh3cT67ANN+Z12A0M1zjjR8eLYdMZ6zosrQu3+aQfYeI7JG6Euaedbiz7Jz1xzT2L0rmPdp9FucZBsfzO4qjWm/44/D5kj+gX/NYjHhwm7FmF8Ny4OOjA0FbPl5A+6JJ7TglKm9v3C+G3t8mVW+vBY/6NhCvmt6NNrqvGmev6Nrn6tUvow5SRvvn26oYr1m6q4qZCaTjkeoDco2HoNvANPlSnknB02pseXUT7TdonbWL4cY4zDZRL1Gnt6Hnej6Am+l2fJuo4wduauG34eMh9CXnk4pawgqpj0NCeO9saY9BjgiD8owGmaWeLfNMmUWfCcx/44LamQ1xumXV8PmzuVriPJ2Id9NXD55fTzxATvo7C0OM8hpAfXZbF9YVO2+IuDJ+NPZ3UP+7IxaC8BW3lA659TN60u7He9MfhPxBQ/3YxHLjjUiH8biY8nt6ve9fcawMQl6t/+JUj7XqRn2D9q3L1D+uA1r+g/HL64bbR4yUOKN84CY91BX7cB2I5+1f3rvHRZtzydsTnP3Cl94K2FlxeH5mOqY8ZwbIgtZfcUE5fu87I8LtRupy9pOFBz3iqhSu/PhL+s6iNHST1C/fTePrxH+J82rh9b2O40rS/j6Z5/onYH274Ro/M/RLi/spF/vFp34LHQPTIDr+jEbH+cT5xmVM7BuH/DfF8DdKxdtiW4Gl07XqRn6AtqbXbl3G2Nqgva2VraX+F66nf9yswFta532MF93F2jEfHeN9ipvu4xz76oeKtbXIPOzbchvLxUXJEI9dvBZUVZ/fjTPxdIbB2BuR3N+LMhcd2Aof/CaN7itnn8HVpyAfz5wjzB21i3uSD+cuA8QjXf9bRPdpGuNdEuI+Vc68L7iF+mDvtN4dR+jTsLSR97vVGh0nXCeBL+9xWfKltB7+pM574r+uS410PEDxhu5gKKsuzmPyELcvGd2OY/FMsiNfrjK6vXBsaZvQ1aQaP2dcmZszDwf0rN9ZZXW+mPZWkzdkQbBepDdzG8MJjDq6f9vvswEzEH9pr0FZdo/1uoupy/S7WBe13uWfsoO8F1Znw2P7SMTwOf0t9pF+Yb0rhdMbSrx0h/VrQcdFB8w36ej4JX/d+YxuPdVFF/jj8KUydAcwhhkNQeXB1fwiFAT7ca+/4uelY/HrT73jW16BxIqefnR3oh9ZXbtzD1Vf6Oiw3HRu2vuIjrHeT+sptpebKks6fcHqqM/mmeur3CQ94tA/NorrsN67CHIJetQg7P8D1ccMOnzZum1gn9EO6EP5pIe35+MzJJBJc+8B6pe0jSIfatTtGBJ0FvS7NtY/dxI+baw1jd7ULajsQF39MmXsGD/NpgKD5xaDncs7WQ/jLA2x9neEQZOtbtWn6agO2HRD3+M0J8HW53sxSKFtfD9BPJ7aePnNzW49b2e4LA+qf3zwP5ro2IG91Jjw37mp3beN4lv14rm3Qssf1gvad3NoXZxu4+Rk63hrreFM7+q1o76fveJPOgUL41W2ON4PqodXjzTHUQ04/x3O8ydkgPB/phvj0XVD9C1rfqjPh27VBUYYX7ou512i1W+n9dzt0QWsyZj835mYiJD3QB76H048xehTkkwgqV+7zRWY/J+emtZmidV+7m+qjdeNndyIkPqyFaXcVwqHbtblPaur2dA+Za+LGgTgupEHHgYfQ3Nl9BJN7PS7s+Be/vnhywLMjPVaqzqQZ9Fm3IZQOFx7w6Pr6gwHPh5yt5OodhOeeJ3cxnIPW12na3H4Bri+F8K/squfDZOJ4r9nXveswa/a4DtJ1IK4vwu2CtgFuzMW1V/zJOq5t0WM0uXVbwKLPjNrBeixtl2FsBRxJSW3FO9t8ZpyB7rU7LqZthntmDEqbK6Mgm4HLDfBG7ckJsBlDKA73TEh1CuE/HKBTzg4F6bSVHap712HsUJ3Bwjql20S5ebognUL4T4aww2F1CuE/HaBTTkdBOg1rZ8LM/dUZLKxTuqWZW1MO0imE/9sAnXLHHtQRB6pTCP/3x1GnOM/0uNg68qNH3FB7F/OJFw/AHPLBhPs4XtAxwFxZcjaNluWXA8qSy9dQyHztEsrXrjbzBeG/aihfW33ytbXNfA21yNdWki8I/40Q+fLbQ0Xn/iH8N0OO7U6UOTO6hwrXja3Ej9u/FFQnxvJ800ueb4KOHMGfUw6aW6N7tH4Wsg6Mz55wvg7g+UlaB4JeC9GO1gFu3M0d7RRnwsNzMlcH/D4rjdMZSx340+DIcKb21uKjqXC+8XMEnqO4ioQfQulybZGG936O2FuL2xvdf9II771eyu2t9Xu1v38mn7ZfW6FzGhB+wcwm5oB3zb3OT/e/Bu37594jwXqm7RbCT0N6CGq3+JO82vUiP9PtFtevMLY7aC5kiAlfR2FAZ5ztpvaZOx6XOzKLa+f0Uyl4Tghwj+1rGGzNn5tLhvBjHf+chOpFmOcerKeED+YpqN4vnTky/3Wn6WC/kw63fKZM2qcz9RwwueeDoFcIWz0fAJ+gZy6ab1pWy4ldwHmkbR/ihR2PYr86usbjUbiP43F7e6kO+53gZ3v6/JBg6lmYvQ91hl/YfrGOuPYTPQet+3BjhKB6EnaMwM2h4XWrY/HrTT/gaHiONNmuLQ7KL6efOhM+zJ5IqiusE4wVtPYcZIu543l0XbneKwxujXZriLzhe3QMFTRvAvwuQW2F7pvn+v+gcTuEvyzALtaZPATV9yHHP89cfcdtYSggHrfOidNa6f133VpHDtIDuzWJ4eLXX16D9PjwIp5rZBTfzhzXd0aInug8ikzaSTdC0nOc0c8KtG/i+puVInyaa7LcnHQd3aNrsruN8EnU8Josrr94TZZ7pwPXF27uAj+PvJSMjTgbgO3p+cgfh6+gcVnRB9Nx2u9n8R6vd04diRtkK7TrdP8M954rN5aie4O593XoGMfv3aQq8sfhVyPbEPSOIfAyu3e8dtz3xtL9r3hvrN9zLcbCdSHM2lnQO00Q/o6AcWjQ/tztbXLfyXCn7Zy2nZeSMSpOc1uINDvZnzsf+ePwQ+M4bpjYnzs6PLZh7ezPxfWl7ozk7Ge7D3u2m3t/O8znN4PWuoPOP9HXC5A/Dv9AQP3rlvNPQE+G61/yeK930DUNXDfpWkjQ3kzuM0O6/q3z6p9JPebybmNMC2WIj6HHrhf54/Bv9upkDOUD/vd2wLOWKyZqqWKtmClWKulykR4rrx2UmT5mSteHR2c2dQZ6ktaZdoDfZwa/8d5vL8prlMkTpA91qQeFj/j8dxz+mQXSihEs4bwlgvKG+dO5gl7CB679sHrbxBrw8Vspk+9GmUYD8k3T9wvPtQG43x+Aj8ODXcd1uJ/oYpIZXSSDyq0fpQnpj+XYbPi9mISjnznD+u7zwXLI78XkXtThj82mdmnQGZ1viGPYpoQ+ThTSjzlG20PDDvQRPn5tFx8nuHptseKd8klNHi06rE4MR7NNi67RLZJ7tDr0kHgw1OO6UMozwmBwKqBfqI8w6XOmJOqTruM0qys1H62w4DoawMUPI0IwBgMwJprORNNh3ETTCdd0pEfjyXw+W0iW3HSuUq5V0qlWo3Hp9MulbCldLZWziXQ2lXYr7TwN0NEGfuqOMvrrI+G/HbAC1ROAqR09yRTCfy/gSZ4bFXH5DGMGMJ/pzuh6RZ8gxqs+5Yr5UqFcSBfTWbfs5rLtlCc3co2E0Ekfgx1n4veFwMJlvKk+MjyMYPud4Ke2PhL+1wG7T/pRHMC6vd6aM64H+MmAfiQOwv8OcXiUzK5gPdCuF4/aBbu6coSk5zh81wvpxxyjQ4EELQ/g41e/DD9JlSIEH/OZxOgHynIy4wdYMOOEbRoOPwnlEYfH1xAf3xvwPvQWJ5jawSmoEcYvytwD/R5rY7NG5g2XTcTnP+DSe9QuYN1QW4ntNF6hnDZrZF5we+fGKGA/aFs8aVYTc4Z3zY1jaPlR209tvt84z89e0X4Rws/1OHEfT6H9Is4n5YjT62XS1Y7aKwi/yONg+BGA/ail3+wbzp/uu4JmWoLab9CMF7SFfp/wgNdHwp+Cyoz2MZNRnCjDi45lIPzpCJOOZQaYfHHtDe7HmPADTL6mO6PtEsTlViVA94ZPsi1zqxJYh3311vqZ1IF+oA7ESXisK862TSLptHq0pKu43CwatoXc+I2OGXD6XP+K71E7jeNDOC4dqs9JAelwdoprd5weaRt5WkC748Z2+APAk3w4hB3bQfiViMMbA8Z2uC971qxgrtSu4WcsHP4S1JddTPoyWvbacePyKPHDZQk6wva2n8Hl7AatE1ybxOHpWBvaWL9PeDyewuGvZOrEdGd0u436pIf54XtBbSPmg8WVp3Z0bALhrw2w+VMYflGGH4SfyoSfgsIAH043Ux0+bZwfXJ70A+IQ/kVMfrh+BK+QaNeL/AT7EfbrHlivtB8J0qF2VOeDTHisS8hfnITH+ufa6BTih9OdTDi0eoaifQw3fsI2ipsuxjoAngNMfuXKrpyIkPQgf/geTj/mjK7zJp5Zw9YR0M+gGf24QXVwkNEP8JlmhI+bgroSZ9IGrvDmPLYrOPwg0iEOj68hPr63jTy7TkfxAD9O/LSjz8vYL8rc6zlOWHEGC+sNylS34/VEF/RLWdx/wKX3KEdcnlDng2zEWNPBWDCO4tqTlpXeb7cjl0pCPqYx+YC0cb2SazuZXFhbB+nHHKNtORFUh7F+oNy4tg9x487oOnxXvRmuVf3G6XBYR7oUa1gQ615BrIOCWJL62ieIdZ8g1l5BrC2CWJJ5PCCIJclrlyDWsCCWZDnuFsSSbEOHBbEky1Gyrj4giDUsiHVIEOshQSzJet+tNkcyj0cFsbYKYj0siCWpL8mxiWT96tZxoWS979ax3JAg1n5BrBNhLNet9V5ybDLRp7WH1a1juW61hZJjOUlbKFmOkvrq1vHXnYJY3Tr+2iOIJdm2JduQpL4k+yHJNtStupe0X5LzcsOCWN1avyTHvt06xuzGvkNf0zUrib5jug82vg5aG+bSiTCcuTXlHoQx4IzOr+S6MuDPNIQP+Z7B6ArnCdKna8zgz/0HLOoHacUIlnDeEkF5C1qLxuvuWAd+WDPaxBpg/EyUaTwg3zj9wQCuXD4GBXXSJ4hF9+px7Z9bv4XwM5nwXD2ZzqQNcaFsZyE/wbJNBpUtthGQ/ljeege9XUfCwVcsepzRbWOGD5ZDfl9H7kURHnbjZd/pb9hbg/f0wn4Ubg+RlpXeb7cjl00G2Vaz/Uw2FSHpgU4dojdIf7xsd5AN047uwQhjw7TbXm+G68TuaPegINZBQaxhQaxdglhHBLGGBbF2C2JtEcSSrBNDgliSdeIeQaxhQaxurRP3CWIdEMTq1rYtqXtJfe0RxJLM435BrGFBLMl6v1cQS7Le3y2IJVknjgpiDQtiTYy/nhw2WrKvrQtinQi28GFBLCmbo6/ps3YnvO6vy2FJtiFJGy3Zp3XruLBb+7RufbaS1L1kG5LUl6SNnug77O87tNsjiCVpCw8JYk3MKRy/NiSpe8k8PiSI1a3PQ5K63yeI1a3zhZLjnAk7cfzGExN24vjpvlvtRJjxFz73kJ5nzK3jA9bMFlirCBaOP5NgzWqBdQXB4vYzQLzZPungszXwHozZTNocPmBw+zi0rPR+ux25XHGAyYccfrIC6+FzUL4j3n9Iey66L7d2nw593iqkHyNcZfk09xLMJXyofuhegnkM1zjx025nvRmO+kWZez0BWAcEsY4IYg0LYm0RxLpbEGtIEOuwIJakviTzKMWLs7PdUlcPCWJJtm3JOnGfINaE/ZqwXybzKKn7XYJYkvX+fkEsybbdre1R0kZ3a18rWY67BbFOhH7oRMijJC9JuzosiCU5XqXP7d1Sv4YFsR4UxNoniCU5NunWPm2iPR6/PHZrv30iPKdJ2mi6d+zJWO8PCmJ161zHA4JYw4JY0B7pe4HarfT+ux25VBrmovHaScQZmS4eiwjOm1cjJD3QEb6H048RrsJ8GvP43FoO1k8P0Y+ZdQ63EiH4mM9cRj/cugIdR873fuN1LBx+LsojDo+vIT6+92VvoUPSTur3rf/Rw22jDSTLtUQqU81l3GwxnalkU8lKMudW0plaIpFPJAvpfCpVK6fzlXwyVUvmkuVBZ3S50zZgqIzTYdsAXcsy1CYD17JmM2XU7lrWbfVmuG7qf+F7RGHOqTdTF1KlsdYF0+fUc3Uh6Jz6sHVhR70ZrtPykxxTSz5L7hfEGhbE6tY5OsmxfrfO0XXrusC9gliSzw2S6xUnwppfN67BazexDnz8dD+xDnz8dL9HEEuy3nfruuaEnTh+upfM40OCWJLjiWFBLEndHxXEmmhD7WHVBbEm2tDx073ks7vkMzK8Q0HnkLRb6f13O3PJASZdIew0YM+Xx26cQbugc+wKvQHYC+V51wB7EYOdSKUSik4uUavUUplcIVlKZFPZbC1dy2Xz6Uotky5WctVEuphKFqo5t5bIV9WMdaqcy9YKlXK2gb1YnHcqA/N0+Hvc+HvqRa9yQr3H30uPkrj6ugf54/CfmdvErHjXgwjXQRjaDRC8iCM5n5l0IyQ9x+HnVyH9GOEqy6c5v9pD+FD90PnVKMM1Tvy021ZvhqN+UeZeENY+QazDgli7BLEOCGI9IIg1LIh1qEt57RbE2iKINdSlvI4IYknWe0lekrrfL4glWY6Sut8jiCWZx6OCWFsFsR4WxJLU132CWN3atocFsWA8Ae914/HjVGekHx47TSF+vcgPY2A/zK83gB+O3+sTj+YDxr/9xH+l99vtzCUAf7IZ/MZ3ISYxusJ5gvRhPNuHwkd8/gMW9YO0YgRLWndBecP8aT2YhPjQ70dwWJPaxBpg/EyUaX9AvnH6gwFcuXz0Ep1w7SzC6ATuTw7ghcNPZ9KGuKDDAeQnqMNkkA5xW4T0x/JNDdDbEhIOzuLocUbXwUk+WA75vYTciyI87KYTDM6O0vbsV75xn/jaDQakM8jEg/xNQRyXIP/JAfmNMvcoRxwfwnHpRDpMJ8KkQ7G4ORrtqvWmPw7/BW9eRufhWwtHYi5l+AW1xWVM+KUoDPDhdANxB5m0Iz7/IR3HCa5DS1EYaqeWCaazDIXpI+mcIpjOKSjMVJLOqYLpnIrCTEHx9O/TkB+uZ2BLz0b+crY0WYR8LndGO/Bbge49Um/yoC5KfmPeuj28ZVETl4ajaZ6O/FYQvzOQ3znE70zkdy7xOwv5nUf8zmb4jLWccVmd7pMviXSwjs4g6ZwhmA7W95kknTMF08FlB2U14Iwuu+NV/3HZgt85yI+W9bnIj5bPeciP6vR85If3RlPHtTfQk25vfx2ivZ3o+uXqJbgJ/Tb9xqpf3K9RN6Hfpl8Y/Y5Fh39so8/FZQV5gvEtxD/NWwzXzz1L542Mj5816fsfJyG/y4nfyYyfxv+9t4AN41usB/qMgfuhKHMv6BnjTB+sXoQ1gLDg3MM+Ev4CTx9m62Q2FzRmgbSXG0o7TN+O0x9k+ADvGOPX2wHXWjnvptxstlLNpkuZdC3ijG67UeYefe5awYTnvmEIuj7HjK6TjW8a15v4eCysXS/yW078+pAfcNT1/pZFI/mvMMQ/jP5x+nEm/BUoD+2UpUksbA8ksCaNEWumM7I9YZtjuF8scDYIHNfm48QP17kZxA+3J/oda9xn4rk36lr1i/MWN3FpOJoP3D8s98GEvuA05A99WR8J+zzUh15B+lD8fPi8+kg//BwG6WiMm+Y17+N0uP5Yu9U+vKqk/zIz55CucGMq2n+tMJR22P6LzjlgPsA7xvh10n+VErVU1S2V0slSJZPNZoP6I3yP9l/nMOG5c3NB1+ea0XWJ67/wfI12vciP9m24/wKOXP9lpv9Nl8LoH6cfZ8LfivLQTlmCbefGTZytuKU+0g/P/+Ax9U2kjZsZJyZL3NyhQ/jjcqP9A66TtH/Az0a0f8DPnu32D6CLdvsHbCdxnjBmL7rH2fg+Ev4O1EdsJn0E7tMhbR3ut6RssZ4Ey7ZGde0wOnHRvXbnjIF3u3PGuC67xA+31wTxw2WWJH64HqaI33kMnzD9i3Z0PIjLyu/ZSSIdbtzNtdVO0+HsI9W3RDq47KCszPZr7dV/XLbgl0B+tKyTyI+WTwr5UZ2mkd88dE0d195w39rOnNuJql+8T4O6Cf02/caqX9yfUjeh36ZfGP2ORYftzBnjssJ56mTs83EyjjHzLOi6M0m+cFoTY6iJMZRfOhNjqCd/H4TP6aNuog9q+o1Vv3guk7oJ/Tb9JsZQo92JMIYKO9cTdqz1/PoT/+lY649onun38/x5nYXSrnvGcWKMNDFG8ktnYow0Mc+E3UQfMzHPhF036Bf3rdRN6Lfp1w1jJFxW7c4z+Y19VpJxzPGcZzJUR6rcGILqFtefdsdQuDzH+n7H+cTP5PgK8xnrWACX1Xi93/FkHauZ3cPRXv3HZcvZT1rWEvaz3XkmvI+znT7oRNVvu/NMY9UvTudE0m+7YyjQU5e839FV+g2rw7G+34HrKO1z8VwPhMNzPRQDp2G2jMJ/1wjSjzkm22Tz7IqzCB+qH+j/pjrNd1xurG66anNp9c3lS6tbN16wpnJVccOmm4urL6hUNlQ3bsS5wSkMMrmltYWGges4cx9jLG+RCzjxYLozupSXE6wVLbBWESxu5AFY57TAuoJgcaMLiHeuTzo4DDfDg/mc24LPVXV/PucSrPNaYK0hWDj+eQTr/BZYawkWjn8+ief6pIPDYGvoMmlz+LTeJlpwXlcfyRnzShCsZAus9QQLx08SrFQLrA0EC8dPkXhpn3RwGNyTplE6EeYex2dj3Z9PmmBlWmBtIlg4foZgZVtgbSZYOH6WxMv5pIPDZNH9HEonwtzj+Nxe9+cDccP0cJirYI8S+q0ESH+8erhWeqWnxOQZrnHGD/ch2A+nk2fS4bCWC2KdI4i1QhDrXEGs8wWxXEGshCBWShArKYiVFsQCmwg2DZfrLJION0Y4PyAdHJ8+KeB4EZ//kA69R9PhOHMzafg07c/Pb8bBdRCf1ITjQl/UR8J/bmET84seJuiSe1KCPgDXLTmbm8pCvnHf6hCd4P5nAbqmjntqBN7tztTiMqJ9JW7/eeKH23OB+OE29RTil2L4jLV+4bIar3pMZ6xdwXS4cTDVt0Q63BiZG2PidoL9IB16L+hkITpj79f+fzyfT9Ov/cPYr4+E/wRq/z8lK0F4vCnYxnO0HWPHjaHoTpAC8qP1+SnIj9bBpyI/XLbUcXYDdNHubBPu6yBP3aRf7dpd7cK6GKsNpXYSt2lqJ3FZ+dlJXL5cH9KpLcBlNWFDw6eDyw7KyvAYom37kiV+kvYF/J6G/Baia+pajVnaWS04UfWLbS51E/pt+o1Vv3R+CjtJ/eJyfLLqN6wOQRftjj9wHc0jfNoH4HB4DOk3z+0wGBSH9ouQ5x4mLnztipvrnk3S4Obb8T3aB81m+Ab1qWbb9xOnn+P0IB/4Hk4/xujExDxnKqReubFtiugc+9G5Nm4+P82kw2FRu8SNvQac0W1MUF/psOUH6ccYPZgoP249aTaj1/Go337l7AbwyZjh0ziBjVuv4eb/9Ekr/Y7jO36lddJvXQfu+ZUNTpuuLwet9aVaYNH1Zb88+JURxqLry5wO+ojfJm9STuvwhgUjw8C66GoU5sXeddBzm+G1p9Btmq49mXmGD157wvrBdXaSE1x3cNn5rcufx+SV1uVzW3CidbndPQAYi9bloD0AbgssWpdxfDouwLaa7vxKM/kBvwzDT9fxdQv88d0A/EQAfioAP2hnMZ5vTBM/PK+ZQfhbAvCDTqY/NwD/PAafYoLdwPt3Tid+EPYuD+PYc4Z3ctWAY7LvTaW4+XqH5Bnb2Hbn2oB3JzvLaRnj9pghfrh90ecezjaYngMbr53l47Xjm7aHcwXT4Wyj2bdT26v/nC3C9oyWNe5bafngcQDVqd8eC+q49obfhj3+O3O7X7943wl1rXbtTui3tX7bfbNsrPo1cwJmd+k3rA7xCZhjfTsP8qR3PcMbwjdWN11a3XpdcfXNleKmm9euubq6fnN146ZeAnu6Dx34TbsmqCIYxwmgq10P8TuL+MNhqT0O76DamJmSMj+sAt7tDqu4IuaGTnRYhbtfOqwKs7UE8xnr8ACX1Vk++ZJIB+tovIc7VN8S6XBbubvpsQKXLWc2aVljs0nLB5tNqlPcLS1G19S1eoxpp1s6UfXb7sFFY9WvmcPtu1+/7Q6r8Af8jv8Lp92l37A6xC+VjvVgKNrn4jEPfNAB/E5C8ejHuU5GfvhAKfqxJTxFsNQZ6bcU+S3zrvsIr1neXo8BEk64PlTo1BukgdM+01DaYfpVrgwwH+AdY/w6+ZhEsloqZ4vFWqpcc8vF2rGXKDE+cKX36MckuJccpzHhDdvVIrQX/DEJ+npkL/I7k/j1IT9s0+jHJAw9bhfD6B+nH2fCX4by0E5Zxpl0cPtuBws+TIGnuqFtm21vyTw3ZgdHbaZ27T4bAe92n43wR9fpRzqw3aMvgXf6kVvMJ4wt0i6oTvT65EsiHayjZSSdZYLpYH2P98d3DR8G0Vb95/od+qE97Ien6mn5hP2IZbsHwo31MIgTVb9L0TV1kvpdivxOJP3icTN1nH6XetcT9bfph+0ida3qaDvPRkuRH+RpYvwxMf7wS2di/PHkt9/z0TV1E+OPpt9Y9dvux9wn9Nud47uJ8UczjOT4g3LvY8IuIX4Q9n70OvLHvOvpzui+6xRnpN8S5Hcq8VvKcAK/ZQynCEkDvw4D4bWr1kfmAcK/wuOtdfmaRTxmjw8mbFHl5vmWevcGvP+9yE+u/pYTmvcWVAewTo/ltz4yT7g/jzLh6VzqGUx4XF9BR9zr8acRrKUM1inoHswVcvoEjsdDn5gj1edpLfJE9cnpH+tpqXfNjZlOIlgnMVhL0b0gfQLH46HPpYgj1eepLfJE9cnp/1QUBnQUd0br+mSCxelzGbpH57Ihfj8THuP1kfAfRjbn8YUj+WG7uZRwX8JgY9sbIRg4HzEmH4PED8fVuMW5I3FbHe1Gy4Z7hQevc0Ld5o7pgLiGXy9t+wgberwFd0wV+OFXT+maLn71lL42gF89pcfwYdfq1dMw46sISQdwqa2ideZ0hiM+6oR7NYq+WpgImSaEb3XUIa1/XH3Fr9UE1T967BXEw+MLzJ8e2QLhv4za+re8a84eg57M2mO3ytljrFdqj4N0qF27bR50xh3VkSR+uL7Qdnc6g4mP2sI2Df53tDZdqVQT6USukK+m05VChn4gAetiioH005lirlzMJRKFdKKaTox7+uVMtlRWJNxq4pg6xjv9TKWUd3PJYqFSzlZSmfJ4p18tpQu5UqGccStuIVFItUpft7NHvUAm5wa1u63+xH/oK/tRfMlXcwF/EuEnhJ8APfU5o/UEaU82krdaLUw54PRjhKuwrhuvlE4mfKh+6F6WATP6qepXVqHuYZvfz+iG8phEOMYMceT6VeDE7bcBHjrMZ8griD2GOJpto7XG3jI8NsRH0UXIHAeUDR7X4Hrfg/xx+P5FTcxe73o6woX4YKemIP9JjD/8hvLqYcLia/obuFO94vBQJ/t98tpP8grhp3r509y+NpPHxPrDvHp8MKcjzG+R5zf8rBbU5iH8FCY8bmPAZ7ozum1OIfEw9wFnpMP3uPKJkLC0D4Z+Csfz+z3A4PhxmMzgcM/TA4QrTpPWB+3oM0+USQe3KdznDzDpC/YPGa6vBAd+/SS/2A/n/fp6Mxx13DMm5Enn90fkmQaHo3y4tiY5NoL7feg+TTdKwvaTsLg/pzrrE+AYZ9LpJ7iTAvhHCE4vE2/Q4dsj9z8s3wjDl+trOk0HY91QH5kOLmfcp2VIn4bteJSJe0e96Y/DPwX1afmQfRq1JTgPL6o371GbTcextE3SuQ/ad9EwuB/H4Z/J9F3UPmAsfe+CEGMEbtxHxwhFpM+LiD65McB0Z7RuaB0eIGnh8TH0L1QHlyEelyzyTwv0OhiQR33vikV8OMwBh6MYXN8JGFy7hnjTGV607VHb0R+QBtefcWn0Eb9Oy4frt/FYgxvDcP64P8fp0Hs9TPhW44+YDzaH28/gcHZ+MvGLMH7UhuH8YhtGxybcMxm2jVy78yu7oLE3xz3MuKo/gDunP2yHpOdy3LybcMu5TK2WqGSLpXSruRy4P6k+Ml/H/qN7fShf2k3G4YnfAPLrrY9MP+b97kXpYCzg0UfCb0JlrV0/igPx40z6/ST9EbyZe7iuUawocw/C6zK9zeNoYo4umSnki4WSm0jWkslUPtuqXDk94bkD7UDXuCz6mbz1kfDbUJ+zg6zD9DHp6XAHAsJFfP4fw2Du9dZH3uPKCNddCA9px+qjOYLfFOTXR9KZ6v3G+sJYwKOPhN9P6i6ubxA/zqQ/maQ/gjdzj9bdKUz4KUx4XT67iT3CeZee+zuWJsHH9yi3AwbbVTadTeTzxXw5W64V0uXSuK89FLK1QipVSqQKlWohkR33uf90qlRL1NT8f6rmpvKJcV/7KLpJteZTKmUS1WKhUBv3/CcSiVo2Xcpny0k1xTjuay/pWq6YreXcTLKSriYrxfFOv5irFtLZVLKcqhWKeTc/3umXKtmyW0glKsVizs1l82NZe6JzJNrBHBWdH1k5Rp7EhT6ms2GnndFjWRNrKlHCh+oHruncFI7LrcPBOTwRxi/K3OsZZ6yg+RrT85Vh6wKkH3OM1s1EkF6jjF7pHCCOS5/1tKPl18ekw83p24IF8bXj5nBvro/0w2VMdUrbO/bj1rGojQuaFwmabwJe8OzNzaXivNA5jc+R9/DNrL26LrX3NC3MF8bdWB/aXUHyAOG/g55TPk/mCrj1A06fPcSPm1Pj1p5oOTTG1SgPkwPyAOH/hVlL49aCIT+G91iluT1WeA0LPzdoCVq/047OHU9lwk9BYeg801TkR9sv1/6xzuk8NJ5bouExHp1bfxyVEd3ziut1jHDHeadzUFEm3aB1P83lD6TNGtork+PW2cANMnqjthS3E2ov6f4J7IfrAdYBdVHyG+vi2FrB4iYuDQdO0k7gd2eO8auP5nU82i2ed6btllunx+HbWafXDvq3uDO6LGn95vqCdtqMdpeR9Lg1B9xm/PpdbkxE7UUvkxftaN/aCE/249D1tZXeb7dDx/WtdL+SoT1eWW79CNwgk29qI3D7oTaCjkWwH7ffP6yNAF20ayO4cSNnP6iN4NZVuTZA2we3HhK07sU9N8EZZRGC6TjB6xrcmnGr53O6B0A7w3U/9PM5pB9zjPaZjWeyVutHtK4H7f/h+tgI8cPpTGbS4bB6BLHoe6O4PGhdMDQ3Evr5HNKPOaN1aqIucG0uwuiVm6sJs2c6wvi1O7/S7VhBc4Bhyp1Lh9Z/nA7u30fs01k8Mg7Ew897OC593oPwH1jcxMx719x7x3RvNM7/Su+/255L0xuGn/2L3POjQ/Q9hclzhAnP9efAu93zW3B/PoX44f5hKvHDfdkg8cM2cRrxM1V3+3zyJZEOt8cvqL8fazrc/gnu+bPTdHDZ0T1JXH821r6Rew7h+kZsW65dzKeJbQuOe1W96Y/DvwHZlheSZxBDc+N5Wv+xa3c+gNZnbBtoHcTzQvSdHuxa7QFu5wwKXPcGED5tlzhNw+PgtvSvXbtnZAHvdm0sbpMDxA/XxRjx69Q2Yz4StiJoTr/TdHCY8TqLa7z7DMNzlW3bH9rHtDsfydkfqlPcPvCYmLpW85jtnDF0IuqX2mTqJPUbIflY6f12O3Ndr992x+QQrl39Gpob6Cr9htUh6EJifILf8+D2oXPP4xA+aI0Ap8eNoyFutz5jttsO6PhzGvKjdWY68sM6oa7VM207Z6Bwzyk4HN23HmE44meRoHlguM/N7/QxaQZx5OZGg+ort17LzbfTeso9U2H+fs9Uj3n6aLU+D3oyvM6X4db5sF77CKcgHWrXbpun+4a4d3W5uQr6LMytu+F5Nul9iLlkOVNMZQpuuZrJFbO5VvsQG+vu9WY4wXJMQrpQXlGnaQ96601OkD7UOby3HMIB1wEzXF3gCnvRoQ3hNHFeekh4ek3f/fgqmv/AeYR84HsYH8Jz++Dx+wHAkXtnYkq9PazJBGtSB1jAi3s3YNIYeXFY/QSrnXdePueVjd/an998+dfJnBb3XmvQfDmE/wWa03qc9E2S67JBc4Hc/i+6byToHT/HCZ73pPMjOB7uV7jx6Ervt9uZC72GBunHHKPjukRQf8SNGUA/U8zwSQMfbv8aV876zJlpzugyw/wAixuHtLtPgO6jCbNPANd3fMZJ0Dkk3PvU3LwPbfeOEzxGpHs7f4vafdw7MDLoPVCu/dJ2z+0rAT+/fSV+ZR40hhpkwnPPGZA2rhODIbAmBaQ9jQk/GJA25oXj0rT96i43FgbdHI+xMN6nRsfCQXtPtQujS64c4yQ81h3XjoPGyVOIHzePzrVjqL+4vXBjbbwHFvpoONsVv0PtOPI2Hbc/afy8m85hO2yAf8rwXFXC8DtNLtS7i+pN/KD3FyJIlxBHtzmo5/p6Ooqj3cUIO0L8VjHpmsyzqhMZw+ufyVkMf3zGitYRfCcj6vB9KlxzZ77g8A5zL8LgUN3iclzp/U+kUgnXreQStUotlckVkqVENpXN1tK1XDafrtQy6WIlV02ki6lkoZpza4l8tZrLpMq5bE0fY1mjee0JyNtgAMdBJr9Yfyb7kFy++WwL/Rd+tsWuF/nj8HCWtfR8RS1XTNRSxVoxU6xU0uWW743Cec2W2/DyeNlwU/shDO+7Zm04t74bJeFoHO0fZOdN9nXYLpvan25430UK9Bb0fIPT73RdH6cVc4zW4URQ3oL2b3LnLgVh9beJdTzL1O+sumNh6k2/HuLXi/z6iR9+PsHvJixF4fz6Rm4/yqX1JsYKhAff6zG5lg2225TN0G6W4z+OgHt4PpabJwWdc/Pp43HO0XLvdzefc3Sqdz3FaY5h8bcH/NpIjzMaj5urpXuDDLXnJHDl1im5faf62X6Od71x09oN1UvWXLylWt686ea1ay4slm+qOsTRzWARlHm/jhlnlMOIovics2FQDB8WOd6DYjjD0PJBcX68BsWGBmNpw5vU2EExZ3CgDsNEBL4GThDm2SjMs1EY7YIGzrTT1u5i4ofb0irih40VpKsN8AyneQ313nCHnj+eHTp0PGCQtXFe6l2vWbvp5trWi9es31zdXK1ctbm0+ubyqs1ryk8Y6tWrHeLooDtCfveQ39Qm9zI41OF4EZSHbrfV3p6W426rG5sYvP9zHHl9uchWzzaD73KHJsxB17NJPnHdWynEAfCgHvQ5o10P8WsMIgm/iDy/BOUSZdICN8v7PxvdA33+P99AraO70QYA","debug_symbols":"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qMuSUJcloS5LQl2WhLosCXVZEuqyJNRlSajLklCXJbEuS2JdlsS6LIl1WRLrsiTWZUmsy5JYlyWxLktiXZakuixJdVmS6rIk1WVJqsuSVJclqS5LUl2WpLosSXVZkuuyJNdlSa7LklyXJbkuS3JdluS6LMl1WZLrsqSu92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqvpq73aup6r6au92rqeq+mrvdq6nqv5kXvNe/fMDTZm4PLXmTJvqWfydl+uuxoK1+hg0Ju4cS+wkl9hZO7CudVb7tVOKavcGxf4bi+wvF9hbP2FU5fd+XU11059XVXTn3dlXNfd+Xc110593VXzn3dlfPVd+W3Z1zd4lk7iyd0Fk/sLJ7UWTy5q3js8RNceytdPy6z1qyFeG4OfdnDD/HPuxfc3sRc8Sb2ijdxIm/iwuNNgnt6k4Nf5CW3bQzklud9n5bj7VSXfc+1xT1+e5/tR/y+8/jXnX9Ynfsa/6o8/qA8/qg8/qQ8/qw7frMoj98oj98qj7/39bcUv/L11yhff43y9dcoX3+N8vXXKF9/rfL11ypff63y9dcqX3+t8vXXKl9/rfL11ypff63y9dcqX3+d8vXXKV9/nfL11ylff53y9dcpX3+d8vXXKV9/nfL11ylff73y9dcrX3+98vXXK19/vfL11ytff73y9dcrX3+98vXXK19/V+Xr76p8/V2Vr7+r8vV3Vb7+rsrX31X5+rsqX39X5evvqnz9DcrX36B8/Q3K19+gfP0NytffoHz9DcrX36B8/Q3K19+gfP2NytffqHz9jcrX36h8/Y3K19+ofP2NytffqHz9jcrX36h8/U3K19+kfP1NytffpHz9TcrX36R8/U3K19+kfP1NytffpHz9zcrX36x8/c3K19+sfP3Nytff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","names":["withdraw_private"],"brillig_names":["discover_new_messages","decompose_hint","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","directive_invert"]},{"name":"_withdraw","hash":"7517973826271635353","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5235018679007078561":{"error_kind":"string","string":"Invalid asset or market id"},"6787403583199288031":{"error_kind":"string","string":"Insufficient balance"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"10435052277855889085":{"error_kind":"string","string":"Function _withdraw can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"15333773746166717806":{"error_kind":"string","string":"Insufficient collateral"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_withdraw"],"brillig_names":["_withdraw"]},{"name":"withdraw_public","hash":"15240537719589822539","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"1VzRbtswDPyXPOdBFCmR2q8Mw5C26RAgSIu0HTAU/ffJWWynTRx3gslaL0VckLk7R2fSNu3Xxd365uXXz83u/uFp8e3762L7cLt63jzs8tbr23Jxs99st5tfP0//vXDNH+8P8U+Pq12z+fS82j8vvgF6CsvFenfXfEZx+TvuN9t13nL583m8874Nd+S76MQXgik5PgZTgtgFx3AhWIjkGCwU6TT4x3LhcRr2KbXhAMmOPU3DPki372Vk30Pglj1ExOvsU0A6Bqec95F9mJo9+HfsG4xogMEXMTxht6QzXJ8VUHlVyAAfTj2fxNf5BCfuGJ0/ygifAO3ulIDuI580wMe7ng/LdT7XJaPThwB9CK8PgfoQpA8R9CGiPgTrQ4g+hL67Sd/dpO9u0nc36bubpnC3j9CWIh9P+oLc+h0wggFGNMBgAwwxwEj6GMEZYIABhjfAQAMMA58HA58HA58HA5+HKXwesT2yx9CfuqV4AEjKANFpA4A2gNcGQG0A0gYI2gBRG4C1AbSdHLWdzNpOZm0ns0GVZoMqzQZVmg2qNBtUaTao0mzQjbNBNy4G3bgYdONi4HMx8LkY+FwMfC7a1Vu0q7doV2/Rrt5Ju3on7eqdtPvwpN2HJ+0+PGn34UnbyUnbyUnbyUnbyflm5QQIIK69SQsCcoYB6iq8OgKqI5A6QlBHiOoIrI4g6gjqrganjqDuaVD3NKh7GtQ9DeqeBnVPg7qnQd3ToO5pr+5pb3A6Dd5bgKAFCFmABAuQaAHCFiBiAWJw+QzQWYBYOB4tHI8WjkcLx6N6RUf1io7qFR3VKzqqV3RSr+ik3qWTepdO6l36JANp1xHUPf2ZYbQQ0nUEiBTb6Bj7IWw6YrABhhhgpCkwcrvcPcaQc0MffumhB3QEx2h04d1wfkPpM7Nr1pRgfpT8/Cjh/CjR/CiF+VGK86PEX0EptdHoeeShoXwlnzsqziOdKZDqFaTaFURXvQKoXsFXFCqMbX+IePIM5oACRuwUcDhX8BV1jbD9ciTiMQXiuibPydkjg/CZQdXpFQD0CmRMQeqeecyfg5wpCNUriNUr4OoVSPUKUu0K2FWvAKpX4KtXgNUrqL4mc/U1mauvyVx9TebqazJXX5NlXvXgQGleB/gDpXkdsQ+UvuIQHHw74Yph9NQ03zvsX/ZDHs8UxOoVcPUKpHoFqXYFaZqTChTqUZw/VXBA8SYoaIJCBih+YIybqMui0P/2PsZ/WVyUJUVZqSRrYCx6LAuKsi6vun74J18k7q+60jEJS5KoJIkLkgZGUK/ebfcDU6UjSaGEXixJKtoRUpKUCpIGxgBHkqAkqWTBYsmCxZIFiyUrYmDS7fraGxheG0mSkqRUkEQlJqQSEw7Mdo0kYUkSlSSF/016y1u/V/vN6ma7Pr6V9v5ld3vyktrnP4/rD++rfdw/3K7vXvbr5s21/UtrG8aeZIkOM5mGSr67v8QgTZlufiJIcekdNJvNzvfO503KHDKPvw==","names":["withdraw_public"],"brillig_names":["withdraw_public"]},{"name":"_compute_utilization_rate","hash":"15197669237011420749","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"precision","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"deposit_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]},"visibility":"private"},{"name":"borrow_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"12348881442450494403":{"error_kind":"string","string":"Function _compute_utilization_rate can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_compute_utilization_rate"],"brillig_names":["_compute_utilization_rate"]},{"name":"_compute_borrow_rate","hash":"228344697676124960","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"asset","type":{"kind":"struct","path":"asset::Asset","fields":[{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"loan_to_value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"oracle","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_borrowable","type":{"kind":"boolean"}},{"name":"optimal_utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"under_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"over_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"deposit_cap","type":{"kind":"integer","sign":"unsigned","width":128}}]},"visibility":"private"},{"name":"utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"precision","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"17134621154673181869":{"error_kind":"string","string":"Function _compute_borrow_rate can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VYy27TQBT1M42TVq1gwwp2bNjYseO4G1RQQ5q+EAKxAQlN/BAV5aEWEMt8Oh2YKx9uZ1pVsSM8UjVj3+Nzz33M2I1t/R2Dqz9brT24xwdh9tQcrjaiBrnCNnXaHdHpdESn2xGdXkd0+h3R2euIzo2O6Ox3RGfQoE4bdA6uLZR4eRDKQ0ZuYLk5ZOPJosqEBZpAB5p7n9RMeAfsDR5gUcD8NsmfhUmF8bagPw4U57AdfkH8m+3whxuKZ39Z82Ms5NdV83RZ53IKz/iAmQFmBhjkOQDMgYFnDpi5AXMImEMD5ggwRwbMMWCODZgTwJwwzJZa4wbdVxiyOWCbMpsLthfM5oFtxmw+2A6YrQe2ObNtgO2Q2fpgO2I23E/HzIbnCOVHcj206vUjq35GjlOFw9xRz7dx5lydCWVg/Zvzps+0+wb9cgxVHt6qa7m/dtRa/Pz88lv+tSifFcVFeXmJvcT35U3jLpybd+B8wDlPf5yfn1Vn5cX019nl92vcWxpuWjuWPjauC3E4dOeuHHtqDlcbfz4qMYbHapa1ew852eY5eV1+KcqL/6l0FgvFt8zHPA/7iZpl2B/UesvSl0w3y+Fq7lFZda+3Jr/nd26I1dbETvEHTA/mhvBzNctjdsQ4bfa8iZOwDnD5GkzANBA+VbOsz8LA6cBzqIteAVQDj+nbU9fhioP8Uh94oMfT6PEZ/imLi3LhavKBPITva/wGDIN++8yvvC4ZXlffAbuHeIrFVN+BIfbnoGFh4DTlwTZoRj89wLgMr+vJnoaf+56B5o9qrduHNvC/MWjF3sWakQ7dq7yN3qXYsIdcjR6ei1csLupNrJmt4aH7nsYv9jc/FzzmV9e7zi0aqC91NcOeoJptazjomSFo9Ja1vanPrUlW/0/sLutc4Oe0xfz7DP9OXeP+pXmV38CqiYiqWFRiLIoiycU9xm9BPoct+F+UURlXVRWXIqnSau3+yyIX6WSUxeM4TBJRrNv/KMvS3dEiTCZFXhVJvG7/aZJGWSayPM2r3SRfrNt/MhaTXEyiaDeJyiQa3+b/N2+7b5UQGQAA","debug_symbols":"vdfbbuIwEAbgd8l1LjyeGXumr7JaVQFCFSkKKMBKK9R3X6fKgWaT0o4QN8hG8zE/jo3wNduVm8vba9XsD6fs5dc1qw/b4lwdmjS7vufZpq3qunp7vX07c90L+o/607FouunpXLTn7AXQE+dZ2ey6MYpLn7Gv6jLNXBr/X++8H8od+bFa40IxqYt9MSmEsTjwQrEQSV8sFOi2+HeeIT4mvepQDqDPS0+PSc8yrr3cWXvgOKSHgPh1emWkvliTm6fnR6cH/yl91yM8oUd8Qg9Z7AGqOCDvAO70YCeuL09DubP1GIb8wujmD08XA6UQcQqE8U6gB54Fct9YIdRPgToGNuZtbPHnxgeF4ZyksZ9OFeOHIpNikwomFVcUhkkJzxQvPjIfEWFQ8fbg9ApMypsUmhStKTcqcjJXbFLBpKJJiUmpRQVnUmBSK3uDwE+Kaa7QpMik2KS+szd4firD2t5w/islJqUWFZ1JgUmtPGUn4+9hBD/fUZFMik0qmFQ0KTEptShxJgVrCicV/Fx5k6Kf76j3NPtTtFWxqcv+brW/NNubq9b577Gc3bqO7WFb7i5t2d2/pqsXdCskIVdIYaD74ip5+qeRmqRG/wA=","names":["_compute_borrow_rate"],"brillig_names":["_compute_borrow_rate"]},{"name":"repay_public","hash":"13426359815358562979","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1bS28jRRDuscd2bMexsyAeEicOcAHJz8SRkFi0YXlJIO0eOTn2WKwUdlfZ7PI4jcSNG+KIhDjsgdPyA/bEDSHxn0hvpuLPn2s6nmTaSVZpKZpxqvurR1dX1dTYgTke4dFfAPd2lMzikDk3k2v7fKOTI1bbp5zBFZGzcEXkLF4ROUNPcs4dLiu03ThrlNCkD1Huv+SmmnwuAD1Hw3aqxDdP/GG7P64q+uUof6+aYJb94A8Ev+IHvy24n8QzfNRF6EWax2usrzWS+8AszhFaAWifEq0ItM+Ihj77OdHQz79IaGtHf5tmdv9acl8lGX34G+qZ9369oshfAN3suBXP7CF8e+2tfj/a7kadXmfU7u7sDQft/mBva9gZdgbDwaQ77PWiYX+4vbO3s93e6fR7UWc62OlNE76CvRv70UvwPwZ8Y/KPM7f9yN+pm2M/ezcRfP3or5Vgj558+9XD8YNJ9NFkchA9eoTng8+ba2TBrGTAfIMxv3y8v39vei86+Pj7e48OF7DXFGy5LxhdN5YL5+EoEY+3kqv9/D7Ytsky343uT6KDy2RaCQWY4vI+Mhaz7ge/J2GmBjoVFZ2Ev4TjNbKXdhUspgmvmll0tTyPq0s3lF/ctEXz2QZpWLWMWFWF5mNPqw69kX9T0XWN9Nawqg6911avd0fw1z3bta7YAnUS/g3FTlnPivCqGa9xpuPSzbXPGJfQBmlY9YxYlzX+abJqepRXo8dY5Fo3i0NoDfjfbjxP2wC51mhdE9bdpnUtWMePeTiK9BltYfm1gxkuz2M9MN83iIY+KDpp8Y19NWt8c8V1T3t8Et8afvBPzsK6You6w+bniW/Ca1XxTdPNtc+YS9AGaVjrGbEuMmehrTlnabJqelRWo8dEi2GGZMYYViZaE2g1orUAi+PbJqzLGt/EFlnjGz57bBANfVB0kviGcZF9tUyy8v9cubicsk6wDX0OFF4VhZfYohgvyi22DoGWZzywe/I17AnHgVI8T8P6oJzQtFwgtmmaxb3kZ4nKknZqKesrS2AFCpZmc8xfdoRA821ztCvbHGMW2xz9U3Rrkt68N2m+qdmplbJe7MTrbprz2Wg43okG/e1uQDqhnMueIayd7QiBlvd+/prhDC27nwHdu2pztIV25lb0HNF1+Rf6kPBfN7O9O+lF3Rrt7xsa/PIU+778OTD6+yCTXNm4lRQe2hCDFcy8knZYZV5N7me9usfj8VFj7daDhz9oScKYxeShDYv9OmPfiQ4fH9yfjA5Hd+/9GDFMIQW+qMCfVsNiHjdmOf9DH5O1nmv3ruusYE0m/E8xq9017vJiVzfNrXlNmsdwZ3g3nl9XcODh/WV7JNI8+zI89jQU+V2PPagPh2YNq5ERSyt1mQ++lXSlwJKZjypPk6stxX5L7rXSgMsxLXS7SgNej/dZUxaGrMucshbeyNyJnkQHh4bGaaEDzeU66lrosNv6FOYhXmh0V9mNj6/sKn8mV98vdG8ALuud5a2UFl60obkVd/S1ChP/5+ro48toPsY+Ol4X8aZEqyK1LzgEKVfBYprwqhmvPtdx6ebaZ9dTZtYuqYbl+Y1pj9OHpjfybzhkbaXIugI9RtoTsiGZ8YlqN56nYdXHHX1M19zxwi6aVknL0DpeYousHS88J64SQXTS4hv7atb4husLS2AVFSztaRz93o4QaL67K/iWuxTP0/Dc8tM4+jR3tHCvOKegTVx20nJKcQksbf80mwvuRdgcu6psc4xJbHP0P/kinObn3H3N6ue4nvN4aPzYSfA9fdPDGfNRJ46D58njwmtVedyVz4xxxzO0QRpWJSOW59rvZE9Dh97Iv+GQVdOjtBo9hlosNiSzVl9ob7T5rRbmf87jmP+z5nGxRdY8jn7G9VUJaPzNI5QP550lvuF6jm+47mZybZ9xdPvT4dZoJ3Llq1CRU8tX6It2hEDz3bHPI19xvVRSbKG9bWyaRb9Z0bl0vmlBHxL+3jr2eJDQkQpm0biun1TxECytifISdOxDmouiuuoAYxb9T/sxhOeapes6K+jzwv8MHXv2JHTrMtB4zSo69hdRCuI28/fbA5rPNC73fJXKgVksF1wurD1K8SOChrWWEUt7VGc+ReDhevzjNuzbyY3FezO51zr2XMYGil6BQy9ej/faMXSFDK1k8fw7MWfHXjvb5+jYc+hAc52lYy9bzCpgxx5dZTc+vrKrvJPcXGTHvm78Vmrbw7YU3SdVYsno2TAEOs5/LwHApwe5nue3qNPtUWfaG01Hg9Fk0h+P2E6G7JQ3/72oE/Wm02kvGvWnW9NT+ePPtbSKN0i5vrClA1vrpsg87SeS5+Wj+aEWijjEZX16ChU+/ARnx258fLX6fxDoPEtGD09FoOP8XUgDHwbpOro6kml7oOlTUGSqK3LdTkCsL/1L8eeydLRcqV7rerjeEGrfo2KbM1+k+f4dkQtr2e/IXWSHOM/vPGpxqEo0PAP8fUbX068d3FXSuisYA6TcqMSAG8/W2FGP53niHGPm45sda0CrL4FVd2BVHVi1JbFcvFHWkPDXk8/lFPwqzW8kn0OYX1HkKRH+FOLod8H8HMH8Bubsg3++mBvPePDebSBNmY9+yfNFV8vzCcRRO5rAJ+84miY3+oLw12yQNXcLrxph5R1b8twTF9bGklhiT9xfe//Tava6yzoUjH7OhP9JnPQjz4nvNWO3TYV/Hr4nvFble5puLt/D+ex7GlZzSSyxp+ZvDT826HFcNyk2QP74GeM65j9ZyzH7l2AeR7MX5jDJReJXLaDViLYJtHWS90a8KC9iNUneGySv5F7N51sK/w3ij7w0/pyXN5X5m8p86ys/k03LylrcX7GprcWua53Z/0LCX1Wt8zvkmb9Sap0/YM7TC6h1nl3XOi91rfMM/Ov5da1jXDa9rnXSsc5S6zy/IrUOzkeMkOZvkPx2YJ7hvKTZEXkuU0vUHPPlM/bftTqqRPP/odoH6w+ufVCHzRR5A7Nc7dNU5mt+ZX3nb8qFWPvIHvno4Y8HW3vj/mDUjjr2Y/e0Hv7/n12/ilxWAAA=","debug_symbols":"1Z3dbts4EIXfxde54PyRw77KogiSNA0MGHHgJAssgr77Sl5LdmLFwtI6gngTSDVnzhdVh0NZw/Zj9evx/v3pdv38e/u6+vHXx2qzfbh7W2+fm7OPPzer+916s1k/3Z7+8Sq0P1j2419f7p7b09e3u93b6gcJq92sHp9/tcfiocnxe715bM5Cc3w+PjB3w4NyPzqngcGaQzoM1kyxHxxtYLCr+mGwa9TTwT9vVqzT0OfcDSfK89HbNPTm/bX3kWtPljp6iiKX6bOJHgbnJu4rfZyanvgTfauRZtDwIY1kEg4xydT7GJMBAQveDW4OfeSeMOrgvRH5elXzMI1xT5P4Ms2Ed6iEQRr12NNwvkxz+dcVQgswWkDQAooWMLRARAsktICjBTJYQNFOVrSTFe1kRTtZ0U7W653Mkbq1EMeTmt8s6/YKEa6Q4AoOV8hoBQtwBYIrMFxB4AoKV4B72uCeNrinDe5pu97TUbqldrTjo1eObfoYsOkJm56x6QWbXrHpDZs+YtMnbHrHpse6NmFdm7CuTVjXJnj1TfDqm+DVN8Grb4JX3wSvvgm+onb4itrhK2qHr6gd7mmHe9rhnna4px1blR1blR1blTO2KmdsVc7Yqpyxa+mMXUtn7Fo6Y9fSGevajHVtxrq2eXcHzn+9b8lD90aUnPxMgcG/gYDzKzi/gfNHcP4Ezu/g/GAHE9jBROD8YP8S2L8E9i+B/Utg/xLYvwT2L437N9tIBQs5dqObYz92fNi+G4Y4zKBBM2jw9RoNaN8tRax2qnE+XILSYbQE+9R3sweSpQHp0oBsaUBxaUBpaUC+NKC8MCAJ8wPlbrRwGun/a56KUujnURY946fK+blyfqmcXyvnn78oSezWgCInDd3f8CeRnj/ZOf/8NUz71mlRTWP8Ho7rOD9raSOZv+Qp0ZHfx/hz35HXHJuf8Xvl/Llufg2V81Pl/Fw5v1TOr5XzW+X8sXL+yuuvVl5/tfL6a5XXX6u8/lrl9deWNP/vgZY0oe+BljRD74Hmn3KNu/fyYqOPnM0zzXE/sLKc8ee6+WOonJ8q5+fK+XUCfnE9agQ+5d9r2AwacQaNNIPG8HwapesQTdFGXitP+G8C0Dd7KiKnHieO4JwOTvTp+rQK32yrmFKB4Ap8tcJIDzB9s8FiUgnFSxheIuIlEl7C8RIZLuEBL0F4Cby7He9ux7vb8e726919sevKEzi/g/NnbP4cwPkJnJ/B+QWcX8H5DZwf7N8M9m8G+zdj/cshgPMTOD+D8ws4v4LzGzh/BOdP4PwOzg/2L4H9S2D/Eti/BPYvgf1LYP8S2L8E9i+B/Utg/zL8iZiZ8BKMlxC8hOIlDC8R8RIJL+F4Cfj3XSx4dwve3YJ3t+DdLeBKLeBKLeBKLeBKLeBKLeBKreCVtoJX2gpeaSt4pa1g/+qof7+86Bt4mRu1384Q43E3gx4UIlwhwRX8eoUpt9ix5oUBWVgaEC0NiJcGJEsD0qUB2dKA4vxAE+4sZEuV83vl/Llu/hgq55+/KE25s5bj/DVsyp21HOcveVPuDOColfNb5fyxcv5UOb9Xzp/r5k+hcn6qnJ8r56+8/o73hi+cv/L6myqvv6ny+psqr7++pPl/D7SkCX0PtKQZeg80/5Q75c5CdqucP1bOnyrn97r58xSPDJd3i3KmGTR4Bg2Ba8hwazSp9lFqx7/z5huP/6JiUVQqivKiqFwSNdxIPBo1eL/RsRWHIh+/O9VDEJcESUlQLAkavn4X34vLcB/nWJAW4A23EI4FlVyI4Ta/sSAvCcoFQRJKgkpuWCm5YaXkhpWSO0Ks4N6TWBKUSoK8JKjEhFpiQqWSIC4JkpIg/b9Bf5qzv+9267v7zeNrE9N++P788LbePh9O3/556T653603m/XT7ctu+/D46333eLvZPrSfrUL7oxUXTTdN+Wxg2vtMg9w0leBn+z+KNKec7UZCaE/b6yiBmlNpGBqOfwE=","names":["repay_public"],"brillig_names":["repay_public"]},{"name":"_repay","hash":"8235755062852530322","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5235018679007078561":{"error_kind":"string","string":"Invalid asset or market id"},"6787403583199288031":{"error_kind":"string","string":"Insufficient balance"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13135008234568508716":{"error_kind":"string","string":"Function _repay can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Z3bblw30oXfRde+4KF4yqsMfgQ5eAIDhh04yQ8Mgrz7tFreu7fd1aLF4sisrnVj2BZLe/ETm1yL3SL/fvj17c9//fbjuw///vjHww//+vvh/cdffvrz3ccPp3/9/c+bh58/vXv//t1vPx7/+8E9/hHquf0fv//04fGff/z506c/H34opYY3D28//PrwQ/U+nL7Dv9+9f/vwg3fun/978xDaQFF0I0V+pCiMFMWRIhopSiNFeaSojBSxI8LHQOlzlY+xui/K3ly3d2F7iHd0eUgrTGNqrnxuTM3nvXFOTONKVDf5lOnY+FF9m6O+ta259+3V1JOboz7VnX3tsPepbOp9jvF59S1F+ty4neq+Vu9nq/fhC/WPzwiv8Ax2KjiNgxa3ouC87zwjueo+Nz/9tXaGRfKb/pqi+xosO808iigXQbF0BM0cp+kbCMX29dRCeaysjJXxS1vzW1VpB2YpsuMkx8s8cHlx+NTYl1L+3Di4y5iKwTNtS9sHbGnt0jpUYlrHtE2mdPjBBce1Db75TUZwrdM6hW2iOw67x7aPBBsIyggmB4JCgh4EhQQDCAoJRhAUEiQQFBJMICgkmEFQSLCAoJAgMomUIDLJNxBsW9LPPn1NMCOTSAkik0gJIpNICSKTSAkSCAoJIpNICSKTSAkik0gJIpNICSKTCAkWZBIpQWQSKUFkkq8JPlJBzuCoEKgwVJAHOCrw+BwV+HaOCrw4RwX+mqFS4Zk5KvDBHBV4W44KvC1HhWxSCXV72znEg46NilFv26Fi1Nt2qBj1th0qRr1th4pRb/s8lWbU23aoGPW2HSpGvW2HilFv26FCoMJQgbflqMDbclTgbTkq8LYcFXhbhop3MLcsFrhbFgvsLYsF/pbFQsDCYTHqcIvfZZSvfpfqZa3PEI0a4hdB9Dlvx774XOo1RKP+eS5Eo3Z7LkSj7nwqRG/Uy78MYil7D0u7Xp29Uec/F6LRnDAXotFUMRciAaIcIhLLBIhILBMgIrFMgIjEMgEiEoscYkBimQARiWUCRCSWCRCRWCZAJECUQ0RimQARieUbIDa3X8/QAgMRiWUCxAmJxdf9moVAqQMxpbZfmNDSobXjvnfeb+goBzCP3/ksvikWH51m8V6z+L4jTf4OJ455x7P6GIFQipCAUIowAaEUYQZCKcIChFKEFQilCBsQChGSA0IpQg+EUoRIJ2KESCfCUzI9IZ2IESKdiBEinYgRIp2IESKdiBEinUgRJqQTMUKkEzFCpBMxQqQTMUICQilCpBMxQqQT5mBZn5A4WCxIESwWJAMOyzdc32oSCxw8iwWunMUCp81iIWDhsMARs1jgclkscLksFqMut3MyWTbqcjtYilGX28Ni1OX2sBh1uT0sRl1uDwsBC4fFqMvtYTHqcntYjLrcHha4XBYLXC6HpcLlsljgclkscLksFrhcFgsBC4cFLpfFApfLYoHLZbEYdblTr1OoRj3x1PPXm1EHPReiUb89F6JRdz4XolEvP/UMuW+45BQQuxCN5oS5EI2mirkQjWaQuRCRWCZARGIRQwwOiWUCRCSWCRCRWCZARGKZAJEAUQ4RiWUCRCSWCRCRWCZARGKZABGJRXwTQPBILBMgTkgso+fi5xro0po9F7/k7Zd3ymFb3uf6JD5oFh81iyfN4m840ra9Yqs7/KLYDfH7y9v74r54BCOnxk18qQcuOXGN6XIXRHLu2PgsPmsWXzSLr5rFN8Xib90NqUO81yw+aBYfNYsnzeI1r7BB8wobNK+wQfMKGzSvsFHzChs1r7BR8wobNa+wUfMKGzWvsFHzChs1r7BR8wpLa0+VKeRdfChX4td+wWa/75hlfy3+9V+w4SI+5+fF+9MG+2WTu8XDwbftacePinL9Vbn+plt/csr1e+X6g3L9Ubl+Uq4/KdevfP1NytfftPT6S6VtzpNqrNfql159e+rz0mtvV/3SK29X/dLrblf90qtuV/3Sa25XvfIVNytfcbPyFTcrT7xZeeItyhNvUZ54i/LEW5Qn3qI88Zal19+eeyhLr75d9UuvvV31qrNuUZ11q+qsW1Vn3ap8xa3KV9yqfMWtyhNvVZ54q/LEW5Un3qo88TblibcpT7xN9V5zU73X3FTvNTfVWbepzrpNddZtqrNu073iRqd7xY1O94obne7EG53uxBvd0qvuN+jXnXij0514o9OdeKPTnXij07zXHL3mveboNe81R68560avOetGrznrRq8560avfMX1yldcr3zF9coTb1CeeIPyxBuUJ96gPPF+h0Nt5upXvfoGzTvNMWjeaY5B805zDKqTblSddKPqpMsfb1NdqLv6TEf156I4UkQjReyEXr3fi/yhUyxcaq5sBJrv4KpE+3emg5yncxYifzBK9S7vcg5nCd/4WQdf9h/28WDVVJjmp03o7eCH035uvhJUVhNUVxPUFhNEbjVBfjVBYTVBcTVBtJqgtJqg1WZqWm2mptVmalptpk6rzdRptZk6rTZTp9Vm6rTaTJ2+w0zdttanTYLeHo87BaDte7sQryx4ysr1F+X6q3L9Tbf+/PqLUsxbJj7Fu9DTX+J+ZY8r6Vr/669htB+0eDLOpae/7kpOf4/uSv/rL3m0n/140l97+pvf95JcS/VKf1Sun5TrT8r1Z+X6i3L9Vbn+plt/ccr1e+X6la+/Rfn6W5Svv0X5+luUr79F+fpbV5r/z4JWmtDPglaaoc+CXn/KTYE2QakbOX1s+02bnkK80k/K9Sfl+rNy/UW5/hmR4fQqujzjcD30Sf/jM5p7hWf4V3hGeIVn8PNpSPsnnkLtfChH5cXevm2rTAiHj3TxrdP+UdX01SXgZ4QEhFKECQilCDMQShEWIJQirEAoRdiAUIaQ+MNOgPAlCD0QShEGIJQiRDoRIyQg7CPcP9WTfbpGiHQiRoh0IkaIdCJGiHQiRoh0IkXokU7ECJFOxAiRTsQIkU7ECAkIpQiRTsQIkU7ECJFOvkZ4xoLEwWJBiuCwBCQDFgvcPosFDp7FAlfOYiFg4bDAPbNY4IhZLHC5LBa4XBaLUZcb6vaGdIgHHRuWaNTl9rAYdbk9LEZdbg+LUZfbw0LAwmEx6nJ7WIy63B4Woy63h8Woy+1hgcvlsBBcLosFLpfFApfLYoHLZbEQsHBY4HJZLHC5LBa4XBYLXC6LBS6Xw5KMutzidxnlq1+6elnrM0SjnvhFEH3O+1nKudRriEYd9FyIRv32XIgEiHKIRr38yyCWsvewNGZ1Nur850I0mhPmQjSaKuZCNJpBpkLMSCwTICKxTICIxDIBIhLLBIgEiHKISCwTICKxTICIxDIBIhLLBIhILHKIBYllAkQklm+A2Nz2bp9vgYGIxDIB4oTE4ut+ycLx/gYeYkpt22pPLR1aO+5757apLwcwj9/5LJ40i0+axWfN4ruO9PjhApzjynxIoFQglCJsQChEWB0QShF6IJQiDEAoRRiBUIqQgFCKMAGhFGEGQilCpBMxQqQT6QmaFelEirAhnYgRIp2IESKdiBEinYgREhBKESKdiBEinYgRIp2IESKdiBEinQgRJod0IkaIdMIcNJscEgeLBSmCxULAwmGB22exwMGzWODKWSxw2iwWuGcOi4cjZrHA5bJY4HJZLEZd7vMnk6X+zaI2sRh1uT0sRl1uD4tRl9vDYtTl9rAYdbkdLMGoy+1hMepye1iMutweFrhcFgsBC4cFLpfFApfLYoHLZbHA5bJY4HI5LBEul8UCl8tigctlsRh1uTOvU0j9O0ABsXf+eopGHfRciEb99lyIRt35XIhGvfzMM+RSNOr8p0IkozlhLkSjqWIuRKMZZC5EJJYJEAkQ5RCRWCZARGKZABGJZQJEJJYJEJFY5BATEssEiEgsEyAisUyAiMQyASIBovQmgJSQWCZAnJBYvte5+CkVzeKrZvFNsfj+HaYxuKP4c5EfKQojRXGkiEaK0khRHikqI0V1pKgNFJWREVFGRkQZGRFlZESUkRFx446XWLZjZSodlskbr+t95fO+XJ7gc+XWydNEsb1Ua/J765y4xnk/RbfkXJ9vfNLRLot7CvnY/NzXvHZfvd/76suV+KJZfNUsvikWf+MCEiXivWbxQbP4+Oriw0V8vpq6b9wd8f30pMX05MX0lMX01MX0tLX03DgJnhLteh73Me5ua2XelQ7pxknwQPgChAEIpQgjEEoREhBKESYglCLMQChFWIBQirACoRRhA0IZwuyQTsQIkU6Eh+lnh3QiRoh0IkZIQChFiHQiRoh0IkaIdCJGiHQiRoh0IkXokU7ECJFOxAiRTsQIkU7ECAkIr++cyB6Jg8WCFMFiQTJgscDts1jg4DksAa6cxQKnzWKBe2axwBGzWAhYOCxwuSwWoy73+bObczDqcntYjLrcHhajLreDJRp1uT0sRl1uD4tRl9vDYtTl9rAQsHBYjLrcHha4XBYLXC6LBS6XxQKXy2EhuFwWC1wuiwUul8UCl8tiIWDhsMDlsljgclksRl3uzHv4Mhn1xDMv7spk1EFPhZiM+u25EI2687kQjXr5mYeP52TU+c+FSIAoh2g0VcyFaDSDzIWIxDIBIhLLBIhILHKIGYllAkQklgkQkVgmQERimQCRAFEOEYllAkQklgkQkVgmQERiEV8hlzMSixximZBYvteFarl4zeKDZvFRs3jqim/1DieOiee4lgSEUoQZCKUICxBKEVYglCJsQChEWB0QShF6IJQiDEAoRRiBUIqQgFCKEOlEeoJmRToRI0Q6ESNEOhEjRDqRImxIJ2KESCdihEgnYoRIJ2KEBIRShEgnYoRIJ2KESCdihEgn3EGzDYmDwVIcUgSLBcmAxQK3z2KBg2exELBwWOC0WSxwzywWOGIWC1wuiwUul8Pijbrc508mK96oy+1hMepye1iMutweFgIWDotRl9vDYtTl9rAYdbk9LEZdbg+LUZfbwRLgclkscLksFrhcFgtcLouFgIXDApfLYoHLZbHA5bJY4HJZLHC5HJZo1OXOvE6hRKOeeOb56yUaddBzIRr123MhEiDKIRr18jPPkCvRqPOfC9FoTpgL0WiqmAvRaAaZCpGQWCZARGKZABGJZQJEJJYJEAkQ5RCRWCZARGKZABGJZQJEJJYJEJFY5BATEssEiEgs4psASkJimQBxQmIZPRc/10CX1uy5+CVvv7xTDtvyPtcn8aRZfNIsPmsWzzvStBfVVLvi95e398V98QhGTo2b+FKT31vnxGrfjwotOdfnG590tMsMlkI+Nj/3ta7dVwqXvpYr8c3OD+rGTZz/y76GS19z7sg/rWGXdaTFw9ky7elFdeMSTD36g3L9Ubl+Uq4/KdeflesvK+un0jbTTjXWa/VVtfqmWX1ZeuXtql963e2qX3rV7apfes3tqudX3Bx29Zm+UH8uSiNFeaSojBTVkaI2UHTjBqC8/4BqLvmqiH+x5rbH5hKvnxRGiuJIEY0U8SOi+p1eTXRVlEeKykhRHSniR8RlV/dU7zovbHLbEzyF0nlh1+g3e1NjaB0zdLlMxCc67ETG83WR5cbx7/9D9aGGXb2j59VXV7cZr/rY830+u7DPj5ni17H5xjntze1Dth2KcPkM8wsfN85pB8IXIIxAKEVIQChFmIBQijADoRRhAUIpwgqEUoQNCGUI643z34HwBQiRTsQIkU6E135Uh3QiRkhAKEWIdCJGiHQiRoh0IkaIdCJGiHQiReiRTsQIkU7ECJFOxAiRTsQICQilCJFOmNtxqkfiYLEgRbBYkAxYLHD7HJYAB89igStnscBps1jgnlksBCwcFrhcFgtcLovFqMt9/pT5Goy63B4Woy63gyUadbk9LEZdbg+LUZfbw2LU5fawELBwWIy63B4Woy63hwUul8UCl8tigcvlsBBcLosFLpfFApfLYoHLZbEQsHBY4HJZLHC5LBa4XBaLUZc788bQSkY98cwrBmsy6qDnQjTqt+dCNOrO50I06uVnXpNQk1HnPxei0ZwwF6LRVDEXotEMMhciEssEiEgscogZiWUCRCSWCRCRWCZARGKZAJEAUQ4RiWUCRCSWCRCRWCZARGKZABGJRXzZZS1ILBMgTkgso1c/ppYOrdmrH3PbL+U7gHn8zmfxQbP4qFk8aRbfd6SpHMWfi/JIURkpqiNFbaCoupEiP1IURoriSBGNFI2MiDoyIurIiKgjI6KOjAj+spnmwrY+NZfu5I7Wyl82s05f9zuNTn8tV+KDZvFRs3jSLD5pFp81iy+axddXF3/zasSznraUnubcYnr8YnrCYnriYnpoMT38MuHdltiaP8woT96x8eeZ94rKSFEdKboxZxS3F7nSYfzdboFs3r22+u92C2Tjj+E9baPtz3CH821efak8RYmtcQrlSnxcWnxO5ZKgrsXT2uIpPCc+rS1+YnZt/Emu6/T1OTfZ+PNWtYivmsU3xeL5E0a1iPeaxa+9IHfEL74gPy9+8QX5WfH8MRL+kmpOb79end3e+FMWulXsED29p7v/Xo+nel0Vh6poqCoNVWW+Kl8cdGVosPO8j/uh+ae/Xj+L/6XFbpUfqgpDVXGoioaq0lAV//NKe9w+pbtyXVWGqupQVRup4j8e3q3yQ1VhqIofGylfcnVt11U0VJWGqvJQVRmqqkNVbaSquKGqGzPA5fMqMVy/vkocqqKhqjRUlYeqylBVHapqI1XVDVX5oaqhsVGHxka9MTaI9qp0PdvUNFSVh6rKUFUdqmojVc0NVQ05hzbkHNqQc2gjzsE7/u2gctm9oswU8e9J7Oa9Je5JNFKURorySFEZKaojRW2gyI8ElFOZHysLY2VxrIzGytJYWR4rK2NldaysDZWFsVESxkZJGBslNzYKnp9ywo1Pg2yzWwtc0chEENrAk6IbKfIjRWGkaGTCjiMTdhyZsPkDgtu+cXCyt0xRGSmqI0W9CZsr4neUOiD4DaVeURgpGhkRNDIiaGRE0Mgrl0aWcBpZwmlkCU8jI+LGxslpC3ObY/PhBf/5LfhTWRsqu7F1ciyLxJT5sbIwVnZjbbz7e0T3d2XT9Vl43t3Y2jCPxQMLhyUAC4clAguHhYCFw5KAhcOSgYXDUoCFw1KBhcMCl8thqVZd7r6Pnz2z21CtutwOFqsut4PFqsvtYCFg4bBYdbkdLFZdbgeLVZfbwWLV5XawWHW5z2NpcLksFrhcFgtcLovFhMt96irZ6aoJN/rUVRMO86mrJlzjU1dNOMGnrppwd49d9c6EY3vqqgkX9tRVE87qqatm3JJ3ZKer9+OWnr9Q9dTV+3FL3a7ej1vqdvV+3FK3q/fjlnpd9ffjlrpdvR+31O3q/bilblfvxy11u0p2umrHLXk7bsnbcUvejlvydtxSsOOWgh23FOy4pWDHLQU7bincj1t60T1Vz7V+AnM/3uplF3jlvB97lUtlwNyPE5sM5n5822Qw9+Py5oKJ9+MJZ15Xeer0/TjIyWDux29OBnM/7nQyGAIYHoxR59sHY9X5dsFYdb5dMFadbxeMVefbA0NwvjfAwPneAAPnewMMnO8NMAQwPBg43xtgrDrfdjmyvAUOjFXn2wXDO19ft5shT+8lpS/APJW1obIbF6Y8U3bdpZTatimZa6BLa8dd5lPyfuHOYQPz8SqfJ0FxrB80VlbGysZ+RjfOw+yWjfXtxg0f3bKxvpWxvt04b7BbNta3GyeQdcvGXlvVjZWNkaxjJOvY663SYvNGTasJyosJamE1QXE1QYsN6uAWW52D86sJWmxQB1dXE9QWE+RXG9R+sZk6+LKaoNUGdVhtpg6L2Y8QVhvUcbWZOi5mP0JcbVDTajM1rWY/aLVBTavN1LSa/Vhqx+uf0z///6dP7376+f3bP04lj1/968Mvf777+OHzP//8z+/bV37+9O79+3e//fj7p4+/vP31r09vf3z/8ZfHrz24z3/8y4fi3vjQ/GNXH/+jhfKmxXCON+ev53L6em6nJ5+e/l8=","names":["_repay"],"brillig_names":["_repay"]},{"name":"add_asset","hash":"232909029596298996","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"oracle","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"loan_to_value","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"is_borrowable","type":{"kind":"boolean"},"visibility":"private"},{"name":"optimal_utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"under_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"over_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"deposit_cap","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["add_asset"],"brillig_names":["add_asset"]},{"name":"get_accumulators","hash":"932076035363254349","is_unconstrained":true,"custom_attributes":["utility","view"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]},{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"7f3druw8dqUJ34uPfSD+k30rjQ+F+nEXDBh2wVX1AY2C771jv7GkiJ1LIa7NZMScJJ8Te2emFEE+Yy5pjkEF9X/+4b/903/53//9P/3zv/4///Y//+H/+r//zz/8y7/91//8v/753/719p/+z3/84z/8l3//53/5l3/+7//p+b/+h+3X/zEu/HXC//wf//lff/3n//m//vO//69/+L/M5o37x3/4p3/9b3/9O9nbh/w///wv//TrP23/8Y/fjk85fh2dN38cG9PJocGGr0ND2B4f6+1//P/+8Tac2GM42aV9OKFcD8e78nWoj/n7cFKX4WS/D6fk6+HEbacTbfw+nNxjOMXar6OLC5Xh5O3r0LSdiFVOh+PytuO/HRJjZTi2bObrcLf9dvT9W/z2kW8xH/kW+5FvcR/5Fv+Rbwkf+Zb4kW9JH/mW/JFv+cjffvjI3374yN9++MjffvjI3374yN9++MjffvjI3374yN9++MjffvjI3378yN9+/MjffvzI3378yN9+/MjffvzI3378yN9+/MjffvzI3378yN9++sjffvrI3376yN9++sjffvrI3376yN9++sjffvrI3376yN9++sjffv7I337+yN9+/sjffv7I337+yN9+/sjffv7I337+yN9+/sjffv7I3375yN9++cjffvnI3375yN9++cjffvnI3375yN9++cjffvnI3375xN++3baPfEuXv323hXh8S0lPR4f7t9iPfIv7yLf4j3xL+Mi3xI98S5e/fXdby9u/xdry27d8P/oWY+5jumVaz0uA5WzVM+8LhsE9jSN8/Y1kgfHnY+Xz1pvnyvhDTMcqcszuODrE+wTK4BMw2+gTMKNPwI4+ATf6BPzoEwijTyCOPoE0+gRGvxMb/Xfi5PfGKaTgnydw4i7C8aSVDclcH5zDPoycnmboT22LOR5Zu103Hh/s7dnB+WFxfjv0F3Grv3WYjbj+Xmc24vqbs9mI6+8mZyPuIf5h4vr79dmI6zcYsxHX74hmI67fws1GHM/5YeIOz/lp4njOTxPHc36aOJ7z08Q9xD9MHM/5aeJ4zk8Tx3N+mjie89PE8ZwfJu7xnJ8mjuf8NHE856eJ4zk/TdxD/MPE8ZyfJo7n/DTxETyneRDP1xBNPn5xYop1lY82vuyb2pnwtB3c1zOZfgR3KMVmBB8nxCaM4Lik2IzgjaTY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FRHNTi+6cnJSrHzT2d/T+cZIlT/C8+2Iaie1/Lmfb/5ibNgnZWw8QZF922mh7bTYdlpqOy23nVaaTjv/kXn9NNN2mm077UWV5HSc9vRg5+M0Xz/tpM0voe202HZaajvtvEpu9m0/zZ1deM4fX66dFrat7TTTdpptO821nebbTgttp73QLR5yu/T9LhPOl/fMo8czwduT014gKcffm9/CyWm+flo5OS20nRbbTktNp9mt7bRzks9BjDMnp/m2085J+rgdp8V4clp+cdpjbun7TTi4F3M7HoW/BUEnNel822mh7bTzKrld5I+/gO1sbqnttNx2Wmk67Tz2uf11H7rdKuLkNNN2mm0bpGs7zbedFtpOi03XyfMko35abjutNJ0WbNOVK7RduULblSuEltPi+T0g2H1q4eSdcPH8DlA7KbecVBpOOr/T1E4yLSfZlpNcy0m+5aTQclJLRdjziih7cxWfllYeJ+WWk0rDSW5rOcm0nGRbTnItJ/mWk0LLSbHlpJaKcC0V4Voq4sX96rEId1tbPDsttZ12fr+6OZX9tOclv8dppem08+C7fpppO+387mjigcTkEyThlWd5+LFy9m2x7bTUdlpuO600nRa3ttNM22nnut182qMZSienubbTfNtpoe202HZaajstt532oht9mMaQy/fT0tZ2mmk7zbad5tpO822nhbbTYttprxLA4zRnT/7eUmk6LW9tp5m202zbaa7tNN92Wmg7LbadltpOa6uS3FYlL1YT3LF8a1w4uQS9WE2onmbbTnNtp/m200LbabHttLYGo7Q1GKWpwUjb1nbaqQC1N8enF0F9fGSpt0vpyWmx7bTUdlpuO+1cgJT233+ZVL7vS5LOf/9VP820nWbbTnNtp/m200LbabHttNR2Wm47ra1KbFuV2LYqsW1VYtuqxLZVyYt1mfK4LRZ7dlpsOu08hrDZ7M812RwfF7zzR4WzO5LX7J7WjM6Prj2hm85DDtEhnS+eyA7J6BuS1Tckp29IXt+Qgr4hRX1DSvqGpO/q7Xtcve3xjGf2JtWO/sPd14735/hb2/h9AmEbfQJm9AnY0SfgRp+AH30CYfQJxNEnkEafQB59AqPfiePod+I4+p04jn4njqPfiePod+Ko/j5wvRtzStqvQjVHlj5/FdKyebopj40atu/r2ylZ0LxC40DzCo0HzSs0ATSv0ETQvEKTQPMKTQbNKzQFNC/Q5A00r9DQDb9EQzf8Eg3d8Es0HjSv0NANv0RDN/wSDd3wSzR0wy/R0A2/QlPohl+ioRt+iYZu+CUauuGXaPyyaKx7oPEnj5qXdbvhKpp1u+EqmnX7mgqavK17h6r8IC9v696hqmjWvUNV0ax7h6qiWfcOVUWzbl5TRbNuXlNFs25fU0Nj1s1rqmjWzWuqaE67YbcdP4B229OeXueTNSaa49fZJtoaHGuP3dBu3fpj6y93+/d9UK7HoMJj31oTn16dMXZWks+3UQDOHU4Azms4ETiv4STgvIaTgfMaTgHOSzjnW9UA5w7HAOc1HAuc13DokC/geOC8hkOHfAGHDvkCDh3yBRw65As4dMiv4Tg65As4dMgXcOiQL+DQIV/A8cB5DWflDtnmfZbWbSdPT7mVO+QqnJU75CqclTvkKpyVO+QaHL9yh1yFs3KHXIWzcodchbNyh1yF44HzGg4d8gUcOuQLOHTIF3DokC/g0CG/hhPokC/g0CFfwKFDvoBDh3wBxwPnNRw65As4dMgXcOiQL+DQIV/AoUN+DSfSIV/AoUO+gEOHfAGHDvkCjgfOazgrd8i1X+XGlTvkKpyVO+QqnJU75CqclTvkGpy0codchbNyh1yFs3KHXIWzcodcheOB8xrOupuHueP1iNYZc4Jm3c3DqmjW3TysimbhTVErbnzhVx9V0ay7eVgVzbpb6VbRrLuVbhWNB80rNAtv9l5Ds/Bm7zU063bDVTTrdsNVNHTDr9AIvMTmz15en8qO5vbPx3T3l9dngVfN/NkE8lEJt3+Wkwl47ROw7piAsycTCKNPII4+gTT6BPLoEyhjT6Bsm/YJbOmYgN1OJmBGn4D2O3F1AurvxLUJqL8T1yag/k5cm4D6O3FtAurvxJUJnO8IlPw+ouTjNxNRzvc7eZiaEvLJSaXhpPP9MWonmZaTbMtJruUk33LSqU5mO143YbYYTk6LbaelttNy22ml6bTzX4bWTzNtp9m201zbab7ttLYqCW1Vcv6Tlcq14/ynHOW4TBV7clJsuQycP8Bd+ybfclJoOSm2nJRaQLRcrmPL5fr8QbsS94oo6aSMzh9Aq51kW06qXa5PT2q5XKfQclJsOamlIlJLRaSWisgtf7m55QaeW27gueUGnv+0Iv7j9h/////53//5P/+Xf/mn/3k75df/+r//9b/+r3/+t3/9+o//6//9H/v/8l/+/Z//5V/++b//p//x7//2X//pv/3vf/+n//Qv//Zff/1v/7B9/Z//O4UU/jGFEm/D+YUqFeP+8dZhmdt/dn/979Hc/vf06z//9e40X+z2j7f/E379F3+dEY39x9v/8bex3cb3/wE=","names":["get_accumulators"],"brillig_names":["get_accumulators"]},{"name":"borrow_private","hash":"11336741756530554013","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"7b3djiu7kp37Lvt6XyR/Mkn6VQzDaNt9jAYa3Ua7fYADo9/9aE5VplSrUmIVZyTJIL+bjZp7MaXgN0LJGJES+X//9j/+8b/9n//5X//pX/6ff/3ff/tP//n//u2f//W//8O//9O//svtX//3b8b//v/+9//6h3/59c///e//8G///rf/ZFcf/v63f/yX/3H7czP2P/7+t//nn/75H//2n8yy/Mffv462ftlH2+0xOpiTwW5J68dgZ7b4frBZk9lH3/62j+E2+rPx2xr34VsIx2i3nL6629w+2pvl0+j/8ve/mRU0r9BsoHmFJnSOZrUPNNuWQWON3fZIjF//EE0EzSs0CTQv0NgFNK/QmFM0PpoHGpdB443xH6O9WR9vsfnf72Avfwd39g7GWX/cwp2LS+Y9buPNMXx9iJDCyeCU0p47t1cz/jmiM8X8+iRZXP86Aa99Auv5BOJyvIl7TuxfE/h12WkNkJzdPw7JxUdkqzvLDJv2xIiPLFrt75cP1758/OOXX83OZ/Xp+eW/Dg3R7J/jEIPN3SPcQy/3FLlJZ3erze+J47ankG+Df00zjTLN4Hcxb4lp/jJNt0yhpjNzqGk7nuYW9tE2WPfXyE8Xs+SXI/J1De8jNyauO5vb3/ER0BpOE8btr+2CMR0bI+dh85LNCpuXbDbYvGQTYPOSTYTNSzYJNq/Y+AU2L9mY3tm0a8Z4C5uXbETq4nTEb5JLGTZhz3rvnvyFd7/D8QLhJP+QKqXtfTgmren4GKbNfOrB/Lxl41ftE9jqTyDY5ZhADO79BG7vf7z20z32ltz/8V9u//pv//ZP//zP//Q//+unZ6nLr/8xL5qyaTmM/fKpmfa7HWVeNFpzV7miq3zRVWvRVVvRVaHoqlh0VSq56rzjlL2qKDdcUW64otxwRbnhinLDFeWGK8oNV5Qbrig3fFFu+KLc8EW54Ytywxflhi/KDV+UG74oN3xRbvii3FiLcmMtyo21KDfWotxYi3JjLcqNtSg31qLcWItyYy3Kja0oN7ai3NiKcmMryo2tKDe2otzYinJjK8qNrSg3tqLcCEW5EYpyIxTlRijKjVCUG6EoN0JRboSi3AhFuRGKciMW5UYsyo1YlBvxNDfccnhEt6TwdNV6v8oXXbUWXbUVXRWKropFV53mhjPL/uWa2/PR9OmqsybQth3NwE/fmjp7Suvj3tNZ3ZOm9y9QmLQIxBOXw2ZHEzPxrFvYR6/b8zc6tntApreAbG8Bud4C8r0FtPYW0NZbQKG3gGJvAaW+ArJLZ3dqu9S/Uwe/L3xrWP1zQCfN6/X4RpBdg3k/OB6N4hieFkl/+jXkW/PqaIqvjxf2Z99LsvFRUn0a+pugheAfEnQQ/EOCHoJ/SHCF4B8S3CD4hwQDBP+QYITgHxJMEPwzgmaB4B8SxJP8KUE8yZ8SxJP8KUEPwT8kiCf5U4J4kj8liCf5U4J4kj8liCf5Q4IWT/KnBPEkf0oQT/KnBPEkf0rQQ/APCeJJ/pQgnuRPCeJJ/pQgnuRPCbbwJOZBML6HYuLxDVaTnvfGOX1p49Px8831ad+dj+8IuWWiuZqJ5monmqubaK5+ormuE811m2iuYaK5xonmOlHd5Ceqm/xEdZOfqG7yE9VNfqK6yU9UN/mJ6iY/Ud3kJ6qb/ER10zpR3bROVDetE9VN60R10zpR3bROVDetE9VN60R10zpR3bROVDdtE9VN20R10zZR3bRNVDdtE9VN20R10zZR3bRNVDdtE9VN20R1U5iobgoT1U1horopTFQ3hYnqpjBR3RQmqpvCRHVTmKhuChPVTXGiuilOVDfFieqmOFHdFCeqm+JEdVOcqG6KE9VNcaK6KY5UN9m07XN1y9MRnK/IBH+QMU+vHc8i2Zb97MfNPv3cMf4+mcKmkUqyhhhHqvYaYhypkGyIcaQatSFGD0YJjCNV1g0xjlS0N8Q4kh9oiHEkq9EQIy5GAKNbcDEiGHExIhhxMSIYR3Ixt9mEA2PKBWJMsMeLm7Q8vbqxV2P3YG+BfSSXpAj7SK5KEfaRXJgi7CO5NkXYR3J5erCbkVyhIuwjuUhF2EdynYqw41KbYPdgb4Edl9oEOy61CfaJXapd1j0SY28zzmC3N5k+hlsTn6DEeDY6LMfoYB/f7dvu2Cd2qS2xT+xSG2K3E7vUltgndqktsU/sUltin9iltsTuwd4C+8QutSX2iV1qS+y41CbYcalNsONSW2Af6kg/RdhndqkuxgO797nGr92OWOy2rY/RyZ3FYuz+4reHGs+jzdloF47IXXKfRv+WaWZXq0immV2wIpk8MmmQaWaXrUimmV25IplmdvGKZJrZ9SuSaeYugR6ZhjrwdmCZ6EKokIkuhAqZ6EKokMkjkwaZ6EKokIkuhAqZ6EKokIkuhAqZ6EJokGmo4+MHlokuhAqZ6EKokIkuhAqZPDJpkIkuhAqZ6EKokIkuhAqZ6EKokIkuhAaZNroQKmSiC6FCJroQKmSiC6FCJo9MGmSiC6FCJroQKmSiC6FCJroQKmSiC6FBpkAXQoVMdCFUyEQXQoVMdCFUyOSRSYNMdCFUyEQXQoVMdCFUyEQXQoVMdCE0yBTpQqiQiS6ECpnoQqiQiS6ECpk8MmmQiS6ECpnoQqiQiS6ECpnoQqiQiS6EBpkSXQgVMtGFUCETXQgVMtGFUCGTRyYNMtGFUCETXQgVMtGFUCETXQgVMtGFUCCTX+hCqJCJLoQKmehCqJCJLoQKmTwyaZCJLoQKmehCqJCJLoQKmehCqJCJLoQGmQxdCBUy0YVQIRNdCBUy0YVQIZNHJg0y0YVQIRNdCBUy0YVQIRNdCBUy0YXQIJOlC6FCJroQKmSiC6FCJroQKmTyyKRBJroQKmSiC6FCJroQKmSiC6FCJroQGmRydCFUyEQXQoVMdCFUyEQXQoVMHpmukcn69UAYczL5dMi0Lkv6KhNdCBUy0YVQIRNdCBUy0YVQIRNdCA0yeboQKmSiC6FCJroQKmSiC6FCJo9MGmSiC6FCJroQKmSiC6FCJroQKmSiC6FBppUuhAqZ6EKokIkuhAqZ6EKokMkjkwaZ6EKokIkuhAqZ6EKokIkuhAqZ6EJokGmjC6FCJroQKmSiC6FCJroQKmTyyKRBJroQKmSiC6FCJroQKmSiC6FCJroQGmQKdCFUyEQXQoVMdCFUyEQXQoVMHpk0yEQXQoVMdCFUyEQXQoVMdCFUyEQXQoNMkS6ECpnoQqiQiS6ECpnoQqiQySOTBpnoQqiQiS6ECpnoQqiQiS6ECpnoQmiQKdGFUCETXQgVMtGFUCETXQgVMnlk0iATXQgVMtGFUCETXQgVMtGFUCETXQgFMt3+P2TSIBNdCBUy0YVQIRNdCBUyeWTSIBNdCBUy0YVQIRNdCBUy0YVQIRNdCA0yGboQKmSiC6FCJroQKmSiC6FCJo9MGmSiC6FCJroQKmSiC6FCJroQKmSiC6FBJksXQoVMdCFUyEQXQoVMdCFUyOSRSYNMdCFUyEQXQoVMdCFUyEQXQoVMdCE0yOToQqiQiS6ECpnoQqiQiS6ECpk8MmmQiS6ECpnoQqiQiS6ECpnoQqiQiS6EBpk8XQgVMtGFUCETXQgVMtGFUCGTRyYNMtGFUCETXQgVMtGFUCETXQgVMtGF0CDTShdChUx0IVTIRBdChUx0IVTI5JFJg0x0IVTIRBdChUx0IVTIRBdChUx0ITTItNGFUCHTzF2IbTGHTOE58FOZbi9pDijPMr0QNS67qMGk3Gi7pH20teHT6N8yzdyFUCTTzF0IRTJ5ZNIg08xdCEUyzdyFUCTTzF0IRTLN3IVQJNPMXQg9MoWZuxCKZKILoUImuhAqZKILoUImj0waZKIL0YVM3rl9tI+5Ryqbtx+Dt+0hqdvOZpkeD2uWpzDOB2/mGL3ZdcmMNsFsO+/b38nlXj0dvLdknnIxngyOt0dLH4Oj3ezz4N95S1uGvNWYt/SpyFuNeUvjjrzVmLd0MslbhXkbae2Stxrzll43easxb2n+k7ca85anIeStxrz15C15qzBveV5G3mrMW56Xkbca85bnZeStxrzleRl5qzFveV5G3irM28TzMvJWY97yvIy81Zi3PC8jbzXmLc/LyFuNeevJW/JWYd7yvIy81Zi3PC8jbzXmLc/LyNvHC9s1HHkbcy9t4nZE/etv/2n87+ziqRbZdV128eyJ7Loqu7aFJ0Rk13XZxXMcsuu67OJpC9l1XXbxTITsui67PNlFdl2WXTxfILuuyy6eApBd12UXvXqy67rsoldPdl2XXfTqya7LssvQqye7rssuevUXZVc4vpty+/Pz6N/gaWM3Ak+HtxF4D/g24OkLNgJPy6wReLpJjcDTaGkEnh5EG/AWe94IPM61EXicayPwONdG4D3g24Cf2Lk6F/YesnF+tRmU5hbM0eo1MTx+mLedgl/sAd7ap7G/sU/sW1tin9i1tsQ+sWf1Szji9saHDPZtefz0d3uMjesd5MQeVBSkm9hTyoKc2CPKgpzY88mCnNjDyYL0gJQBObHHkgU5sWuSBTmxD5IFibMRAomzkQHpcTZCIHE2QiBndjabTwfILfulZuvCTtK69NStj+nHTTc/sw9qiN2DvQX2mT1WQ+wzO7KG2Gf2bw2xz+z2GmKf2Ru2w77O7CQbYp/ZdzbEjkttgh2X2gS7B3sL7LjUJthxqd/G7s2xZYP3yyfsv1HiPMVQ4ibFUOIQpVBuuD4xlDg5MZS4MzGUOC4xlB6UUihxRmIocTtiKHE7YihxO2IocTtSKANuRwwlbkcMJW5HDCVuRwylB6UUStyOGErcjhhK3I4YStyOGErcjhTKiNsRQ4nbEUOJ2xFDidsRQ+lBKYUStyOGErcjhhK3I4YStyOGErcjhTLhdsRQ4nbEUOJ2xFDidsRQelBKocTtiKHE7YihxO2IocTtiKHE7QihDAtuRwwlbkcMJW5HDCVuRwylB6UUStyOGErcjhhK3I4YStyOGErcjhRKg9sRQ4nbEUOJ2xFDidsRQ+lBKYUStyOGErcjhhK3I4YStyOGErcjhdLidsRQ4nbEUOJ2xFDidsRQelBKocTtiKHE7YihxO2IocTtiKHE7UihdLgdMZS4HTGUuB0xlLgdMZQelFIocTtiKHE7YihxO2IocTtiKHE7Uig9bkcMJW5HDCVuRwwlbkcMpQelFErcjhhK3I4YStyOGErcjhhK3I4UynUot+P8gdKFLTd6iztJd2s2PoE0dzRDuRdZNEO5EVk0Q7kLWTQeNK/QDFX9y6IZqpqXRTNUdS6LZqhqWxbNUNWzKJqNavglGqrhl2iohl+ioRp+icaD5hUaquGXaKiGX6KhGn6Jhmr4JRqq4VdoxjqLXRYN1fBLNFTDL9FQDb9E40HzCg3V8Es0VMMv0VANv0RDNfwSDdXwKzRjndUti4Zq+CUaquGXaKiGX6LxoHmFhmr4JRqq4ZdoqIZfoqEafomGavgVmrHOcpZFQzX8Eg3V8Es0VMMv0XjQvEJDNfwSDdXwSzRUwy/RUA2/REM1/AJNHOusX1k0VMMv0VANv0RDNfwSjQfNKzRUwy/RUA2/REM1/BIN1fBLNFTDr9CMdRasLBqq4ZdoqIZfoqEafonGg+YVGqrhl2iohl+ioRp+iYZq+CUaquFXaMY6K1QWDdXwSzRUwy/RUA2/RONB8woN1fBLNFTDL9FQDb9EQzX8Eg3V8Cs0Y50lKYuGavglGqrhl2iohl+i8aB5hYZq+CUaquGXaKiGX6KhGn6Jhmr4FZqxzhqURUM1/BIN1fBLNFTDL9F40LxCQzX8Eg3V8Es0VMMv0VANv0RDNfwKDWfRvUZDNfwSDdXwSzRUwy/ReNC8QkM1/BIN1fBLNFTDL9FQDb9EQzX8Cg1n0b1GQzX8Eg3V8Es0VMMv0XjQvEJDNfwSDdXwSzRUwy/RUA2/REM1/AoNZ9G9RkM1/BIN1fBLNFTDL9F40LxCQzX8Eg3V8Es0VMMv0VANv0RDNfwKDWfRvUZDNfwSDdXwSzRUwy/ReNC8QkM1/BIN1fBLNFTDL9FQDb9EQzX8Cg1n0b1GQzX8Eg3V8Es0VMMv0XjQvEJDNfwSDdXwSzRUwy/RUA2/REM1/AJN4iy612iohl+ioRp+iYZq+CUaD5pXaKiGX6KhGn6Jhmr4JRqq4ZdoqIZfoeEsutdoqIZfoqEafomGavglGg+aV2jmrYa9W+zHaO/W7ROak0h82JGY1TxFEs/i3pb4MXizT68c1zv0eevshtDnreAbQp/XGzSEPq/raAd94tMEG0Kf1yk1hD6vB2sIfV531xC6B3p96DjSBtBxpA2g40gbQMeRNoA+liON+2jn7fpp9K/JDnaSZmayYzmwzGTHcj6ZyY7lODKT9TNNdqwKOzPZsSrbzGTHqigzkx2rkstMdqYKarDTFzOTnamCGuyExMxkZ6qgBjvFMDPZmSqowU4azEx2pgpqsNMAM5OdqYIa7MS+zGRnqqAGO1UvM9mZKqjBTr7LTHamCmqw0+kyk52pghrsBLnMZGeqoAY75S0z2ZkqqMFOYstMdqYKarDT0jKTnamCGuxEs8xkZ6qgBjt1LDPZmSqowU4Gy0x2pgpqsNO7MpOdqYIa7IStzGRnqqAGOwUrM9mZKqjBTqrKTHamCmqw06Qyk52pghrsxKfMZGeqoAY7lSkz2ZkqqMFOTspMdqYKaqzTjbx7TDb7m0AT9t/t2eXxyja6k7Hx4BFdyoxNB/GUPo/9DXyoKk4B8LFOYtIAfKhqVgPwoSpqDcCHquo1APcArwt8KHejAfhQDksD8KFcngbgOM3KwHGaVYGbZaxjznw8NliK3uSI23hsmeScf4w2y9lrr+ZQc43Lp9F3kmN5yJYkxzKHLUmO5fpakvSQFCI5lk9rSXIsA9aS5FjOqiXJsSxTS5JjeaGGJMc6vK4pSTyOFEk8jhRJPI4USQ9JIZJ4HCmSeBwpkngcKZJ4HCmSeBwhkmMdaNeUJB5HiiQeR4okHkeKpIekEEk8jhRJPI4USTyOFEk8jhRJPI4QybGOamtKEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeI5FiHKTYliceRIonHkSKJx5Ei6SEpRBKPI0USjyNFEo8jRRKPI0USjyNEcqzjTpuSxONIkcTjSJHE40iR9JAUIonHkSKJx5EiiceRIonHkSKJxxEiOdaBxE1J4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE4wiRHOvI8KYk8ThSJPE4UiTxOFIkPSSFSOJxpEjicaRI4nGkSOJxpEjicYRIRjyOFEk8jhRJPI4USTyOFEkPSSGSeBwpkngcKZJ4HCmSeBwpkngcIZIJjyNFEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeGpFnwOFIk8ThSJPE4UiTxOFIkPSSFSOJxpEjicaRI4nGkSOJxpEjicYRIGjyOFEk8jhRJPI4USTyOFEkPSSGSeBwpkngcKZJ4HCmSeBwpkngcIZIWjyNFEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeIpMPjSJHE40iRxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHESLp8ThSJPE4UiTxOFIk8ThSJD0khUjicaRI4nGkSOJxpEjicaRI4nGESK54HCmSeBwpkngcKZJ4HCmSHpJCJPE4UiTxOFIk8ThSJPE4UiTxOEIkNzyOFEk8jhRJPI4USTyOFEkPSSGSeBwpkngcKZJ4HCmSeBwpkngcIZIBjyNFEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeIZMTjSJHE40iRxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHESKZ8DhSJPE4UiTxOFIk8ThSJD0khUjicaRI4nGkSOJxpEjicaRI4nFkSNoFjyNFEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeIpMHjSJHE40iRxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHESJp8ThSJPE4UiTxOFIk8ThSJD0khUjicaRI4nGkSOJxpEjicaRI4nGESDo8jhRJPI4USTyOFEk8jhRJD0khkngcKZJ4HCmSeBwpkngcKZJ4HCGSHo8jRRKPI0USjyNFEo8jRdJDUogkHkeKJB5HiiQeR4okHkeKJB5HiOSKx5EiiceRIonHkSKJx5Ei6SEpRBKPI0USjyNFEo8jRRKPI0USjyNEcsPjSJHE40iRxONIkcTjSJH0kPwWSW9D+hjt3Wozo40Px2uv5inueDbLbYkfgze7PY1dPzTCPfWvEb6sf41wfP1rhJfsXyNcavcaBfxv/xrhrPvXCM/ev0Z0A/rXyKNR9xrRZ+hfI/oM/WtEn6F/jSbuM7gjELMtLkPd2mX5GG29+6zRneTE3QBZknFizy5McmJnLUxyYv8rTHJilypM0kNSiOTEjk+Y5MS+TJjkxO5JmCQeR4okHkeIZMLjSJHE40iRxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHkSHpFjyOFEk8jhRJPI4USTyOFEkPSSGSeBwpkngcKZJ4HCmSeBwpkngcIZIGjyNFEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeIpMXjSJHE40iRxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHESLp8DhSJPE4UiTxOFIk8ThSJD0khUjicaRI4nGkSOJxpEjicaRI4nGESHo8jhRJPI4USTyOFEk8jhRJD0khkngcKZJ4HCmSeBwpkngcKZJ4HCGSKx5HiiQeR4okHkeKJB5HiqSHpBBJPI4USTyOFEk8jhRJPI4USTyOEMkNjyNFEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4rkUB4nrgfJtPhPo3/PNgzlQ7KzHcorZGc7VD2fne1QNXd2tn6q2Q5Vu2ZnO1R9mZ3tUDVgdrZD1WnZ2U5VS4115nl2tlPVUmOdHZ6d7VS11FhncGdnO1UtNdZZ1tnZTlVLjXUmdHa2U9VSY52tnJ3tVLXUWGcUZ2c7VS011lm/2dlOVUuNdWZudrZT1VJjnT2bne1MtZQf6wzX7GxnqqX8WGehZmc7Uy3lFz/VbGeqpfxYZ3NmZztTLeXHOuMyO9upaqmxzorMznaqWmqsMxezs52qlhrr7MLsbKeqpcY6AzA726lqqbHO0svOdqpaaqwz6bKznaqWGutst+xsp6qlxjojLTvbqWqpsc4ay852qlpqrDO7srOdqpYa6+yr7GynqqXGOkMqO9upaqmxzmLKznaqWmqsM42ys52qlhrrbKDsbKeqpcY6Yyc726lqqbHOqsnOdqpaaqwzX5JZj9luudEmxI/B9mkHHBvdydh48IguZcamuIec0uexd+JD1XMqiA9VU6ogPlRdm8Ietjd+yYy2wdkdeUjPo8MZ8xurHbo126fRd5JD1cxNSQ5Vj7ckOdZZM01JDuUjmpIcyqM0JTmU/2lK0kNSiORYnqklybG8UEuSeBwpkngcKZJ4HCGSY50105QkHkeKJB5HiiQeR4qkh6QQSTyOFEk8jhRJPI4USTyOFEk8jhDJsc6xaUoSjyNFEo8jRRKPI0XSQ1KIJB5HiiQeR4okHkeKJB5HiiQeR4jkWOdLNSWJx5EiiceRIonHkSLpISlEEo8jRRKPI0USjyNFEo8jRRKPI0RyrHPfmpLE40iRxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHkSG5jnUeY1OSeBwpkngcKZJ4HCmSHpJCJPE4UiTxOFIk8ThSJPE4UiTxOEIkxzontSlJPI4USTyOFEk8jhRJD0khkngcKZJ4HCmSeBwpkngcKZJ4HCGSY51f3JQkHkeKJB5HiiQeR4qkh6QQSTyOFEk8jhRJPI4USTyOFEk8jhDJsc4Vb0oSjyNFEo8jRRKPI0XSQ1KIJB5HiiQeR4okHkeKJB5HiiQeR4ikx+NIkcTjSJHE40iRxONIkfSQFCKJx5EiiceRIonHkSKJx5EiiccRIrnicaRI4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE4wiR3PA4UiTxOFIk8ThSJPE4UiQ9JIVI4nGkSOJxpEjicaRI4nGkSOJxhEgGPI4USTyOFEk8jhRJPI4USQ9JIZJ4HCmSeBwpkngcKZJ4HCmSeBwhkhGPI0USjyNFEo8jRRKPI0XSQ1KIJB5HiiQeR4okHkeKJB5HiiQeR4hkwuNIkcTjSJHE40iRxONIkfSQFCKJx5EiiceRIonHkSKJx5EiiceRIbkteBwpkngcKZJ4HCmSeBwpkh6SQiTxOFIk8ThSJPE4UiTxOFIk8ThCJA0eR4okHkeKJB5HiiQeR4qkh6QQSTyOFEk8jhRJPI4USTyOFEk8jhBJi8eRIonHkSKJx5EiiceRIukhKUQSjyNFEo8jRRKPI0USjyNFEo8jRNLhcaRI4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE4wiR9HgcKZJ4HCmSeBwpkngcKZIekkIk8ThSJPE4UiTxOFIk8ThSJPE4QiRXPI4USTyOFEk8jhRJPI4USQ9JIZJ4HCmSeBwpkngcKZJ4HCmSeBwhkhseR4okHkeKJB5HiiQeR4qkh6QQSTyOFEk8jhRJPI4USTyOFEk8jhDJgMeRIonHkSKJx5EiiceRIukhKUQSjyNFEo8jRRKPI0USjyNFEo8jRDLicaRI4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE4wiRTHgcKZJ4HCmSeBwpkngcKZIekkIk8ThSJPE4UiTxOFIk8ThSJPE4MiTDgseRIonHkSKJx5EiiceRIukhKUQSjyNFEo8jRRKPI0USjyNFEo8jRNLgcaRI4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE4wiRtHgcKZJ4HCmSeBwpkngcKZIekkIk8ThSJPE4UiTxOFIk8ThSJPE4QiQdHkeKJB5HiiQeR4okHkeKpIekEEk8jhRJPI4USTyOFEk8jhRJPI4QST+Sx/HmGO1N2j6Nvs92JB+Sn+1IXiE/25Hq+fxs/VSzHakuzs92pNo1P9uR6sv8bEeqAfOzHalOy852qPPU87OdqpYa6lzy/GynqqWGOt87P9upaqmhzsnOz3aqWmqo86bzs52qlhrq3Ob8bKeqpYY6/zg/26lqqaHOEc7PdqpaaqjzePOznaqWGupc2/xsp6qlhjofNj/bqWqpoc5Zzc92qlpqqPNK87OdqpYa6tzP/GynqqWGOj8zP9upaqmhzqHMz3aqWmqo8xzzs52qlhrqXMT8bKeqpYY6XzA/26lqqaHO6cvPdqpaaqjz7vKznaqWGurcuPxsp6qlhjp/LT/bqWqpoc4xy892qlpqqPPA8rOdqZaKQ52rlZ/tULWUN26fbTDLyWyHqqWysx2qlsrO1k8126Fqqexsh6qlsrMdqpbKznaoWio726Fqqdxshzq/Jz/bqWqpoc7Byc92qlpqqPNk8rOdqpYa6lyW/GynqqWGOt8kP9upaqmhzgnJz3aqWmqo8zbys52qlhrq3Ir8bKeqpYY6/yE/26lqqaHOUcjPdqpaaqjzCPKznaqWGmpf//xsp6qlhtofPz/bqWqpofaZz892qlpqqP3a87OdqpYaa9/z7GynqqXG2vc8O9upaqmx9j3PznaqWmqsfc+zs52qlhpr3/PsbKeqpcba9zw726lqqbH2Pc/MNjXosG5hH71u0T3P9h5Rg2xbHvyX7WtE/jQi63YhnAsxE5Hb0rKPjsvzDzzCx5usNd5kq/EmocabxBpvkiq8yQtfLvwmpsab2Bpv4mq8SY1PvK/xifc1PvG+xife1/jE+xqf+LXGJ36t8Ylfa3zi1xqf+LXGJ36t8Ylfa3zi1xqf+LXGJ36t8Ynfanzitxqf+K3GJ36r8Ynfanzitxqf+K3GJ36r8Ynfanzitxqf+FDjEx9qfOJDjU98qPGJDzU+8aHGJz7U+MSHGp/4UOMTH2p84mONT3ys8YmPNT7xscYnPtb4xMcan/hY4xMfJT7xMRyj02JO3iTWeJNU4U3SUuNNTI03sTXexNV4E1/jTVbhNzH25E0kPvHxePzjkl0+vcnX0fF4xBLd4wmL/fWM5svY2w3pY2xKn8fegw+ag4+ag09qg7fLsmgO3mgO3moO3mkO3msOftUcvN4V9ha83hX2FrzeFfYWvOYV1vS9wm77WHNbkU6i73uJzUXf9xqbi77vRTYXfd+rbC76vpfZXPQS62yy4Yh+DZno33/H8BZR6C6i2F1EqbeI7NJdRKa7iGx3EbnuIvLdRbR2F1F392zb3R3S1r9Dvv2mul2c6y6i+p+1YB8R2fA1orW7iLbuIgrdRRS7i6jBp99vR0Srf47o62Drj0Cs9/5L+H7RHb7RHb7VHb7THb7XHf6qO/xNd/ih8/BtfIT/tSDzUXf4va+678NfO19113Wveey6ufeDt9vj+o/B262/+nWunS/RP5nrmkJ6O9fO1/P16P3aNZj3g+Oyv3D0Tz+09svHVDtf+yWn6ueZauc1heRUO68/JKfaea0iONWt95X1J1Nd975jDNunqZ68sHF7zNasjxf29mxw3Jc8t3waekfY+4KtAOFIdUAjhCPVF40QehD+KcKR6qFGCEeqsxohHKl+a4Sw836XBoSd99wUIAy4kz9GiDv5Y4S4kz9GiDv5U4Rx1ixckj0QPn1V6hRhjHsQn34cfPrC5vbe+yvf/g5PX8FO8YP5rGnbkrmHeXXms9r2lsxn9fktmc/aGGjJfNZOQkvms7YeGjJPs/YqWjKftbnRkjk+tD5zfGh95h7m1ZnjQ+szx4fWZ44Prc8cH1qfOT60NnOz4EPrM8eH1meOD63PHB9an7mHeXXm+ND6zPGh9ZnjQ+szx4fWZ44Prc7c4EPrM8eH1meOD63PHB9an7mHeXXm+ND6zPGh9ZnjQ+szx4fWZ44Prc7c4kPrM8eH1meOD63PHB9an7mHeXXm+ND6zPGh9ZnjQ+szx4fWZ44Prc7c4UPrM8eH1meOD63PHB9an7mHeXXm+ND6zPGh9ZnjQ+szx4fWZ44Prc689xNMh2SOD63PHB9anzk+tDpzVWcoxveDw7aPDeETxftMNWXXn83UTzPTFo7+cUD9mgn+3Uvf49+Uxx+Uxx+Vx590x9/k/EjJ+E3X8fvF7Qco+yWlzEs7fxQLzsensNePu22TcxbbzdZNNVs/1Wz7rhukZ9t3lSE9275rEunZ9l3BSM+273pHeLah7+pIerZT1VJBby11j19vdXSP3yuPX28Fc49fb01yj19vlXGPv/O6wRwNRe+Mz7x0XPzebHePudroTsamuL9wSp/H3rl0XmG04hI7r0Wacem8amnGpfP6phmXzuumZlw8XE65dF7nNePSef3YjEvndWkzLtS751yod0+5JOrdcy7Uu+dcfOdczN6P9Mae9ANS73VGLv7e64Fc/L2v27n4e19fc/H3vg6+j98uva9Xufh7X1dy8ffe78jF33tfIhe/7vXXLrrXX7voXn/tonv9tYvu9dcuytdfo3z9NcrXX6N8/TXK198m+/tLxq98/TXK11+jfP01ytdfo3z9tcrXX6t8/bXK11+rfP1tsq+xZPzK11+rfP21ytdfq3z9tcrXX6d8/XXK11+nfP11ytffJvs5SsavfP11ytdfp3z9dcrXX6d8/fXK11+vfP31ytdfr3z99crXX698/fXK11+vfP31ytdfr3z9XZWvv6vy9XdVvv6uytffJnsOSsavfP3tfCfBfPzK19/OdxLMx698/e18J8F8/MrX3973BszGr3z97X3/vmz8ytff3vfYy8avfP3tfR+8bPzK19/e96rLxq98/e19P7ls/MrX3973k8vGr3z97X0/uWz8ytff7veTy8WvfP3tfn+2XPzK19/u9zvLxa98/e1+/7Bc/MrX3+7348rFr3z97X5/q1z8ytff7veLysWvfP1NytffpHz9Vb7/lVW+/5VVvv+VVb7/lVW+/5VVvv+VU77/lVO+/5VTvv+VU77/lVt0r7+u+/2vLttXdNvHmmWxnwbfwUy70XUOzLQ7XefATLvVdQ7MtHtdZ8B0v3lZMzB6TzG5x6/3tJF7/F55/Hqrmnv8eouPe/x6a4R7/HqX8nv8elfc3/F3v6tYLn69pzXc41e+/na/q1gufuXrb/e7iuXiV77+dr+rWC5+5etv97uKZeLvflexXPzK19/udxXLxa98/e1+V7Fc/MrX3+53FcvFr3z97X5X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WbKVZclWliVbWZZsZVmylWVJKMuSUJYloSxLQlmWhLIsCWVZEsqyJJRlSSjLklCWJbEsS2JZlsSyLIllWRLLsiSWZUksy5JYliWxLEtiWZaksixJZVmSyrIklWVJKsuSVJYlqSxLUlmWpLIsKeu9mrLeqynrvZqy3qsp672ast6rKeu9mrLeqynrvZqy3qsp672ast6rKeu9mrLeqynrvZqy3qsp672ast6rKeu9mrLeqynrvZqy3qsp672ast6rKeu9mrLeqynrvZqy3qsp672ast6rKeu9mrLeqynrvZqy3qsp672ast6rKeu9mrLeqynrvZqy3qsp672ast6rKeu9mrLeqynrvZqy3qsp672ast6rKeu9mrLeqynrvZqy3qsp672ast6rKeu9mrLeqynrvZqy3qsp672ast6rKeu9mrLeqynrvZqy3qsp672ast6rKeu9mrLeqynrvZqy3qsp672ast6rKeu9mrLeqynrvZqy3qt50XtNxzcMTfLm5LIXWXJs6WdSsp8uO9vKV+igkFs4oa9wYl/hpK7CedXbbhWO6Ssc21c4rq9wfF/hrH2F09ddOfZ1V4593ZVjX3fl1NddOfV1V0593ZVTX3flVPuu/PaMq1s8a2fxbJ3FEzqLJ3YWT+oqHnv+BNfeStePy6w1ayaem0NfjvC38NfdC25vYmq8ia3xJk7kTdz2eJPNPb3JyS/yots3BnLL875Py/l2qsux59riHr+9T/Yjft95/OvBf1ud+xr/qjz+TXn8QXn8UXn8SXf8ZlEev1Eev1Uef+/rby5+5euvUb7+GuXrr1G+/hrl669Rvv5a5euvVb7+WuXrr1W+/lrl669Vvv5a5euvVb7+WuXrr1W+/jrl669Tvv465euvU77+OuXrr1O+/jrl669Tvv465euvU77+euXrr1e+/nrl669Xvv565euvV77+euXrr1e+/nrl669Xvv6uytffVfn6uypff1fl6++qfP1dla+/q/L1d1W+/q7K199V+fq7KV9/N+Xr76Z8/d2Ur7+b8vV3U77+bsrX3035+rspX3835etvUL7+BuXrb1C+/gbl629Qvv4G5etvUL7+BuXrb1C+/gbl629Uvv5G5etvVL7+RuXrb1S+/kbl629Uvv5G5etvVL7+RuXrb1K+/ibl629Svv4m5etvUr7+JuXrb1K+/ibl629Svv4m3euvW3Svv27Rvf66Rff667rf/yoXv+711ynf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KK9//yivf/8or3//KK9//yi+611+vfP8r3/3+V4+X3kIyz/GfDd6j3uL2eOG4fsy197Vacq69r+uSc+29BhCca/f7dUnOtffaQnKundcha1rjY672/Vx9SHscPrp4DLYpnoZtwhG188do59IHm85rnKZsPGxesum8Ngurtx+jw7Zs79k4t491/inos6Hrtu4hr2F5Gvyr/vsac0rHKy9L/DT6jrHzElELxs6rTy0YOy9stWDsvGZWgrH37fu0YOy80teCsXMToQVj535DC0YPRgmMuBgRjLgYEYy4GBGMuBgRjLgYCYy9b4KqBSMuRgQjLkYEIy5GBKMHowRGXIwIRlyMCEZcjAhGXIwIRlyMBMbet5LWghEXI4IRFyOCERcjgtGDUQIjLkYEIy5GBCMuRgQjLkYEIy5GAmPvG/JrwYiLEcGIixHBiIsRwejBKIERFyOCERcjghEXI4IRFyOCERcjgbH3Y020YMTFiGDExYhgxMWIYPRglMCIixHBiIsRwYiLEcGIixHBiIuRwNj74VBaMOJiRDDiYkQw4mJEMHowSmDExYhgxMWIYMTFiGDExYhgxMVIYOz9iD0tGHExIhhxMSIYcTEiGD0YJTDiYkQw4mJEMOJiRDDiYkQw4mIkMPZ+UKkWjLgYEYy4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","names":["borrow_private"],"brillig_names":["discover_new_messages","decompose_hint","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","directive_invert"]},{"name":"borrow_public","hash":"7613533971097197876","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"1ZzRbtswDEX/Jc95EEVKpPYrwzCkbVoECNIibQcMRf99chbbaePFmJprWC+FXYi8J7avSduy3xZ365vXh5+b3f3j8+Lb97fF9vF29bJ53OW1t/fl4ma/2W43Dz9P/71wzR/vD+Ofn1a7ZvX5ZbV/WXwj9hKWi/XurllmcznH/Wa7zmsuL5+Pd963w534bnTSgcGSnB4HS6LYDY5hYLCJ2HGwSZTTwT+WC8/XoU+pHU6UpqOX69AH67a9jWx7CtrSU2S+TJ8Cy3FwynGf6cO16cl/oG804gQaOqSR1He/XaXfc4HBx4QN04TY0egITXDmjoPzoo3QBGo3pQV2n2nSMA35jiaEyzSXfy47tAChBTxagNECghYIaIGIFlC0gKEF0E4WtJMF7WRBO1nQTpavO9lHanshH09qfm7rDgoBrhDhCgpXMLhCQisEB1cguIKHKzBcAe7pAPd0gHs6wD0dvu7pyO25O4b+0ivFQ/oETR8dNj1h03tsesamF2z6gE0fsekVmx7r2oh1rWJdq1jXKrz6Krz6Krz6Krz6Krz6Krz6KryjVnhHbfCO2uAdtcE9bXBPG9zTBve0YauyYauyYauyYatywlblhK3KCdtLJ2wvnbC9dML20gnr2oR1bcK6NmFdmx8Nfjk/mWsfCpKRnSkQ+Bd4cH4G5xdw/gDOH8H5FZzfwPnBDiYHzg/2L4H9S2D/Eti/BPYvgf1LYP8S2L8E9q8H+9fDL3/Je7wE4yUELxHwEhEvoXgJw0vAb20RO7wE3t2Mdzfj3c14dzO4UjO4UjO4UjO4UjO4Ugu4Ugu40xZwpy3gTvsKE7ku5wf7d3wSl3l3OT9Faac8U4z9YDkqKFzB4Arp6wq56e0m9Oe+7mSnDU3/Zyd0HM0ufJio3gCNz/maGojmBuTnBsRzA5K5AYW5AcW5Aen0QKkdzV5HXpjJ99W1faEl3wNnOeO3yvlT3fzRVc5PlfNPX5Q4tt0f88k7h//gV+aOX8M5//Q1TLjdoiyiY/zmujbO2dlLcjQ+wfP6/EQ9v43xp+4dv7wc7Iw/VM4fK+fXyvmtcv5UN7+6yvmpcn5fOT9Xzl95/dXK669WXn+18vqrlddfrbz+2pzO/wegOZ3QD0BzOkMfgKY/5YbugzIcRi858xO+/pM14vmMP1bOr5XzW+X8qW7+dI1LBjbpNZw/5T9o+Ak0eAINgWv44anR+Tl2FyWh3+c+xr9RWhRlRVGpJGp4yvFoFBVFDX+Kr5+Kk2/09vdO5RjEJUFSEqQFQcNTPi8/F/fD8zjHgkIJXiwJKtoQVhKUCoLYlQRRSVDJAcslByyXHLBcckRwLDj2WEuCrCQoFQRJiQmlxITiS4K4JEhKgsL/Br3ntV+r/WZ1s10fv6V6/7q7Pfm06svvp/Wnr6w+7R9v13ev+3XzvdX+U6sNsRdbsuMM06Dk5/JLDtYU6WYXUYpL76hZbTa+dz6vSmbIHH8A","names":["borrow_public"],"brillig_names":["borrow_public"]},{"name":"constructor","hash":"11720634556152480666","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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Lm3GhXr3mAv17iGXTL17zIV695iL75yL2fqR3tiDfkDuvc4oxd97PVCKv/d1uxR/7+trKf7e18Hv47dL7+tVKf7e15VS/L33O0rx996XKMWve/21i+711y6611+76F5/7aJ7/bWL8vXXKF9/jfL11yhff43y9bfJ/v6S8Stff43y9dcoX3+N8vXXKF9/rfL11ypff63y9dcqX3+b7GssGb/y9dcqX3+t8vXXKl9/rfL11ylff53y9dcpX3+d8vW3yX6OkvErX3+d8vXXKV9/nfL11ylff73y9dcrX3+98vXXK19/vfL11ytff73y9dcrX3+98vXXK19/V+Xr76p8/V2Vr7+r8vW3yZ6DkvErX38730mwHL/y9bfznQTL8StffzvfSbAcv/L1t/e9AYvxK19/e9+/rxi/8vW39z32ivErX3973wevGL/y9bf3veqK8Stff3vfT64Yv/L1t/f95IrxK19/e99Prhi/8vW3+/3kSvErX3+735+tFL/y9bf7/c5K8Stff7vfP6wUv/L1t/v9uErxK19/u9/fqhS/8vW3+/2iSvErX3+z8vU3K19/le9/ZZXvf2WV739lle9/ZZXvf2WV73/llO9/5ZTvf+WU73/llO9/5Rbd66/rfv+r0/YVDdtYsyz20+A7mGk3ui6BmXan6xKYabe6LoGZdq/rApjuNy9rBkbvKSb3+PWeNnKP3yuPX29Vc49fb/Fxj19vjXCPX+9Sfo9f74r7O/7udxUrxa/3tIZ7/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexQvzd7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf9/rru99VrBS/7vXXd7+rWCl+3euvX3Svv17xrmL3+HWvv17xHl33+HWvv17xjle/41e8MdU9fuXrr/L9r7zy/a+88v2vfO/7XwWXt/jT4gov/aON5dI2w5w/j71z6Xxdb8al83qhGZfO65DzuHy/QaPvfYOxZmB637msHZjOS7J2YDqv9dqB6byIbAfG9w0m7S/tky+BicF9DI4x7GO9/Zhq54Ws5FQ7r00lp9p5ufnNVO/xd14WFuPvvHorxd/59nSr8es22IQDe9759nTl+PsuWcrx911ZlOP3yuPve1Uvx9/3Ul2Ov+/1txx/3+tvOf6+19/n+K2xX+PvfHu6cvx61t/j+PWsv8fx61l/j+PXs/4ex9/5+htN3AenfBB/5+tvMf7O199i/J2vv8X4O19/S/F3vj1dOf7O199i/J2vv8X4O19/i/F3vv4W41e+/na+PV05fuXrb+fb063JLdvgHFLhpX3eJ/v8VaZkD8bauGzHGdtoH5Vt+ODS+breikvn2+m149J5HSLE5T7XzmsW0bl2Xt+IztVPNNfO6ybRuXZeY4nOtfN67EdzvbXctsE+Hcx1pNqtNNeR6rHCXDvfMlF2riPVTaW5jlQ3leY6Ut1UmqufaK4j1U2luY5UN63rXjelg7qp820mZec6VN1UmOtQddP3c+18q0vZuQ5VNxXmOlTdVJjrUHVTYa5+orkOVTcV5jpR3dT59qDfzfUev95a6B6/3vrmd/ydbw9ajl9vHXKPX29tcY+/73ohLMsWSHDBHMTvlcff97pejr/vtbocf9/rbzn+vtffcvx9r7+l+NfOtwctx9/3+luOv+/1txy/7vV3XXSvv2vn24OW49e9/q6dbw9ajl/3+rt2vj1oMf7Otwctx698/e18e9By/MrX3863By3Hr3z97Xwbz3L8ytffzrfFLMevfP3tfJPJcvzK19/Ot2wsx698/e18A8Ry/MrX3863KizHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18/8Fy/MrX3873HyzHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18/8Fy/MrX3873HyzHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18P79y/MrX38730ivHr3z97XzPu3L8ytff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M0/40OuZ40OvZ44PvZ45PvR65h7mlzPHh17PHB96PXN86PXM8aHXM8eHXs4840OvZ44PvZ45PvR65vjQ65l7mF/OHB96PXN86PXM8aHXM8eHXs8cH3o187zgQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxodczx4dezxwfejlzgw+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzC0+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzN3+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17O3ONDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfMVH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZB3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZx7xodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZx5wodezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5hkfej1zfOj1zPGh1zPHh17P3MP8cub40OuZ40OvZ44PvZ45PvR65vjQi5m7ZcGHXs8cH3o9c3zo9czxodcz9zC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYGH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZW3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ+7wodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZy5x4dezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5is+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzMP+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17OPOJDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfOED72eOT70eub40OuZ40OvZ+5hfjlzfOj1zPGh1zPH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+E3SFW+SL3iTF4/Mhd/Enf7RzBL3sG9/u5byev5bhPPfIp7/Fun8t8hnv0VelvPfQmI9+faHWXmx57+FO/8t/NkLb17W898inP8W8fy3SOe/RT79Lcxy/luY89/Cnv8Wh0m7rlvXdE3PlZ79uCjWXJRqLjpOlSXus/r1d/5LRZJfPOZaYt5L2OX2oPjLZabuMlt3mau77PhmudweKD0ue9qEfbtsrbss1F0Wqy5zL3TLj+3olxzMl8tekMxp25bemGX5QtL5usvWusti3dxS3WUvPjg5u6cg179e5pe6y0zdZbbuMld3ma+7bK277PiDcxuaH5fZ5yz5+89z6ng/Lek3SVe8Sf7zN/n+WWQ+fkIo+xbm/LewP32L+2Wu7jJfd1ndLfLF87niZbHuslR3Wa66LCx1l5m6y2zdZXULaahbSF886ojrfmON8flnqkefFhuX/RtG0dovb5FPf4sXjzpE38Kc/xb2/Ldw57+FP/8t1vPfIpz/FvH8tzj/0x3P/3Sn8z/d6fxPdzr/053O/3Sn8z/d6fxPdzr/053O/3SnH3+675flqsvyUneZqbvM1l3m6i7zdZetdZeFusti3WV1WZJrsmRdlqXuMlN3ma27zNVd5usuW+suC3WXxbrLUt1ldVli6rLE1GWJqcsSU5clpi5LTF2WmLosMXVZYuqyxNRlia3LEluXJbYuS2xdlti6LLF1WWLrssTWZYmtyxJblyWuLktcXZa4uixxdVni6rLE1WWJq8sSV5clri5LXF2W+Los8XVZ4uuyxNdlia/LEl+XJb4uS3xdlvi6LPF1WbLWZclalyVrXZasdVmy1mXJWpcla12WrHVZstZlyVqXJaEuS0JdloS6LAl1WRLqsiTUZUmoy5JQlyWhLktCXZbEuiyJdVkS67Ik1mVJrMuSWJclsS5LYl2WxLosiXVZkuqyJNVlSarLklSXJakuS1JdlqS6LEl1WZLqsiTVZUmuy5JclyW5LktyXZbkuizJdVmS67Ik12VJrsuSut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZoXvde8f8PQZG8OLnuRJfuWfiZn++myo618hQ4KuYUT+won9RVO7iqcV73tVuGYvsKxfYXj+grH9xXO2lc4fd2VU1935dTXXTn1dVfOfd2Vc1935dzXXTn3dVfOV9+Vvz3j6hbP2lk8obN4YmfxpM7iyV3FY4+f4Npb6fpxmbVmLcRzc+jLHn6If9294PYm5oo3sVe8iRN5ExcebxLc05sc/CIvuW1jILc87/u0HG+nuux7ri3u8dv7bD/i953Hv+78w+rc1/hX5fEH5fFH5fEn5fFn3fGbRXn8Rnn8Vnn8va+/pfiVr79G+fprlK+/Rvn6a5Svv0b5+muVr79W+fprla+/Vvn6a5Wvv1b5+muVr79W+fprla+/Vvn665Svv075+uuUr79O+frrlK+/Tvn665Svv075+uuUr79O+frrla+/Xvn665Wvv175+uuVr79e+frrla+/Xvn665Wvv175+rsqX39X5evvqnz9XZWvv6vy9XdVvv6uytffVfn6uypff1fl629Qvv4G5etvUL7+BuXrb1C+/gbl629Qvv4G5etvUL7+BuXrb1S+/kbl629Uvv5G5etvVL7+RuXrb1S+/kbl629Uvv5G5etvUr7+JuXrb1K+/ibl629Svv4m5etvUr7+JuXrb1K+/ibl629Wvv5m5etvVr7+ZuXrb1a+/mbl629Wvv5m5etvVr7+Zt3rr1t0r79u0b3+ukX3+uu63/+qFL/u9dcp3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yivf/8or3//KK9//yivf/8ovutdfr3z/K9/9/lePlw4xm+f4jwZvUYcUHi+c1o+59r5WS86193Vdcq691wCCc+1+vy7JufZeW0jOtfM6ZM1reszVfj9XH/MWh08u7YNtTodhm7hH7fw+2rn8wabzGqcpGw+bl2w6r83i6u3H6BiW8D0b57axzj8FfTR0DesW8hqXp8G/6r+vMee8v/KypE+j7xg7LxG1YOy8+tSCsfPCVgvGzmtmJRh7375PC8bOK30tGDs3EVowdu43tGD0YJTAiIsRwYiLEcGIixHBiIsRwYiLkcDY+yaoWjDiYkQw4mJEMOJiRDB6MEpgxMWIYMTFiGDExYhgxMWIYMTFSGDsfStpLRhxMSIYcTEiGHExIhg9GCUw4mJEMOJiRDDiYkQw4mJEMOJiJDD2viG/Foy4GBGMuBgRjLgYEYwejBIYcTEiGHExIhhxMSIYcTEiGHExEhh7P9ZEC0ZcjAhGXIwIRlyMCEYPRgmMuBgRjLgYEYy4GBGMuBgRjLgYCYy9Hw6lBSMuRgQjLkYEIy5GBKMHowRGXIwIRlyMCEZcjAhGXIwIRlyMBMbej9jTghEXI4IRFyOCERcjgtGDUQIjLkYEIy5GBCMuRgQjLkYEIy5GAmPvB5VqwYiLEcGIixHBiIsRwejBKIERFyOCERcjghEXI4IRFyOCERcjgHHt/bhnLRhxMSIYcTEiGHExIhg9GCUw4mJEMOJiRDDiYkQw4mJEMOJiJDD2fgi9Foy4GBGMuBgRjLgYEYwejBIYcTEiGHExIhhxMSIYcTEiGHExEhgtLkYEIy5GBCMuRgQjLkYEowejBEZcjAhGXIwIRlyMCEZcjAhGXIwERoeLEcGIixHBiIsRwYiLEcHowSiBERcjghEXI4IRFyOCERcjghEXI4HR42JEMOJiRDDiYkQw4mJEMHowSmDExYhgxMWIYMTFiGDExYhgxMVIYFxxMSIYcTEi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","names":["constructor"],"brillig_names":["get_contract_instance_internal","decompose_hint","lte_hint","discover_new_messages","notify_created_nullifier_oracle_wrapper","directive_invert"]},{"name":"repay_private","hash":"9492929774625906864","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"field"},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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c3XDfN2wUDesLktSTZY4pVTdMF03zNQNs3XDqG6Yqxvm64aFumGxblhdlui6LNF1WaLrskTXZYmuyxJdlyW6Lkt0XZbouizRdVli6rLE1GWJqcsSU5clpi5LTF2WmLosMXVZYuqyxNRlia3LEluXJbYuS2xdlti6LLF1WWLrssTWZYmtyxJblyVUlyVUlyVUlyVUlyVUlyVUlyVUlyVUlyVUlyVUlyWuLktcXZa4uixxdVni6rLE1WWJq8sSV5clri5LXF2W+Los8XVZ4uuyxNdlia/LEl+XJb4uS3xdlvi6LPF1WRLqsiTUZUmoy5JQlyWhLktCXZaEuiwJdVkS6rIk1GVJrMuSWJclsS5LYl2WxLosiXVZEuuyJNZlSazLkliXJakuS1JdlqS6LEl1WZLqsiTVZUmqy5JUlyWpLkvqeq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qk96r2n/hqFOpDPDTrJk39JPp2S+Dctt5ct0UMgtnDBWOHGscNJQ4Zz1tnuFo8cKx4wVjh0rHBorHDdWOGPdleNYd+U41l05jnVXTmPdldNYd+U01l05jXVXTq3vyi/PuLrF4waLxw8WTxgsnjhYPGmoeEz+Ca65la5fw4zRrhDPzaGrPXwf/rx7we1NdIs3MS3exLK8ifWPN/H28CaZX+RFu20MZNVx3yeV305V7XuuKfv47X0yX/HT4PG7nb931j7H74TH74XHH4THH4XHn2THr5Xw+LXw+I3w+Edff0vxC19/tfD1Vwtff7Xw9VcLX3+18PXXCF9/jfD11whff43w9dcIX3+N8PXXCF9/jfD11whff43w9dcKX3+t8PXXCl9/rfD11wpff63w9dcKX3+t8PXXCl9/rfD1l4SvvyR8/SXh6y8JX39J+PpLwtdfEr7+kvD1l4SvvyR8/XXC118nfP11wtdfJ3z9dcLXXyd8/XXC118nfP11wtdfJ3z99cLXXy98/fXC118vfP31wtdfL3z99cLXXy98/fXC118vfP0NwtffIHz9DcLX3yB8/Q3C198gfP0NwtffIHz9DcLX3yB8/Y3C198ofP2NwtffKHz9jcLX3yh8/Y3C198ofP2NwtffKHz9TcLX3yR8/U3C198kfP1NwtffJHz9TcLX3yR8/U3C198ke/21Svb6a5Xs9dcq2euvHX7/q1L8stdfK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysSvv8VCd//ioTvf0XC978iJXv9JeH7X9Hw+189XtqHpI/x5y7eovbRP144uq+5jr5Wc8519HWdc66j1wCMcx1+vy7OuY5eW3DOdfA6xCUXH3M1r+dKIW1xULRxv9ikmA1bhz1qS/vV1qYvNoPXOF3ZENicshm8NguOzNfVwSv/mo2127WWDkHnLnXebSG7oA4X/6r/nmNOaX9lpeK3q+8YBy8RpWAcvPqUgnHwwlYKxsFrZiEYR9++TwrGwSt9KRgHNxFSMA7uN6RgJGDkwAgXw4IRLoYFI1wMC0a4GBaMcDEcGEffBFUKRrgYFoxwMSwY4WJYMBIwcmCEi2HBCBfDghEuhgUjXAwLRrgYDoyjbyUtBSNcDAtGuBgWjHAxLBgJGDkwwsWwYISLYcEIF8OCES6GBSNcDAfG0Tfkl4IRLoYFI1wMC0a4GBaMBIwcGOFiWDDCxbBghIthwQgXw4IRLoYD4+jHmkjBCBfDghEuhgUjXAwLRgJGDoxwMSwY4WJYMMLFsGCEi2HBCBfDgXH0w6GkYISLYcEIF8OCES6GBSMBIwdGuBgWjHAxLBjhYlgwwsWwYISL4cA4+hF7UjDCxbBghIthwQgXw4KRgJEDI1wMC0a4GBaMcDEsGOFiWDDCxXBgHP2gUikY4WJYMMLFsGCEi2HBSMDIgREuhgUjXAwLRrgYFoxwMSwY4WIYMLrRj3uWghEuhgUjXAwLRrgYFowEjBwY4WJYMMLFsGCEi2HBCBfDghEuhgPj6IfQS8EIF8OCES6GBSNcDAtGAkYOjHAxLBjhYlgwwsWwYISLYcEIF8OB0cDFsGCEi2HBCBfDghEuhgUjASMHRrgYFoxwMSwY4WJYMMLFsGCEi+HAaOFiWDDCxbBghIthwQgXw4KRgJEDI1wMC0a4GBaMcDEsGOFiWDDCxXBgJLgYFoxwMSwY4WJYMMLFsGAkYOTACBfDghEuhgUjXAwLRrgYFoxwMRwYHVwMC0a4GBaMcDEsGOFiWDASMHJghIthwQgXw4IRLoYFI1wMC0a4GA6MHi6GBSNcDAtGuBgWjHAxLBgJGDkwwsWwYISLYcEIF8OCES6GBSNcDAfGABfDghEuhgXj4C7GJRc3jFGnAsYQt4ttPIRNSuXCJrMFoik8FIox99I6qu2ldXpcbHwuaqvMjl3TA7vVuUCi9vR1dTQHkUykzNUUlP26msKvFNle2/kvSQd3VJD0c0kJks4m6eBOE5J+LungrheSfi7p4A4ckn4u6eDdAEj6uaSDdyYg6ceSxsG7JJD0c0kH79hA0s8lRfdoOknRPZpOUoKks0mK7tF0kqJ7NJ2k6B69JynptL00RVOQ1Cm9PwFVFB5z3KijwdODOnowHagntEl6UEcnowd1NBt6UEc/oAd1AvUO1OGqe1CH8e1BHd60B3V40x7Uh/Kmv0Lyaijjdg9pKFdzD2mokv8e0lD18D0kGi+koSqpe0hDlRn3kIZag+8hDbVA3UMa7+6tx7t76/Hu3nq8u7ce7+6tx7t7j3XG/T2k8e7eY529fg9pvLv3WGeC/w5prPO17yGNd/ce69zne0jj3b3HOo/4HtJ4d++xzsm9hzTe3Xus81vvIY139x7rXNF7SOPdvcc67/Ie0nh377HOYbyHNN7de6zzAe8hjXf3HuvcuntI4929xzpP7R7SeHfvsc75uoc03t17rPOn7iGNd/ce61yke0jj3b3HOq/nHtJ4d++xzpG5hzTe3Xus803uIY139x7r3I17SOPdvcc6D+Ie0nh377HOKbiHNN7de6z98+8hjXf3Hmtf93tI4929x9pv/B7SeHfvsfbBvoc03t17rP2Z7yGNd/cea9/ge0jj3b3H2s/2HtJ4d++x9hO9hzTe3Xus/RzvIY139x5rP717SOPdvcfaz+we0nh377H2k7qHNN7de6z9fO4hjXf3Hms/lXtI4929x9os4x7SeHfvsbZZuIc03t17rB/o30Ma7+491k+77yGNd/ce60fB95DGu3uP9XPSe0jD3b3DeL+1DOP91jKM91vLMN5vLYMa7u4dxvutZRjvt5ZhvN9ahvF+axnG+61lGO+3lmG831qG8X5rGcb7rWUY77eWYbzfWobxfmsZxvutZRjvt5ZhvN9aBqYfEKnwCEmHQ0i/3+TzH7vch9m6YVQ3zNUN83XDQt2wWDcsVQ37/McA92G6blhdllBdllBdllBdllBdllBdllBdllBdlri6LHF1WeLqssTVZYmryxJXlyWuLktcXZa4uixxdVni67LE12WJr8sSX5clvi5LfF2W+Los8XVZ4uuyxNdlSajLklCXJaEuS0JdloS6LAl1WRLqsiTUZUmoy5JQlyWxLktiXZbEuiyJdVkS67Ik1mVJrMuSWJclsS5LYl2WpLosSXVZkuqyJNVlSarLklSXJakuS1JdlqS6LElVWRKVqhum64aZumG2blg2S8jvw74di/MY5vLD9GOYUX9/3RO4vffXxdE+tqm9tSMy16a4NTRS+n7tPRw/VjhhrHDiWOGkocLJP5zoF44eKxwzVjh2rHBorHDGuivrse7Keqy7sh7rrqxb35X3Y/q0UuY5HqMGi0cPFo8ZLB47WDw0WDwf35vvw3zdsFA1jGkXvJeP+iLTvnaFN7Et3oRavIlr8Sa+xZvwfAOA9ONNXDq8yWdPwu8hxfFCSsOFxLTj2wchkU7buTRknjOJab83xoDMaAE1/+ZWaQFsv9VbMSI3XER+uIjCcBHF4SJKo0XUfpO3YkR6uIjMcBENd892w92zO+zv5pTaXttRKr12cvtLp6gPE6CvCfjBJxCT3a5W9vsEMg7Z6N0iG1e6+vZMcvuq6e1ZnClcbZ3ZChztH9eq3LVGpwc/lb5dfccegL0H9gjsPbAnYO+AvcPujMB+w66BvQd2A+w9sFtg74GdgL0H9tH93qTY4VK7YIdL7YIdLrULdrjUHtgDXGoX7HCpXbDDpXbBDpfaBTsBew/scKldsMOldsEOl9oFO1zqFdhNTFvU9viNkx07XGoP7BEutQt2uNQu2OFSu2CHS+2CnYC9B3a41C7Y4VK7YIdL7YIdLrULdrjUHtgTXGoX7HCpXbDDpXbBDpfaBTsBew/scKldsMOldsEOl9oFO1xqF+xwqR2wJwWX2gU7XGoX7HCpXbDDpXbBTsDeAztcahfscKldsMOldsEOl3oF9qA3ICZYlcEOl9oDu4ZL7YIdLrULdrjULtjhUrtgJ2DvgR0utQt2uNQu2OFSe2A37e/t0W6TtUrbwmu75LaTMqJKj6tvlO7xO+Hxe+Hxh7Hj924/1sg7m4k/Co8/yY7fKuHxa+HxG+HxW+HxD77+FuMffP0txj/4+luMX/j6a4Wvv1b4+kvC118Svv6S8PWXhK+/7Q82ZI5f+PpLwtdfEr7+kvD1l4Svv074+uuEr79O+PrrBl9/D/1DH0Mm/sHX32L8cvrP+fjl9J/z8Q++/hbjH3z9LcY/+Ppbit8Pvv4W4x98/S3GP/j6W4x/8PU3ONqeFgev/DH+zJNlu11r6RB07lLn96OSXVCHi3/VKM8x355q7zGr+O3qO8bBbyNjYLQqbd85t994ZK8Oe8Rhv5K+eIfBb3vT8R78Nj0d78GXlel4Yxlsy5vAuynvwW3+dLwHb0tMx3vwNsp0vAdv+0zHG/6yKe8If9mWN/xlW97wl215w1+25U3g3ZQ3/GVb3vCXbXnDX7blDX/ZlHcavR400e/RH86nzfLWN3JbHMEffhhts0/I1fa7aEfq27V3MqNXbv3IEMickBm9GupHZvS6pR+Z0SuMfmRGrwX6kRm9K9yJjFdq9P5tPzKjd1r7kVm4Bvbbbj8361W4lozbMNLvDX4OpuPOcd2VLO4XH79rm7/WWLNdbIjEbMik00PGA7yvDZlu6q+7WkN9pdatSKC+0utWXVBf6XUrS6iv9LrVM9RXet0uOdRXHTbYhvrjqL/u0w6or/S6T3SgvtLo9a2sPnp9K6uPXt/C6hv0+lZWH72+ldVHr29l9dHrW1l9gvoLq49e38rqo9e3svro9a2sPnp9K6uPXt/E6pu4/YzUWGWe1R/9kEOof6n66PWtrD56fSurj17fyuoT1F9YffT6VlYfvb6V1Uevb2X10etbWX30+hZWf/QD1aH+peqj17ey+uj1raw+en0rq09Qf2H10etbWX30+lZWH72+ldVHr29l9dHrW1h9h17fyuqj17ey+uj1raw+en0rq09Qf2H10etbWX30+lZWH72+ldVHr29l9dHrm1j9oDd4Jlj1rL5Hr29l9dHrW1l99PpWVh+9vpXVJ6i/sPro9a2sPnp9K6uPXt/K6qPXt7L66/b6ktnmmJwrXOtU2A8+1+qYK19nmYd1u2a8HNftP/FyXLeTw8tx4Z5ItNvFSvnS8qj9vjwaG6Qsj6XtbANB/pXlX7grAvlVWLgtAvlVWLgvAvlVWLgxAvlVWPhbUJBfxYW/BgX5VVz4e1CQX8WFvwgF+VVE129p+Qnyryw/un5Ly4+u39Lyo+u3tPzo+i0tP7p+K8uf0PVbWn50/ZaWH12/peVH129p+Qnyryw/un4zy1/a9Cah67e0/Oj6LS0/un5Ly4+u38Ly3yYO+VeWH12/peVH129p+dH1W1p+gvwry4+u39Lyo+u3tPzo+i0tP7p+S8uPrt/K8mt0/ZaWH12/peVH129p+dH1W1p+gvwry4+u39Lyo+u3tPzo+i0tP7p+S8uPrt/K8ht0/ZaWH12/peVH129p+dH1W1p+gvwry4+u38zyF4660wZdv6XlR9dvafnR9VtafnT9Vpbfouu3tPzo+i0tP7p+S8uPrt/S8hPkX1n+qXy/N7TLH4qKJrVdbZKzhatJqS1bSNExte5noWuaahn9iKRVSu+BxCJ3a/ZPEpGW8kkq7JCpaap1FPp/rP9UCyn0/1j/qZ6fQf+P9Z/qARr0/1j/dStp6P9L/6keoUH/j/Wf6hka9P9UfzfVQzTo/7H+Uz1Fg/4f64/+39r6o/+3tv4E/ZfWH/2/tfVH/29t/dH/W1t/9P/W1h/9v6X19+j/ra0/+n9r64/+39r6o/+3tv4E/WfWv7R/hkf/b2390f9bW3/0/9bWH/2/tfVH/29p/QP6f2vrj/7f2vqj/7e2/uj/ra0/Qf+l9Uf/b2390f9bW3/0/9bWH/2/tfVH/29p/SP6f2vrj/7f2vqj/7e2/uj/ra0/Qf+l9Uf/b2390f9bW3/0/9bWH/2/tfVH/29p/RP6f2vrj/7f2vqj/7e2/uj/ra0/Qf+Z9S+dpJXQ/1tbf/T/1tYf/b+19Uf/b2390f9bWX+j0P9bW3/0/9bWH/2/tfVH/29t/Wld/bWKWyDahcLVFNIWCEVSh6vtF8mFO2nMJBfuSTGTXLi7w0xy4T6JDjtJY0okjfb7OmlskLJOFvbJvf1/0H9l/fXCfRLof9N/4T4J9L/pv3CfBPrf9F+4TwL9b/oT9F9a/5W7O9D/Nivov7T+K3fSoP9NaOi/tP7o/y2tv0H/b2390f9bW3/0/9bWH/2/tfUn6L+0/uj/ra0/+n9r64/+39r6o/+3tv7o/y2tv0X/b2r9C/vkGIv+39r6o/+3tv7o/62tP0H/pfVH/29t/dH/W1t/9P/W1h/9v7X1R/9vaf0J/b+19Uf/b2390f9bW3/0/9bWn6D/0vqj/7e2/uj/ra0/+n9r64/+39r6o/+3tP4O/b+19Uf/b2390f9bW3/0/9bWn6D/0vqj/7e2/uj/ra0/+n9r64/+39r6o/+3tP4e/b+p9S+dk+fR/1tbf/T/1tYf/b+19Sfov7T+6P+trT/6f2vrj/7f2vqj/7e2/uj/La1/GNz/u+Q2kULUBf1tiLui8RA2KZUL29qwRX27fL86xszFZDc9KR54OPWFcXAbLQUjASMHxsFNnRSMg3sjKRgHtxhSMA5eqY+C0blths7nMA5e8ArBGAd/bjwMxqA2jCFlMA7++FUKRriY9zCmbYnxymYwwsWwYCRg/BCj1hmMcDEsGOFi3sLowwbER5XBCBfDghEu5j2McQvaJ8pghIvhwJjgYt7CeHvysoWhYwYjXAwLRriYTzEan8EIF8OCkYCRAyNczHsY0xZ0VLmVGi6GBSNczFsY4/6hjtmVGi6GBSNczHsYrd0wknnCaBVcDAtGuJhPMTqVwQgXw4IRLuYtjElv16ZM+W0VASMHRriY9zDaDUgincEIF8OCES7mPYz7d3iSz32o4WJYMMLFfIoxPLcmrIaLYcEIF/MWRq3c9pWyW6CZAlzDxzCBXNjJkNkC0XT4QVoWpNVxA2l1elxsfC7qWy35mOPhO5G3+2g2bLV9SciGQ0n16+q7SASRxhdpYRcmR6SFPZ4ckRZ2kHJEWtifyhFpYfcrRiSzsLeWI9LCzl2OSAt3BeSIhI6DAJEIIo0vEjoOAkRCx0GASOg4CBAJHQcBIqHjML5IFh0HASKh4yBAJHQcBIiEjoMAkQgijS8SOg4CRELHQYBI6DgIEAkdBwEioeMwvkiEjoMAkdBxECASOg6XiGTMfjXFgkhR+8cBMupxdf5IGApq+zE5Bf3Y28A6/yUp+hPTSUqQdDZJ0fuYTlJ0SqaTFH2V2SR18I7iJN03Orz96TOSouKVJmlU26/O6XZ5RlKCpN0lHeVgU50eqh/Ohd0ONrUOtTSS5e1kQZWOZHk7WVD/I1neThY830WyvJ0seM6MZHk3WTx6FkiWt5MFz92RLG8nC57/I1neThb0WZEsbycLIVmQLO8mCzq4SJa3kwUdXCTL28mCDi6S5e1kQQcXyfJ2sqCDi2R5N1kCOrhIlreTBR1cJMvbyYIOLpLl7WRBBxfJ8nayEJIFyfJusqCDi2R5O1nQwUWybMoY+1CdTCZZ0MFFsrydLOjgIlneTZaIPguS5e1kISQLkuVLmaA3GU2wKpMscENIlreTBW4IyfJ2ssANIVneTha4ISTL28mC77MgWd5NloTvsyBZ3k4W9FmQLG8nC77PgmR5O1nwfRYky9vJQkiWt5LFmG1zPmtjLCSLmC8dJPRkl5YfXdal5UffdGn50QldWn70NheW/wYG8q8sP/qPS8uPjuLS8qNHuLT8BPlXlh9dv6XlR9dvafnR9VtafnT9lpYfXb+V5dfo+i0tP7p+S8uPrt/S8qPrt7T8BPlXlh9dv6XlR9dvZvlNTJuOVpmM/Oj6LS0/un5Ly4+u38ryG3T9lpYfXb+l5UfXb2n50fVbWn6C/CvLj67f0vKj67e0/Oj6LS0/un5Ly4+u38ryW3T9lpYfXb+l5UfXb2n50fVbWn6C/CvLj67f0vKj67e0/Oj6LS0/un5Ly4+u38ryE7p+S8uPrt/S8qPrt7T86PotLT9B/pXlR9dvafnR9ZtZ/sJRTkTo+i0tP7p+S8uPrt/K8jt0/ZaWH12/peVH129p+dH1W1p+gvwry4+u39Lyo+v3nvxkd/kp6oL8Vqv9ak0Hfll8gTbYOvjDxSFz8c2qf13rnT1eelcTTbyZ1ERPTpaauzD+sEDsaqLFJkxNteFQz59Nj47Zm2rq9FDTFNR0ai9XnKJwVPNOHY2qHtTRH+pBHW2ZHtQJ1DtQRxOiB3V4/x7U4dF7UIeX7kEdnrcD9QBv2oM6vGkP6vCmF1CnlOJO3aW/v+yq3TqbWxf7Zp/Us0QwssNLRJBodIlgkYeXCH56eIlgvoeXCE59eIlg60eXKKIHMLxEaBgMLxG6C2NJZJ8lQndheIkIEo0uEboLw0uE7sLwEqG7MLpECRVdhUS+IJGm/VvYmmx8LZFXtL20V0m9vljfrtiuvv3t/LOiKABnU5Sg6GSKorycTVFUo7MpiuJ1NkXxJE20oulZUTx4m0tRp/CcbjZF8VhvNkXRM5pNUfSMJlPUrLyOqnii6B3NygtSAc3Kd/YCmqlukdHRjiaoEhqttq1ftD5M0urc1aT37diIHtdmX/nCjd50egij0rer73oS9JxKz6la6tDTTNVQh55mqnY69DRTNdOhp5mqlQ497VQNAOhpp+paQE87VasFelr0h+bSk6DnVHqiPzSXnugPzaUn+kNz6Yn+0Fx6oj80lZ6E/tBceqI/NJee6A/NpSf6Q3PpSdBzKj3RHxKlp4nbF6CNVSajJ/pDc+mJ/tBceqI/NJee6A9NpadDf2guPdEfmktP9Ifm0hP9obn0JOg5lZ7oD82lJ/pDc+mJ/tBceqI/NJee6A9NpadHf2guPdEfmktP9Ifm0hP9obn0JOg5lZ7oD82lJ/pDc+mJ/tBceqI/NJee6A9NpWdAf2guPdEfmktP9Ifm0hP9obn0JOg5lZ7oD4nSM+iNtAlWZfREf2guPdEfmktP9Ifm0hP9oan0jOgPzaUn+kNz6Yn+0Fx6oj80l54EPafSc67+UNpfOhkq6Gn3V6ZDGPkDWLOXakpfEKdqyiS7fShI+RLEaPR2dTROF1K340ZbcapGy6QaTdU8mVSjqRoic2qUpmpyTKrRVI2LSTWaqhkxqUZTNRgm1Yig0fAaTdUImFQj9BnG1wh9hvE1Qp9hfI3QZxhdI6/QZxhfI/QZxtcIfYbxNUKfYXyNCBoNrxH6DONrhD7D+BqhzzC+RugzdNeo8ANJr9BnGF4jjT7D+BqhzzC+RugzjK8R+gzja0TQaHiN0GcYXyP0GcbXCH2G8TVCn2F8jdBnGF4jgz7D+BqhzzC+RugzjK8R+gzja0TQaHiN0GcYXyP0GcbXCH2G8TVCn2F8jdBnGF4jiz7D+BqhzzC+RugzjK8R+gzja0TQaHiN0GcYXyP0GcbXCH2G8TVCn6G7RoWNg71Fn2F4jQh9hvE1Qp9hfI3QZxhfI/QZxteIoNHwGqHPML5G6DOMrxH6DMNr5Iaq6+4hDVXG3EPqu2rbUibruCenjhQfyWm+4nfC4/fC4w/C44/C40+y4/dKePxaePxGePxWePzC118vfP31wtdfL3z99cLXXy98/Q3C198gfP0NwtffIHz9DcLX39B8/bXabiclW51U4bWNNdtsDVGpXSRm88/ggb0H9gDsPbBHYO+BPQF7B+xRAXsP7BrYe2A3wN4DuwX2HtgJ2Htgh0vtgh0utQt2uNQu2OFSu2CHS+2BPcGldsEOl9oFO1xqF+xwqV2wE7D3wA6X2gU7XGoX7HCpV2AvbX+R4FK7YIdL7YA9KLjULtjhUrtgh0vtgh0utQt2AvYe2OFSu2CHS+2CHS61C3a41C7Y4VJ7YNdwqV2ww6V2wQ6X2gU7XGoX7ATsPbDDpXbBDpfaBTtcahfscKldsMOl9sBu4FK7YIdL7YIdLrULdrjULtgJ2Htgh0vtgh0utQt2uNQrsBc2og8GLrULdrjUHtgtXGoX7HCpXbDDpXbBDpfaBTsBew/scKldsMOldsHe3qUaYzfsJpoSdu137MYGKdgLPwcO7Y9lB/Zf2BOwd8De/vB0YP+FXQN7D+wG2Htgt8DeAzsBew/sDth7YPfA3gM7XGoX7HCpXbDDpfbA7uBSu2CHS+2CHS61C3a41C7YCdh7YIdL7YIdLrULdrjULtjhUrtgh0u9AnvpZwUeLrULdrjULtjhUrtgh0vtgp2AvQd2uNQu2OFSu2CHS+2CHS61C3a41B7YA1xqF+xwqV2ww6V2wQ6X2gU7AXsP7HCpXbDDpXbBDpfaBTtcahfscKk9sEe41C7Y4VK7YIdL7YIdLrULdgL2HtjhUrtgh0vtgh0utQt2uNQu2OFSr8Be2qItwaV2wQ6X2gU7XGoX7HCpXbATsPfADpfaBTtcahfscKldsMOldsHewaWm7WJrD1uD/3rtXyFFZcYLyY4XErUOiZTdXpuUK31eXl19n4CTPgE/9gR8dNs9yMegD698Dz/IDj/KDj8NHn5S25Lkkwl/Dl8r2eFr2eEb2eFb2eEPvvKWwh983S2FP/qqWwh/9FW3EP7oq24hfNmrrpG96hrZq66Rveoa2atu+1PoecOXveoa2auukb3qGtmrrpG96lrZq66Vvepa2auuHX7Vpb1Nldxz+MOvuq/DH37VfR3+8Kvu6/CHX3Vfhz/8qvsy/KuPkby/SfPbm7l9qL8utkrbwmu75OLX1eHm/verfz1kfbrYhrhdbOMhbFIqFzbtRxxrCo8HsTHmXlrHw+nJh6e2PvvwTxmzX01xv9pqNfKzZqu25+nGav3t6nuyEJIFyfJusjgkC5Ll3WTxSBYky5cyhR/mxPbHIyJZ5CZLRLIgWd5NloRkQbK8mSztD9BEsshNFo1kQbK8mywGyYJkeTdZ0MFFsrydLIRkQbK8myzo4CJZ3k4WdHCRLG8nC/os/ZNF+0eyqFiQn0Lawr79+YjEuq8vEnh0Q6RJGve7BR2JPCRFz0KcpPuOCBStyUiKzsJ0ksL/TycpQdLZJIWXnk5SON7pJMU3i8RJqsIuqVEZSfH9n+kkRfdoNkkDukfTSYru0XSSons0naToHk0nKUHSySTNH1dwm+E+6hG+TvprENUMcjWDsp0Qp7eEc8Z+G5TLoMfmzDEedsuNX+8QLn+HePk7pIvfISl1+Tvoy9/BXP4O9vJ3oMvfwV3+Dv7ydwiXv8PVn+mU3wnV7fs6OApPt8uU3wHThX0zCFKZQbHmnfK3nH39dZ6eB+U3KXRxW/5csplBumaQqRlkawZRzSBXM8jXDMp/FPb6xKWcTrFmUKoYZNXrQV5l5pTftsqFtA+KmUHZjPB6o+dtygyyhXfKfZ7yGyMVPoT57YhKg2o+7vnNX7Rx26S08RkUpOuGmbphtm4Y1Q1zdcN83bBQNyzWDUtVw9xJlsSwDzt8sfMxTJeH+cwwUzfM1g2jumH5LLnZt22Yzd148l9fLg8LdcNi3bBUNSz/1czyMF03zNQNO9HN73LbkFll8o/39KPG044yn4BwgiTtnzdSLjNMl4dlPqbB1A2zdcOoblioGhbzJI+NGKszw3TdsDxJ8mof5jM3hfwx7bdrH3MLmUU4ncxt/yr8rRGUycmk64aZumH5LKFE+ydA5eZGdcNc3TBfNyycfLp33ZzJfExTrBuWKoIMSqm6YbpumKkbZivuk7dhVDfM1Q3zdcNSxZ0rKF1z57oN03XDTNWwkPdrZpuaez4TLqj8Pbk0SNcMMjWDbM0gqhnkagb5mkGhZlCsGVSTEfmVzKWtuPKHRyuPQbpmkKkZZGsGUc0gVzPI1wwKNYNizaD0+SCtVM0gXTPI1AzK39MfD+FuzxYzw07u6cVh+Xv6zalsw46P/B7DTN0wWzeM6obl12LtdyQ65pCcWNT08GMp926paphRdcN03TBTN8zWDaO6YSc1lFGPYihkhvm6YaFuWKwblqqG5fvQ5WG6blg+S9zDNLqYMsNs3TCqG+bqhvm6YaFuWKwblqqG0Vnfah9mTebzRqZumK0bRnXDXN0wXzcs1A2LdcNS1TCn6obVZYmry5KTHrjdH9/ePsiZW9BJD7w4zNUN83XDQt2wWDcsVQ3zdQWGryswfF2B4esKjJNfLb0+Of72X/MC+Ecv1Yfcu6WqYScd9+IwXTcsL0AI2++/dEgmM8zWDaO6Ya5umK8bFuqGxbphqWrYydOE4jBdN6wuS2JdlsS6LIl1WRLrsiTWZUm+k6XTY1lMJjcsVQ3L95hM1Nv3mkz0jxte/qvC0e6d12gPz4zyVxe+oXsLyY4XEo0XkhsvJD9eSGG8kOJ4IaXRQjL5nmrfkPR4IQ139zaK4+5t9u94RtKhdPWHu6/t5+fQrXuWmQBJn4CTPgEvfQJB+gSi9Akk4RPQSvoEtPQJGOkTkL4Sa+krsZa+EmvpK7GWvhJr6SuxGX4deLkb820Co9+FSo7MtL8LjbJ5uk6PjRrU8/NtYzzQnKEJQHOGJgLNGZoENCdorAKaMzQaaM7QGKA5Q2OB5gwNAc0ZGlTDp2hQDZ+iQTV8igbV8CkaVMNnaAjV8CkaVMOnaFANn6JBNXyKhoDmDA2q4VM0qIZP0aAaPkWzbjV8a+PtaMhk0KxbDZfQuHWr4SKadeuaIpp1V6jCD/KMW3eFKqJZd4Uqoll3hSqh8euuUEU06/ZrimjW7dcU0axb1xTRENCcoVm3X1NEk62Grdp/AG3VYU+v/GS19nr/dbb2pgTHmH03tFu1/tj6y97+vgcVOIJyj31rtT8cnSG8V5LfNQNw7nAS4JzCye+AAjh3OBpwzuEYwDmHYwHnHA4BzjkcBzjncDzgnMNBhfwCDirkF3BQIZ/DiaiQX8BBhfwCDirkF3BQIb+AQ4BzDgcV8gs4qJBfwEGF/AIOKuQXcFaukG+z3+BYlfn2VFq5Qi7CWblCLsJZuUIuwlm5Qi7CIcA5h7NyhVyEs3KFXISzcoVchLNyhVyEgwr5FI5VqJBfwEGF/AIOKuQXcFAhv4BDgHMOBxXyCziokF/AQYX8Ag4q5BdwUCGfw9GokF/AQYX8Ag4q5BdwUCG/gEOAcw4HFfILOKiQX8BBhfwCDirkF3BWrpALv8q1ZuUKuQhn5Qq5CGflCrkIZ+UKuQiHAOcczsoVchHOyhVyEc7KFXIRzsoVcgnOwkcf2f14RHNriGbQrLt5WBHNupuHFdEsvClqwY0vfPRREc26m4cV0ay7lW4Rzbpb6RbRLLzZewnNwpu9F9AsfPRREc261XARzbrVcBENquFTNO3rms8Orw9pQ3P78zHd7fB62+Gomc8mEPdMuP2ZMhOIo0/A2H0C1mQmkIRPoMPhKswT0NInYKRPwEqfAI0+ARX2CRiVmYCTPoHRV+LiBIZfiUsTGH4lLk1g+JW4MAE//EpcmsDwK3FhAvkdgQJtEQXyzyYiv9/Jw9QkFzODbM0gqhnkagb5mkGhZlCsGZTVSav9uAmtvHsaRvlfbJeH6bphpm6YrRtGdcNc3TBfNyzUDYt1w+qyRNdlSf4nK6/vHZT/KUfab1PJ5AZV3AYo/wXu0jvFmkGpYlD+i7ClQboChDE1g2zNoLxOfsuIFDJplP8CWmmQrxlUul1nB8UaEKliUP5bMaVBNRlhazLC1mSErfnkWlczyNcMCjWDPs2I27/0ryvzv7eJai//Dh/5X4Xg06WettrPO3u89BZX/nbH9eLxpy8et50pfYx/fvH04xdX25Kj/hx5/jbL8uK3f5hfF1I2Xd1+WK8Lh7cg+yuqfBv+9ZDw+ZD4+ZD04ZDbv+yvK/N3cW+3xxFRPe6t2qbf0vjPh4TPh8TPh6SPh+Tv3a+HZO/c0exDDt8P3YaYz4fYz4fQ50Pc50P850PC50PyN664e+iUvg3JPH7z233dBvr7w0DfXz5d+vL5bwbwvby+9uXNtS9vr315uvbl3bUv7xlfPtqnlw/Xvny89uXz1bnZvrSebPjzfST/zPD1EP35EPP5EPv5EPp8iPt8iP94SP5w1NdD4udDPlc/fK5++Fz98Ln6+QP6zG5FjA9/Tv78sXWvh7jPh+SfboWtu2HS06cyf/DX6yHx8yHp4yH5o5NeD9EfDrn9i+AlbneN3z45O5DC5tm8ocNAfRt4++f/+0//8dd/+ue//et/3ob8+q//99/+5b/++u//9vXP//r//s/2X/75P/76t7/99X//4//5j3//l3/9X//3P/71H//27//y67/9RX39z/+8OT3zR1DO/sNv5/4/bw96wh+3hyXuH367ndt/vz3gCcrEX//91wAKPv5BIfwe8HuE8ul2RdAP8//rOkN/mLQbx18vdXsjMtvLOP2H87ul+v1/efWHd9urxvBHTHuunA93jzfUf5jb//X3G6P/Hw==","names":["repay_private"],"brillig_names":["discover_new_messages","decompose_hint","store_in_execution_cache_oracle_wrapper","call_private_function_internal","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","directive_invert"]},{"name":"deposit_private","hash":"13431218909836776948","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"field"},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","names":["deposit_private"],"brillig_names":["discover_new_messages","decompose_hint","store_in_execution_cache_oracle_wrapper","call_private_function_internal","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","directive_invert"]},{"name":"deposit_public","hash":"10150626329462612454","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"field"},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["deposit_public"],"brillig_names":["deposit_public"]},{"name":"_liquidate","hash":"6856466024572346970","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debt_token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"user","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debt_to_liquidate_amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"1840251649407153602":{"error_kind":"string","string":"Insufficient borrowed amount"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14434150440419769526":{"error_kind":"string","string":"collateral >= debt"},"15333773746166717806":{"error_kind":"string","string":"Insufficient collateral"},"16523063005220065570":{"error_kind":"string","string":"Function _liquidate can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_liquidate"],"brillig_names":["_liquidate"]},{"name":"_deposit","hash":"404334594737014563","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"951653053333916160":{"error_kind":"string","string":"Deposit cap exceeded"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5235018679007078561":{"error_kind":"string","string":"Invalid asset or market id"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"16022896159229267359":{"error_kind":"string","string":"Function _deposit can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_deposit"],"brillig_names":["_deposit"]},{"name":"sync_notes","hash":"6029861944564366081","is_unconstrained":true,"custom_attributes":["aztec::macros::functions::utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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sld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV/ciey37NwxdEXdw2osq2bf0c6X4X0472sq30YNCbsMppobzKivWGo6zNRxvazjB1nDE1nBWW8OJtoaTbA3H1lU527oqF1tX5WLrqlxsXZWLratysXVVLrauyuXTV+XTZ1zdxpOMjScbG08xNR6/LMbG44yN53gD9Vtj/3Wa926tjOeWBzyepBzT3+9ecHuT8Ik3kU+8ydrkTUJ8vEkMT29y8Iu8HLaNgcLyvO/Tcryd6rLvubaEx2/vi/8afzQ+/nXnH9cQvo8/dT7+3Pn4S9/jP/7iQ0fjd52P33c+/tD5+KXz8Vu//9bG3/n913V+/3Wd339d5/df3/n913d+//Wd33995/df3/n913d+//Wd33995/df3/n913d+/w2d339D5/ff0Pn9N3R+/w2d339D5/ff0Pn9N3R+/w2d339D5/df6fz+K53ff6Xz+690fv+Vzu+/0vn9Vzq//0rn91/p/P4rnd9/187vv2vn99+18/vv2vn9d+38/rt2fv9dO7//rp3ff9fO779r5/ff2Pn9N3Z+/42d339j5/ff2Pn9N3Z+/42d339j5/ff2Pn9N3Z+/02d339T5/ff1Pn9N3V+/02d339T5/ff1Pn9N3V+/02d339T5/ff3Pn9N3d+/82d339z5/ff3Pn9N3d+/82d339z5/ff3Pn9N3d+/y2d339L5/ff0vn9t3R+/y2d339L5/ff0vn9t3R+/y2d339L3/ffsPR9/w1L3/ffsPR9/w1L3/ffsPR9/w3m97+qjb/v+2/ofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1Xo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","names":["sync_notes"],"brillig_names":["sync_notes"]},{"name":"get_total_borrowed_assets","hash":"9396283747648448687","is_unconstrained":true,"custom_attributes":["utility","view"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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6HGzYuhxs2LocbNS6ANuVgw9blYMPW5WDD1uVgy9nxm98xt6l2Lt6JhX8u62sPoE3txRTu1O26Kc2m22RTm1e2yLcmo32Bbl1O6uKco4tVtri3Jq99UW5dRuqi3Kqd1RW5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKhNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKjNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKgttphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxHKvOB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFsuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mEsiy4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4nZaoTS4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4na+i9K7xX4c7V2In1DujMSnFYkJ5mkkeW/ccckfB0f79Mk5/BbJ4qM6EAmH1oFIeL8ORMJVdiCSRyT9IuGEOxAJj92BSLj3DkQiF+hAJBIH/SI5EocORCJx6EAkEocORJo7ccjr0c7b8Ono33A8cI7hzO2wK3DmdrYVOHM7ygqcuZ1cBc7cDuocjp/buVTgzO0YKnDm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KnHXqsRdqxJ3rUrctSrx16rEX6sSf61K/LUq8deqxF+rEn+tSvy1KvHXqsRfq5JwrUrCtSoJ16okXKuScK1KwrUqCdeqJFyrknCtSsK1KonXqiReq5J4rUritSqJ16okXquSeK1K4rUqideqJF6rknStStK1KknXqiRdq5J0rUrStSpJ16okXauSdK1K0rUqydeqJF+rknytSvK1KsnXqiRfq5J8rUrytSrJ16okX6uScq1KyrUqKdeqpFyrknKtSsq1KinXqqRcq5JyrUrKpSoJy3LtNHPtNHvtNHftNH/ttHDttHjttHTttHzttGtVci17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwkL2W7QlDU7zZOe1oH9VtY83ytLPpr9P2XvnW6oXS4SjTlRpO0DWcqGs4Sddwsq7hFE3DiUcZv9RwjK7hWF3DUXVVjouqq3JcVF2V46LqqhwXVVfluKi6KsdF11XZ6Loqm3dfleO2y8qy2J3xWGXjccrG45WNJygbT1Q2nv0N1E1e9xmx9um1j/vjMTEtj7cepC+7F8T99d7WX1Le8CX7a8k//hIXH18S3dOX7PwiL7t1YyC3PO/7tOxvp7pse64t7vHb+2I/xm+Ujz9s/ONttfPr+G3n43edj993Pv7Q+fhj5+NPnY8/dz7+0vf4nfb7b238nd9/Xef3X9f5/dd1fv91nd9/Xef3X9f5/dd1fv91nd9/fef3X9/5/dd3fv/1nd9/fef3X9/5/dd3fv/1nd9/fef3X9/5/Td0fv8Nnd9/Q+f339D5/Td0fv8Nnd9/Q+f339D5/Td0fv8Nnd9/Y+f339j5/Td2fv+Nnd9/Y+f339j5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","names":["get_total_borrowed_assets"],"brillig_names":["get_total_borrowed_assets"]},{"name":"get_position","hash":"11038975716457282617","is_unconstrained":true,"custom_attributes":["utility","view"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"position::Position","fields":[{"name":"collateral","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"scaled_debt","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"debt","type":{"kind":"integer","sign":"unsigned","width":128}}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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lLKSMk0pKynTlLJGZJ1RVlKmKWUlZZpSVlKmKWUlZZpSVlKmGWWNpExTykrKNKWspExTykrKNKWsEVlnlJWUaUpZSZmmlJWUaUpZSZmmlJWUaUZZEynTlLKSMk0pKynTlLKSMk0pa0TWGWUlZZpSVlKmKWUlZZpSVlKmKWUlZZpR1kzKNKWspExTykrKpERWH9OGsJ7JGtsma1qW9l1WUqYpZY3IOqOspExTykrKNKWspExTykrKNKWspEwzylpImaaUlZRpSllJmaaUlZRpSlkjss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLJWUqYpZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrKNKOsjZRpSllJmaaUlZRpSllJmaaUNSLrjLKSMk0pKynTlLKSMk0pKynTlLKSMk0o6+1/Q9YZZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrKNKOsjpRpSllJmaaUlZRpSllJmaaUNSLrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oqydlmlJWUqYpZSVlmlJWUqYpZY3IOqOspExTykrKNKWspExTykrKNKWspEwzyhpImaaUlZRpSllJmaaUlZRpSlkjss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLJGUqYpZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrKNKOsiZRpSllJmaaUlZRpSllJmaaUNSLrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oayZlmlJWUqYpZSVlmlJWUqYpZY3IOqOspExTykrKNKWspExTykrKNKWspEwzylpImaaUlZRpSllJmaaUlZRpSlkjss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLJWUqYpZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrK9HNZ8+I2WcvzxHdlvX2k26A8y/qiCOqyFkFx7exov7T1aO/Lb0f/krWRMk0pKynTlLKSMk0pKynTlLJGZJ1RVlKmKWUlZZpSVlKmKWUlZZpSVlKmCWXNCynTlLKSMk0pKynTlLKSMg0pawxhPTrWs1uEOfqvg3N+lEDIe6tsj5uPy9M09g/Objs6+7ScHO2Ky1tVlb/uTx5/ett45+aearfu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SMvwK3DDr8APv4Iw/Ari8CtIw69g+GtyGv6KlvRf0Q53HvDL/r65vuS6/rDDl+LiY9xXR7i/o+wPxsXOcalzXO4cVzrH1c5xrW/c/rPrPxjnOsd11kvprJfSWS+ls15KZ72UznopnfVSOuul/qRefP0+znWO853jQue42DkudY7LneNK57jaOa71jWud9dI666V11kvrrJfWWS+ts15aZ720znppP6mXmL+Pa13j3LJ0jnOd43znuNA5LnaOS53jcue40jmudo7rrBfXWS+us15cZ724znpxnfXiXtRLXcI27jnXTXuxrstly3Xz0702l+vO0f72P6+f7erj6LznK1yLbT14ceX44OJWF1Xyk71Je8fGun5uet6tLpUvLtkqF7cWTAplh0uByy6XCpddLg0ue1z8ApddLg4uu1z8TFyWB5d2wiX4x6Nf4SloCGFvA9RbP7ryuLWYj88Oae/o6tY51xBPjs2bPjnk34696xPQR7U+EX1+pE92mz5l2eE4lV8Q5DiVvxDkOJUfEeQ4lX8R5DiV35HjGKbyR4IcJfxU2jj6JT6juU/J65tS0DelqG9KSd+Usr4pFX1TenVxr26b0vPOAOvNgdD6xsWlc5zrHOc7x4XOcbFzXOoclzvHlc5xnfUSO+slddZL6qyX1FkvqbNeUme9pM56SZ31kn5SL/77TcRUO8e1vnF56RznOsf5znGhc1zsHJc6x+XOcZ31kjvrJXfWS+msl9JZL6WzXkpnvbz68WLbrISvi6uDmKXrbuK/+nHm/FyObya9+vGpeS4FLrtcKlx2uTS47HF59eNv81zcTFzmu0n86iEC9FGiTxDQ52W0tqdP8+tif72LJm2H+1a/lhDHX0Iafwl5/CWU8ZdQx19CG34JbdG9hFja+tRyrKHuLMCNvgA/+gKUX5fPF6D8qny+AOXX5PMFKL8iny9g/3pcl7h9SXVL+Pd/zG5fPDh5Pq51jfMvHpw8H+c6x/nOcaFzXOwcl16NK49xPn0flzvHvagXt3krX/2Sv4+rneNa37gXD06ej3Od43znuNA5LnaOS53jcue4znpxnfXiOuvFd9aL76wX31kvvrNefGe9+J/Uy9Nmi9u43DmudI6rneNa37iwdI5zneN857jQOS52juusl9BZL6GzXkJnvYTOeomd9RI76yV21kv8Sb2E+n1c7ByXOsflznGl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stfYl73Gvuw19mWvsS97jX3Za+zLXmNf9hr7stf4Intt2y8MXYtuZ9iLKtm29HPPr4j5Nez7zxjrsj4rW8PjMdHbfeOdY1td3xDT2u/H3qcTdE0n6ppO0jWdrGs6Rdd0qq7pNFXTeXXvQGo6Ttd0dJ2Vg66zctB1Vg66zspB11k56DorB11n5aDrrBw/fVbO2y4ry/Pblbf5OGXz8crmE5TNJyqbT1I2n/0N1F1d9xnx3qWT+bhclm36uXzbvSDu3++9+kvqJ76kXfIlIT++JIenL9l5Iq+GdWOgsDzv+7Tsb6e6bHuuLeHx7H2776wU929qK5p/2vjnFML3+bvB5+8Hn38YfP5x8PmnweefB59/GXz+dfD5a7/+nsw/D379zYNff/Pg1988+PU3D379zYNff/Pg1988+PU3D379zYNff8vg198y+PW3DH79LYNff8vg198y+PW3DH79LYNff8vg198y+PW3Dn79rYNff+vg1986+PW3Dn79rYNff+vg1986+PW3Dn79rYNff9vg1982+PW3DX79bYNff9vg1982+PW3DX79bYNff9vg19829vU3LWNff9My9vU3LWNff9My9vU3LWNff9My9vU3LWNff9My9vU3LWNff9My+PXXDX79dYNff93g1183+PXXDX79dYNff93g1183+PXXDX79dYNff/3g118/+PXXD3799YNff/3g118/+PXXD3799YNff/3g118/+PU3DH79DYNff8Pg198w+PU3DH79DYNff8Pg198w+PU3DH79DYNff+Pg1984+PU3Dn79jYNff+Pg1984+PU3Dn79jYNff+Pg11/1+1+dzH/w/a/S4PtfpcH3v0qD73+VBt//Kg2+/1UafP+rNPj+V2nw/a/S4PtfpcH3v0qD73+VBt//Kg2+/1UafP+rNPj+V2nw/a/S4PtfpcH3v0qD73+VBt//Kg2+/1UafP+rNPj+V2nw/a/S4PtfpcH3v0qD73+VBt//Kg2+/1UafP+rNPj+V2nw/a/S4PtfpcH3v0qD73+VBt//Kg2+/1UafP+rNPj+V2nw/a/S4PtfpcH3v0qD73+VBt//Kg2+/1UafP+rNPj+V2nw/a/S4Ptf5cH3v8qD73+VB9//Kg++/1Vexr7+5sH3v8qD73+VB9//Kg++/1UefP+rPPj+V3nw/a/y4Ptf5cH3v8qD73+V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","names":["get_position"],"brillig_names":["get_position"]},{"name":"public_dispatch","hash":"4728768962972240477","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"951653053333916160":{"error_kind":"string","string":"Deposit cap exceeded"},"1602191554767750373":{"error_kind":"string","string":"Function _borrow can only be called internally"},"1840251649407153602":{"error_kind":"string","string":"Insufficient borrowed amount"},"2830029349304997821":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"4270187767586857285":{"error_kind":"string","string":"Function _compute_total_collateral_value can only be called internally"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5235018679007078561":{"error_kind":"string","string":"Invalid asset or market id"},"6787403583199288031":{"error_kind":"string","string":"Insufficient balance"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8945853978429536226":{"error_kind":"string","string":"Function _compute_collateral_debt_value can only be called internally"},"10435052277855889085":{"error_kind":"string","string":"Function _withdraw can only be called internally"},"12348881442450494403":{"error_kind":"string","string":"Function _compute_utilization_rate can only be called internally"},"13135008234568508716":{"error_kind":"string","string":"Function _repay can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14434150440419769526":{"error_kind":"string","string":"collateral >= debt"},"14687457983715723088":{"error_kind":"string","string":"Asset is not borrowable"},"15333773746166717806":{"error_kind":"string","string":"Insufficient collateral"},"16022896159229267359":{"error_kind":"string","string":"Function _deposit can only be called internally"},"16523063005220065570":{"error_kind":"string","string":"Function _liquidate can only be called internally"},"17134621154673181869":{"error_kind":"string","string":"Function _compute_borrow_rate can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["public_dispatch"],"brillig_names":["public_dispatch"]},{"name":"compute_total_deposited_assets","hash":"17111342261467205514","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"deposit_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["compute_total_deposited_assets"],"brillig_names":["compute_total_deposited_assets"]},{"name":"_compute_total_collateral_value","hash":"12269064071142659555","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"4270187767586857285":{"error_kind":"string","string":"Function _compute_total_collateral_value can only be called internally"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_compute_total_collateral_value"],"brillig_names":["_compute_total_collateral_value"]},{"name":"_borrow","hash":"2817846743070341506","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"1602191554767750373":{"error_kind":"string","string":"Function _borrow can only be called internally"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14687457983715723088":{"error_kind":"string","string":"Asset is not borrowable"},"15333773746166717806":{"error_kind":"string","string":"Insufficient collateral"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1dTYhkWVa+8ZuVURkVkVVZ1W2LbhrEEcWIjMiMTBeS0l3T0z/OtD00btxEZUZqSTvdVFc3o4IGCuLOhQvFhTKgC2FwcKEg4oAMCm4EEYVx4eBG8AdRGByY2Uzfyncivvjiezffi3g3MjIrLiQv8t37zjn33HPOPef+ltxFqn7yV4LfPtXcfLIyJ8mzs1zqFgirE5PO0jWhs3xN6KxcEzqrkeicUS5PtG84z5SqS09Wube2Lp7byf9lyC+Qsd1twlsk/KPOQW9b1K9A+p/B9zDrceAfGPytOPA7Bvez4yl8rIvlV5Ln2+MpL9+Gb7ysNZPfpWmRCVzLK0Pe5yiv4uZhWx7K7E9RHsr5O0nerU/+dt309/clv7eJxhjyhvUsur3uCfrLUDefXhlP+WF4e53Dfn802B91e91hZ//40dFBp3/w6PCoe9Q9ODo42z/q9UZH/aPB8aPjQee42++NuucHx73zBK/BfnUcpV4TPX0I8F2BfDP4n45D/wT+a+N53neWTAb7M3F4M7HBr8fhzQT+G3Hg9w3+m+OieX84MNhvFQ/71GD/5PKw9/nFbXdh915OjKPZyq0pqhkbgk/nprYY35mdaQtYpreG51aBeBDWa4RnuwA8ZrMbkHeSPDvLpf020Yl4dpI6+jT8+Bc+98Hp+2ejnzg7ezL68MMS1ash6FcpD8zbOWC+yDA/+9F77z0+fzx68vCLjz98Ogd7R8C232Wn68Z0YTlMNcLxI8nTy8mnalOaW0zz50dfOBs9WSfWOqpKTdB0m/Ks7H7y9NX+YVJzZqlP24K2Is1wFrVD/A1R1yK7nRLhM3qYPyZmTTcvuvZtm/J8MlNUEnkV8a68YlhNN19/lgWsa5FhS1ZZMPwNF1U2uyG+3hZ8Nd41Ba1tyvOJ268p8DQFnusEy9wU1hODr56Gh9+lyS/qZsiWLYpH2dWQniyKB2FZyMEyVQQehGUumOn2Hcg7SZ6d5VLXYLeAtuL0tNsxHrXdfLK8XcC9Q3l3IY/l6B7kcdvvQV6T8u5D3h34zalC/yOffB/9o9BHczlLzzt/q/CbUxH8bbl5/qKNR95UBR6fTM9qVP6D5GltiHwscqgB28ARrudJfhaRkccLysgO5bVFPSxvV9RD9XMtysO+qU156BftUh7WBYeIuB+quPm2syGflkvvH/l/jlF8SvNfqynwWIes/G8kT99WX6KY5gr82MwxzcaPXQ2skO+57ebrehUxjeFvuKiy2Q3xVcWKxjvV97XdfD/H7dcSeFoCz3WCxTFNDN9c9WcxYg3V38aI0XzimKZVIB7la5luY79boF/TZd8Fk/Jd2IfN6rtw+6Dv26K8B5AXGqNUPo/xKW/cEWcsLr/fyPxF3jN/kffMX+Q98xd5X4PfnBR/jU95446GoMfsmIo70Mdin8nKfy15rkPc8TzIzyIy8nhBGWlSXlvUQ8UdaT4ewlf9B8cd6Ltw3IF2+rrHHV9PnmsSdxxn6TsR/ybu2MC6qbBizzeY/EaeHz2yetSBLvOj/btvAl7kRc1NeVcXdNeo/F5tCvNbybuW+H6H6h1pHnY/JAtID4+jYRtxf67itLhjnxf1QHxWD3yH+Btu3gbGsMkq/lU6xj4UftsWeTsr4evivl1JlL9s/PcPM/hhbG8YfxrPUa9fHV88W4LmNL8/DdYbBAu/b9N3uyl4sExb1AvzFXzWsThx+MUYm/+769J5gviV72vfKrnietyNU4/MtsLwN+LytRviK/KHbcU9QWtb5O2uhK/dHtOFScVsLL+O6o8J6c5rK1D+9ogXkdr0sCR4kUVXsG3uUT1CunIvTj0y64rhX5WuKL6GdGVP0NoWeXdXwtdun+nCpMbA8uqK0Z1XV1D+7hMvIrXpoCR4kUVXsG32qB4hXdmLU4/MumL4V6Uriq8hXbkvaG2LvHsr4Wv3gOnCpMbj8+qK0Z1XV1D+EH8WWebxwbagR8WkLMuR4uHMsszrhSNttQuuF0b+hOw+r/dQvkjkuazcdh/5yemyuaU8soxyZPht7MJijndLU9hfhqX8Wdfdh+qCKXJ/M1kneT8O/F4Wu4v4l52nVX1KpHGWYJ8SmtdP8/vTYO3lhBW5b5+0aTtQb2W7Fa2qHjYnovqDLGMS7QC/Wqvn10THHsSBP2mP+4IXWCfDH/ILs+qY4VqV36bqFmpn5beFYN3PCWtd7WZWf5V9pziy2R0YXS+4+WR5L8I7m2+1vO8BunhdxEuB774XvsvrAxsvfN/+lRx+A8rZi5SHvLc6Me99OkmenQVTb9g57g4Gg22io+B2Peb2cYIfLwmeZm0Do9u3wb/kaIMXIM/wtwQNrAsPiB5+F7IJD1K+Y7kviXehPt7qWxnP023bdKuQV6Td9Xz/Bq0vQD2tjWfzUA7qSV7bzeswx4aK7y8KXrRcOt+3BZ4Y84LKFmN9DP+Om7bdJA54Zfjee44SHyqF52Hw/x4BB78vAJPYAGHgclkyhhkcTDsAd7o/+aPT00+Cmlfe/+AXS07TyO9V2oE6TGC/M3r60ZMvnA2fDj//+JdGDGYvBXxFgOfxEPzO2hTlNqT3Jn9oT9mOv0T0nCT/d5ZL+yG7gTJv+C9hq2+1MrHkPlSXzeiLkOeoikpieDe8LR2w7/YC8PB3ZLb2QiKAzYz48emcdo0NnrnGkdz+iWv8kqA/1HVhfbCeabBeyglLuTyM5z7gCLngNuxiVuXPEkb7/7+c/FZLRribqYt61QP1wu/rBEtNRYdMhtoStYpp3bR6qyloeQrFO6OPR0+eOkqXmQ41spvVdPhvrYnjjurmi0ywnioyyevdWp28l/WgPoXL5Zge5K3RFnc1dXefZ8OcoAtH//OO0uLhZ5/KwQuUC8MfYwRWrdzgUShlEvBdaBRqN4CnvSQetYJmnWZzfeLIHXWJI/4XAt+hri4zQ/yVBVdTsH1A086RCo4OnyTPzoLpsHf06GjYP123Wfq8uxCwDfJE/Go0TK1Aw/bgNsgyao/ft1K+Q3oQlxqlVnqrIn5cheFTFfJiR/y4sqQ2ns1DOeCIP203CvcjFYGH3Sflrqxi9UKajKAcGP6VRfxtYFJaR3LDIv5WCvhQxL9LZe3JchvSxdDKmsij//shXVGDPAtE/CxJarFdURF/KwAPf1/lpAo2M+LHp3PZJpwjbWwMToaF3EC1UCkEK+tkWNqiTIUHF4CHJvA44r+dZPj/y8lvFfHzwve8ET9+zxG/UsOQyVBuxyoWp6bVW+n2EhE/mw5kV0jV0yJ+a+LI+zdyR7JtykPLi+LCSXm3uLdj0Yif1xiuyxkDy6zLyhPxh9QKxf4keXYWTPvHZwfDo/3zmzSysmhEdQ/gMw1oviPv6d+PbD57WUx9qMuzfPU0WJy3rntqVMTL3auCdTcnrMiD4JM23Q3UG/E3A7SqemRxE7LwxKfXxpfDUm2VJUpeJ5fDfk8Dy6fDp49Pi4iVeattA1iV5i3esFi5kQI+FCunWTBsOeeySaFq9VWN1SgtV7H7ArFyE6qbpmxFxcqNADz8vapFvkoE1BBYiZ7O6U5v1Zvjsm74CW2AC8HKujibO5lmAE8TcFTcvHVLi5XfhVj5rUCszNNKeWNl/D7L7HjIZKDJuoGz42w61DkSeWLldylWjnSOVaHnzOWdjcPzqBaNldNUynBy89tsYuhsK1ZFLpd2/onCjd/VCQaLZxneVwRuNR7gy58k/3eWTMzDqps/2w3p4XNefr48LYNtU3HzJox5gzKIeNk0IN5dwuvlqFuf5VUjAq/2B905XpVz1rEi+KfKtwVP1BDm3NnfAZ7UC+ZJ79Hx8HQ4lZ+G4MmOoDnEk0ag/GU82UnhyceCJyX6Jmu74JlvvGeQ64uw6inl03Tql4HmfgrNNfjudgaaq4JOnx6OZ2mw8r8KNAzATjMfzFZv7vWZt/8+4ew/y8jmXp+F0uZeH4FHhRDXCdbmXp/seNbhXp8iV7mZXq/b3Befw4txD8uROn9BrZzjWEqtiCy5+XTZXNvmXh/N35tyr89f0djA5l6fzb0+m3t9NDzWISv/jxDTbO71mVdA5q/Rw/y5qX5syPfc3OsTjhXVOh77lnfG+MTtt7nXZxYPv0uTX9Wfbe71Scezudfn4v/NvT6a95t7fWbLtxMCN/f6THHHlJ9FZGRzr896xx0/kDQgxh3r1udsUR7K7S3KQ7ndpjy0exyD40EKb41n8/BQEtW3W7qsP/qxBXeZ8xIelE1eF4zyzucgoh7jDq75hYRP338y/NnRO6PhWYnoTKs/l0uzGVnm6SItzcp8nq7hX9U8ndqlG5qnUzv11Xai1fA1vz4v49PlOU8X25R16Arkr/88yZ9P3EflPUUiNizlW7EsRPIpM4+pGP5VLVvNuoxS6XXangWfsuwzKHLPwlXA4jGVtN3g+DQ8/C5NfpXvEmuemPchLrrnSOFBWDymcrdAPAjr4fjiyftTfDpJnp3l0vG63cOwS3noy7IcqZNsLA9PneK+FA9jQ9+ck+rb8d6HPOM163LaDPNXjV0p3jN/kffMX+R93nliPN0mz3iNutfKbKTxpirw+GR6VqPyv0bjNZGOW5DjNXyPzvMgP4vIyOMFZYRPE9sT9VBn6YbiF74jCvsmPmMc/aL7lId9AI/XKN8X2y40XsP9of2fZbwG15YreKxDVv53xXjNFfqxmWOajR+7Glgh3zPy9qbMMQ3vP499bE3WY1TU+GLanY4+cfupLYvqhLHrBItjmhi+uerPYsQaqr+NEaP5xDHNvQLxKF9r3eIO9mGz+i7cPuj78lg3xh15xxQXjTsizfPl9huZv+ruPcV75i/ynvmLvL+KeWI+ykvFHaF5Yiv/T2sUdzwP8rOIjCw6T3yX8tRdXyruCJ2vwvPE2H9w3KFO4lV2+rrHHf8l4o68c4fIR0d5+Dtky5EmVf6OW4y2Rkba0s5faxJ+LBP7jKosfgTibxCtBdMTjMGQP4vEYChH63ZOGvKTk7J/eE5annlN1CPuI42GtL37aWdHVaD8nUD5RffEl6rTuvJe5/olNLRT6oh4SgGa7ft6Svk7BGtSHmi2vc6VwPc+ebtj/QDbnZ9+8vjpyFEqw28PjBeUlkQ5TDzZ7dy84Ymk6JkHfwx/w80zL4bhuUP0MH9CC8Pt2+u4MDxLJxRng1T2wR/Dv6pOSPE11Am1Ba1q0pLbTzl0asDxOsHiwZ8Yi91RN0O2bFE8yg6F9GRRPAiLB39iTZw/HF882RHy6SR5dpZLg7iDxt2eGiCzxEEtyo0KalmOMKjlts87IFVy80k5dcanvANL6+LEMn/5EmPMQ94zf7MOKOSd0EanOc/Akgp4SwSzKujyyfSMndpPJ4UiT6zIgSU+bLUaBXf+xZ0sPxygYB7KFsuPmiTOKiPGi7wDS2rju9pkUKK8u6Ieqp+rUh62Jwe86BfxJBT2ATywhHKrJrt4YKkk6OP/OWjyif0MozerDln5n4EgizcgrItN5A0IKLe8AQHlljcg8O2QmIdXjL05ns3D/ijvQDzayzwbENTiHvabkBehTQbKtzZexNqAkGYzjJYt8a3J3S14fxUDdYa/QbQWTM8kRrpF9DB/OEbaFrS2Rd5q+Lr4hqKsOmR0F7EBoeTm+ZtlEMtoSBvE2iJYVv5XMg5iIT1LD2JxwFMS5RwhbDPClPsz0wwAp20XVXk6Bn87DvxeFuVUnQxf3aaeBovz2PDU49QtaHhCB0CjAUEepMG6lRNW5A6gp5Sf6434W6KubBgUrK1Aveurr3c38s6qCV+3BS+wThyIKicgq64YrlV10qpuoXZWnXQI1nZOWOtq/xZ1TuLUI98Ofp/SdsOg7qpBs9fpOwxS8jo8xou89xKjfvBKEZRBXrWhbF/JzfcHefsIKxfZF7hS+4Z1Yvu2jC/A9i22L6DqFmpn1Ff2BZaxb9wnxrZvl/kCIfu2FahHeSX1yH9CSYny0L7xYEpW+5b3hrpF7VsZ8ti+oQyyfUO9YlllPeR3LKv8vfrO2thR2YrAVRa4jBd4HzjqhU/V8Syuk+R9Z7n07D7w79Cp7mgHauPZPPQP6kme6guMN6pN2KfO2yZ1gScEqyJgKZ5j/+VTFfJi8xzlgnmONot5jnk2SLzt5ut9siTtR6fHo4P+YD9u357fvqlJXEvKFhndeW/LVNfKtQQNaLPSbICSx7b4vpLyHetoyHdTeqRkH/svn6rjWTpOkved5dIz2f8G7aSbGZwbz+ZltTcV4oXiu4rfWi6d76sYoL7MZiH+HTdtu8m4XRF3KmJ5FKSymzey5RQcKllFym5eQfPeqYg0OPGbYee8U7GcAr4iwJtsMtuQVBVHY3mWP7SnK4r5gxekocwb/gXuVKxAddmMbkEef6MkhoezLXS378oBePh73YZSlGRnGS6uxaE/GCIqEV5ViNh08+3JeLDLDHW3PKfTSirm5bOe/Faua43wKdNdCtSLv8ffai1ByGSgybJv1SVfq+qycA7b8C9xpyKbDtUJZTUdnhxrYq5C1WlRMfPConKPlk2w53CS/N9ZMqllSIbLn1doYtCEfLzHrORmlweglbd3PHOozo3Nu2Qg7SzCUgpuLqe8U3sX2Ts99ia2tzWlg3lUA7z+L+u5B1b+snvnrY3UPhxeHo3nUvISu6bAo+7BVNGNfevffTP5HZPvg6OLuwOf0ZrAtzs2OVUhH8v/YPKC95WZWTpZkM7zwbB73hueDw+GZ2f906E66wV1smj8j0bdUe/8/Lw3GvbPD89Xjr972Dvd7zwanve7nU5/dHAZfq8/L1P3yV0R5m0RnfYb3R18jxHcw/HFk5dgHJJ9juTmSfvMM15bUAelh6+OZ+tg5d8Gd+Q4wM+J++Lm+cnugoqWW4Jubge8m5KjA1UHK3+S0O3Lvg421acrGHXrK9s+c4/neLbeWe9ztPKhu1KQZ8p+s1tYE7CQ568TrcbDutMRnMHjO2rfhDay5UpquSzv0ca686xIReC1PJStbaD550hnI7mvAzXiZEnNnJYoT834sCwhDywP5SDvEnzjRd7l1UXYiaqbxbcueouhI+st6mgo1Myq5xYHtN18W7J8q74gj8749DrhQ3nBZYmmM9zvqtEpq4P/7j2Kg/AOaRV2vjqe5mP5X4c+6n3qo1SYq+QyNArGfZSSS9V/sdznHXrIMhts+c7FPmsk+1ZPw98QPIkxPKT0TK0gMP7EvA86rf9V7ezjrTtuvs3U/UY4JPPG+OKpdJ3tAOo62wE1fBXSdYz1lS9dIlhKj5VeqFFf1HuzQ+yb/ibo/R+Q3qvZcqW/rPcsq5iHbcS+qWpztQrVyqu4WPlhhhtlopkB1lYAt9om3wzgRrp462yT/k+7m+sZrvE0D2cWfKpCXpE2S/XZ2M9yn531nsEQL1U7qu1dTcpDPWZ9RLx8xybqH+u4OjML9YX7aNRH7KOLjuc7+2enh6P9T4ZcBofd/eOzPPF8iertnB7y5i1vWWe0sVxNwE7DzbKBMNRKyZjjJaePzvoHB73B+enZ8engoJOHv8uuIkTYoZUyzJMi8Cj+hqYpSpRnePgd46kKPJf5u39Z0zjT+skK5GP5r0G/99Vaeh3rVH/up5HmUqA+Sm9uC7r+RoyzXOXOCuXDlOh/LI8+A/eBZQErtEujlYIX84pcqa9myUOw0rb5PSsznqfrKlaiqTEx1Yfzahz0QbLEVKFxppB9UD6q6k/tW7QBaG9VH8R9jepjQv2fKmv+u09bY/h2PC3n0+3xLFws49ysXX1WF8i7nQHW7QCs7QCsRkZYIdxIa5Xg7yT/11Pgb1P5ZvJ/FcpvCXpqBP8/wX5/pzZbxmD+N5T5XxprqwEObrs7mCfKoz5weaurx/ltGAf1qQV4irbfaXSjLBh+xYNSyhNh4TvD1SBYRdu0ItskBOtORljGT2xf/3urnuQn5SK19T7Xoey0nhn+iX2OQ89E9lrjME8NfxGyZ7hWJXuqbiHZw/IsewpWKyMs46eSt2YcHvTYrrsUHiB+/B/LI4wqlb9D9PuE/Qz3S4qPiBPh+dQW5RuB8vY/rl1AGA3Ix/J7SbtYX7wL39j3qm13U+gtpeBP4weWV3LlyWsmNE7WhkA5a6O0+f+0GD/Nl8J37EcqP4xh4Vw72gAez7Ty3w96wfFL7PUC1ZQ6ID/QB351fPFUSxN5zhG/s3K8MyRWXxOyx4i/4XS7nhRDTzcrXzn2rgpa1RhEib5TccBmHC1/Ox72D7tHR8Oj08PT8+P+6aNVr3vqHwwHp8NBt3vc74763YNV4z/rn54edc+H54eD4cHZ4WiRcUS+39wn038cKy96Lo7pVPpv+BtEayz9zzq/YLxTa2rblOfTa+NpOc6riHflFcNquvn6syxgXa9i3trwN1xU2eyG+Loj+KqOX+O5I5yH4vZTc1TqKOTrBIuPKOZ5SPU0PPwuTX5RN0O2bFE8aXOlaXqyKB6EZfMRLFNF4EFYD8cXz7jHj+ffpdukPOzPuK3xKEhun6xHmOZdYzcZU3X5jhGOFCucN4kuTMx7xV/kPfMXec/8VfdrFHECBB4Ru+gxwmiHkYasR6Ba+S9SvBfpiH4Z703G293zIz+LyMiixwg3Ka8u6mF5LVEP1RfxMcLYf9QpD30X3q+DdpqPEVZrUOvwjmPBqqjXtvjuJHl2lkoHR4zLdEqtX+H/a25eN80nqRHc/0k+8o/fIj29XXi9DntG606gXlxnK/vvQOtvx6f1YBla/xVo/R1oqFCb+mRHI3M7/TPA+734dT9epu5/D7T+fo66vzXWdf9bgPel+HUfLVP3rwKtfxSd1kF3GVr/HGj94/i09peh9U+IvkgxtPQheB2q0au2X/vEfpCV/9OkkLrbXK3jVftjOFZW63jV/hij1ZPw//Vi6vMXN6w+f33D6vN3N6w+/3DD6vP1G1aff7th9fmPG1af/1uz+qi5vwbBKEEeH0uj1qo2iRakcbMucD3WBda3pnhe2JotYzBvQZkd2steG09xxFoX+ADWdfu0WReYO631usAHIF8vr6atN+sC3WZdoJK3dV0XiHYd+z/7lm12d2sWjuIX9mHWF03meCGvQXm4Rm+H6L07nqcXYbWI3rtEr/W9SubbAn+WdYuhdYC7ovyuKO9l5YeIp3XxLbav8RR9nZlvxrPwrL9G3tUFLTUqPwD7eZyhf/blPhMol9eOVMez77CvVDJr5SdrH8bzNFoe2mK0Tz4Zr5FfCMvoYJ/nIcka+mH2fVvgv0X4lQ+I77L4gMpn9O3z4wmNq7LNdYKP75g2k50oe0gPDh+d9g+GnVHX/7t/2dqv7wL4KvNH0DIBAA==","debug_symbols":"7Z3bbh03sobfxde+4KF4mlcZbARJJjMwYCSDJLOBjUHefffSUh/sRYoSu5piif9NYMddqqpPzeb/94H876d//PLTf/71w5df//nbH5/+9vf/fvr6288//vnlt1+Xv/33r8+ffvr9y9evX/71w/F/f1K3/1j1dPwf//7x19tf//jzx9///PS3EKL5/OmXX//x6W9Ra7P8hH9++frLp79ppf76n8+frG4JMi1BtiWIWoJcS5BvCQotQbElKDUEUfaM0NaQe47S1kb1Tdjnx+OVWZNoRXuSFDIHU1Lh+WBK2m8He5c5OBLFtXzydDz4Vr3mqT6l9XCtU7/qDU/1Lm7sY4W9dmGtXntrX64+OUvPB6cl7vvqLXf12nxT/S0HdciRvRQs50Gya5BRWldyOBXV8+HLH2PltHB6rT86q74Hm73M3IoIe0E2VAriPE/DKwjZ9HBpiW1hqSnM5S9kaiG1jQ7l91+js9kzxdv9SrAPD+1SdjD554ON2s8qa3Tm2JC2UzaktB9tImWOtm69nNLhV2dU7lijk17LMCpVjnZmvdQdT7zbsTeGGgxPMzRgeJqhBcPTDAkMTzN0YHiaoQfD0wwDGJ5mGMHwNMMEhmcZeviU8wzhU17FMK04vHYPDOFTzjOETznPkMDwNEP4lPMM4VPOM4RPOc8QPuU8Q/iU0wwDfMp5hvAp5xnCp5xnCJ9yniGB4QPDGxd4jzwX+Ik8F3iEPBfo/jwXaPkslwh9nucCzZ3nAh2d5wJtnOdC4JLlAr2b5zKt3jVxfVRt7KGOlcu0erfCZVq9W+Eyrd59mUuaVu9WuEyrdytcptW7FS7T6t0KFwKXLJdp9W6FC/Rungv0bp4L9G6eC/RulsvSNcDkwUDxFsBA8hbAQPMWwBDA5MFA9RbAQPYWwEyre4Peygjffav1tqOfME4rk9+EUXu/LjejfYiPGKdV1awY9bQanBfjtIqdF+O0+v5tGEPYOgzpcabW07oBXowEjBwYp3UavBin9SW8GOFiWDDCxbBghIvhwGjgYlgwwsWwYISLYcEIF8OCkYCRAyNcDAtGuBgWjHAxLBjhYl6FMalt+4hkMhjhYjgwWhYXo+O2FYQhV8HoXNo2dUjucLTK/Wy/7SISDmhuP/mpfC27fCO7fCu7fHpF+cF9wEsI36Kx2jpAPA/RA+J5iAEQz0OMgHgeYgLE0xBJAeJ5iBoQz0M0gHgeogXE8xAJEM9DhGM5vW6nJjgWBohwLAwQ4VgYIMKxnIfo4FgYIMKxMECEY2GACMfCAJEA8TxEOBYGiHAsDBDhWBggwrFkF7vVDi4kD8bDWRTAwC0UwMABFMBA1RfAEMDkwUB9F8BAURfAQCUXwED5FsBA+ebBhGmVb2VltDCt8q2BmVb51sBMq3xrYAhg8mCmVb41MNMq3xqYaZVvDcy0yrcGZlrlWwEToXwLYKB8C2CgfAtgoHwLYAhg8mCgfAtgoHwLYKB8C2CgfAtgoHzzYNK0ypd104c0rU5mXR8+TauqeTFOq8F5MRIwcmCcVt+zrmWXpnUDvBin9Q68GKd1GrwYp/UlnBiNgothwQgXw4IRLoYFI1wMC0YCRg6McDEsGOFiWDDCxbBghIthwQgXw4FRw8WwYISLYditwGi4GBaMLC6mdd1+Hw3tR2fX7Q9+/SgoHG7eax/v5ZPs8p3s8r3s8gsqVettyChtba38baBrHdQ3STIFRbuWH6Lbt8PwLncw7XtWOKWOBz+VH2WXn0SXX9rzU0r5Wnb5Rnb5Vnb5JLt8J7t8L7t82bOukT3rGtmzrpU961rZs66VPeta2bOulT3rWtmzrpU961rZs66VPeta2bMuyZ51afQLpzN+K9+Eh/JHH7peb3fZvH4s/z2GrtnL9/7l8vVye36/RZ7sYZHedL9PSEl6B06J70CL78CI78CK74DEd+DEd+DFdxDEdzD4nEwhrYqIoo2P9Q8+I9fq94PPx9X6B5+Nq/UPPhdX6x98Jq7WP/g8XK1f/Czsxc/CXvws7MU7Yy94Hn482oX1LTwX9+WnrU1PvQbBc/abexU8v7+5V/G+PIj35UG8Lw/iFUEQrwiCeEUQxCuCIP5eeRR/rzyKv1cehfvzKNyfR+H+PA4+G1frH3wurtY/+ExcrV/4/fEofhZO4mfhJH4WTuKdcRLvjJN4Z5zEO+Mk3hkn8c44iXfGSfYza6tkP7O2SvYza6tke2KrZHtiqwafiav1y/bEVkmfha2SPgtbJX0Wtkq6M7ZaujO2Wroztlq6M7ZaujO2Wroztlq6M7Za9n1qq2Xfp7Za9n1qq4V7YiPcExvhntgI98RG/Cz8LksB8XYgfhY24p2xEe+MjXhnbMQ7YyveGVvxztgKn5Gt8LvU77JIEGf9wu9SW+GO2Ap3xFa4Iy6uFOTsXn8wx/pvYcUVeiphhfnGuG1JZmUOKydnaVFS63LPlHSl/0i0/uhIno4HPxVUmD4M+a0gqyu/Pm/XFN7thyZ/z2Avz0CXZ3CXZ/CXZwiXZ4iXZ0hXZygt3MOYQV+e4fIx7S4f0+7yMe0uH9Pu8jHtLh/T7vIx7TjGtPGb3DA+7Eui6fuuG9arHkl0jySmRxLbIwn1SOJ6JPE9koQeSWKPJD1GfOgx4kOPER96jPhw+YweLp/Rw+Uzerh8Rg+Xz+jh8hk9XK7S4+UqPV6u0uPlKj1ePqYjz5j266XJ+8OOaWsO1yGH75AjdMgRO+RI1+dIqkMO3SHHa8a49S/niGq7pxhV2NeGduGew3bIQR1yOI4cy+Viu9t5/OWFzMFWufU+qlVxPzi/6HbaiteHXR3N/b5u8v2LJ70V7765CfxUUBitoDhaQWmsgkip0QrSoxVkRivI9i8obdcsE2pvDyyPoNRWiLH0UD8Jr98Jr98Lrz8Ir7//pLTcYlvrXyxgrf5g98fJwT3W338Oo22jkuW5a6jVH9VeSLTfbxRDuv+UR9veKUv9sVZ/0tt7CSq5+FC/Fl6/EV6/FV4/Ca/fCa/fC68/CK8/Cq8/ya7fCJ9/jfD51wiff43w+dcIn3+N8PnXjHT9fypopAv6rSA70hX6qaD+l1xnaC3IVS2nXu40r4Xo5QL1UL8RXr8VXj8Jr98Jr5/FMrjtvlp00R/rf8oRO+RI1+cg1SGH7pDDdMhhO+SgDjlYxrfbvmeKLtFDDt8hR+iQI3bIka7P4VSHHLpDjsI4Xx4tbzkWz/9yDsavy6j0nYiN++dudHis8eY30Kj0nQhjBnd5Bs+QofKCL5U+FeFNEnskSVf/QkpfizBm0JdnMJdnuHxw+8sHt798cHt/eYZweYZ4eYbLx3TgGdMvve5JQXfIYTrksB1yUIccrkMO3yFH6JDjNWP8MBs3vOJLIV2fI6oOOTRHjvd5VZmi6V/8iy9RRjtaQTRaQW60gvxoBYXRCoqjFZT6F8T5qmZSwuvXwus3wuu3wuvvPymxvqqc+s9hrK8qp/5THuurFikIrz8Krz+Jrt8pJbx+Lbx+I7x+K7x+El6/E16/7PnXKdnzr1Oy51+nhM+/Wvj8q4XPv3qk6/9TQSNd0J8KGukK/VRQ/0su56uaTkfh9SfZ9RslvH4tvH4Wy/Di657OUIccrkMO3yFH6JAjdsiRrs9hVYccLOP7xVdKnTUdctgOOahDDtchh++QI3TIURjny6S15XCushFG0Nu2GYH0XtD9lRZX+kSEM0fpExHWHLpDDtMhh+2QgzrkcB1y+Ffk8JXPBTRZuz6CXP583I4mq96Wgbqqtxjdy+rtxZeMXOnrk2vLJ7uV/2jgKY5XUhquJKfGK0mPV5IZryQ7Xkk0XkluvJL8eCWNd/V241293XhXbz/e1duPd/X24129/btcvdMq90jV5N7N/Znd/bmHm3WexHfgxHfgxXcQxHfwDhPV4h+3T7Z10rUOXn5T0/l3mNeWu//b78C46ruyL7+r6YJ6jw62TWmXDqpvm1aeNgctvgMjvgMrvgMS34ET34EX30EQ30EU30GS3kEUPydH8XNyFD8nR/FzchQ/J0fxc3Icaz54KmmsC/ytpDTWFfuppPe4BNvNLpOtWtPaO23JiO/Aiu+AxHfgxHfAYyqcSVsHjtyxg6cssUuW1CGLV6pLFt0li+mSxXbJQl2y8Ix4p2jP4ipvc+sY/HavO4bDBcKkeK/KD1lVGLKqOGRVacSqSh+7+X2QKO++Wcj2KUy3hZm2MNsWRm1hri3Mt4WFtrD4irBvz6ansNQUZlRbmG4LM21hti2sdJaEfVwGrR/CXFuYbwsLbWGxLSw1hdniWRIPYeYhrHCWBLsv0xNCeggzbWG2LYzawlw9LCr3EObbwkJbWGwLK5wlMe1h6eBH8hOa8tsjcn346E27lDvarU+jjdrPI2t05tiQts8iQkqHmS9S7tUEt86TdFiJ3ajcsWZ58r+WYVSqHL3LTXd4fm7uS2z70lcNgPgWiBoQz0M0gHgeogXE8xAJEM9DdIB4HqIHxPMQAyCehxgB8TxEOJbzEB0cy6sgbksSLzcUHyHCsTBAhGNhgAjHwgCRAPE8RDgWBohwLAwQ4VgYIMKxMECEYzkP0cOxMECEY2GACMfCABGO5RHiExgCmDwYOIsCGLiFAhg4gAIYqPoCGCj1PJgA9V0AA0VdAAOVXAAD5VsAQwCTBzOt8jVxfYht7KGODcy0yrcGZlrlWwMzrfKtgZlW+VbAxGmVbw3MtMq3BmZa5VsDM63yrYEhgMmDgfItgIHyLYCB8i2AgfItgIHyzYNJUL4FMFC+BTBQvgUwUL4FMAQweTBQvgUw0yrfoLcywnefdL3t6CeM0+rkN2HU3m88lpvHjxinVdW8GKfV4JwYg5pWsfNinFbfvw1jCFuHIZlHjNO6AV6M03oHXowEjBwYp/UlvBjhYlgwwsWwYISLYcEIF8OBUcPFsGCEi2HBCBfDghEuhgUjASMHRrgYFoxwMSwY4WJehTGpbQ+IZDIY4WJYMLK4GB237SLMYXumPEbntp/tkjscrXI/e3latHI8oLn95Fv5RskuX8su38gu/zUq1YYPeAnhW1s2GALE8xAdIJ6H6AHxPMQAiOchRkA8DzEB4mmIVgHieYgaEM9DNIB4HiIcCwNEAsSzK3oGC8fCABGOhQEiHAsDRDgWBohwLOchEhwLA0Q4FgaIcCwMEOFYGCASIJ6HCMfCABGOhQEiHEt26dtAcCEFMHAWeTAObqEABg6gAAaqvgAGSr0AhgAmDwaKugAGKrkABsq3AAbKtwBmWuX78spowU+rfGtgplW+NTDTKt8amGmVbw0MAUwezLTKtwZmWuVbAzOt8q2BmVb51sBA+ebBBCjfAhgo3wIYKN8CGCjfAhgCmDwYKN8CGCjfAhgo3wIYKN8CmGmVL+emDyFOq5NZ14eP06pqXozTanBejNMqdl6MBIwMa9nFad0AL8ZpvQMvxmmdBi/GaX0JL0a4GA6MCS6GBSNcDAtGuBgWjHAxLBgJGDkwwsWwYISLYcEIF8OCES6GBSNcDAPGqOBiGHYriAouhgUji4t5r3X7o7KyyyfZ5TvZ5b9GpR5yLOU/hYW2sNgWlprCXrWXYiZMt4WZtjDbFkZtYa4trO0s0W1niW47S3TbWWLazpLCXjVaabPNpopibdxvM6TWYZ/HtI+5+TTataTlUaPejvYud7DfVv0N3seXD17qSLsIcMYfD3/q1ozerdZbtzo8lG9ll0+yy3eyy/eyyw+yy4+yy0/vUL7Zy/cPl/LCHhjvWZEeriIzXEV2uIpouIrccBWVpo7tje/llotOH/AGDd8GFdEGQDwPMQLieYgJEE9DJAWI5yFqQDwP0QDieYgWEM9DJEA8D9EB4nmIcCwMEOFYTm8LEAmOhQEiHMt5iA6OhQEiHAsDRDgWBohwLAwQCRDPQ4RjYYAIx8IAEY6FASIcCwNEOJbzED0cS3b/jOjhQgpg4CwKYOAWCmAIYPJgoOoLYKDUC2CgvgtgoKgLYKCS82AClG8BDJRvAcy0yvfldadjmFb51sAQwOTBTKt8a2CmVb41MNMq3xqYaZVvDcy0yrcCJk6rfGtgplW+NTBQvgUwUL4FMAQweTBQvgUwUL4FMFC+BTBQvgUwUL55MAnKtwAGyrcABsq3AGZa5cu512BM0+pkzm3JYppWVfNinFaD82KcVrHzYpxW37MuoZ6mdQOcGJOa1jvwYpzWafBinNaX8GKEi2HBSMDIgREuhgUjXAwLRrgYFoxwMSwY4WI4MGq4GBaMcDEsGOFiWDDCxbBgJGA8v0le0nAxLBhZXMx7bReXdJBdfpRdfhJdvnmNSrX2A15C+NaWTUYD4nmIBhDPQ7SAeB4iAeJ5iA4Qz0P0gHgeYgDE8xAjIJ6HmADxNEQLx8IAEY7l9IqeycKxMECEY2GASIB4HiIcCwNEOBYGiHAsDBDhWBggwrGch0hwLAwQ4VgYIMKxMECEY2GASICYW/o2EVxIAQycRQEM3EIBDBxAAQxUfR6Mg1IvgIH6LoCBoi6AgUougCGAyYOB8i2AmVb5vrwyWnLTKt8amGmVbw3MtMq3AsZPq3xrYKZVvjUw0yrfGphplW8NDAFMHsy0yrcGBsq3AAbKtwAGyrcABso3DyZA+RbAQPkWwED5FsBA+RbAEMDkwUD5FsBMq3w5N31IYVqdzLk+fArTqmpejNNqcFaMcVrFzotxWn3PupZdnNYN8GKc1jvwYiRg5MA4rS/hxQgXw4IRLoYFI1wMC0a4GA6MCS6GBSNcDAtGuBgWjHAxLBgJGDkwwsWwYISLYcEIF8OxW0GCi2HByOJiWtft99HQfnR23f7g14+CwuHmvfbxVr5WSgmvXwuv3wivv6BUdfJb/cZU698Gu9ZBfZMlU1G0a/0hOr0d7V22/G0B0+B9fPngpY60X8+c8cfD7+3S6O2S2dsNj/W7uX5d/h3aNXu73lc6WKa2fXpJ9rDATVoHWJDfQpTfQhLfQmkjSUktaPktGPkt2LFboLAVQtHGTAMkvQEnvYHB5+V6A4PPyvUGBp+T6w0MPiNXGyhtmWfcoYH4TQP3ON0YZxrjbGMcNca5Utz+q7JaP8YVrinW7U6aDvedtrjQGBcb41JbXGnDkuX+2c7FxcoJT2o7mkyonPDR6rWmaE2qKId9qxDt6HB/z6bnBnT/Bkw0WwOKXm4gqrieYVHbmk7SXpmtbE/2wXuWtvUgt8dR0n99vBusfBvMLBQtKDJQJFBkoOhAkYGiB0UGigEUGShGUGSgmEDxPMXS9h6g+CaKGhQZKMK7cFCEdzm9w8dCkUCRgSK8CwdFeBcOivAuHBThXTgowrswUHTwLhwU4V04KMK7cFCEd+GgSKDIQBHehYMivEt2X5yFDPxIiQw8RokMfEOBjIcXKJGBvi+RgWYvkYEOL5EhkCmQgV4ukYEGLpGBBi6RmVYDv7y2/NLStBq4RiZMq4GrZKbVwFUy02rgKplpNXCVDIFMgcy0GrhKZloNXCUzrQaukoEGLpGBBi6QidDAJTLQwCUy0MAlMtDAJTIEMgUy0MAlMtDAJTLQwCUy0MAlMtNqYM5NRrVK0ypmzg0JF47T6mtmjtOqcWaO02p3Zo4Ejuc3UFg4TusLmDlO6yKYOU7rOZg5TutQmDnCz3Bw1Ap+hocj/AwPR/gZHo7wMzwcCRxZOMLP8HCEn+HhCD/DwxF+hocj/AwLRw0/w7Bl5tI1/AwPRxY/07p3pEvucHR270ifts38DmxuP/levxVePwmv3wmv/xV61Sl3rP8eFxrjYmNcaoszqjFON8aZxjjbGEeNca4xrvF8MY3ni2k8X0zj+WIbz5fSxjwubM9jtVe+dh0QsimsLm3MM067etty2evwWL8VXj8Jr98Jr98Lrz8Irz8Krz+9Q/3FnRefSirtnfGeJenxSjLjlWTHK4nGK8mNV1JhEvGH3T0X+/agNUtrv1fjYmNcaosrrWjtddzjnKsgf7/dNnVpMekrG3i/3TZ1adXnEGmLi4easu1SUusSqst9j0pNkWglGcnTY0WFS1swYR+G3+5/+7lyeCT1eKJSnzSuTxrfJ03okyb2SZO6pCkt7MmdRvdJY/qk6XMV8H2uAr7PVcD3uQr4PlcBz3EVMH4TB8aHw0y8PgzyqUeWoLpk0V2ymC5ZbJcs1CWL65LFd8kSumTpMvZDl7Efu4z92GXsR46x7+1qALzbD03+OYW9PgVdn8Jdn8JfnyJcnyJenyJdniKp61Po61NcP7rT9aM7XT+60/WjO3WZzVOX2Tx1mc1Tj9ncKNUli+6SxXTJYrtkoS5ZXJcsvkuW0CVL7JKly9jXl8/yRuvrU5jrU9jrU9D1Kdz1Kfz1KcL1KeL1KS7X8MZcP7rN9aPbXD+6zfWj27Dcl18eXK5HRx0fk1w/vs3149tcP77N9ePbXD++7fXj214/vu3149teP77t9bO3vX502+tHt71+dNvrR7e9fnTT9aObrh/dxDG6Q9ze5I/aZpLYHkmoRxLXI4nvkST0SBJ7JEkdkrhXjPbv3inI6ENP28uM3u8H05pE90hieiSxHEluXnI7/PjNoguZw61y69FWHX7f+XfnD7/uwxe7xj7XT+9RP+mtfvfwJq95zZt93WvyA9YUBqwpDlhTGq8mrwasSb9HTWm7lplQe+la6f37ArVYnccWjPwWrPwWSH4LTn4L7zFlWb+aMGujqbUQ7PZhtAou08J7zHC0fZloiUKthag2fbhoMfXYwntMiLR9L7m0UPs8XSW9fYalkouPLSTxLQQlvwUtvwUjvwUrvwWS34KT34KX30KQ34L82TnIn52j/Nk5yp+do/zZOcqfneNY88K9prEu9Peaxrpy32t6j0uxM+urONZV7aq2aV9sgYx9aCEp+S1o+S0Y+S1Y+S3wuAx7WPCDDmv9Li3c0/g+aUKfNLFHGlv4WETp7UXz5c/W1tJct2SZM+t9weWPD0uW2cJnKOPU77dnzMH7TP1m9PrJvFi/Hb1+zhVGlyd/o7f74gp/tvB1kJz6vfD6g/D6o/D6k+z69ejTda3+4afrSv3DT9cv11/4TkKZbQ0+5XdzsO5HYQvfPtTCSt8z2H1xS4qZMN0WZtrCbFtYXglov69mGHNI8hOA3d5YuLmpTFhsC0tNYYU31athui3MtIXZtrD8781ti6Lqo+Pdw1xbmG8LC21hsS0sNYUV3nCuhuXPEuf3VU9jyoSZtjDbFkZtYa4tzLeFhbaw2BRWeNPS7lsZLbNLJky3hZm2MNsWRm1hri3Mt4WFtrDYFpaawkLbWRLazpLCizDLRX4Lc5lLUOHlk2oYtYW5tjDfFhbawmJbWJvAiG0CI7YJjNgmMPJPxsJ+P4z8Y1D+ocm+79zxUeUeZFqCbEsQtQS5liDfEhRagto8TWryNFS6YV4L021hpi3MtoVRW5hrC/NtYaEtLLaFtZ0l+fscL187KH9zYV+5PplcUMNlgPKLutQyhZag2BKUGoLyi6NUQBjdEmRagvK/p+12QQqZ0yi/yEgtyLUE1S7X2aDQAiK2BKWGINtyRtiWM8K2nBG2ZeRaaglyLUG+JajljCjcW/H7Kwv+MODXfVCocG+lGhaqYYePgPaw2BaWmsIKdwRol+N0lOPeP4eFtrDYFpaawgo3Eqphui3MFH4BaT9L9l8ArVG2KYqaokJLVMFov/yZPRV8di3KNVXom6LaaMSmqNQSVTCvtSjdFNV09samszc2nb2x6dwovJ1bOQ8L78/WomJTVGqJSk2jMjWNysLLjbUo2xRFTVGuKSpL3qfNOx02+1rX33B5W14L0g1BpVnPqcNEdFg46flNO1ea9qpxujEuf3oEv73hFEL8Hr4rTHy1KGqKck1R+UtHjNtjpxjDY1RoispfOuL+qCSGTFRqiSpM6LUo3RRlmqJsUxQ1RWXJG7293mC02S8dyxPr57DUFJaf0r8Ni5kw3RZmmsIKV1O1Dxet98vAcnzu1ZNtc0xzeBnYGp17l2S3bSGlw5pHkfLvjD8fTPrbuzOfM62mrVWjUuXofT9Md1gXYHWPrvDa9/RYArDksERgyWFJwPKIxZce9syORQNLDosBlhwWCyw5LAQsOSxQuVkss6rc7SUdr10Gy6wqt4JlVpVbwTKryn0Zi55V5VawzKpyK1hmVbkVLLOq3AoWApYclllVbgULVG4WC1RuFgtUbhbLFCr3qVUzhXK9tzqFGr23OoXCvLc6hWq8t0rztDqFuru3OoViu7c6hQq7tzqFsrq3Oo9asvOoJftx1JKJ64MhYw917K1+HLVUbfXjqKVqqzRPqx9HLVVb/Thqqdrqx1FL1VY/jlqqtvpx1FKtVfo4aqna6jxqieZRSzSPWqJ51BLNo5ZoHrVE86glmkct0Txqyc2jltzHUUtBb2WE7946ftvRdzAfR1u9CcztK/a1Qx9iBszHUWLMYAhg8mA+jspjBvNxNOHbwISwr4qQcrPSx1GQzGA+jt5kBvNx1CkvGP9xtCwzmEmVbx3MrMq3CmZW5VsFQwCTBzOr8q2CgfItgIHyLYCB8i2AgfLNgwlQvgUwUL4FMLMq37RvTZRMDsysyrcKhrJgdNw2kT/uT38Dcw9zbWH+rWGPLTmX1puSPh4WM9Yqt7tn8NsOnIcbmLe9Pe8FpaY+CotOV8NsW1jb76iwPnMtLLX1Vlg1uRrW1ltq7C22hAWl28JMW5hrC/NtYaEtrJFk03gLWo113Qhaj1aQGa2gOFpBabCCzGgntRlsdg4mjFbQaCe1pdEKcqMVNNpJTaNdqcmOVtBoJ7Ub7UrtRpMfbrST2o12pXajyQ8/2kntR7tS+9Hkhx/tpA6jXanDaPJjqDtefy1//d8ff//y409ff/ljCbn9639+/fnPL7/9+vzXP//v3+u//PT7l69fv/zrh3///tvPv/zjP7//8sPX336+/dsn9fyfv+tI9rOOnpZWb2eCDjEsfyez/P32i9BOLf/uXLiheAqw2n3W1qjb/9BPR8Tlf7gYltqW+v4f","names":["_borrow"],"brillig_names":["_borrow"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Lending::deposit_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::deposit_private_parameters","fields":[{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"nonce","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"on_behalf_of","type":{"kind":"field"}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::borrow_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::borrow_private_parameters","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::_borrow_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_borrow_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::compute_total_deposited_assets_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::compute_total_deposited_assets_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"deposit_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]}}]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":128}}]},{"kind":"struct","path":"Lending::_compute_total_collateral_value_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_compute_total_collateral_value_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":128}}]},{"kind":"struct","path":"Lending::_compute_collateral_debt_value_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_compute_collateral_debt_value_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":128}}]},{"kind":"struct","path":"Lending::repay_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::repay_public_parameters","fields":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"nonce","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::_liquidate_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_liquidate_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debt_token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"user","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debt_to_liquidate_amount","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"Lending::withdraw_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::withdraw_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::_withdraw_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_withdraw_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::borrow_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::borrow_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::deposit_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::deposit_public_parameters","fields":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"nonce","type":{"kind":"field"}},{"name":"on_behalf_of","type":{"kind":"field"}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::add_asset_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::add_asset_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"oracle","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"loan_to_value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"is_borrowable","type":{"kind":"boolean"}},{"name":"optimal_utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"under_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"over_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"deposit_cap","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"Lending::_compute_borrow_rate_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_compute_borrow_rate_parameters","fields":[{"name":"asset","type":{"kind":"struct","path":"asset::Asset","fields":[{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"loan_to_value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"oracle","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_borrowable","type":{"kind":"boolean"}},{"name":"optimal_utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"under_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"over_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"deposit_cap","type":{"kind":"integer","sign":"unsigned","width":128}}]}},{"name":"utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"precision","type":{"kind":"integer","sign":"unsigned","width":128}}]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":128}}]},{"kind":"struct","path":"Lending::liquidate_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::liquidate_public_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debt_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"user","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debt_to_cover","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"Lending::repay_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::repay_private_parameters","fields":[{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"nonce","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"on_behalf_of","type":{"kind":"field"}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::_compute_utilization_rate_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_compute_utilization_rate_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"precision","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"deposit_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]}},{"name":"borrow_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]}}]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":128}}]},{"kind":"struct","path":"Lending::withdraw_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::withdraw_private_parameters","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::_repay_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_repay_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::constructor_parameters","fields":[]}}]},{"kind":"struct","path":"Lending::_deposit_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_deposit_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::update_accumulators_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::update_accumulators_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"PriceFeed"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000a"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Lending"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"market_assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"market_assets_list","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"market_assets_list_len","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"scaled_deposited_assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"scaled_borrowed_assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"scaled_total_deposited_assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"scaled_total_borrowed_assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"deposit_accumulators","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"borrow_accumulators","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}}]}}]}],"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"UintNote"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"UintNote"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]}]}},"file_map":{"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"25":{"source":"//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n","path":"std/meta/expr.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"46":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n","path":"std/slice.nr"},"52":{"source":"use dep::aztec::hash::pedersen_hash;\nuse std::ops::{Add, Sub};\n\n// Utility used to easily get a \"id\" for a private user that sits in the same\n// \"space\" as the public users.\n// It help us to have a single mapping for collateral that have both public and private users.\npub fn compute_identifier(secret: Field, on_behalf_of: Field, self: Field) -> Field {\n    // EITHER secret OR on_behalf_of MUST be set. But not both\n    assert(!((secret == 0) as bool & (on_behalf_of == 0) as bool));\n    if (secret != 0) {\n        pedersen_hash([self, secret], 0)\n    } else {\n        on_behalf_of\n    }\n}\n\npub fn covered_by_collateral(\n    collateral_price: u128,\n    borrow_price: u128,\n    loan_to_value: u128,\n    collateral: u128,\n    increase: u128,\n    decrease: u128,\n) -> u128 {\n    let price_precision = 1000000000 as u128;\n    let ltv_precision = 10000 as u128;\n\n    let collateral = (collateral + increase) - decrease;\n\n    let collateral_value = (collateral * collateral_price) / price_precision;\n    let debt_covered = (collateral_value * loan_to_value * price_precision) / (borrow_price * ltv_precision);\n\n    debt_covered\n}\n\npub struct DebtReturn {\n    debt_value: u128,\n    static_debt: u128,\n}\n\nfn div_up(a: u128, b: u128) -> u128 {\n    let div = a / b;\n    if div * b < a {\n        div + (1 as u128)\n    } else {\n        div\n    }\n}\n\npub fn debt_updates(\n    interest_accumulator: u128,\n    static_debt: u128,\n    increase: u128,\n    decrease: u128,\n) -> DebtReturn {\n    assert(interest_accumulator > (0 as u128));\n    let accumulator_precision = 1000000000 as u128;\n\n    let current_debt_value = (static_debt * interest_accumulator) / accumulator_precision;\n    let new_debt_value = current_debt_value.add(increase).sub(decrease);\n\n    // static_debt_increase = amount / accumulator\n    // rounding up new debt.\n    let static_debt_increase = div_up(increase * accumulator_precision, interest_accumulator);\n    // rounding down repayment.\n    let static_debt_decrease = (decrease * accumulator_precision) / interest_accumulator;\n\n    // We need to allow repaying of the entire debt as well etc. This is very prone to failing\n    // if you try to repay exact due to time diff between sim and execution.\n    let new_static_debt = static_debt.add(static_debt_increase).sub(static_debt_decrease);\n\n    DebtReturn { debt_value: new_debt_value, static_debt: new_static_debt }\n}\n\npub fn debt_value(static_debt: u128, interest_accumulator: u128) -> u128 {\n    let accumulator_precision = 1000000000 as u128;\n    div_up(static_debt * interest_accumulator, accumulator_precision)\n}\n","path":"/home/jean/work/noir/comet/contracts/src/helpers.nr"},"53":{"source":"mod asset;\nmod position;\nmod helpers;\nmod accumulator;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Lending {\n    use dep::aztec::prelude::{AztecAddress, Map, PublicMutable};\n\n    use crate::asset::Asset;\n    use crate::helpers::{compute_identifier};\n    use crate::position::Position;\n    use dep::price_feed::PriceFeed;\n    use dep::token::Token;\n    use crate::accumulator::Accumulator;\n    use dep::aztec::macros::{\n        functions::{initializer, internal, private, public, view, utility},\n        storage::storage,\n    };\n    use dep::aztec::protocol_types::traits::{FromField, ToField};\n\n    #[storage]\n    struct Storage<Context> {\n        market_assets: Map<Field, Map<AztecAddress, PublicMutable<Asset, Context>, Context>, Context>,\n        market_assets_list: Map<Field, Map<u64, PublicMutable<AztecAddress, Context>, Context>, Context>,\n        market_assets_list_len: Map<Field, PublicMutable<u64, Context>, Context>,\n        scaled_deposited_assets: Map<Field, Map<AztecAddress, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, Context>,\n        scaled_borrowed_assets: Map<Field, Map<AztecAddress, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, Context>, // static debt\n        scaled_total_deposited_assets: Map<Field, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>,\n        scaled_total_borrowed_assets: Map<Field, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, // static debt\n        deposit_accumulators: Map<Field, Map<AztecAddress, PublicMutable<Accumulator, Context>, Context>, Context>,\n        borrow_accumulators: Map<Field, Map<AztecAddress, PublicMutable<Accumulator, Context>, Context>, Context>,\n    }\n\n    #[private]\n    #[initializer]\n    fn constructor() {}\n\n    #[public]\n    fn liquidate_public(market_id: Field, collateral_asset: AztecAddress, debt_asset: AztecAddress, user: AztecAddress, debt_to_cover: u128) {\n        let _ = Lending::at(context.this_address())._liquidate(market_id, collateral_asset, debt_asset, user, debt_to_cover).call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _liquidate(market_id: Field, collateral_token: AztecAddress, debt_token: AztecAddress, user: AztecAddress, debt_to_liquidate_amount: u128) {\n        Lending::at(context.this_address()).update_accumulators(market_id, collateral_token).call(&mut context);\n        Lending::at(context.this_address()).update_accumulators(market_id, debt_token).call(&mut context);\n\n        let scaled_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(debt_token).at(user);\n        let scaled_borrowed_amount: u128 = scaled_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(debt_token);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let borrowed_amount = (scaled_borrowed_amount * borrow_accumulator.value) / 1000000000 as u128;\n\n        assert(borrowed_amount >= debt_to_liquidate_amount, \"Insufficient borrowed amount\");\n\n        let total_collateral_value: u128 = Lending::at(context.this_address())._compute_total_collateral_value(market_id, user).call(&mut context);\n        let collateral_debt_value = Lending::at(context.this_address())._compute_collateral_debt_value(market_id, user).call(&mut context);\n\n        assert(collateral_debt_value > total_collateral_value, \"collateral >= debt\");\n\n        let debt_asset_loc = storage.market_assets.at(market_id).at(debt_token);\n        let debt_asset: Asset = debt_asset_loc.read();\n        let debt_asset_price = PriceFeed::at(debt_asset.oracle).get_price(0).view(&mut context).price;\n        let debt_to_liquidate_price = (debt_to_liquidate_amount * debt_asset_price) / 1000000000 as u128;\n\n        let collateral_asset_loc = storage.market_assets.at(market_id).at(collateral_token);\n        let collateral_asset: Asset = collateral_asset_loc.read();\n        let collateral_asset_price = PriceFeed::at(collateral_asset.oracle).get_price(0).view(&mut context).price;\n        let collateral_amount_to_liquidate = (debt_to_liquidate_price * 1000000000 as u128) / collateral_asset_price;\n\n        let collateral_deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(collateral_token);\n        let collateral_deposit_accumulator: Accumulator = collateral_deposit_accumulator_loc.read();\n        let scaled_collateral_deposit_amount_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_token).at(user);\n        let scaled_collateral_deposit_amount: u128 = scaled_collateral_deposit_amount_loc.read();\n        let collateral_deposit_amount = (scaled_collateral_deposit_amount * collateral_deposit_accumulator.value) / 1000000000 as u128;\n\n        assert(collateral_deposit_amount >= collateral_amount_to_liquidate, \"Insufficient collateral\");\n\n        let scaled_collateral_amount_to_liquidate = (collateral_amount_to_liquidate * 1000000000 as u128) / collateral_deposit_accumulator.value;\n\n        let debt_borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(debt_token);\n        let debt_borrow_accumulator: Accumulator = debt_borrow_accumulator_loc.read();\n        let scaled_debt_amount_to_liquidate = (debt_to_liquidate_amount * 1000000000 as u128) / debt_borrow_accumulator.value;\n\n        let scaled_user_deposited_amount_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_token).at(user);\n        let scaled_user_deposited_amount: u128 = scaled_user_deposited_amount_loc.read();\n        scaled_user_deposited_amount_loc.write(scaled_user_deposited_amount - scaled_collateral_amount_to_liquidate);\n\n        let scaled_total_deposited_asset_loc = storage.scaled_total_deposited_assets.at(market_id).at(collateral_token);\n        let scaled_total_deposited_asset: u128 = scaled_total_deposited_asset_loc.read();\n        scaled_total_deposited_asset_loc.write(scaled_total_deposited_asset - scaled_collateral_amount_to_liquidate);\n\n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(debt_token).at(user);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        scaled_user_borrowed_amount_loc.write(scaled_user_borrowed_amount - scaled_debt_amount_to_liquidate);\n\n        let scaled_total_borrowed_asset_loc = storage.scaled_total_borrowed_assets.at(market_id).at(debt_token);\n        let scaled_total_borrowed_asset: u128 = scaled_total_borrowed_asset_loc.read();\n        scaled_total_borrowed_asset_loc.write(scaled_total_borrowed_asset - scaled_debt_amount_to_liquidate);\n    }\n\n\n\n    #[private]\n    fn repay_private(\n        from: AztecAddress,\n        amount: u128,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        asset_address: AztecAddress,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        // docs:start:private_call\n        let _ = Token::at(asset_address).transfer_to_public(from, context.this_address(), amount, nonce).call(&mut context);\n        // docs:end:private_call\n        let _ = Lending::at(context.this_address())\n            ._repay(AztecAddress::from_field(on_behalf_of), amount, market_id, asset_address)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn repay_public(amount: u128, nonce: Field, owner: AztecAddress, market_id: Field, asset_address: AztecAddress) {\n        let _ = Token::at(asset_address).transfer_in_public(context.msg_sender(), context.this_address(), amount, nonce).call(&mut context);\n        let _ = Lending::at(context.this_address())._repay(owner, amount, market_id, asset_address).call(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _repay(owner: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == asset_address, \"Invalid asset or market id\");\n\n        Lending::at(context.this_address()).update_accumulators(market_id, asset_address).call(&mut context);\n\n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / borrow_accumulator.value;\n\n        assert(scaled_user_borrowed_amount >= scaled_amount, \"Insufficient balance\");\n        scaled_user_borrowed_amount_loc.write(scaled_user_borrowed_amount - scaled_amount);\n\n        let scaled_total_borrowed_asset_loc = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address);\n        let scaled_total_borrowed_asset: u128 = scaled_total_borrowed_asset_loc.read();\n        scaled_total_borrowed_asset_loc.write(scaled_total_borrowed_asset - scaled_amount);\n    }\n\n     #[private]\n    fn borrow_private(secret: Field, to: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let on_behalf_of = compute_identifier(secret, 0, context.msg_sender().to_field());\n        let _ = Lending::at(context.this_address())\n            ._borrow(AztecAddress::from_field(on_behalf_of), to, amount, market_id, asset_address)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn borrow_public(to: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let _ = Lending::at(context.this_address())._borrow(context.msg_sender(), to, amount, market_id, asset_address).call(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _borrow(owner: AztecAddress, to: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n\n        assert(asset.is_borrowable, \"Asset is not borrowable\");\n\n        let total_collateral_value: u128 = Lending::at(context.this_address())._compute_total_collateral_value(market_id, owner).call(&mut context);\n        let collateral_debt_value = Lending::at(context.this_address())._compute_collateral_debt_value(market_id, owner).call(&mut context);\n\n        let borrow_price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n        let min_collateral_for_borrow = (amount * borrow_price * 10000 as u128) / (asset.loan_to_value * 1000000000 as u128);\n\n        assert(collateral_debt_value + min_collateral_for_borrow <= total_collateral_value, \"Insufficient collateral\");\n        \n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / borrow_accumulator.value;\n        scaled_user_borrowed_amount_loc.write(scaled_user_borrowed_amount + scaled_amount);\n\n        let scaled_total_borrowed_asset_loc = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address);\n        let scaled_total_borrowed_asset: u128 = scaled_total_borrowed_asset_loc.read();\n        scaled_total_borrowed_asset_loc.write(scaled_total_borrowed_asset + scaled_amount);\n        \n        let _ = Token::at(asset_address)\n            .transfer_in_public(context.this_address(), to, amount, 0)\n            .call(&mut context);\n    }\n\n    #[private]\n    fn withdraw_private(secret: Field, to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let on_behalf_of = compute_identifier(secret, 0, context.msg_sender().to_field());\n        Lending::at(context.this_address())\n            ._withdraw(AztecAddress::from_field(on_behalf_of), to, amount, market_id, collateral_asset)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn withdraw_public(to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let _ = Lending::at(context.this_address())\n            ._withdraw(context.msg_sender(), to, amount, market_id, collateral_asset)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _withdraw(owner: AztecAddress, to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(collateral_asset);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == collateral_asset, \"Invalid asset or market id\");\n        \n        Lending::at(context.this_address()).update_accumulators(market_id, collateral_asset).call(&mut context);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(collateral_asset);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        let scaled_user_deposited_amount_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_asset).at(owner);\n        let scaled_user_deposited_amount: u128 = scaled_user_deposited_amount_loc.read();\n        let user_deposited_amount = (scaled_user_deposited_amount * deposit_accumulator.value) / 1000000000 as u128 ;\n        assert(user_deposited_amount >= amount, \"Insufficient balance\");\n\n        let total_collateral_value: u128 = Lending::at(context.this_address())._compute_total_collateral_value(market_id, owner).call(&mut context);\n\n        let collateral_debt_value = Lending::at(context.this_address())._compute_collateral_debt_value(market_id, owner).call(&mut context);\n\n        let collateral_price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n        let withdraw_amount_value = (amount * collateral_price) / 1000000000 as u128;\n\n        let total_collateral_value_after_withdraw = total_collateral_value - withdraw_amount_value;\n\n        assert(collateral_debt_value <= total_collateral_value_after_withdraw, \"Insufficient collateral\");\n\n        let scaled_withdraw_amount = (amount * 1000000000 as u128) / deposit_accumulator.value;\n        scaled_user_deposited_amount_loc.write(scaled_user_deposited_amount - scaled_withdraw_amount);\n\n        let scaled_total_deposited_asset_loc = storage.scaled_total_deposited_assets.at(market_id).at(collateral_asset);\n        let scaled_total_deposited_asset: u128 = scaled_total_deposited_asset_loc.read();\n        scaled_total_deposited_asset_loc.write(scaled_total_deposited_asset - scaled_withdraw_amount);\n\n        let _ = Token::at(collateral_asset)\n            .transfer_in_public(context.this_address(), to, amount, 0)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_total_collateral_value(market_id: Field, owner: AztecAddress) -> u128 {\n        let mut total_collateral_value: u128 = 0 as u128;\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id);\n\n        for i in 0..market_assets_list_len {\n            let market_asset_loc = market_assets_list_loc.at(i);\n            let market_asset: AztecAddress = market_asset_loc.read();\n            Lending::at(context.this_address()).update_accumulators(market_id, market_asset).call(&mut context);\n            let collateral_asset_loc = storage.market_assets.at(market_id).at(market_asset);\n            let collateral_asset: Asset = collateral_asset_loc.read();\n            let collateral_price = PriceFeed::at(collateral_asset.oracle).get_price(0).view(&mut context).price;\n            let scaled_collateral_amount_loc = storage.scaled_deposited_assets.at(market_id).at(market_asset).at(owner);\n            let scaled_collateral_amount: u128 = scaled_collateral_amount_loc.read();\n            let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(market_asset);\n            let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n            let collateral_amount = (scaled_collateral_amount * deposit_accumulator.value) / 1000000000 as u128;\n            total_collateral_value += (collateral_amount * collateral_price);\n        }\n        total_collateral_value / 1000000000 as u128\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_collateral_debt_value(market_id: Field, owner: AztecAddress) -> u128 {\n        let mut min_collateral_value: u128 = 0 as u128;\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id);\n\n        for i in 0..market_assets_list_len {\n            let market_asset_loc = market_assets_list_loc.at(i);\n            let market_asset: AztecAddress = market_asset_loc.read();\n            Lending::at(context.this_address()).update_accumulators(market_id, market_asset).call(&mut context);\n            let debt_asset_loc = storage.market_assets.at(market_id).at(market_asset);\n            let debt_asset: Asset = debt_asset_loc.read();\n            if(debt_asset.is_borrowable) {\n                let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(market_asset).at(owner);\n                let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n                let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(market_asset);\n                let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n                let user_borrowed_amount = (scaled_user_borrowed_amount * borrow_accumulator.value) / 1000000000 as u128;\n                \n                let borrow_price= PriceFeed::at(debt_asset.oracle).get_price(0).view(&mut context).price;\n\n                min_collateral_value += (user_borrowed_amount * borrow_price * 10000 as u128) / debt_asset.loan_to_value;\n            }\n        }\n        min_collateral_value / 1000000000 as u128\n    }\n\n    #[private]\n    fn deposit_private(\n        from: AztecAddress,\n        amount: u128,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        let _res = Token::at(collateral_asset)\n            .transfer_to_public(from, context.this_address(), amount, nonce)\n            .call(&mut context);\n        Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, market_id,collateral_asset)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn deposit_public(\n        amount: u128,\n        nonce: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        // docs:start:public_to_public_call\n        let _ = Token::at(collateral_asset)\n            .transfer_in_public(context.msg_sender(), context.this_address(), amount, nonce)\n            .call(&mut context);\n        // docs:end:public_to_public_call\n        let _ = Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, market_id, collateral_asset)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _deposit(owner: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(collateral_asset);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == collateral_asset, \"Invalid asset or market id\");\n        \n        Lending::at(context.this_address()).update_accumulators(market_id, collateral_asset).call(&mut context);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(collateral_asset);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        let total_deposited_assets = Lending::at(context.this_address()).compute_total_deposited_assets(market_id, collateral_asset, deposit_accumulator).call(&mut context);\n        assert((total_deposited_assets + amount) < asset.deposit_cap, \"Deposit cap exceeded\");\n\n        let scaled_user_deposited_asset_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_asset).at(owner);\n        let scaled_user_deposited_asset: u128 = scaled_user_deposited_asset_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / deposit_accumulator.value;\n        scaled_user_deposited_asset_loc.write(scaled_user_deposited_asset + scaled_amount);\n\n        let scaled_total_deposited_asset_loc = storage.scaled_total_deposited_assets.at(market_id).at(collateral_asset);\n        let scaled_total_deposited_asset: u128 = scaled_total_deposited_asset_loc.read();\n        scaled_total_deposited_asset_loc.write(scaled_total_deposited_asset + scaled_amount);\n    }\n\n    #[public]\n    fn compute_total_deposited_assets(market_id: Field, asset_address: AztecAddress, deposit_accumulator: Accumulator) -> u128 {\n        let scaled_total_deposited_asset_static = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let total_deposited_asset = scaled_total_deposited_asset_static * deposit_accumulator.value / 1000000000 as u128;\n        total_deposited_asset\n    }\n\n    #[public]\n    fn add_asset(market_id: Field, asset_address: AztecAddress, oracle: AztecAddress, loan_to_value: u128, is_borrowable: bool, optimal_utilization_rate: u128, under_optimal_slope: u128, over_optimal_slope: u128, deposit_cap: u128) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n\n        assert(loan_to_value <= (10000 as u128));\n\n        asset_loc.write(Asset {\n            asset_address,\n            oracle,\n            loan_to_value,\n            is_borrowable,\n            optimal_utilization_rate,\n            under_optimal_slope,\n            over_optimal_slope,\n            deposit_cap,\n        });\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id).at(market_assets_list_len);\n        market_assets_list_loc.write(asset_address);\n        market_assets_list_len_loc.write(market_assets_list_len + 1);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        assert(deposit_accumulator.last_updated_ts == 0);\n        assert(deposit_accumulator.value == 0 as u128);\n\n        deposit_accumulator_loc.write(Accumulator {\n            // 10**9\n            value: 1000000000 as u128,\n            last_updated_ts: context.timestamp(),\n        });\n\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n\n        assert(borrow_accumulator.last_updated_ts == 0);\n        assert(borrow_accumulator.value == 0 as u128);\n\n        borrow_accumulator_loc.write(Accumulator {\n            // 10**9\n            value: 1000000000 as u128,\n            last_updated_ts: context.timestamp(),\n        });\n    }\n\n\n    // Create a position.\n    #[public]\n    fn update_accumulators(market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let mut deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let mut borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n\n        let timestamp = context.timestamp();\n        let time_delta = timestamp - deposit_accumulator.last_updated_ts;\n\n        // Only update if time has passed.\n        if !(time_delta == 0) {\n            let precision = 1000000000 as u128; // 10**9\n            let utilization_rate = _compute_utilization_rate(market_id, asset_address, precision, deposit_accumulator, borrow_accumulator);\n            let borrow_rate_per_year = _compute_borrow_rate(asset, utilization_rate, precision);\n            // TODO: let supply_rate_per_year = borrow_rate_per_year * utilization_rate * (1 - reserve_factor);\n            let supply_rate_per_year = (borrow_rate_per_year * utilization_rate) / precision;\n\n            let new_borrow_accumulator = ((borrow_accumulator.value * borrow_rate_per_year * time_delta as u128) / 31536000 as u128) / precision;\n            let new_deposit_accumulator = ((deposit_accumulator.value * supply_rate_per_year * time_delta as u128) / 31536000 as u128) / precision;\n\n            borrow_accumulator.value += new_borrow_accumulator;\n            borrow_accumulator.last_updated_ts = timestamp;\n            borrow_accumulator_loc.write(borrow_accumulator);\n            deposit_accumulator.value += new_deposit_accumulator;\n            deposit_accumulator.last_updated_ts = timestamp;\n            deposit_accumulator_loc.write(deposit_accumulator);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_utilization_rate(market_id: Field, asset_address: AztecAddress, precision: u128, deposit_accumulator: Accumulator, borrow_accumulator: Accumulator) -> u128 {\n        \n        let scaled_total_deposited_asset = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let scaled_total_borrowed_asset = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address).read();\n\n        let total_deposited_assets = (scaled_total_deposited_asset * deposit_accumulator.value) / precision;\n        let total_borrowed_assets = (scaled_total_borrowed_asset * borrow_accumulator.value) / precision;\n        let mut utilization_rate = 0 as u128;\n        if (total_borrowed_assets != 0) {\n            utilization_rate = (total_borrowed_assets * precision) / total_deposited_assets;\n        } else {\n            utilization_rate = 0;\n        }\n\n        utilization_rate\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_borrow_rate(asset: Asset, utilization_rate: u128, precision: u128) -> u128 {\n        let mut rate = 0 as u128;\n        if utilization_rate < asset.optimal_utilization_rate {\n            // rate = base + utilization * slope1 / optimal No base for now\n            rate = (utilization_rate * asset.under_optimal_slope) / asset.optimal_utilization_rate;\n        } else {\n            // rate = base +slope1 + (utilization - optimal) * slope2 / (1 - optimal) No base for now\n            rate = asset.under_optimal_slope + (utilization_rate - asset.optimal_utilization_rate) * asset.over_optimal_slope / (precision - asset.optimal_utilization_rate);\n        }\n        rate\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_position(owner: AztecAddress, market_id: Field, asset_address: AztecAddress) -> pub Position {\n        let scaled_user_deposited_asset_loc = storage.scaled_deposited_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_deposited_asset: u128 = scaled_user_deposited_asset_loc.read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let collateral = (scaled_user_deposited_asset * deposit_accumulator.value) / 1000000000 as u128;\n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let debt = (scaled_user_borrowed_amount * borrow_accumulator.value) / 1000000000 as u128;\n        Position { collateral, scaled_debt:scaled_user_borrowed_amount, debt }\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_total_deposited_assets(market_id: Field, asset_address: AztecAddress) -> u128 {\n        let scaled_total_deposited_asset = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let total_deposited_assets = (scaled_total_deposited_asset * deposit_accumulator.value) / 1000000000 as u128;\n        total_deposited_assets\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_total_borrowed_assets(market_id: Field, asset_address: AztecAddress) -> u128 {\n        let scaled_total_borrowed_asset = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address).read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let total_borrowed_assets = (scaled_total_borrowed_asset * borrow_accumulator.value) / 1000000000 as u128;\n        total_borrowed_assets\n    }\n\n\n    #[utility]\n    #[view]\n    unconstrained fn get_accumulators(market_id: Field, asset_address: AztecAddress) -> (Accumulator, Accumulator) {\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        (deposit_accumulator, borrow_accumulator)\n    }\n}\n","path":"/home/jean/work/noir/comet/contracts/src/main.nr"},"56":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr"},"57":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"64":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"65":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"66":{"source":"use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr"},"67":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"71":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"88":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"92":{"source":"use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr"},"93":{"source":"use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr"},"96":{"source":"use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr"},"97":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"100":{"source":"use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr"},"102":{"source":"use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr"},"103":{"source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr"},"104":{"source":"use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr"},"105":{"source":"use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr"},"106":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr"},"107":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr"},"109":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr"},"110":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr"},"111":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr"},"112":{"source":"use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr"},"133":{"source":"use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr"},"136":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"139":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"140":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr"},"141":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"142":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"143":{"source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr"},"144":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"149":{"source":"use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"150":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"151":{"source":"use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"152":{"source":"use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr"},"154":{"source":"use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"156":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr"},"157":{"source":"use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"159":{"source":"use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"168":{"source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"182":{"source":"/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr"},"185":{"source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"186":{"source":"use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr"},"188":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr"},"189":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr"},"191":{"source":"use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/field.nr"},"193":{"source":"use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"204":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/jean/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr"},"221":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr"},"223":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"266":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"269":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr"},"271":{"source":"use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr"},"276":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, FromField, Hash, Serialize, ToField},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"283":{"source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"284":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"298":{"source":"use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"300":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"301":{"source":"use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"310":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"321":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"335":{"source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"339":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"340":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"356":{"source":"pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr"},"359":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"369":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/home/jean/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr"},"400":{"source":"use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr"}}}