{"noir_version":"1.0.0-beta.4+0000000000000000000000000000000000000000","name":"Lending","functions":[{"name":"borrow_public","hash":"12296407488885726513","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"1Z3dbts4EIXfxde54PyQnOmrLIogSd3AgGEHTrLAIui7r+xashNrrS2tI4g3gVVzzvki6HAsmUw/Fj+Wj+/P96vNz+3r4ttfH4v19unhbbXdNEcfv+4Wj7vVer16vj//50XY/2A+jH99edjsD1/fHnZvi28krPFusdz82L8WC43Gz9V62RyF5vXl+MDcDg/K3WjPPYPVQz4OVqfUDU6xZ7Cp2nGwadLzwd/vFizj0Lu3w4l8Onodhz5ad+5t4NxTzC09JZHr9B5Fj4O9qftKH8emJ/5Ev/dIE3jkPo/k0lokj7GriQK+JqyfJuWOxgZoYrBwHNy8tAGaSO3vaVHCVxrvp2HpaFK6TnP915WANiC0AaMNBG2gaIOINkhog4w2MLQBOsmKTrKik6zoJCs6yXp7kjlR+1mI01nPbz7WHRwi3CHBHTLcweAOjnaIAe5AcAeGOwjcAZ7pCM90hGc6wjMdb890knbuTvF06+XpIO9Q+RSw8oSVZ6y8YOUVKx+x8gkrn7Hy2NQmbGozNrUZm9p8e2rJQvsEiozsqwE2txmb24zNbcbmNmNzm7G5zdjcGja3hs2tYbutYVNr2NQaNrWGTa1hU2vY1Bo2tY5NrWNT69jUOvxG1+E3ug6/0XX4ja7Db3Qd/vDK4Q+vmu8B8RaEt2C8heAtFG8R8RYJb4HtzhQMrI/tz0QBrE9gfQbrC1hfwfoRrJ/A+uD80lB+c+B8Xb/JaErtE5XgdvoGMebfHo734DCBB93u0Yh0i6WINZ57XA6XoHQcLSF+WgR0AOK5AcncgHRuQHFuQGluQHluQDY3IJ8eyNvRwvkTUN88Sjl08yjL1xUlJKFyfqqcnyvnl8r5p29KktrPgCJn67n/gz+LdPw5XvJP38NU2jMqqnmI38Lpc5xdLEAmmb7lKdGJ34b4vVs/3byOdsGfK+e3yvm9bn4NlfNT5fxcOb9Uzq+V88fK+Svvv1p5/9XK+69W3n9j5f03Vt5/45zm/wPQnCb0A9CcZugD0PRTbuR2majEwVvO5p7gtB1YWS74rXJ+r5s/hcr5qXL+MW4ZxPTkEfic/+ChE3jECTzSBB6982mm7g8UZJrwDxRQ/5aKHIw7nLPHqL04nwbbp/NzcHC0Q//GilEd6GaHoeVC/fsrxrUQvIXiLSLeIuEtMt7C8BYOt7CAt8Cn2/DpNny6DZ9uuz3dV1ddWQLrZ7C+gfUdq+8BrE9gfQbrC1hfwfrg/Do4vw7Or4Pz6/COzCHgLQhvwXgLwVso3iLiLRLeIuMtDG+BTzfh0034dBM+3YTt1EwK1o9g/QTWz2B9A+tjP2kzB7A+gfUZrA/OL4Pzy+D8Mji/DM4vg/PL4PwKOL8Czq+A8yvg/Ao4vwLOr4DzK+D8Cji/As6vgvOr4PwqOL8Kzq+C86vD+bWhL4uTdtslUjrtltCjQ4I7ZLiD3e4w5hY+Vp8ZUAxzA6K5AfHcgGRuQDo3oDg3oDQ90Ig7Fznmyvmtcn6vmz+Fyvmnb0pj7tzlNH0PG3PnLqfpW96YOw84aeX8sXL+VDl/rpzfKuf3uvlzqJyfKufnyvkr77//Y2H4vPkr77+58v6bK++/ufL+a3Oa/w9Ac5rQD0BzmqEPQNNPuWPuXGSLlfOnyvlz5fxWN7+PcctwfTcqO03gwRN4CNxD+hdCk2pXpfHk0Tzx+F2ViqpyUZUVVXlJVf864cGq3uuNTkttKfHp2akei7ikSEqKUklR//m7+r249K/OHCrSArz+dYJDRSUnon9F31CRlRR5QZGEkqKSC1ZKLlgpuWCl5IqQWHDtSSopyiVFVlJUEkItCaFSSRGXFElJkf5p0a/m6O+H3erhcb18bWr2b75vnt5W283x8O2fl/adx91qvV4937/stk/LH++75f16+7R/bxH2P/bmovmuaZ8NzP460yB3TSf4vv8fRZpD9ngnIewP9+dRAjWH0jA0HP8C","names":["borrow_public"],"brillig_names":["borrow_public"]},{"name":"get_total_borrowed_assets","hash":"10882890731369331842","is_unconstrained":true,"custom_attributes":["utility","view"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"H4sIAAAAAAAA/+29aZQc13UmGFkbUAkUKgmAJEgAJEiQFHfmXlWWF0girIUULUuybHnPqsykKFIEBYAEd0ahsBALQZAiqM27LS/yIkuyZFuWN3lmbPc5PjM/PKfHM56Z4+MzPT0z7p4en+6ePj06M4Mg82Z++eWNFxGV9xVSRL1zgIqMd99377vvvvvuWyIiF7yZxi7+y3WuJ+AeJ6HZ1/lbHC6VDLGKPuXMGcqZAznHBi5AeLzW8u+/7s2/00QT5Y8bVn6a+FrizxcXFqeD/mQsf2UaMD3glwV/wg9+cUMH5zNhP35AfGc6v9F+pIzkoR19tpO38eK/LUHv+knAi9LngK9gTxOesU00PLdZaVuM/FK3KL0rDLqpx7dUma9XyvP1crnZKjaa9bn2QmWuWFmsVRaWFkvFSq0835xrVIrFVqW1VC026wu1ZquxUKu0FxsLdcG+V8WutBYvQtUa9fnFUrtRbxcXq3PzlUZ7bq7ZaC5UW3O1YrO0VC8tlUvt+flGrdZYqi2USu3WQq0938XeH3rRWVnwv98LfqUm+O8G/Ak7+YuC/x4/+F0/+V4/+F39v8+L/nvy39fBDwJ73d/vRfZSF//9fnRTFfwH/OBXBP8HAD/nAf8DfvC7tvODfvC7tv9BP/pvC/6HOvgBYJfmK+XyXGVhrrgw3yyWqs2l8vxF779YLS4VG0vl1kK1tNCulquVpebS4nx1vlFqF9uNpYX2/Jvggv1hL7JXurb5Q150X+mOKx9RdFMcLnV9/g/HY69a/YL9Iwp2uVFZKi60i43afGOuNV+7OFwXL14szrfa9XJj8eLAXW6WSqVW9eJ/5VazurDYrJcW6625cm3xIrtum3409NGmpSXB/1Fj/HqjuNCq1+cE/8eM8RcX63ONi/oU/B83xq8s1VvtylzXH/yEMX6jVm23a5WG4P+kMX6tVGzVynNd2/wpY/yFxWKtPj/ftZ+fNsa/GHdWmguN7pytYa2fxVZxqVlakLnHYgdfeERJeC8Z8+6khRzxC4L+eUhA/PMkq3VcliN+KA/qR+YyortmOChrQclDH8N548o94aNh/Zgh1o8bYv2EIdZPGmL9lCHWTxtiSb/229eq3XG06QW/Mi/4LS/4xZbgt33gl3qx44OAH9jJ38X/GODnPOA/5Ef/XfyP+9FPd17zcAffB/Yj9tjd+OgTfvTeje8e9YPfnXMc8IPfjX8f84Pf9Tuf9IO/IPgH/eB3499DfvC78eNhP/jd+PdxP/hNwX/CC36pq58jgG/nl8tdv/mkF/xKF/8pP/hd3/m0F/xqF/8ZP/jdNZtn/eB3/fNzfvC7/vl5P/jduOoFL/i17vw79IJf79rPsh/87nruUT/4Xftc8YPftc9jfvC79nncD343fjjhB78bP5z0g9+NH170g98dv075we+O76f94HfH9zN+8Lv+7awf/K5/e8kL/lx3fD/nB787f3nZD37Xf573g9/1n6/4we/6z1f94Hf956f84Hf922t+8Lv+7YIf/K5/e90Pftf/fLqDH6weu8I3NgVvnvP51rY38TYHvfM/D7YOv/ORA0sPP/D4JxZbB3G1W2Y4cq3dxxShbu2hvuvAo4cPNpYOv6PZPNg6dIgRJhTkIAY1D6gfazz06HubjDa5OrSPtA4eeujAo4w2lRJNzixtAHrDmLUoZ7g2knzIG8/qGc5Hm2n2RJB/nmQ1nn+XcsRP5GH94J5ILui1NpYtKHnchnmFT17hU1DyOIYeBuucIdYxQ6yzhliWdTxtiHXSEOuMIdZxQ6wjhliWurfsQy+PKFZoiGVpE5a6t7Svo4ZYln3b0iaWDbEsffSrhlijOj7K3MRvbFVszCi8JUneJuCNMRUnjsRR7qjcX23r4TKdpM1Q5tBTjy49cOBw61DgKBAlOSzP90dNefywxOYUdQiCZMX+fQrFcgCPss0QJpbNKVjaVIyNGXW+MUYGxJC2wkDYcBJRSVMP5L9WkwjNSWiTCNHPJj/6KecIH+XZpOiHbZjbLhf07HESsJB+E9QR6fFayuO9/6HztxAM9iN5gCCn5I0r90S/0UT7v6W6Yduwnfpph2oprZ0K/3zgs9/07FSzC20wmw4G29ny0FaadtV824ySJ1iyAIV2ivSboY5Ij9dSHu/9b52/hWDQptlOZ5T64D2003/sXE/H1Gdf53dxqDQ3p41T3A9QT5aH0NP2A+GfD3zaXa8faO2k+RPR3RZF1oKSx4s+WxQ+WxQ+BSWPA9FhsM4aYi0bYq0YYr08olgnDbHOGGIdN8Q6Yoh1yhDL0u5HUV+ucTArVpQsbfW8IdYJQyxLW7WsY2iINap9+4Ih1pOGWLIJy3Gm4EdpOhjse9ZzN+Qn9cB7yD9PstrK04uVNL1qMa3oZ9aPfrryzCryzCr6kbYsKHmCdUXnN84ZkH4W6oj0eC3l8Z4sVBQIM0o8Zygo9cF7OGe4K9dfN2wbtlOf7YD8RG68h/zzgc9+U3Tahdb/p4PBdjbUTzFNu6K80pZXKHmCJccg0E6RvgB1RHq8lvJ47x1kp2jTbKdXKPXBe2inbyc7xbZhO/XSDqV2ajsV/vnAZ7/p2almF7OKHqeDwXY21E8xTbuivNKWW5U8weosYffZKdJfAXVEeryW8njvB8hO0ab5wbOtSn3wHtrpezu40zH12df5XRwq1apaW9rhz5VmlHpyP0Nd29l1JXU/E/75YNAufPSzbSRPnB2I7rYrshaUPLaR7Qqf7QqfgpLH85phsFYMsY4YYi0bYp0yxAoNsU4aYp02xLK0iaOGWC8YYr1shKX552HkOmckV5TOG2JZ9u0LhliWvtCyP54xxLJsx9cNsSxtwlL3Vn07MK6jpU2cNcQaVT9hKdflEDOtj2mXTveW/fGYIZZlHT81onJZxhOWdeT9AZxb5jp/p4PBvmc4z27liJ/UA+8h/zzJaitPb56t6XWbolfR3ZWKrAUlj+fZVyp8rlT4FJQ8HjOGwVoxxDpiiGVZx5OGWGcMsc4bYlnq/oIh1no7ZsN63RDL0iaOGmKdNcSy9F8vG2JZ6t7SVi11P6r+y9JWLe3rtCGWZTta2pdlH7K0r3OGWKEhlmUdRzWWs6yjZTwxqu04qrHcpwyxRjXOsYwx1+OJt0YfsvQTlnJZ2Vd0zeuqw8j1SmiHZal7yxhAxlo+7yb4UfK7hlZOfcaW19C8nMFKWEPTztZNB4N2aKifUpp2RnmlLa9S8gTr6s5vPBOG9FdCHZEer6U83ntXRykFwowSnwm7SqkP3hP9RmfCvqfzYzqmPvs6v4vDpXleDxUeyBv1ZGh3qT5QgfzzgU+76/UDrZ00/yK6u1qRtRAM2g7bw9UKn6sVPutYo4X1ASMslw+T/ChNK+Ws/S3yk3rgPeSfD7z6hZJLr5q/FP3s8KOf7hnlHYo8OxT9SFteo+QJ1rWd3zgeIf0OqCPS47WUx3sP0nh0DdByH7hGqQ/ew/GoMdZfN2wbtlM/7ZD+mQ/hnw989puenWp2ofX/6WCwnQ31U0zTriivtOW1Sp5g7ez8RjtF+mugjkiP11Ie7z1Odoo2zXZ6rVIfvId2eqDzYzaI759p+jPian6bdYjluD94ae9Sq5i2Pwj/fOCzf/b6wzUp9Sr6udaLfprtNPaD8kpb7lTyBGtX5zf2B6S/FuqI9Hgt5fHeCeoP2He4P+xU6oP3sD+E5LexbdhOvbRDsdhOa6fCPx/49JM9O9XsQhv/poPBdjaUp5WmXVFeactdSp5g7e78RjtF+p1QR6THaymP914jO0Wb5mf1din1wXtop+dovsv12df5XRwqtUpaW9rhN4rTiq7t8MsL00p72eEvzgv+dX7w64J/vRf8+W777vGCX+vq5wY/+E3Bv9GP/XTl3+sFv1IR/Ju84Le68t/sBb/axb/FC/5it/++zQv+Qtf+b/Wjn2773uYFv10T/Nv96Kcr/x1+5O/6/7sA33ItQvDv8YJfrIg+7g56aVypk/CXWOROoM/F/BUszhNeecLyFfdpdUP5ed53N8iDOojDujsj1rSS56NN73LUG/nPOGTlekSJ34GzWp1E6agh1vOGWOeMsLTYdhi5njKUa6eRXFr8OwzWbkOsDUZYUeKPHg4j13VGckXX148o1h5DrBsMsW40xNpriHWTIdbNRlhRei20k+sWQ7leMpTrbUZyRde3GmJZjR3R9W2GWLcbYt1hhBUlXjsdFSzZQ/a73lVd8LveVWn4Xe+qNv2ud9Uqfte7qnN+17uqSxKr3xD0Ui7oty0c3+zmFdXUz4IK/zzJaitPb353I8nD+uHzO3sVWQtKHvfRvQqfvQqfgpLHZ3mHwXrVECs0xDpliHXSEOuoIdYRQ6zThlgrhlgvjyiWpa0eN8Sy0r02bo+KrVr2x/OGWKPaH18xxLLsQ6Oq+xOGWJZ+wnKstfTRlrq31Neo2pdlbGLZjpa6vxz8xAUjrOia57DDyPWsoVy7jeSyxIrS06GdXNcZymWl+yi9YIhlaRN7AjusDUZYUbKyiSg9b4j1jCGWpX1ZymVlq6PsCwuGclnaqmU7WvrVUdWXpa3y2uqo9G1L//W6IZZl/HXMEOukIZZlTG45V7Bce5T4Xtax90BervPX7x5AcdV7AHv8yOPcA9gTDOpVOw9rKE8zTTujvNKWNyl5giV7+Xi2H+n3Qh2RHq+lPN77QqfhCoQZJT7bf5NSH7wn+o3O9v/8eH/dsG3YTv20Q/pvwAr/fOC135RcdnGjokfNLqRsQcnjmD5te2ltz2ffhsE6a4i1bIi1Yoj18ohinTTEOmOIddwQ64gh1kuGWJZ9yLIdXzXECg2xzhtiWfZtS/uy7EOWfvVy0P1pQyxLHy2+UHuOyjD+KGrPORnid585uNmhC+TPZ3EkX/srWJwnvPKEZVy3kqturrkbxuF8tlfDujkjlvZsnI82vclRb+Tv91nAWtnvs4C1ut9nAattsfm3gT5zpLvbvLTlfOp3qQj/PMnqq0/dRvKwfng+dLsia0HJ47N7tyt8blf4FJQ8HreHwXrVECs0xDpliHXSEOuoIdYRQ6yXDLHOGWJZ6n5UbfW8IdaKIZalfVn6nLOGWJeD7k8bYlnW8eURxbLs28cNsax0H13zudxRsdVRjQEssdbH7fVx+ztl7Fgft9fH7fVx+62p+1G11VcMsSz1ZelzLHV/whDLsg9Zjtuj6qNHNZ6wrKNl7GvZjpa6vxz8xAUjrOiaz+cMg3WTIZbVOnl0fbMRVpT47PEwchUM5XrWSK4ovWCI9bwRVnTN+1/runfXkZ+dGAZrtyHWdUZYUbLU161GclnaapQs+9Co2v2o1vGt7gst5YrS+tjxnT92ROk5I6zo2vLMg5W+ouvrDeV6xlAuq7E2Spbjo6W+RnHsiNLrhliWc75jhliWezqW6wCW6xOW53P4+TY8G5br/NXeFx/x2df5XRwuNXPET+qB95B/nmQ1lqfk0uttil61990byrOUI3yU5w5FP9KWdyl5giXvycTn25D+Dqgj0uO1lMd7Y5Nv/i0QZpT4+TbtXel4T/QbPd/27Yn+umHbsJ36aYdy6ufbhH8+8NpvSi670Pq/ZhdSVmsvHvfTtpeGddIQ62VDrGVDrLOGWK8aYq0YYp0zxLKU66gh1hFDrAuGWE8aYr1uiGWprzOGWJb98bwhlqXdW/pCy3Y8Zohl6XMsbeK0IZal7sMRleslQyxLm7CMTSzHbct2HFX/ZWlflv1xVH20JZalfR03xBLdz3TycH6T6/z1/A24ao74ST3wHvLPk6y28vTmeppe71D0KrpL832x6Nrym03sm4fBOmuItWyItWKI9fKIYp00xDpjiHXcEOuIIZbVt5GiFBpiWfbH84ZYlvZlqa9ThliW9mXZhyz9qqVNWPrVUe3blv3Rsg+9aohl2R8vB/s6bYhlGQPIWDvbycN4e2/QzydrzI/lhW5GKZfr/PX7Dd+F1O/rEP55RSc+Yv67U+pVdHePImtByeOzK/cofO5R+BSUPB6bhsF61RArNMQ6ZYh10hDrqCHWEUOslwyxzhliWep+VG31vCHWiiGWpX1Z+pyzhliXg+5PG2JZ1vHlEcWy7NvHDbGsdB9d8/s6RsVWRzUGsMQa1XHbUveWMYClj7aMJ0bVVtfH7Us3pq3H5Nmw1mPyS2df63HhpbOv44ZYo6r7UbXVVwyxLPVl6XMsdX/CEMuyD1mOHaPqo0d1TLOso2Xsa9mOlrq/HPzEBSOs6JrPOA0j19OGct1kJFeuc88Ky3J/yFJf1xvK9YKRXFF63ggruuZn+kfBJqLEzzaPgu4t+7Z1f7TqQ9H1zUZYUbLsj5eDffH7hobB2m2IdZ0RVpQs9XWrkVyWvjBKlj56VO1+VOv4Vh9rLeWK0nps8p0/dkTpOSMsy3giSlb6iq4tY/JnDOWyGmujZDk+WuprFMeOKL1uiGW5pnDMEMty38pyncly/cvyfCG/b6gAebnOXznni74u4rOv87s4VCqlft+Q8M8Hg2OVnTy9c77XBoN6LSh6Fd3tVGQtKHk8N96p8Nmp8CkoebznOwzWWUOsZUOsFUOsl0cU66Qh1hlDrOOGWEcMsV4yxLLsQ5bt+KohVmiIdd4Qy7JvW9qXpVyW7Wgpl6WfsLQJy3Y8bYhl6e/Fr0psxTHBvs7v4lCpVpPYBGOZXNDPG2MTw7huPkf8RE94D/nnSVZbeXpxndZuqB+O63YpshaUPG7DXQqfXQqfgpLHfXMYrBcNsSzlOmuEFV1vCmywrOt4xBDrtCHWy4ZYxw2xLPV13hDrNUOslwyxVgyxLHV/0hDrqCGWZR0vGGI9aYgl63wcW0RpX+fvxeGwMl+vlOfr5XKzVWw063PthcpcsbJYqywsLZaKlVp5vjnXqBSLrUprqVps1hdqzVZjoVZpLzYW5vzGDrWF6WDQxxvGJiXB3+0Hvyz41/nBrwj+9X7wq4J/kx/8muDf7Ae/Lvi3+MGf8/vug9K84N/jB7/bv4p+8BuCX/KD3xT8sh/8luBX/OC3Bb/qBb9cFPyaH/yu/6z7we/6zzk/+F3/Oe8Hv+s/F/zgd/3nd/nB7/rPt/vB7/rP7/aD3/Wf3+MHv+s/v9cPftd/fp8f/EXB3+cHf0nw3+EHv+v/3+kHv+v/3+UHv+v/7/WCX+n6//1+8Lv+//v94Hf9/7v94Hf9/3v84Hf953v94Hf95/v84Hf9231+8Lv+7X4/+F3/9n4/+F3/9oAf/K5/+wE/+F3/9gE/+F3/9oNe8Ktd//NBP/hd//MhP/hd//NhP/jd+POH/OB348+P+MHv+s8f9oPf9Z8/4ge/G39+1A9+1z//qB/8rn/+MT/4Xf/8437wu/75J/zgd/3zT/rB7/rnn/KD3/XPP+0Fv9aNPxt+8Lv+f9EPftf/L/nB7/r/ph/8rv9v+cHv+v+2H/yu/3/QD37X/3/MD37X/z8U9FIPu9JavLjVUmvU5xdL7Ua9XVyszs1XGu25uWajuVBtzdWKzdJSvbRULrXn5xu1WmOptlAqtVsLtfZ8V/aPq9jDpN6+yMM+9FJqd/3CI4CfM5N/vov/CS/4xW6/etSLfppdv3xAadtytVlfbBTn2nONxnz74iBabl78U79oNe1aubFQWWpctKLmYquxWFlaKC81y81Ka/6ir2lVFuqtVm/MeszabkrFrt4/6UXvvf2Qg+Z6n3/j/+ibpuc7G6WzHfxJ4DVN9Zrq/JbvtUbpobBHMwn5SP9XnYMq0e/XOvxmqIxgBEFvD3fKvN5v6HUhR/yCQD+jJfzzim58nNGaInlYP3xGa4Mia4HyosR79hsUPhsUPhrW64ZYRwyxXjLEWjHEOmOIddQQ66QhlmUdjxtijap9hYZY5wyxzhtiWdqXpb5OGWJZ2pdlHzpriGVpE5Z+Vc5yamfJ7cbmekPGWpx3SJI8nDdMUN4jQH9v2KPjNE6/sU4bL/77p209XKZjeTBuehjw42KGKIkeN0K+ZYwj+Hk/+BWxqemgX6dcp3yMriRf+ytYnCe88sGg3n3Eh1rdUH7uLxi/ow7isKYzYk0reT7adKOj3sh/xiGrVg9+dkHzR1r8LfR5h1xIP6vwlrKiw82QZ6jDskuH2BeF/2agbbYWH3/w/gMPBpTGSQ+itx1E976wpwe2wekYrIB+76B744CHye+c8dKOA1KnrOMAzlcfprzV+r0osW9AnQvP6N4/O9YWsAzaUNq1BaHfNt3j9x87N6eDwb67r/O3mC2V+YbncWxR2mdTMJgkb7Oi77S2JHJHtvTtVcYUmykP/egM5WGf30J56A9nKS+vyLNa+8S2moqplwUf1NEG4rPBkA/qeyPx2WjIR/PXPOZHaV/nb3G41F3jx+faDPvWEvcfTJI3A7w5VtwCeWxHs5DHbY/v7OD2ukLRcdq+LHqKMK/d3sNlOkme47XMvov1i7pn/aLuWb+oe9Yvv9srCNLrV/SUVb+Xg/2uxkY/nEKH2tgwQ7S4D8G+6L6wR4d1mVDKR+nBsB9L6Isbe3J/oiP3qLVv1rEf22K1Yz+P7zgW8fiOthI3vqN9af5j2DEM22p97E/PR1sz8Rz7Zrb/TZQ3auMzxtojMD6PvH5xfYWT5fh8Odjvamz0O2l8/pgyPmtrg+OK7Jo/9rz+XU7jh5F/Phj09z7WlLV1QW0PJrJpsddDhw8cbDzY+mCr0fcaQ838OB+T/J6ge/x7mn5PEc7D4SCOK6WtuixfzgaDZsVubN2ksptU1uX6qbXR6wLLhUkLX1GfnDSXK3JHfx/L4HLR/jgku9ymJD6XHHFI9T0leasuE2p9aFg+ru0zXC7e1/lbHC4teN6aa3L/waSFhBwuWk5pJG+rouO0fVn09FYMx1e75Mj6Rd1r/UCS5XTyctDvanSYZbqDbcXTHdy6zFF5nu5IXSaU8lHi6Y7Q/8H6cuQlG/u1I+qrHcNQR+tjf3o+acZ+Y/tf9Va81je4rdH3cfug72OdDrOdtdrxA/kY6rfBfQ8T617TL+qe9Yu6Z/2i7lm/qPusy5FCl1W/yOetqt+0OhRdDDM+b4rBTDM+iw4mlPJR4vFZ6P+dYzmS25dlHyd5o8RHmIxto5LGDyP/PMlqLE+J9Y/6Q/1kXI6cpGKcHyjQScuROfo9RjiPhIM4rpRTcLSq83JkTpFhRsFik/LUhKmXI+VePvDq/romNa7oFfXDuptQZC0oeWuk1zktPAxIZgzDsg5bci/rciS2KZ8uFxmiv/w0qKY71GtEv6/zuzhkYhuYAHm0tpwk+tnpfhppg3GgHVNwtOGEd7BQJzycCN9Ir0/SdC9nrKvK4kJjqTGoq6Q6anYgZSPXLH5K29WUcrNUFumjJD5P6CX8nQJeSCNlJ4l+B+jzmY4+tZMbIs80lbft05f2NLnUKetpcmxHlA0x5fQ2t21cu9wE7fI8hU3IbzaIr4f8fkjhx8uakh8laeNtcN+ujUultOOh8M+TrMbjSHc83EbysH60EOuRA43muxqPHXr8kRaHFryiKfAFghMapMVUAJGQnsOvApW7Pxwsx0lUOUky3wsPD9zdueaZtpSP0nQwWGfLFbe0JiP81+qjgFeQPKyfMdKPJxNezAWD5jqu8BR5pS23KXmC1fE6fa4L6bdCHZEer6U83vvujj0VgsFux7NOrUviPdFvZKd1slOcMcnsVAsZ76O8jY68aUeea6UUV4ofonIzCmZUn9MUYmm2hu3N0yC0/ThfFIe1n7Cw/DbC2p6A9QBhYfnthHVlAtb7CQvLX0lYVyVgfYKwsPxVhHV1AtajhIXlryasHQlYBwgLy+8grGsSsB4jLCx/DWFdm4D1ScLC8vzh650JWAcJC8vvJKxdCViHCAvL7yKs3QlYhwkLy/PHqq9LwHqcsLD8dYR1fQJWi7CwvJSdUbB4fN4D9y/F+Cz88ySrr/F5TzCoV9QPL3HcoMhaUPLYb92g8LlB4aNhXWmIdZUh1tWGWDsMsa4xxLrWEGunIdYuQ6zdhljst5LG6w+Gb/51jddSDm0X6caBRhujESMuHhgP0scF95PMGk8txvx42J+Hy1kcD+KyIMfkuDO0jfIwxmS/j7tS2ykPd6WkPhhj8jLbS537fpd7ikWcm8TpytcpA146KhjyQax7w34+a7/kUmylqQfy973kIrq40qGLq7zwrqZefrqKdHGlJ12IX0qaF/BSsxb7X6nQ43LVg63D9x948J1PfbjxIB+q4SmiiMOHurbR7+0xYu0juqvot4QXcYd7sHk0OXg5jOn3JdDjddxBdW3atJV4as2G99g1YPkdDj5XDsnnSoWPdC0MoSxNWfD9fAey994jbaqKdRL+M4qesrh25JUPBtvIhxvQ6uZqZwxh00zpr82INa3k+WjTaxz1Rv4zDlm1evAhVPFzt3diqSgM+j3H0iEPS34eEqrU09qj8F+rd++mffeXFtpKWT4UGaXnwh4d540r98YcWGcNsV4xxDpjiHXUEOuIIZZlHS3b0bKOy4ZYlnU8bYj1kiHWKUOsFUOs84ZYJw2xLG3Csj9a9iFLm7DU13FDrJcNsSx1f8wQy1L35wyxLPVl6QtDQyxLfY2qL7TUl6XPuRxiJkubsBy3rXQfXeODHaNk95a6P2GIZWn3lnW09BOWMYClvi4YYqX5Pk3Wd3pr61KXyzu9a0Rn8U7vGt0bBzxM+A5pXg8LgN7vemwl9ZMtwj9Pshq3f3fNSjt+pK17iu52KbIWlLxb4RrzkM8uhU9ByeNxexis04ZYLxlinTLEWjHEOm+IddIQy9ImzhhiHTHEsrQJS30dN8Sy1NcxQyxLfb1iiGVpq0cNsS6HdjxniGWpL8txKDTEstTXqI5Dlvqy9PeW9mXpcyz7o6VNWMZMVrqPrnkNZlTs3lL3JwyxLO3eso6WfuK4IZalvi4YYskajPaoCh+R1+awOx18sPzOFFjafFjotUdbXGs92qMtsvbg6RGPsqs9tMdjVrPWI3orER2v9aBv2x2DFdDvEt2LW+vhc0s/21nIEv16Oo+mHs3m84p4ZpTPRWqPK+I9tl/tMVW/dcz+toGtlPcI5PFR/U8AljzymVP4jNNvrG9kr8sZ3jyC7fFwDOakQjtBeUL7W/meHC915FjrtvezVrh2bb8/7NFx0tpe6hvp/PyQbc/nX1Fu7XFcXCPHPJGV73E7YvltDj63DcnnNoXPjFIuF/NX+PA95qPJ7FpvXy0fxBJf4XftPrv9s57R/vls7icgj7+19Sjk4T4QJ61viC6ivvG3l/xFv2unQ35EDHWIfZuTpkN82WUaHc4GyX17s1IPbZzgZxqyjhNY/goHn/yQfPIKn1GLRa6kPLQlfkwRbelqynsU+Hwk7M87AOX4cbnHIG8j5X0S8vhFogchj33DIcjL6hswZtp4ZQ+X6QLi6Ro30f8/QnnaS3z9PrpWSf1ySn50zdN3s7r7rdojtdo300V3VyuyFigvSs+EPTrOG1fujTmwThpivWyItWyIddYQ61VDrBVDrHMjKtdRQ6wjhlgXDLGeNMR63RDLUl9nDLEs++N5QyxLu7f0hZbteMwQy7IdLf2Xpb5eMsQKDbEs9WXZhyzjCUt9nTLEWverl86vWuk+uub91lGxe0vdnzDEsrR7yzpa+onjhlijGq8+ZYgl8aqUwzk+rjl73pcrX8p3bGh7zDynl3ztr2BxHr9j42o/dXO+Y8NlB7gHxfv0w7xjg9/L4vsdGzsc9Ub+Mw5ZtXpcZaiTDYSlPaeirS1lbVvtnTtS1nMf655duMqhJ+Q/zHMqZaLbH/b0wG23IwYroN9luhd3dkHsCN/tIvtb0TMsn9yky4yvnMZ32myDfKT/jU09zMOd69lg0J66X5Gg39F1oXMtbe9nzTT7Oj9/YOoRpT45BUtbI5c6RbaU5QsH+CwTf+FAMOO+cLAR8pF+eVNPljO7dMwcYOIzXfz1C9lHiPv6Bcsg9MdBBvn6BWNOxNRrOgbz82CLL27SMQMFU6vXZqoXy5AnGYT+LNTrHByQQhr5jc/8yQfjhdeMwiuIuYfYWJbzXHyTykbX+PULzmNbYX1h+Tidsq0I/QWHrWxUZMD6cruyDEyzOUaGzyoy4Ov9lg489lTnaxQBJf5aBL92j5uSm2CjghOXRA1R9T6/SceR3y7zw23YaYXHdIyMWHYz1KXZeqR1uBWjoDEC2xDDbCzQE/tKKRcEvseU9F8YE/75QLfbfTbylNiPizysH94X3KzIWlDyeH8/LZ/NgBN9HC/OFnDs1GxhMoZ/TikfUNmcci9K+EyvFrtwnbW4GO+5zjQIncZn65B8tqbkc+WQfK5U+DCWFkdGaSns5SP918C/vrJLxxyLwZTPXAi9FttrZ06EXlubuEqpo/Z8/dVBMm/UJY9HOzLKmrQ2cBXJqs0x08q6P1xbWTdklDWv8MYx+eKg89ATrYMPHDjcfQtzoIgR0DWPbTx+8zAzHSMqh138m5dt2NVtp98zinxaEjkwMe/xIDnxkeT/ErroazFdNAj0Lipmz9NSLIvTUjGJZ4CO9fws1QfpkafQPwd8tNDvGaq30P+NEvoVFJlEnmkqbzvEz7VEh88Hg0nyXgDefHwsBPp3Qf05adNYqVOki7/PMI3FdkTZEBOHDGzbuHb5O2gX/lAf8ns2iK+H/N6g8GNdSn6UpI1DuG/XxrVGjvhJ3fAe8s8Hg7r1EVaGJA/rR3PDjg/1PQ/XCP9RghMapMX0URAJ6dl1c7PvVMpxElVOksz/HlYb/pHcFnb9jSQ3yjCu3ONoa6Miv8YnPySfvMInzQfdppS68qnSKPHH1w5DHn/Q7fFgsF6S94QD84gD80lH3lOOvKeVvKjOrZmejOyOta7BH4nDtovrB3FY+wkLy4eEtZyAxR+Jw/LLhHU0AYs/EofljxLWSgIWfyQOy68Q1rEELP5IHJY/RljHE7D4I3FY/jhhnUjA4o/EYfkThHUyAYs/EoflTxLWiwlY/JE4LP8iYZ1KwDpEWFj+FGGdTsA6TFhY/jRhnUnA4o/EYfkzhHU2AatFWFj+LGG9lIDFH27C8i8R1rkErPsJC8ufI6yXHVjRtSxmzyrlXyas8wlYuwkLy0vZGQUr1/kr4dcrcN8u3CmlPu0v/PMkq608vfDrlWBQr6gfXtV7VZG1oOThWIR5yOdVhY+G9bwhVmiItWyIddQQa8UQ65gh1nFDrBOGWCcNsV40xDpliHXaEOuMIdZZQ6yXDLHOGWLxWOaK66NreeOFK66XciHk8fLQOJVBesSImzeMg8xhgszXk8yrnT9E1zcRFpZnn3s0AetmwsLyWeYP0fUthLXa+UN0fTdhrXb+EF3fQ1irnT9E10XCGmb+8ETYjzXM/OGjhLXa+UN0XaI6rnb+EF2XCWu184foukJYq50/RNdVwlrt/CG6rhHWaucP0XWdsIaZP8wRlmv+8EoC1jxhYflXCOvVBKwFwsLyrxLWpxKwvouwsPynCOu1BKy3ExaWf42wLiRgfTdhYfkLhPV6Atb3EBaWf52wPp2A9b2EheU/TVifScD6PsLC8p8hrM8mYO0jLCz/WcL6XALWOwgLy3+OsD6fgPVOwsLynyesn0nAehdhYfmfIayfTcC6l7Cw/M8S1s8lYO0nLCz/c4T18wlY309YWP7nCesXErDeTVhY/hcI6xcdWFH6cNiPheV/kbB+KQHr+wkLy/8SYf1y4K7je4J+LCz/y4T1KwlY7yUsLP8rhPUFB1aUmmE/Fpb/AmH9aoJc7yO5sPyvEtavJWDdR1hY/tcI69cTsO4nLCz/64T1GwlY7ycsLP8bhPXFBKwHCAvLf5GwfjMB6wcIC8v/JmH9VgLWBwgLy/8WYf22AytKcippVin/24T1Owly/SDJheV/h7C+lID1QcLC8l8irN9NwPoQYWH53yWsLydgfZiwsPyXCesrCVg/RFhY/iuE9dUErI8QFpb/KmH9XgLWDxMWlv89wvpaAtaPEBaW/xphfT0B66OEheW/Tli/n4D1o4SF5X+fsP4gAevHCAvL/wFh/WEC1o8TFpb/Q8L6RgLWTxAWlv8GYf1RAtZPEhaW/yPC+mYC1k8RFpb/JmH9cQLWTxMWlv9jwvqTBKwGYWH5PyGsP03AWiQsLP+nhPVnCVhLhIXl/4yw/jwBq0lYWF7KzihYuc5f2X/6Fty32++plnLET+qB95B/nmS1lae3//StYFCvqB/ef/oLRdaCkhfCNeYhn79Q+GhYy4ZYRw2xVgyxjhliHTfEOmGIddIQ60VDrFOGWKcNsc4YYp01xHrJEOucIdbLhlivGGK9aoj1KUOs1wyxLhhivW6I9WlDrM8YYn3WEOtzhlifN8T6GUOsnzXE+jlDrJ83xPoFQ6xfNMT6JUOsXzbE+hVDrC8YYv2qIdavGWL9uiHWbxhifdEQ6zcNsX7LEOu3DbF+xxDrS4ZYv2uI9WVDrK8YYn3VEOv3DLG+Zoj1dUOs3zfE+gNDrD80xPqGIdYfGWJ90xDrjw2x/sQQ608Nsf6MsJYVLFxzlFcduM7JSbmjkId040CzDPe1c3Uafg7y48qhzG2SWeMpWCsJWA8S1jDn8T5GWFg+63m8nYSlncfTnoP7eNifh8/Bnady+HUFfrbuMOQ9T3n4HNyfU94TkBdS3hHIW6a8JyHvKOU9BXkrlPc05ImO8Dk4eT5SdPSxzv1pqpvY4L7O7+KQaSvgBoGuR2y3XMzfIBhcY48S+wB8Awk/Wv28IR/Ekse0xUbRfvHtLJgnfPge88HyL8RgyaPZUcIvqh2CfKQ/3Gn76HnQT9OrAkJFvim49z5HXaWs2NQy5BnaVEnwV/zgV1z+F+vEfTAE+iz2hbzyQaCOK/uMdOeqWwj32A5xPEAdxGEdzYg1reT5aNNlR701n6vJqtUjrm8in82KTlzjc6jQu8Zn0SGOkYY6LLt0qI3xq3k7p+htJ9Hxl0XRBo/GYAX0eyfdGw/0t3Nqvm0mRk7hm+THsbzQuV5hkcZvaHw0mYUPvl8A3zb6Kj0r38nqe+UHPteyC/KR/ne39TAvdDC1527i+koO+OG7CfhVMcIv7lUxh2Lk+xyMe/ymwkNKnXc5ZBbMiWCQb5QeDHUZfp7irmUo7zvuEl6zJC+3D9dFaxO2u+cUPcTpNkoYp2Acg/RfyBinoH1znIIySVltrsd60PjgPZceXHy2DMlni8Jn2DhE4xMqMvOcKkroT75C/kTsDvsWlpXn4CeJ/ufAn3zN4U/CoJ8f/tZ8M/sT4RfnT9g+hf4bDn+ixeb3h/EyCyb6E5SZ/YnQ/yn5E0/xk+pPhJc2Xs4Guj6CIN14Oavowfd4OUt8lg35IJb0FS2WY/+TNbbG8hzLxvXXv5nReWr9FW13kujb0F//G+qvIZQXnWt2s0x5ywpf7jNBMDg/i5LLly3HYKUdo4T+v3OMUZp8IdxzzaWXqVzcXANpsE68/jfu4IF2i/clNsax8xDRHiXaZQct6xxllLe++53bz1elL+AapiTJO67ILHn4zO+Hwh4dp3H6jXWKbOVzu3q4TMfyoJ6Ox2Bq/uLhsJ9W6jym4K4QLvoA1pe8Z4v7/3/qVCbq//9mRsdjO4mSfF3X7/x1vsbti4nbl/XDSWtfkTtq37/O0L7YhicoD322xAA8n0OMiH6sE6iNal9aTX/56yH7i6ZP3iPQxk7U5yRh3LylRzOxpV8moeHxIkrSf6TPiv4mlPJR4tiva2cdnpF+rtyt83f1tyDQ/QLqgd/JeDzQZdHqLLQ3kj1iH7Ozx2pJ2vEkyYy8X/TEO0f8gkBf5xX+M4o8IndeyZsYQtZaaW6uXK82a+3F+nyt1soRvsjK93iNUnsXxDaFXnR92ouuK03xAeNhD/8U6DVKE5D3IuVNQp7IGPWhHbv75T/lSf40+kf+BYV+f9ijy9KWBYUPzzmGwVpeJdbWoL8PaGMhxjY8FmL8gu8BfUeMX07j68S3sd/HerIf/F7ydTj+GdpQVYtH2ded9MQ7ra8T/jNBfNvmlbxhfF2zVi1V2wu1xWa70mrOtXPB4JgwrtxjX6fZ7VaF3rOvKGq+jv3ZBOSdpDz0dSKj5uv8jIuVYhr9I/+CQs++Lm1bFhQ+7OuGwVpeJZb4OoyDOE5FX8dx6opSH/R1PC+7l3ySn1ff62uE7FNR3ijhHHoF9MT6ZRy8h3EzluE1G6G/H+L2927R5ZM63KfIp50pwno9sCWebkWhi/ZJZe3xwdbhD32scbDV/FBr6WDr8Higi8dV5OrzdCoguihN0L0n6Tcv30wRjgzBE0FyQpNALK3pEJuH3g/ClGcvubBDxGtf529xyKRNHXmoRbOz61Ll1NMK4Z8PBk3Ox/GRZZKH9cPDo59tiXIx+sANL31HqR0O6oblEHvhY4CSr/2V+vI9HibQFtluXC4wzmUdAJf101t69OwD0hzZSrMVj/eQ/hHKW4a65Bz4vAzShn58jpZ2MNSResiXXCYgz7KfRXLcsrsnB9sThlFx9q99vkHoXUfJoiRbDa6jRZptoS2JjWjtLGW07fArSNasW/9XKHx896krqD5oxxziZd161Ow3aQvtmZg+GbeFVoV8pP9h2EJ7ntoTy6Oe36hX2Mtboz5TztpntHZw9ZllhV57Lae2xfpDYX+e1mc0vbLtTCkyaOOcZjtClyZ+QPns2qiUOn4Q/msVPxxKqVfRzwt+9FNM4yM0v7as5LGvx76P9C9AHdnX4zjB07jPdPyB60iBq+/gPdHvG8f/aLriOw5y9YfV8kEs+WyLPAogc4lfghjqF7bEl5dPtUxBGe04AtcHbQjHhi/Q2IDbJK5teZ77XAdjw6+vcqz3ecwvyb/zJ3CwfFwcukmRK7r+ZOda2liWSL4KbfzlmGl4lLB9vk7tg75Qax/hrU3vpSzisozfABn/wNH3UMZvxtBF1weDQTr2RUGgxyHchrg8odHzsQCh/7OU8bzYg9/YpKTG89j+HJukHY9YT0iPGOKDCkTPOoyS2MW/BLv4a+rfmh9dbR+OiyPjfL/nZcOFND4f+ecDnzFTL0bRPtHnsomjivyLYTx9kg0JfTTXYT9fACzhi58iXKF7PEa5Ypoooe/577foGFg/LS6S19MjRhrfn9WetTqNQr9JY9caH1fM9JwhH+zP0m6eH62riu6PgZxajMzH2o5DHcYJQ6Pn9UbG59fqSfmJQD9mK/2Bx73dnXX7N4680djrqmOU5HOMOUWmcYXmKMl8Iujx1mR+P8ks9P8MYzUfW9fmLni8i4/qC/1/AEz+QPwJKJ/Gj2rbaLhVJvJox6dPUjncruM217B5y1zDOUE4XM8xuLddwda2jKN/+zq/i0MmwZMt1QngcUqRZ5Lox2f75TpDOnXpLPp3WuGLrz/cTnxPE9/Ihp4kuxTZcD6A7c5twnEqy/kJyhf6aejPGzrX2hETHB9nZ3XeOH940SHrSUVW7DNHwv787hY/6Ou7d+uyojwo66VbN9Rj8751j7BfP5r/0B6ByOo/tC39FcrDsZj9r7Y2uAw07G+wHTR6Pj4p9DuhnWVu5VpvjP7KuKStW/AawHNQB9c4lbTtfcOsjhv32Fcr7K9vd10W1jlumtV5Rwn74C0Zee+P4f2XW3uYt5EOtbUPy/hPa6urgv56LRMW3+MYD8svk8zLBjIXHDJr4zPH+tr6xFEHHyx/lOpzVKmP53g29dxV+OcVnfiYu2pzS9deS9Inuplee22P1m44d0XfGhBfnLsep3suX5zkF/Zl9Au4doz0nwe/8C7yCyiX9APNZ1wd6LIEgbuNCkp5fk2Rr3nh1VSfFxz1ybrPiuXX6hHPq4lPnN18kOxG2jXrI8zPgt38kMNueE9S24PW2iDNGryrDQ6l5BMOySdMyeetbFMtI5v6ONjUxxxx3ltdz0cN+WhrPTxusX4xT/jwPVectEL1ibObI7M6z7R2I/QfBLt5OoXdaG2wTHlHFb5rdSZnrfyhC2tZwRJ6LbZ1xWBp9wO0xy7Ftv0+dpL+PInwz5OstvL04l1tjeCYorvNQW/to9E6VCrP39taOvjUY4e5MQSwEPQr+TgBCn1Av7lcJNQE0byg8IgSvicEDalA5TmgZvw0MiXRJuVrnfBYTD2DIF0nxPJZ33nIz6cK/auwiJLmPQ1oPFne07AcI/u4Uod8TDlcNMY8rPP7HHUW+s866nw0oc77w/46o3xHqRxOZpdj6iz3NwaBeqhCMDQd7wj6Zc9qT1h+rYKVHcQnbnD/QszicdzB0UchH+m/Dwb3X6fBPYTya1X/MOivV6jU61GgWSZ6qdeEghmlB8MeHtJ/uVN3zws/6rNOcQEd1i+699XZZN242lzoS9DmX0/R5q7+E8K9t3wgU2oV09g48v+OD2T+51y/ktMGMlzOFcgw7TLRWQUymkxxtFkDGZwBcCCT9cQIlhc6v6epygMnmnFXBztT3IsO8YSFawbHp68YPyR6fFhT0x2fsBD6fwFBzPd1dg21tromRr4gSNdWWH6tTvdcQ3x8rOJGiVc01jpYj7NBeYIjKUj6u4wDJj91JvT/cEUP8+9pwEx7iizNSi3bfBCkW+F39be0/Yd1NKFgRokDKKH/TxRALUN5Oz9VK166Xbta6sGfAzrtVEVeyRvqZT1z7VKxXp+rtMuN+VatzmOkyMr30uzo3aDQ+10xqqov6zkGeo3SBOStUN4k5OHOIL/Awk9gVm2m0T/yLyj0/MLZrKvGFljy0gltsn6pfFnaD1cI/f/rWNAIFfm0l/66XiDMkyGuI/vEKO3r/E2ypHZCEn7SPhsUWZZJL93FgkJPL+/c3V+XZaUu4qPGHTwC5V4uiNcd8xhTyh4I+mU7mkI2LO+aiDJthLFWJ1A0PnuG5LNH4eNz5wt5JsVjVxd6ZdDfxO1IPR728pH+v4Z47NoOpvZULsrIbaDFQuwj+eQd07C/EfrroV8lfTAA6+myM4zHXB8MEPqbOjJcygUtrvNE0Dvdi/7x3WF/HYT+nzt1iPT/tkI2zPfEYH4YMG/PiPneGMz9gHmXwx6vDfr5aSdBXU+JY3k8dYuyGLdv96NJj/vB735g57CiC6yT8B/2KWDktVZPrWt1c7UzfjyOd6Y1rMMZsaaVPB9t6no6EvnPOGTV6rFMOtH4XKvoROifcMiF9NKH0falrOgQP8pnqMOyq73xI4HCfzUfTRK9XU10/NEk1P3jMVgB/b6a7o0H+keTIr0f6Izn2rpJIUZmkYHvsf1jebZ/Pz5zvqSdlJbEsRjLyGmcfqPcUXv/1bYeLtMhBttxGPTX3eVz4zC0tdykfh8l3IyQTetDhw8cbH3g4ENPNA639j/RevSwYr8bg/76Jb2JDmVFuWaIjjczD9Pvp+j304o8nFgnmGYUuriU1D/ugOvV9A8s71q/3Dskn70KHxfWHQqWy3/vVegvF/+9l+hkzjWM/95L9+L891o9Mc1YOH/aH/ZoeA1f6J+i+ZCf2GehIv4dfafoTHg/4Yl3jviJvvEe8p9R5BG580reMOvT5flKqTR/cQu9VawWG82iqy/jPe77RxT6uxR60fVTfnStvmD5COg1ShOQ9wTlTUKeyKitT/vxTwup9I/8Cwo9r5ekbUsNa/8qsWR9Gn289O218k1+fUr2eJLf/rACeXyQC/d7cC2dkxaHSn0ju13e3sNlOpZVeyJrNhjUIbdV1rmvNtf0u56xdm2FfY+T1lZS36xthe0hcvv1TWunQ/Q5nDQdSn0jHZ7PoEO0NV6TR18rco+aficoD/cJ7w17dJySdPhPKeau2qFIPkiMeppSsHj+9pAij/iYp4N++bH9osT7gVj+acJ6LgFrP2Fh+TRPviDWA4Tl2pNdTsB6P2FpB9cF62gC1icIC8vz/sxKAtajhIXlec/hWALWAcLS9uQF63gC1mOEheX5bQ4nErD4bYdYPu4NIHFYBwnL9faVFxOwDhGW9hEObY0IY7YZ5Z70db8fFCll/tCWNv/xsTeg6V2Lc0V3pxRZC0oejtuYh3xOKXw0rEOGWKEh1hFDrKcNsZ4zxHrBEGvZEOuoIdaKIdYxQ6zjhlgnDLFOGmI9boj1JGFpc2vNt23u/IvSG/sA72o8dujxR1oBJYwnIyxe/38qhn9BKR9Q2RzdS7PvhLEmr4WI/50K9L1PPjsi9P8rnB2Rtza5ykfJdd58mvCNx7Fy2nGV99x9v4XVdZ4gSjyuautHBSWP1ySmUvKxsPEo3Rvq/HNK+YCwcsq9IND3mLAv3UgYT5G8fI99BJYXOo3P3iH57FX4uLBuVLCEflmh36vQa/MtKev3K0a9PSZtzroMPIX/avaYRG87iY73mLS5K2MF9Hsn3UvaY8I2fTxGTuGbZCtY3mWTU0PymVL4MFbcA9q8lyX013b6qtgX6t5wnajier7I73Me86n3soT/jCIPv/kb84bZy2rPl4tLlXarWKssLi4Vmy6fgffYx2hrJ29T6D1/kF3dy8J1yihNQN4y5U1Cnsio7WX58YPzxTT6R/7al1A4fkvblpZYspeFY4n07bXyTZ59ysjuZeGZniz7I9gevJf1tFIP15iN91xt9bSDz21D8rlN4TOjlMvF/BU+fI/5aDJr8xh8fqB0Ra8M9hN8fgDLHg57+Uj/x/D8QNVxtorXhLhPoA1Gifs9vuU2zfgu9AsdmbTnB7RnoA6H8TILj7TPcwr991KMsRz0131f53dxyKQ9PyC8XG/QZX0EQa9NXM+Xac/keo5lytrzN5I0v8Zn3XFNi8/u4BrVEcrDvYaPhP15/OF0zMM1+KcoT1vLlbzTkMfPwuOb3NFGOWm+Wdol6g8br+zhMl1APNFuVihPe5ZdOy94O1xjnsjK99jesPzjMeXYj3g+m1jy3Ke75/9DRVdYJ+Hv2hdKM74gr7XatwmVurnOOoUgD+9baFhhRqxpJc9Hmx5x1FvzCZqsWj14Pq/1s9sVnQj9skMupNdedCRl12q9RtMh9sVh1mtEb3cQHT/TgTYYxmAF9PsOuhe3XpP0HOjDV+gyp30vh9D/CsRxj8I1r2Ui1mTQnzcJec93rv2umc81tXUV1t3zwJvnQC8o9Uk7luKZvb/PcP4G4yaUDTGx/Z4Fmri9jmchzj2zS8fMBXpsz7G22ETaZ3WFPnTE2kIzEVOvwzGYr4MtrsTYeqBgavV6gurFMjxOMgj9SaiX7CMFQaCOs5Pw++GwX7YjCq8g5h6PBUdi8lx8k8pG18/AtTbWs70+S/SyTxmnU7YVoT/vsBXtWSjXWWmWgWmeiJHhNUWGaJzY1MlfOvDYUzFbS7xdyo/QclNyExxScOKSqCHiId2BceS3y/y0bbkg5h43g5TFd941W4+0DsftvY0R2FQMs7FAT+v7sN206n3YJxRZC0oex4tp+ax2H5ZtYTKGf04pH1DZnHIv6PA4v+HNa20uymsfWeeiWudgrLh3cSyFvXyk/yL4I/6C3+Mgh4YpZ1aFXouLXS8MDRV6bbwSXWrzFBdv7dyv0C9nlFXb61kGmiMkawh5RzPKuj9cW1kfzyhrXL+UMeyik37oidbBBw4cbmFXYTECup6me3HHg+T3EzGibiY6XvYO6TePmzwmPanIpyWRAxPLMh4kJ36f9zegi74W00WDwH2sSTuGjyH3wzTl0rawXOaY5jU86JoQg18TJPTfcrimlcBdb+4S2nFyXLIVebSj6fzaurX/sHmxqX08EXUwGaavr6Yf7Yi89hrbAtGjrrStIV621T6ahVtD2nF+dkla3VxH+fA9+eMKRivs5SP93zrsT3sMwPXhtKwft0X9dj/8KeXDXp7oybP9tTT7Qx2w/bnqq+lHO0aPWxzSvgWiR11przYTnpr/E53jq8207e1czF+Rle+5jhbcF/bzOWrIB7FkW5D9pRbKRdfVoJ8eP6is+UumFz3jUovWfvxR6n+CPvYkbNvzOI3Lj//2Cp039u9QkZV55+E9+v8X+R8sf5TKS96/B9n3744vL+2vPULFr+xA2+XHEFaUemKbsx8T+v8Mcr4H+nCU0JeIXJ59STvrWKb5WtdYluRrebxCOw3hmm1Q03nctGJKoUc8jvEmO7aofewXx8wVkv25jLKnjQ1DqMff0SuztXHL1Vaa39deI34iBdaKo74nQWaNHv0E0l+h6J4xJwPdlo7HYG4HzE9nxHw0BvNqwOR4RBs/te9HCL32mIj2sXLtccFTlIeyLwMuYo4ptI8Rf+3xxkDhGzjk5TE3SV727ZJ3N4wNN3aupwnP2C9WXG15p1KftG0ZOurPWFJuIhi0V60Pvajo67atOuZkRsw7wd5lfNVinY+HPd53E2/Nh4Rwj31gqMiFMYfr1cIcH1SV/uo6qut13C21itq422H1pvzAF31nELiPNQh90hybY3ik/1jYn5fmm1LIZzXj2ldpXNPa1KULxN1F9FI39PGoi4chH+nvdfh4bY4ewj1uD832cV4p8miPveO86Y3yYS/vUtqrK07U9LMyhH7YXrW4R7PXFeKjLcemtVcpG937Atkr8uGPox5TMFx6OqbUm/U0FUPPMZDQ/0iKuAplWIZ7q10f0Ma4FwOdN/ZN1Al/SFfofzKlP1+bNZlSSesfqFfuHy4dRilrjMjrLtrj0lr/OEl52lprGr8bJVffkbLRvSMpPnyctb+yjNq8XPP1Qn/A4eu1sTSEe1nXb/nRBvQdUvbSrQnotow6SOPrXfOdYXw9z7m1o8dJvrvlsL+4dR6U9ZCjbmnjrqx7G5ey7ddyb4PbXtvbyJFOEEvzDdr6DMdbq403o8Tfik6KN3kNVOjPZYw3XXb4HR1vrsIORy3e1HyQ2Gt074MpPn3nsj/X/paFDxpX5MKxWHuMNkr7On+LQybXnozfz40VazniJ/rAe8g/r+jRUJ6Sq11RP2OkHz+fkyu+8ZQf236U2uGgbuL8To7Ky15YlN4POHxcW/ukZkTzm7TWpMWBWFZ4cBz4ZVg7+x3C1B6PSxv/4uOL+xxzx+Wgn6fW5q7Puh0HPho9jk1I/3XH/FDzlZrdCX3Sng9/vlPbX2fe2nkBbSwV+m+O1PywXLrUe/Y8ZrnmjmiDvA+kjUXYL7gPaDGX1l/xk3Va3+LXaKKMPF7ynDFKrbBHMxVTpzhfIa+kZF/xNxnnjFfCvaxxMfcZbc7o4q21kctnYLvF+Yy/dfiMpHM+rFOh/5cOnWp+yKVTi3M+aXW6P9RlTatTof+fUvjhtDoV+n9w6FTTkUunaf1MmrW/JJ3ykWZtT9mlU6H/1w6daq89cOlU6P+PS6hTrDO/LhZ9BvqI8WDQ3+Vjym13YB6PwXTNvxgjri01n8Zt+R8cbanV63jKep0wqteJjPUS+v/HU72ei6nXcxnrdTyhXs9RvbrybUuuV9wZKl77F/oJwHTFdsude2/1NTM+Q4W28RzlaeeXXDaxmvnNLTS/cb1yRNoo7lEZtgGh35bSBtbmTLhuAyLrG/KH/fV2PRYSJbYBLe7G9QZer0J6mSdrNrBMfKxs4IbZfjpfZ2vx1VRYb5xH4BrF+4n+OPDV+iLTS7+bCHRfzOdPhP4WsFc+Wzul1Ce6d+s2nXdcX+E1DaF/+7Ye5h2da+1xfj7/iv6B196150hQz9xvhb6Yst+KXJei36J9pfHdrrWQJN8tOtN8N/vnKQVLe2WW1s9FRu21B4L7xrmGLcnya2vJQr/a+Of7HHGCNu9BPdViMO8Fu3/ntv76a+edIrr7t9nwfrdi54KpzQ9cjxAmzQ9EHteci+vNbXU/+QXXvpuUSxuPYh6v2bv6lXa2l3U4Fbjn9jx/+JBiZ2nOPqR9zinp2ZZbSc+ufR8tRnDZSdoYQVtDk7KaLxYZPa+RlrP6Yld9Nf2s9kwk64r9rsse0vhitBXBje490/HF2h7tcynqpp3B0PbCua+IfA9DX+Fz89r474rbhf5Rh19MWg9a7VkCbZ/zuKOcts+JvPZ1/haL7aGS8BO/tUGRJW68fAL0+M7duqy5AXmHS9rYmSM98TqKDe9yMUf8gmBwrsBjkzbe7DORp7cnq61Ja/1O9HPSizylNu7Jov3iniy2jRY/aGsXOB8JKTbSfAD60wrkI/0JiMtWYjCDIPs4i2e8/mamH9f6jJrUU/MtJyhPmx+6ntfhGAf1i/R8llHoz4FvcD1jKHL5PTvevuRnY/n8q+vTS5r9oS2k2Ts7oeDzuuhnHXGo63zuckbZVxTZuZ9z3wkpRkWeYQqeWn/NEc+487m7IB/pf3kN44b187mD9Ks9nxtCXtrzuV/pKFd7fjvN5zdde93amIX2vRvykf5rDvvT5iHYB7LOQ0SerGeEO5e+7a98qfc7eE9DW6tIczZT+8xQ1G6vdpTrU49z88VuTCttKDbJaQLykf4vOzaZh3rI34kh5GzPNUrtSqPdqDWazepSg18rHyVps+g1U5E9fGtbT2eiJ2udRUnwJ/3gd5/7nYC6jit1Ev5iS2NAn4v5GwT6nEV45QnLuG4lV91Qfl4rmCB55DoOayIj1nRM3j6benfbdNxRb+YfR6/1Abk/5cBHeu11yVOkiw1+dFF2tRuOx8J/Na/Nlt+7iI4/c4b6nozBCuj3Lro3HuivzWa/NBMM1lvKePYpqV8nKvzzgdf+0PUDkyRPXN/F1wk+cqDR7Lzlk10eNx2qE+G42tx03WGR7rE5jFE5CfW0IZTlzCkYmgr4C/U5hb/mSsZj+AZBz1zZfSRhyfW4Q5Y4jBxhzDgw1rvOetdR0nrXWX3X0drPc6RcTdt15N5aRZ+uKCwIBl9irUWMHE1GSd7ml1PyskSmvrBmgsH6sy14clupn2jjmYgn23TORMYVvYruJhVZC8GgS+b209z1pMLnOwUL/Y82PD8Y9udpvop9E+pes1WJ3tnHaSfJpJzk4WyGZ1kyu8D7G4LBukwS/Q2dYybSd6aJ/77O7+KQSfuo3jTVYQPUQVsBfIDqIPRv79Qhor1pe7/O+GQV5qE+eVa5kfSAeSg3t4OsIuHKqGBpdRD6Ozpyj8aJvmJVW50UWd+QP+yv9ybIG1foORbYrNBvAhrRWYHotf6r9X/UOa9e40k9pke8SaKvQxvxbhPadZ5kx7pvoDxtNUxb5ZkGmT9EfZZ9xr7O7+JwaW4mGPQjkmYUvbEvxX7C/jJPMmMe2gHqgJMW44ouIrnuo13bQMGy9BMTQT+/Uem3+JZ/7rfYR8cVeu63Sf2cT8ljW7J9a2NBlj4TJT4hhvYibYN9Jm7c1WIi9hfaSluUeGwV+h+lfuppNVIdW4WX56WFunb6XtKMUm/2Edh/2EdwLIJ56D+y+gjRRVYfocWNmv9gH8HtHiWtD3D/wD7Au8U4bnD/wBhW3iSaI8wgCJwnDVzrDVEfst4tK5abS/VW+eKG3ly9VF5oZtktywWDfoHXKLS6aTE7z5+YbjLQ1z9c83GtnZPWP6z1W6/WS/Pzjfml+lJ7obq0mKRfa/7l+fn6QnmxWJ1rLrWb1cpa819arC9WW4tL9VK1XqkWV2Vf0q/QBjQ7mST64xA38gngMQdmlPhLMkL/ojJfYDmDIN2Om2sZFuXR+g3v4K6VPc815hcXlhaqjWq9uHTRZ2RpT5c/d+nEtaag+XEXFrbxobCfXpufaPMEjjc+o8xPGBNPRzweJsuMdoDjBMc8Qv8zIMMKxaGoB9GX5znMUo74BYG+Zif884o+fKzZabvcmn15jh0Xc4SP8mxQ9KPFbTx3krhNWwNB3DGix2spj/e+2LGtAmFGidcENyr1wXui30j2X3E8SZqL+Su4fI/9AuqGfSX6aTwh/iX6kCv2d23dXPwH98U/gXWxr9C6mGb7PH7kguT9IOQX5694XBT63wdfwR+v5XER68kyIr8JhW+U2F8J/Tdpjuap36tztLjTT1i/aOxynXRx9V/XiSOcG2v0gsfrxX/hGGM2QplxRS6OZYT+v3LEMtNKvbT+Jvdd6xkoj7Z+I2W19RvRvef1myVt/QZ1OBkm62fDEPrh/SCM23hNVjvpxD4B+Wj72tr+JPqTL4FtpNkrcY2v2mlibT7NT7xpc3tXv0P6uH2aqRj6uH73P2aM7Q6Hg5gsQ9rYTuj/AWQ44YjtcCz7x+1uWdmv4RwL6f93GMv+FY1l3PZR0uJyXnvR1hjR37rWhLV1K1ef1PYXuE/G7UdgPIX0/06xidlgsN+Ox/BD+bS9Gq1v5GOwtPaMEscmQv8fHT5fW2PW9rOFPmkvSeTRdLM50HljfbA9D1N9hP7bo7V/p35dFfXK44hLh1Finc8o9KhLXs+fgTzeH8M+uonykC/vNSXNoXiM0eIn9FHamSPUgcg5rdTXru2WSjniJ/XDe8g/HwzavI85a1obEf3M+NFP0WWDM4p+RJ4tXuQpVsRWCgpvkbXzsa0+v4L0M6BDpMdrKY/3dndeiSgyzEI5wS9QXpR4vox548q9sUuEVVCwUG/SplE/3kq64C+Va38Fl++xjNieYvMuH7FaPoglcZTWn6J/+zq/i0OlSlnqsUWph/BGu7LrO7W5tL5O+OcDr3255LJh1A/vVRYUWQvBoA0/Hfbokuwb+WhY50cUa8UQ67Qh1kuGWJb6OmmIdcYQ67gh1hFDLMs6njXEspRr2RDLsj9atuNRQyzLPvSyIZZlO1ra6quGWJb2dc4Q6zVDLEu7H1WfY1nHC4ZYTxpivW6IZakvy9jE0r5GNS60tPtRjeVCQ6xThliXQyw3qnZvGZusj2nZsEY1lhtVX2gZy1n6Qst2tNTXqMZfTxlijWr8dcwQy7JvW/YhS31ZjkOWfWhUdW/pv44bYo3q2pClfVnGvqMaY47i2BFd856VxdgxG4ON1669YY1PTpFZ21PGM6XTwWB9LfeVBX+rJ3yp9xWKrrBOwp/3mCVf+ytYnCe88oRlXLeSq26uvWjcd0cdxGFdkRFrWsnz0aYFR72R/4xDVq0eM4Y6mTTE4rN6Wv/X9m+FfqtCr9nJrMJbykrbboM8w7Ytu9oWfYTwX81bB0VvHyE6eW/FWDDYN66IwQro90fo3jjgYVor/86/+b0iUZLzKNoZoujfvs7v4lCpXnb5Vr/jTL2SI36i04D0JvzXyne7fFiU+AxGGh8WpWfDHt0wfidKnzLEeskQa8UQa9kQ67whlmUdjxpiHTHEsrSJ0BDL0iZeNMS6HGzijCHWWUOsUe3blrq31NcxQyzLOp4yxLJsR0u7P26IZWn3JwyxLG3igiGWpU2sx19vDR9tOda+YIh1OfjC1w2xrHxOdM1z7WHkeiW0w7LsQ5Y+2nJMG9W4cFTHtFGdW1nq3rIPWerL0kevjx3f+WNHlI4ZYln6wnOGWOtrCpeuD1nq3rKOrxlijep8yFL3Jw2xRnW90DLOWfcTly6eWPcTl073o+on0sRf2rcQZI9d28cXrK0JWPsJC8tvJaxtCVgPEJZ2nmFGwcp1/soe+Xa4b332AvlJPfAe8s+TrMbydPfItweDekX98B75lYqsBSWPz7Rwe+4zqcdcQ2s3O/xyk+stPLBuV3lpo2rqd88K/7zSDj5s5iqSh/XDNnO1ImuB8qL0fNij47xx5d6YA+usIdZ5Q6wVQ6wjhlgnDLFCQ6yXDbEs9WVZRyu5ND87KrZ6zhDLsm9b2sQZQ6x1/7Xuv3zW0VL3y4ZYlnb/iiGWZd8e1f5o6aNHday1bMejhliXwzh0OdTRUi5LvzqK43Z0zfP2UbEvS319yhDrpCGWZWwyqmPaen+8dHUc1XH7cpinWfpoPkf3VrT7lwyxRnWt41VDLB8+mp+RjNK+zt/iUKlSlbVo3JPKBf18Pe39tHLET3SE95B/nmQ1lse594P6GSP9+NnnKDZzhI/yXKXoR9tX4DhyR+c3vi8f6a+COiI9Xkt5vPdkB8TST0bPnh/sZGToA+WldqlSa83VivVGtdasV8rN8lyxWa21S6X5UnmhOl+ptJeq8835cqVdnisvzQSD7c59wFMbV9P2Ad7L8tQnnXtZ25U2yrqX9XDYoxul8ffBsL8+rnf2+7GFyuJqbcH3O/s1W3C9sz+tLTwX9uiGbT/LmNpyLnnKEMsythjVNTrLWH9U1+hGdV/gtCGW5bzBcr/ictjzG8U9+Cit7wNfOt2v7wNfOt0fM8SytPtR3ddc9xOXTveWdXzNEMsynhhV3V8wxFrvQ9mwXjDEWu9Dl073lnN3yzmyPE/Ca0hR2tf5WxwuVacVvkbY3Xfm7hgeu8k3BPsae7nbgn2tgl2qVEoXxZkrtZvtSm1uobxYqlfq9Xa1PVefrzbbtWqjOdcqVRuV8kJrrtguzbcuripXlubq7YXmUr2LvdNc7kpN1tLw++H4/ffJTkOIbeL33cepbHQ9BvlI//COHubGzvUM4AaAEaVpwssFlmuO5WKO+AWBvgYq/PMkq608vTXQMZKH9cNroOOKrAXKi9IzYY+O88aVey6sk4ZYLxtiLRtinTXEetUQa8UQ69yIynXUEOuIIVY4onKdN8SytHtLuSx1f8oQy7IdLXV/zBDLso4XDLGeNMR63RDLUl9nDLFGtW9bjh0ST8hz6Bg/bg768zB22kR5E5CHGJiH8k045MPyEzHluB4S/05R/r7O7+JwqST4G/3gd79jsUHRFdZJ+Es8Own0uZi/gsV5witPWNa6c9UN5Wc72ADy8PcuNKwNGbGmlTwfbTrlqDfyn3HIqtVjgnSi9bOcohO5v9EhF9LPKrylrOhwGvIMdVh26RD7ovBfzTdARG/XE528O2QsGLTBDTFYAf2+nu6NAx6mWcLQ/Cj357j2LcSUj9KMg8+MUk7qtwlkvA7yNxKP6xQZr3PIiOWFTuOTG5JPTuHDWNoaTZSWwl4+0h/urMtEdXhlVz/m9Yp8rr64R6G/HmhEHk03UnYm0G1O+yt8gsBtQygD+6k9hnz2AM0k8bnBkM8NQLOZ+NxoyOdGoNkE5aLfeyEP7Ux86a2Qb+dLywtSz9uCwSR5t8O9T4c9OTiN02+UO+oP397Ww2U65nkT5N1OeTdD3h2Udwvk3Ul5b4O8uyjvVkWe1bYzttVNMfWy4IM6upn43GzIB/V9C/G5xZAPtp201XQw2HaXyv6xbSXvDsjjtr4T8rh97oI81undIMMjYY+Ok9bfRE9Rf7t2ew+X6SRdzvqVuso1p3X99vJWq18c1zit67eXl0a/q9Hhh1PoUHhiW0mdJL6V8n8Fe5D/Be1B4lzzwbA/bxfk3Ud5u5W8CP+Lnc1aiW9RDzzHwHFoXLnnmmPcEoM1AVjTgCXvaZwk+v+low+/Nlmfc8Uswvs2T7zTjO3If0aRR+TOK3kTQ8jaXpovVor1erNVry7Wqu1cMNh3x5V7PO+6XaHXvrkour7Dj67L3W8whz18jIWjNAF5t1HeJOSJjJHd79jdL//tnuRPo3/kX1DoH4A6ZGlLn1joDyywNqwSa2vQ35/Q52g+cxvxyeozsbzQeR5/5zVfJ0nzLSgjp6Sx8rEMYyXq9TbSxSjM1aPrAuWhn7qC8jAW4XgOYxFc7+SUNP8/tbuHy3RcD7Sn22MwZfzdC/kSP0wS7f8Hccu3KW7BOfkPhP15OPcVPhHGVdf07iMfLQaK0sdj5NrWwfE7bleb2loOxwx3eOKdNmbgtRyUR+TOK3nDxAyLpXalVVxcrJYXm7V6vZ4jfJGV73HMcKdCr71PWHR9lx9dL2oxA66DRWkC8u6gPIwZREYtZrjTk/xp9I/8Cwr9Q1CHLG0p4yn6UI5j0Vd8LOzPwzU3nMdcRX3cT7xVXuR+g0nz8zw+oE3y+IBzeh4f7oG8rOOD6CLr+IB+EuuE8k3APc3H8/zt5k47RXXYe00/PxzThXdE92vUtn76dbmlrQ2yTu6Be1nX6bGvZ1mnxzjoHspDOy9SHvblEuVhe5Yp7y5FnjTjS5Q4nnWtYfla1+a9jNsN+aC+48ZSCz6aH/Y7LmSzf2xbyStCHrd1CfK4fcqQxzqtQB6+Z4ST1t9ET1nXOS9X/eLZGE7r+u3lrVa/OJ5yWtdvLy+Nflejwyzr9NhWWKdhYp8H1yRGLRa3Ur2Q13oMtR5DxfFZj6He+mPQ1XDNaX0M6uWtVr+4lslpXb+9vPUYajBdDjFU2rWeHOXFxVo/GL75d5LofwvWmb5I60w4zt0KvO/uPBR/ucZIrvb6ToqR4s5FWPDR9tTXY6RL5wO5rdfXmUZfv+vrTL08H/rFsZXTun57eaMQI2Fb8TrTamOffztC60yebKSpxRCsW7SfrDEUtudqn6m5m/J8xlcoz2pjAWyrtXqm5q0aq/k975PN/rFtNf/JbW3hP7OuM+HZ2Sxj0OWq36zrTKvVL/K5nPSbNYYSPWXVr6dzrCOl37Q6xHOsWWIotFEec3GtR+hwrYcxkIffNkr/vSd+lsNPn+y9L+RWkof1I+Pf5qD3PPyDrcMfeHzxkYeW7ms9degdjzY/0Dh4+KHGI+9oNg+2Dh3C2iCHGaW2bC1MI9cF5T5i3JZQC3nLxGww2Mq3EdbtCVj7CUuLPATrjgSsBwhLiy6k3J0xfJBGW+FBee5MkOf9Ybw8fCrwrgSsTxAWlr+LsO5OwHqUsLD83VTunhg+SIPe8B6Ft4bPdltMkPlA2C8zylUkrFIC1mOEheVLhFVOwPokYWH5MpWrxPBBGhxJK8Anp9zT5DkYxstTIaxqAtYhwsLyVcKqJWAdJiwsX6Ny9Rg+SFOD+3Xgk1PuafI8HsbLI2XTjHAoq+GIkvqpBOG/ViNckl75zTxziqwFJQ/HEMxDPnMKHw3rNkOsOwyxbjfEutMQ625DrHsMsYqGWGVDrJIhVsUQS3yi+DRs163ER4sR7nbwwfI8U8ByuZi/wofvMR9NZm0l7aHwzb/RjOTZa3tl0Abx7VhYVsaiSaJ/alcP84UOpuhSmynJGIC2Zedze29ux7E1IJ3g+INfWOWkzRpF7qwrtdhGPFZi/5+jPOzP85SHfWqB8sqKPKu1L2yrtbJjXrG+x5CPFgezvi34aDGyFmNiP8E84cP3XG9z4hX7uP7/+Wt1nnH9X2K/SaJ/CPr/z9GJFow3Dft4nfsxJi2G4pMg85DH9rwAeWyD3wV52LacNL8husi62oRjndRplPQbpay7XaiL1fpQ9pPYp9lPYlvF+UlsX20MGdYXYFut+9D0fLDtpK08xxCZ/UuN8iz9i+S9HfKugWtOSTFLlt2Cy1W/6HM5reu3l7da/fL6FCZL/WI7vlX1m1aHoous8Qfa6Bzg8xiAdBhDxq1zBwoG4/C4KHUeU8rKF8a0te7txENbb8d7PAZtV+R1jal++/ebb5xHflIPvIf884pOfKxzllPqVYtty6RzzOO1Nm09v6Lw0bDYL2mx13Qw2McM9VVN237CP6/owUf7aftJ2xW9roV9x7XzPQ55qn7k6b71Ttuv0db/ojetTAVBbPzKNhm3ryP34toGefP+smuvr5yAtZ+w4uoQ10aIxfvLmg4mKe/GzltC3/gq4s5+mrs6NNcCTb5z7Zq3ed57St2nee/JzxzevfeE+kGb3RC4bQfbLm5f/i6lrmzLdybIxLac9QwAYrEtu84A3JOAxbaM5TkuQF/NJ78qSn0kr6rIF9n4dTvj8e9x4Bcd+GUHvutkMa43VigP1zWrgH+LA9/1NYA7Hfh3KfiMKX4Dz+/cRHlCe1sHI4qR652jRtOBz7G3UtbW6wOqM/rYrGttIvcwJ8u5jbE/VikP+xfPezTf4HsNbK1Olq/ViW/uD75O5Etb+X06NZv9a74I/Rm3NY6t3D4YB7BO485YcNL6m+hpNE7mjr5+sz5hj6d21/WbrN+sT5atVr9+3nI7WvpNq0PRxTBP50mdolPPV3euH2wdvq/11EcajzzUbBx+6MCjH2x98vHWocMTBHtTjDjym4cmMRHECRziRmmM8vhl3vKy1LFAT2I2fpak/IdVInfWsEprYi104rAKh18Oq9IcLUF5VhseYFvdGlMvCz6oo7UOd1jfFnyw7fgY1ChMK7BtNbfJbY1uk9sH3SbrFIelnXDNKWkak2VYulz1m/UDQ6vVL/K5nPSbNawSPY3GA6ejpd+0OsSHSrOEVWijPOZizCMfdJC8XVDubVRuN+QJvvaBK1wikI+sztLv6HpP53qS5PrzDt400RnbQ5OX3oQH8vbU11M/thH3MkqUO6/kDfMxiXJrcaneaLQrS+3iUqP9xkOUiC+y8j3+mMTbFPotCr3n6WpD+gt+TAJtO0oTkHcL5U1CHk4V+WMSfj4eVGmk0T/yLyj074M6ZGnLgsIH+3cWrK1Bv91i3/bb38rdj82hTUrS4vmscyMc67LMjfBD9zym7IG8uA94RNeurYS4DwujPGl8UZRcNjERUy8LPqijPcRnjyGfPUCz1h889vwyiEz2r407/HFDzMOl+j2Ul/bDoVlfCLfal0FcrvrFuIuTpX6Rz+WkX4ybOWn6FT2t228vD/0ipyQbzTI3QhuVOq3HH+vxRxyf9fjjre+/s75MbT3+yKbfvXDNaV2/vbw9lDdq8d16/NGjsYw/WPZJhfY6yhPaffA4crtzPRsMjl03BP1510HejZR3vSKT5O1RZMoRD3wcRuijtBT210Ho392RO9Lle3brmGMxmHJEVVvnk3pMd/5OQJ6d/S6VIrlvgQ9/ok7fqG/YXyccz8cVel5LvVmhR3sVHWmPx+8lrOsVrBvgnqwVavoUGS+FPlFG1ufehDqxPjX9o55ER1rMtIuwdilYqGOXPkXGS6FPlJH1eWNCnVifmv5vBBrRUSEY1PVuwtL0uQfu8Vq2lJ9S6BFvkuiXwOec29UvH/pNtoXrFGz0vTnCwHrklXrMUB6WjXAnd/TjJr3ajdtGe4QH9znFtrXXdEhZz4+XZn6FDb/eQntNleTho6e8p4uPnvJjA/joKb+GD1PSo6dp4qsc8RFc9lVsMzcpMuKrTrRHo/jRwmJKnkKf9KpDtj/NXvGxGpf98WuvpBzGFyg/v7JF6Jehr7/Sudb8sejJrz8utjR/jHplf+zSYZSy9nnRmfaqjhLlob1wv7tJwcRXbaFPk79D7U03m61StTS3MN+qVpsLta2Ej7rY5IF/tdaYW2rMlUoL1VKrWlpz/ku1+uLSRSGKrdIb6lhr/rXm4nxxrtxYaC7Vm5Xa0lrzby1WF+YWF5ZqxWZxobRQSeIf9bNvwXqo8A8UuRgny9pglB4O3/wrY+UUlLd8NFfwN5B8Rvgl0dNkMKgn4b3RS93a7TTtgPzzJKuxrruPlG4keVg/fJZl2o9+WtEjq2J76POnFN2wHBtIxrwnGbVxVWTSztuIHBHNAj2COOZJRr99tN09W4ax4UPhm38jnl+iuYK0DcY1aPdjkI/0vwdrP1+htR/2uVHaBPkblHz5Le01ptDiNf8W2VmvSC82ORVT1ymqq9B/A2K4Z7brmKg/lGssBvOPlbhQMHGu5urzQr9Jocc+JvLMBoN9cxOVQ9mng/6E97T2yREtj8EyTmG5uN/TCk6cDBsVHG0+PU2yIk+2hyjxnGdc4YN9Csf8aYW/4fhQ08ZKSZI3RfXFPKz7D4c9Ok7aHFPqFNX3czSnQTqWR+trlrGR3J+E+8x3nGiniBbHc9bZpIGMBYXPFOFucMifI5wJpdxMoPdH7W9aeXOKvNpYMywfxPqRsJ8PtjOOaf9I/hP9+LhS9omwl4/0/xrGtH+VckxjX4J1+GjYu8c+m+NY7pO89sFjF9PgOI70/0YZu9g/IFZ07/9MESNocR/HCLO7e5j/TPrUYoDZYFA3bMPTxAvjYxlfWAf/Gdr1/94Vz0v0OuOoY3Tv27t0OpQB6RhDGzsFQ+vXUm5WkYv7HvuOKQcPbTzTeExS3rDto43bGGtoMYyWj+M58uF7Ywp9UvyRj8HWcKcUHM3Pb6S8nJLHPgzriz6MYxNtToa+Uet3cW3nir012dPEVVMO2TX9oR+yXsspzhdLxaW5WrtdatYbi9WktRy5vyHsr9cbf+HeJNQrShuRnvKmIW8i7Oef7/yeAD6IJXJMEv2NHX8727k/BWWkfEHhP0X8++RW7qGtMda4ck/oozbd2ZHRxxpdubYw31hYLJbK7XK5Ml9PaldNT7h2ECXRNbbFlFK3SaK/Hca+O2G9/Q1ahV9E93YHXS7m7xsYyr2JsP+e1kZou0IvvPPhoIyStwnyJonP5s5v1BdiiRyTRD9Ptov2JuULCv+NxL9PbuUe2+4mhX6TQh+1T6kjo9gt1t167e8NnoSP91i2t3vsV0sL9fZCpbJYqiw0Wwul+pqvvVcri+1S++L6e6VdrMyX1nzvoVEsX9xzWVyslVqNhYX2mte/VCq169XF+fpS+eIS35rvfVTbc416e65YKzerrXKzsZq9D5w749ztATpzpc3dsKycueK5Wwv87Q+CL+EYTGTW4twxytPmdFoMzPMXjId4DcYVxwbB4HwYywvdjFKu6+eDwfjVct0pzfiD/POKTnzsk2hrplOKXkU/m/zIUxV5NivyaO0c7atsCQbbDOUTLFwjk093avG42Lu2XzNNedoc0DUHxXV811q7tmagrXlxvw8Cvd/LnIHXGD4O/X6Z+r0219H6L/d7tlXM085Kudoc5468BjSj0G8GGp53o03MpMDa4OC9RaGfcfBGubAs846zXdfenOczLzXtzAvumWAcF9eOSJ9Gl1o7Fogedaf1Y+6PyHcT5WH/4z6Odir2i/2Fx2jsjzhGW8cVjbnWQrVeKS9V2guN+eL8Wsc1i836UnGhUmo2GnPFufr8auIaXruPknZOwnqMYTm1MVj45wPdX++zkafEPl/kiRuDRXeufTttjTEXDPpUl5/VsMYMsfh5D2wPtgU/5wnSx2PCPx8M6tSHLYwpetX6Fe//5YJ0Z51ySt64cu87GUvb98rF/BU+fI/5sP0jn7g52q/RHE3KpZ2jCf1N1/Uwv0ixmtb+3HeitK/zt5gtVfmG3/NSxQafrcfEMQi3CydtD17kzvrcNY7xmygPx4fNlIdj2QzloU/cQnm+bHcypl4WfLQ4yDXer5aPtu+hnc8Ylg+2He8lauPZasdGbb6ojY3oW/5yt84TfQuWlXkv7y9uB9/yL+j9WJ7O4Myz/WPiNRq0X+25G7Zn9A1sgzi34LO4mJLO7mR5dhRtbxrwuV8iT89xcCb9Rynruy1E7qw+VpuLaXFOnvKG9c0oj4WvGI+plwUfpFmrd2is9Zjh+Tx+Zv/DYwyvEWMe+h9uH21tQ/Kwf2BMzEnrb6KnrO8GuBz1yz6Zk6V+c1SPfZ3fxeHSyOs3a0wudFn162ltYKT0m1aHoguL+ATPZ2r7btp8XOi1/SQ+5xQlLY6WsqM6x8zaDzj+xPVrtplZyEOdcEqa02Z5dlmbpyAdnzfLKTLiXEQ788v2oa3vaPtVLhm1tVGXvaI+eX9Ge26DeeOcSttL5DnVnZ05VdKzy6KnS7GPg3qdJJlcOoxS1j4vOisEg/7RtVfDc+FJBRPX2az3OebKS7VGpbZQXGrV5hr1uaR9ju5Z87BHZ9iOZeEr7TUe9PzBRNiTSfhr5ymFTmSd9iNrUWSVM2TSh5An1mWM6Pmaz2zed11Pbqyj1APvIb7Qa+fX8FyfyKidddwUZsPaSFgbhsASubQzfRtWKZeGxWdbs5xV/Z5O20R94v8HXbL0BDvRBAA=","debug_symbols":"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6HGzYuhxs2LocbNS6ANuVgw9blYMPW5WDD1uVgy9nxm98xt6l2Lt6JhX8u62sPoE3txRTu1O26Kc2m22RTm1e2yLcmo32Bbl1O6uKco4tVtri3Jq99UW5dRuqi3Kqd1RW5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKhNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKjNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKgttphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxHKvOB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFsuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mEsiy4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4nZaoTS4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4na+i9K7xX4c7V2In1DujMSnFYkJ5mkkeW/ccckfB0f79Mk5/BbJ4qM6EAmH1oFIeL8ORMJVdiCSRyT9IuGEOxAJj92BSLj3DkQiF+hAJBIH/SI5EocORCJx6EAkEocORJo7ccjr0c7b8Ono33A8cI7hzO2wK3DmdrYVOHM7ygqcuZ1cBc7cDuocjp/buVTgzO0YKnDm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Sty1KnHXqsRdqxJ/rUr8tSrx16rEX6sSf61K/LUq8deqxF+rEn+tSvy1KgnXqiRcq5JwrUrCtSoJ16okXKuScK1KwrUqCdeqJFyrknitSuK1KonXqiReq5J4rUritSqJ16okXquSeK1K4rUqSdeqJF2rknStStK1KknXqiRdq5J0rUrStSpJ16okXauSfK1K8rUqydeqJF+rknytSvK1KsnXqiRfq5J8rUrytSop16qkXKuScq1KyrUqKdeqpFyrknKtSsq1KinXqqRcqpKwLNdOM9dOs9dOc9dO89dOC9dOi9dOS9dOy9dOu1Yl17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew3XstdwLXsN17LXcC17Ddey13Atew0H2WvZnjA0xZud0472Ud021ixPO5v+Om3vlW+tXigdjjJdqeEEXcOJuoaTdA0n6xpO0TSceJTxSw3H6BqO1TUcVVfluKi6KsdF1VU5LqquynFRdVWOi6qrclx0XZWNrquyefdVOW67rCyL3RmPVTYep2w8Xtl4grLxRGXj2d9A3eR1nxFrn177uD8eE9PyeOtB+rJ7Qdxf7239JeUNX7K/lvzjL3Hx8SXRPX3Jzi/ysls3BnLL875Py/52qsu259riHr+9L/Zj/Eb5+MPGP95WO7+O33Y+ftf5+H3n4w+djz92Pv7U+fhz5+MvfY/fab//1sbf+f3XdX7/dZ3ff13n91/X+f3XdX7/dZ3ff13n91/X+f3Xd37/9Z3ff33n91/f+f3Xd37/9Z3ff33n91/f+f3Xd37/9Z3ff0Pn99/Q+f03dH7/DZ3ff0Pn99/Q+f03dH7/DZ3ff0Pn99/Q+f03dn7/jZ3ff2Pn99/Y+f03dn7/jZ3ff2Pn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","names":["get_total_borrowed_assets"],"brillig_names":["get_total_borrowed_assets"]},{"name":"repay_public","hash":"9826994799100394905","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"1Z3dbuI6FIXfhWsuvH9sb8+rHI2q/jAVEoKKtkc6qubdj8OQQEtKNCYrim9QUrz3+ghZ3k5i04/F0+rh/fluvf21e138+Odjsdk93r+td9u89/F7uXjYrzeb9fPd+Z8XrnlhObR/fbnfNruvb/f7t8UPEla/XKy2T822mMs5fq03q7zn8vZle8fcNnfKXesUexprcvHYWBOFrnHwPY1N1Y6NTYOeN/65XLCOQ59S25woTUfvx6H31h17Gzj25GNLT0HkOn3yosfGKcd9pQ9j0xN/om804gQa1qehIqH9msWfvjkvPQLemTs2zps2cE54auHNi/t6VFM/TfcJVKJdpxnxDBXXS8OJOxrx12muf1whtACjBQQtoGgBjxYIaIGIFjC0QAILKNrJinayop2saCcr2sl6u5M5UDsW4nBW8/Ow7qAQ4AoRrmBwhYRW8A6uQHAFhisIXEHhCnBPe7inPdzTHu5pf7ung7RD7eBPl14pNOmDw6YnbHrGphdsesWm99j0AZs+YtMbNj3WtRHr2oh1bcS6NsKrb4RX3wivvhFefSO8+kZ49Y3wEbXBR9QGH1EbfERtcE8b3NMG97TBPW3YqmzYqmzYqpywVTlhq3LCVuWEHUsn7Fg6YcfSCTuWTljXJqxrE9a1+dkdOP/tviVz7RNRMrILBQZ/AgHnV3B+D84fwPkjOL+B84MdTGAHE4Hzg/1LYP8S2L8E9i+B/Utg/xLYvzToX3U0UMFcCu3ElrxtZzNbDrNhiN0EGjSBBt+ukUG72VLE6s81LpuLUzq2Fuc/zbs5AMncgHRuQH5uQGFuQHFuQDY3oDQzIHHTA6W2tXAcmP+Xr4qi6/pRFr3gp8r5uXJ+qZxfK+efvihJaMeAImcTur/hjyIdf/SX/NPXMJX2iIpqHOI3dxrH2cWUNpLpS54SnfhtiD91M/LytrcLfqucP9XNr65yfqqcnyvnl8r5tXJ+Xzl/qJy/8vqrlddfrbz++srrr6+8/vrK66+fU/9/AJpTh34AmlMPfQCavsv13D6XFz94yZmvaU7rgZXlgj/VzR9c5fxUOT9Xzq8j8IvpScPxOf9Bw0+gESbQiBNo9Pen2v0IgmoYeKw84m8C0DdrKrS7D5lv+g3hnDX2/On4NArfLKsYU4HgCnyzwsAcYPpmgcWoEoqX8HiJgJeIeAnDSyS4hDm8BOEl8O42vLsN727Du9tud/fVWVcWwfkNnD9h8ycHzk/g/AzOL+D8Cs7vwfnB/k1g/yawfxPWv+wcOD+B8zM4v4DzKzi/B+cP4PwRnN/A+cH+JbB/CexfAvuXwP4lsH8J7F8C+5fA/iWwfwnsX4ZfETMTXoLxEoKXULyEx0sEvETESxheAn6/iwXvbsG7W/DuFry7BVypBVypBVypBVypBVypBVypFTzSVvBIW8EjbQWPtBXsXx3075cHfT0Pc4N2yxlCOK1m0KNCgCtEuILdrjDmEjvWNDMg7+YGRHMD4rkBydyAdG5Afm5AYXqgEVcWso+V81vl/Klu/uAq55++KI25spbD9DVszJW1HKYveWOuDOCglfP7yvlD5fyxcn6rnD/VzR9d5fxUOT9Xzl95/R2eGz5z/srrb6y8/sbK62+svP7anPr/A9CcOvQD0Jx66APQ9F3umCsL2Xzl/KFy/lg5v9XNn8a4ZLi+WpQTTaDBE2gIXEP6p0aTahel/vSd5zsef6JCUVQsirKiqFQS1T+ReDCq93yj01QcCny6d6rHIC4JkpKgUBLUf/yuPheX/nmcQ0FagNc/hXAoqORA9E/zGwqykqBUECSuJKjkhJWSE1ZKTlgpOSPEF5x7EkqCYkmQlQSVmFBLTKhUEsQlQVISpH8b9Dvv/Xu/X98/bFavOaZ58337+LbebY+7b/+9tO887Nebzfr57mW/e1w9ve9Xd5vdY/PewjUvjbhoXObymWGa80ydLHMl+Nn8R5G8y8kvxblmtzmO4ijvSmbIHP8D","names":["repay_public"],"brillig_names":["repay_public"]},{"name":"compute_total_deposited_assets","hash":"15078958202233558575","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"deposit_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["compute_total_deposited_assets"],"brillig_names":["compute_total_deposited_assets"]},{"name":"sync_notes","hash":"11458989905199010708","is_unconstrained":true,"custom_attributes":["aztec::macros::functions::utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"7f3drvM4l6WJ3kse54FITvGnb6WxUciqyi58QCKzkJW1gUYh770d4SXZ77dkcb0K2nOSfE4CKyIkm3zGtDTHoE39n3/47//8X//3//gvf/vX/+ff/tc//F//9//5h3/5t//2T//xt3/719u//Z///Md/+K///rd/+Ze//Y//8vyf/2H54x/OpT9P+F//85/+9Y9//1//8U///h//8H+5RVz4x3/453/973/+nfztRf6fv/3LP//xb8t//uO341OOX0fnRfZjYzo4dPXr16HrujxeVvx//v/+8Tac3GI4OaRtOGs5H46E8nWoxPx9OKXJcLJswyn5fDhx2ehEH78Nxy8thlO8/zq6hLUynLx8HZqW72J5dzickJcNvwslxspwfFnc1+Fh+eXor3fxH3mX8JF3kY+8y/qRd4kfeZf0kXfJH3mX8ol3CctH3uUjn/3wkc9++MhnP3zksx8+8tkPH/nsh4989sNHPvvhI599+chnXz7y2ZePfPblI599+chnXz7y2ZePfPblI599+chnXz7y2V8/8tlfP/LZXz/y2V8/8tlfP/LZXz/y2V8/8tlfP/LZXz/y2V8/8tmPH/nsx4989uNHPvvxI5/9+JHPfvzIZz9+5LMfP/LZjx/57MePfPbTRz776SOf/fSRz376yGc/feSznz7y2U8f+eynj3z200c+++kjn/38kc9+/shnP3/ks5+bfPbDssb9XUp6Onq9v4t85F3Wj7xL/Mi7pI+8S/7IuzT57IfbWt72Lt6XX97l+9E3a7aN6danPy8BlqNVz7wtGK7haRzr/TNSFoXx533l83a9yZXxrzHtq8gxh/3oNd4n4HqfgO99AqH3CUjvE1h7n0DsfQKp9wnk3idQ+p6AXzq/E/vF/p04ydY4rWmV5wkcuIt1/6aVX5M7Pziv2zByepqhHNoWt39lzd/WWPajxR8dnB8W55dD/yRuv3UYjbj9Xmc04gLxDxO3302ORtx++zsacfv9+mjE7RuM0Yjbd0SDEXf2LdxoxPGcnyaO5/w0cTznp4kLxD9MHM/5aeJ4zk8Tx3N+mjie89PE8ZwfJu7xnJ8mjuf8NHE856eJ4zk/TVwg/mHieM5PE8dzfpo4nvPTxPGcnybeg+d0D+L5HKLL+y9OXPGh8tJOyrapnVuftoP7+k5m6MEdarHpwcdpsenBcWmx6cEbabER2Lxk04Pf0GLTgzPQYtNDD6/FpoduW4sNffFLNkJf/JoNffFrNvTFr9nQF79mI7B5yYa++DUb+uLXbOiLX7OhL37Nhr74JZuVvvg1G/ri12zoi1+zoS9+zUZg85INffFrNvTFr9nQF79mQ1/8mg198Us2kb74NRv64tds6Itfs6Evfs1GYPOSDX3xazb0xa/Z0Be/ZkNf/JoNffFLNom++DUb+uLXbOiLX7OhL37NRmDzkg198Ws29MWv2dAXv2ZDX/yaDX3xSzaZvvg1G/ri12zoi1+zoS9+zUZg85INffFrNvTFr9nQF79mQ1/8ms3MfbEvcWMTFrdUSSbZSbqn185HI4lL/jo4+id8+c8nsfoOnmQ6JPaZu3lF7DMbBUXsM3sQRewCdg3sMzsnRewzmzJF7DP7PUXsM1tJRey4VAXsoYOnfA+JHZeqgh2XqoJ9Zpd6m33asZfaQJxLfn9xV5anV3f+3TIJMvUg08wuuCOZZnbNHck0s8vuSKaZXXlHMs3s4vuRqYsHwyNTF0+TR6YuHkGPTF08tx6ZunjYPTI5UoguZCKF6EImUogfy+SXdRuJ87cZV2TyN1m/DvcuP0HJ+ejotOxHJ//4LnW8y0QK0YVMpBA9yORJIbqQiRSiC5lIIbqQiRSiC5kEmXqQiRSiC5lIIbqQiRSiC5lIIbqQiRSiB5kCKUQXMpFC/FymkPMuk0htIcPHfSw+xvVxdAmHCP324rdFwOej3dHRIe0jDyX8cvSfspJaDCkrKceQsgqyjigrKcqQspK6DCkrKc2QspLqDCkrKdCIsgqp0ZCykjINKSsp05CykjINKasg64iykjINKSsp05CykjINKSsp05CykjKNKOtKyjSkrKRMQ8pKyjSkrKRMQ8oqyDqirKRMQ8pKyjSkrKRMQ8pKyjSkrKRMI8oaSZmGlJWUaUhZSZmGlJWUaUhZBVlHlJWUaUhZSZmGlJWUaUhZSZmGlJWUaURZEynTkLKSMg0pKynTkLKSMg0pqyDriLKSMg0pKynTkLKSMg0pKynTkLKSMo0oayZlGlJWUqYhZSVlGlJWUqYhZRVkHVFWUqYhZSVlGlJWUqYhZSVlGlJWUqYRZS2kTEPKSso0pKykTEPKSso0pKyCrCPKSso0pKykTEPKSso0pKykTEPKSso0oKyykDINKSsp05CykjINKSsp05CyCrKOKCsp05CykjINKSsp05CykjINKSsp04iyOlKmIWUlZRpSVlKmIWUlZRpSVkHWEWUlZRpSVlKmIWUlZRpSVlKmIWUlZRpRVk/KNKSspExDykrKNKSspExDyirIOqKspExDykrKNKSspExDykrKNKSspEwjyhpImYaUlZRpSFlJmYaUlZRpSFkFWW3I6mXdEeaarFJ2WddlKd9lJWUaUlZSpiFlJWUaUlZSpiFlJWUaUVYhZRpSVlKmIWUlZRpSVlKmIWUVZB1RVlKmIWUlZRpSVlKmIWUlZRpSVlKmEWVdSZmGlJWUaUhZSZmGlJWUaUhZBVlHlJWUaUhZSZmGlJWUaUhZSZmGlJWUaURZIynTkLKSMg0pKynTkLKSMg0pqyDriLKSMg0pKynTkLKSMg0pKynTkLKSMo0oayJlGlJWUqYhZSVlGlJWUqYhZRVkHVFWUqYhZSVlGlJWUqYhZSVlGlJWUqYRZc2kTEPKSso0pKykTEPKSso0pKyCrCPKSso0pKykTEPKSso0pKykTEPKSso0oqyFlGlIWUmZhpSVlGlIWUmZhpRVkHVEWUmZhpSVlGlIWUmZhpSVlGlIWUmZBpT19t+QdURZSZmGlJWUaUhZSZmGlFWQdURZSZmGlJWUaUhZSZmGlJWUaUhZSZlGlNWRMg0pKynTkLKSMg0pKynTkLIKso4oKynTkLKSMg0pKynTkLKSMg0pKynTiLJ6UqYhZSVlGlJWUqYhZSVlGlJWQdYRZSVlGlJWUqYhZSVlGlJWUqYhZSVlGlHWQMo0pKykTEPKSso0pKykTEPKKsg6oqykTEPKSso0pKykTEPKSso0pKykTCPKKqRMQ8pKyjSkrKRMQ8pKyjSkrIKsI8pKyjSkrKRMQ8pKyjSkrKRMQ8pKyjSirCsp05CykjINKSsp05CykjINKasg64iykjINKSsp05CykjINKSsp05CykjKNKGskZRpSVlKmn8saF7fLmp4Hfijr7SXdDuVZ1hdFkJetCJIrtaP9UrajvU+/HP2nrKRMQ8pKyjSkrIKsI8pKyjSkrKRMQ8pKyjSkrKRMQ8pKyjSirImUaUhZSZmGlJWUaUhZSZmGlFWQdURZSZm6lFVC2I6WXFsijOK/Do7xUQIhHs2yPBYfl6dhHB8c3X509OtSOdolF/eqSn+uT56/etl5x+KeajcfHJxvS6VfB2cf/fPBf9Y5sRt1PkOdk0NS5zPUOcEsdT5DnZNUU+cT1HkmuqfOZ6hz1jKo8xnqnMUd6nyGOme1izqfoc6FOqfOJ6hz1kOp8xnqnPVQ6nyGOmc9lDqfoc5ZD6XOZ6hz1kOp8wnqvLAeSp3PUOesh1LnM9Q566HU+Qx1znoodT5DnQt1Tp1PUOesh1LnM9Q566HU+Qx1znoodX69zv2a9jrPtZd2Oe6j/uNv+eX4P6uRVUuq0U41srZINVqpxriwAkg12qlG1umoRjvVyGoa1WinGlnzohrtVKNQjVSjmWpk/YhqtFONrPJQjXaqkbUYqtFONbIWQzXaqUbWYqhGM9XoWIuhGu1UI2sxRqox7d+1uv3569F/CsUyRSdCkeB3IpQgVB9Ckft2IhSRaCdCkRZ2IhRBWidCkTH1IZQnfulEKJKJToQimehEKJKJToQShOpDKJKJHwsVQvI7FFl9Bb27DWZfunA5PX4IHQ+FWvwulPdPx/4pE7lEFzKRSnQhE5nEj2WSJe3jFiepIlNcHls/PAHM6x08GYMO+EBmoASeDEAJPJ5eCTweXQm8AF4HPB5aCTyuWAk8PlcJPM5VCTzOVQe84FyVwONclcDjXH8OPkrZwcfqj1p8SBt5H8rTalguvx0iCz63C5kEmXqQCQ/dhUw47i5kwp93IRNuvguZ8P49yLSSFHQhE7lCFzKRQnQhEylEFzIJMvUgEylEFzKRQrxNJnH7llIiyy8y/YmeZEENPWmBGnoSAC30EVevhh6nroYe962GHkethl5Ar4Ue56uGHjerhh43q4YeN6uGHjerhT7hZtXQ42bV0ONm1dDjZtXQC+i10ONm1dDjZtXQ42bV0ONm1dDjZrXQZ9ysGnrcrBp63KwaetysGnoBvRZ63KwaetysGnrcrBp63KwaetysFvqCm1VDj5tVQ4+bVUOPm1VDL6DXQo+bVUOPm1VDj5tVQ4+bVUOPm1VCnxbcrBp63KwaetysGnrcrBp6Ab0WetysGnrcrBp63KwaetysGnrcrBZ6h5tVQ4+bVUOPm1VDj5tVQy+g10KPm1VDj5tVQ4+bVUOPm1VDj5vVQu9xs2rocbNq6HGzauhxs2roBfRa6HGzauhxs2rocbNq6HGzauhxs1roA25WDT1uVg09blYNPW5WDb2AXgs9blYNPW5WDT1uVg09blYNPW5WC73gZtXQ42bV0ONm1dDjZtXQC+i10ONm1dDjZtXQ42bV0ONm1dDjZrXQr1O72SA7+pBi7eiYN/LhFrY/gXd3lFO707Yop3abbVFO7R7bohRQtkI5tbtri3Jqt9YW5dTuqy3Kqd1UW5RTu6OmKCNupxlK3E4zlLidZihxO81QCihbocTtNEOJ22mGErfTDCVupxlK3E4rlAm30wwlbqcZStxOM5S4nWYoBZStUOJ2mqHE7TRDidtphhK30wwlbqcVyozbaYYSt9MMJW6nGUrcTjOUAspWKHE7zVDidpqhxO00Q4nbaYYSt9MKZcHtNEOJ22mGErfTDCVupxlKAWUrlLidZihxO81Q4naaocTtNEOJ22mEMi+4nWYocTvNUOJ2mqHE7TRDKaBshRK30wwlbqcZStxOM5S4nWYocTutUDrcTjOUuJ1mKHE7zVDidpqhFFC2QonbaYYSt9MMJW6nGUrcTjOUuJ1WKD1upxlK3E4zlLidZihxO81QCihbocTtNEOJ22mGErfTDCVupxlK3E4rlAG30wwlbqcZStxOM5S4nWYoBZStUOJ2mqHE7TRDidtphhK30wwlbqcVSsHtNEOJ22mGErfTDCVupxlKAWUrlLidZihxO81Q4naaocTtNEOJ22mFcsXtNEOJ22mGErfTDCVupxlKAWUrlLidZihxO81Q4naaocTtNEOJ22mFMuJ2mqHE7TRDidtphhK30wylgLIVStxOM5S4nWYocTvNUOJ2mqHE7bRCmXA7zVDidpqhxO00Q4nbaYZSQNkKJW6nGUrcTjOUuJ1mKHE7zVDidlqhzLidZihxO81Q4naaocTtNEMpoGyFErfTDCVupxlK3E4zlLidZihxO61QFtxOM5S4nWYocTvNUOJ2mqEUULZCidtphhK30wwlbqcZStxOM5S4nUYoy4LbaYYSt9MMJW6nGUrcTjOUAspWKHE7zVDidpqhxO00Q4nbaYYSt9MKpcPtNEOJ22mGErfTDCVupxlKAWUrlLidn6KUsPivoyWs8ReUByORtCFxq3saST4ad1zy18HRP71yXu8i4aM6EAmH1oFIeL8ORMJV2hfJ41c7EAkn3IFIeOwORMK9dyCSIJJ9kUgcOhCJxKEDkUgcOhCJxKEDkeZOHPJ2dBC//nL0H3DC3E6/Amduh12BM7ezrcCZ21FW4AhwXsOZ20FV4MztXCpw5nYMFThzd+oVOHTIr+EIHfIJHDrkEzh0yCdw6JBP4AhwXsOhQz6BQ4d8AocO+QQOHfIJHDrk13BWOuQTOHTIJ3DokE/g0CGfwBHgvIZDh3wChw75BA4d8gkcOuQTOHTIr+FEOuQTOHTIJ3DokE/g0CGfwBHgvIZDh3wChw75BA4d8gkcOuQTOHTIr+FM/mT7Chw65BM4dMgncOiQT+AIcF7DoUM+gUOHfAKHDvkEDh3yCRw65NdwJn8aegUOHfIJHDrkEzh0yCdwBDiv4dAhn8ChQz6BQ4d8AmfqDlnCA051Tw2Xtn0v/PJ4ZZ/DwbF555FDqRxbdoVK+fXYPwWaukvvQKC5nyTeg0BTu5UeBJraMfUg0NSurQeBBIFsCzS1e+1BoKkddA8CTe3iexCIJMG4QCQJpgW68Z47Ssj7BrdZXE0hn/cta0OQx9HuEMnqdvXXvPxy9J383BmBJvm5zb8m+bldvSZ5gbwS+bl9uCb5uQ22Jvm5nbMm+bktsSb5ub2uInmHh9Uij4fVIo+H1SKPh9UiL5BXIo+H1SKPh9Uij4fVIo+H1SKPh1Ui7/GwWuTxsFrk8bBa5PGwWuQF8krk8bBa5PGwWuTxsFrk8bBa5PGwSuQDHlaLPB5WizweVos8HlaLvEBeiTweVos8HlaLPB5WizweVos8HlaJvOBhtcjjYbXI42G1yONhtcgL5JXI42G1yONhtcjjYbXI42G1yONhlciveFgt8nhYLfJ4WC3yeFgt8gJ5JfJ4WC3yeFgt8nhYLfJ4WC3yeFgl8hEPq0UeD6tFHg+rRR4Pq0VeIK9EHg+rRR4Pq0UeD6tFHg+rRR4Pq0Q+4WG1yONhtcjjYbXI42G1yAvklcjjYbXI42G1yONhtcjjYbXI42GVyGc8rBZ5PKwWeTysFnk8rBZ5gbwSeTysFnk8rBZ5PKwWeTysFnk8rBL5gofVIo+H1SKPh9Uij4fVIi+QVyKPh9Uij4fVIo+H1SKPh9Uij4fVIX8DCXkl8nhYLfJ4WC3yeFgt8gJ5JfJ4WC3yeFgt8nhYLfJ4WC3yeFgl8g4Pq0UeD6tFHg+rRR4Pq0VeIK9EHg+rRR4Pq0UeD6tFHg+rRR4Pq0Te42G1yONhtcjjYbXI42G1yAvklcjjYbXI42G1yONhtcjjYbXI42GVyAc8rBZ5PKwWeTysFnk8rBZ5gbwSeTysFnk8rBZ5PKwWeTysFnk8rBJ5wcNqkcfDapHHw2qRx8NqkRfIK5HHw2qRx8NqkcfDapHHw2qRx8MqkV/xsFrk8bBa5PGwWuTxsFrkBfJK5PGwWuTxsFrk8bBa5PGwWuTxsErkIx5WizweVos8HlaLPB5Wi7xAXok8HlaLPB5WizweVos8HlaLPB5WiXzCw2qRx8NqkcfDapHHw2qRF8grkcfDapHHw2qRx8NqkcfDapHHwyqRz3hYLfJ4WC3yeFgt8nhYLfICeSXyeFgt8nhYLfJ4WC3yeFgt8nhYJfIFD6tFHg+rRR4Pq0UeD6tFXiCvRB4Pq0UeD6tFHg+rRR4Pq0UeD6tD3i94WC3yeFgt8nhYLfJ4WC3yAnkl8nhYLfJ4WC3yeFgt8nhYLfJ4WCXyDg+rRR4Pq0UeD6tFHg+rRV4gr0QeD6tFHg+rRR4Pq0UeD6tFHg+rRN7jYbXI42G1yONhtcjjYbXIC+SVyONhtcjjYbXI42G1yONhtcjjYZXIBzysFnk8rBZ5PKwWeTysFnmBvBJ5PKwWeTysFnk8rBZ5PKwWeTysEnnBw2qRx8NqkcfDapHHw2qRF8grkcfDapHHw2qRx8NqkcfDapHHwyqRX/GwWuTxsFrk8bBa5PGwWuQF8krk8bBa5PGwWuTxsFrk8bBa5PGwSuQjHlaLPB5WizweVos8HlaLvED+LeTFp/J1tITVV452kvbXXt3TuPPRLOOSvw6O/kmavH5pijseT1N893ia4ujH05SsYDxNSSGG0zSRb4ynKcnJeJqSyYynKWnPeJoKmg6nKTnSeJqSI42nKTnSeJqSI/1Y07APxMUlVFTyflm+jvYSftX0Tp60R4l8JpPRIk9yokWefEOLPCmEFnmBvBJ5HL0WeXy3FnncsRZ5PKwWeTysEvmCh9Uij4fVIo+H1SKPh9UiL5BXIo+H1SKPh9Uij4fVIo+H1SKPh9UhHxY8rBZ5PKwWeTysFnk8rBZ5gbwSeTysFnk8rBZ5PKwWeTysFnk8rBJ5h4fVIo+H1SKPh9Uij4fVIi+QVyKPh9Uij4fVIo+H1SKPh9Uij4dVIu/xsFrk8bBa5PGwWuTxsFrkBfJK5PGwWuTxsFrk8bBa5PGwWuTxsErkAx5WizweVos8HlaLPB5Wi7xAXok8HlaLPB5WizweVos8HlaLPB5WibzgYbXI42G1yONhtcjjYbXIC+SVyONhtcjjYbXI42G1yONhtcjjYZXIr3hYLfJ4WC3yeFgt8nhYLfICeSXyeFgt8nhYLfJ4WC3yeFgt8nhYJfIRD6tFHg+rRR4Pq0UeD6tFXiCvRB4Pq0UeD6tFHg+rRR4Pq0V+ag+b1518WeSXo/+kk6b2mVU6U3vBKp2p/VqVztSeqkpHoHNCZ2pvUqUztX+o0pm6x6/SmboPr9KhVz6hk+mVz+jQK5/RoVc+o0OvfEZHoHNCh175jA698hkdeuUzOvTKZ3TolU/oFHrlMzr0ymd06JXP6NArn9ER6JzQoVc+o0OvfEaHXvmMDr3yGR165dd0ZKFXPqNDr3xGh175jA698hkdgc4JHXrlMzr0ymd06JXP6NArn9GhVz6h4+iVz+jQK5/RoVc+o0OvfEZHoHNCh175jA698hkdeuUzOvTKZ3TolU/oeHrlMzr0ymd06JXP6NArn9ER6JzQoVc+o0OvfEaHXvmMDr3yGR165RM6cz+7vUqHXvmMDr3yGR165TM6Ap0TOvTKZ3Tolc/o0Cuf0aFXPqNDr3xCZ+5nRFfp0Cuf0aFXPqNDr3xGR2amU9y604m1o13KXwf7px1UfQ4Hx+adRw6lcmzJ25BL+fXYu0JT9+tdKDS1Z+hCoal9S0nbsMXJUjnap+A3iVJ5PjodaXRju4nkXfzl6Dv5qT2RKvmp/ZYm+bmflaxKfmqfqEp+ag+qSn5qf6tKXiCvRH5uT6xJfm6vq0keD6tFHg+rRR4Pq0R+7mclq5LHw2qRx8NqkcfDapEXyCuRx8NqkcfDapHHw2qRx8NqkcfDKpGf+znMquTxsFrk8bBa5PGwWuQF8krk8bBa5PGwWuTxsFrk8bBa5PGwSuTnfj66Knk8rBZ5PKwWeTysFnmBvBJ5PKwWeTysFnk8rBZ5PKwWeTysEvmCh9Uij4fVIo+H1SKPh9UiL5BXIo+H1SKPh9Uij4fVIo+H1SKPh9Uhvy54WC3yeFgt8nhYLfJ4WC3yAnkl8nhYLfJ4WC3yeFgt8nhYLfJ4WCXyDg+rRR4Pq0UeD6tFHg+rRV4gr0QeD6tFHg+rRR4Pq0UeD6tFHg+rRN7jYbXI42G1yONhtcjjYbXIC+SVyONhtcjjYbXI42G1yONhtcjjYZXIBzysFnk8rBZ5PKwWeTysFnmBvBJ5PKwWeTysFnk8rBZ5PKwWeTysEnnBw2qRx8NqkcfDapHHw2qRF8grkcfDapHHw2qRx8NqkcfDapHHwyqRX/GwWuTxsFrk8bBa5PGwWuQF8krk8bBa5PGwWuTxsFrk8bBa5PGwSuQjHlaLPB5WizweVos8HlaLvEBeiTweVos8HlaLPB5WizweVos8HlaJfMLDapHHw2qRx8NqkcfDapEXyCuRx8NqkcfDapHHw2qRx8NqkcfDKpHPeFgt8nhYLfJ4WC3yeFgt8gJ5JfJ4WC3yeFgt8nhYLfJ4WC3yeFgl8gUPq0UeD6tFHg+rRR4Pq0VeIK9EHg+rRR4Pq0UeD6tFHg+rRR4Pq0M+LnhYLfJ4WC3yeFgt8nhYLfICeSXyeFgt8nhYLfJ4WC3yeFgt8nhYJfIOD6tFHg+rRR4Pq0UeD6tFXiCvRB4Pq0UeD6tFHg+rRR4Pq0UeD6tE3uNhtcjjYbXI42G1yONhtcgL5JXI42G1yONhtcjjYbXI42G1yONhlcgHPKwWeTysFnk8rBZ5PKwWeYG8Enk8rBZ5PKwWeTysFnk8rBZ5PKwSecHDapHHw2qRx8NqkcfDapEXyCuRx8NqkcfDapHHw2qRx8NqkcfDKpFf8bBa5PGwWuTxsFrk8bBa5AXySuTxsFrk8bBa5PGwWuTxsFrk8bBK5CMeVos8HlaLPB5WizweVou8QF6JPB5WizweVos8HlaLPB5WizweVol8wsNqkcfDapHHw2qRx8NqkRfIK5HHw2qRx8NqkcfDapHHw2qRx8Mqkc94WC3yeFgt8nhYLfJ4WC3yAnkl8nhYLfJ4WC3yeFgt8nhYLfJ4WCXyBQ+rRR4Pq0UeD6tFHg+rRV4gr0QeD6tFHg+rRR4Pq0UeD6tFHg+rQz4teFgt8nhYLfJ4WC3yeFgt8gJ5JfJ4WC3yeFgt8nhYLfJ4WC3yeFgl8g4Pq0UeD6tFHg+rRR4Pq0VeIK9EHg+rRR4Pq0UeD6tFHg+rRR4Pq0Te42G1yONhtcjjYbXI42G1yAvklcjjYbXI42G1yONhtcjjYbXI42GVyAc8rBZ5PKwWeTysFnk8rBZ5gbwSeTysFnk8rBZ5PKwWeTysFnk8rBJ5mdnDituPFlfiL0ff6czsM+t0ZvaCdToz+7U6HYHOCZ2ZfU+dzszepE5nZv9QpzNzj1+nM3MfXqWz0iuf0aFXPqNDr3xGh175jI5A54QOvfIZHXrlMzr0ymd06JXP6NArn9CJ9MpndOiVz+jQK5/RoVc+oyPQOaFDr3xGh175jA698hkdeuUzOvTKJ3QSvfIZHXrlMzr0ymd06JXP6Ah0TujQK5/RoVc+o0OvfEaHXvmMDr3yCZ1Mr3xGh175jA698hkdeuUzOgKdEzr0ymd06JXP6NArn9GhVz6jQ698QqfQK5/RoVc+o0OvfEaHXvmMjkDnhA698hkdeuUzOvTKZ3Tolc/o0Cu/ppOnfi58nc7UvbK4sNFJbjmgM3WvXKUzda9cpSPQOaEzda9cpTN1r1ylM3WvXKUzda9cpTN1r1yjM/Xzp+t06JXP6NArn9GhVz6jI9A5oUOvfEaHXvmMDr3yGR165TM69MondKZ+zm2dDr3yGR165TM69MpndAQ6J3Tolc/o0Cuf0aFXPqNDr3xGh175hM7Uz9Os06FXPqNDr3xGh175jI5A54QOvfIZHXrlMzr0ymd06JXP6NArn9CZ+7l9VTr0ymd06JXP6NArn9ER6JzQoVc+o0OvfEaHXvmMDr3yGR165RM6cz+3r0qHXvmMDr3yazqlg9Q9pu3oNebwTOc+gw66/eWh7xK/z6BNV+XDVhghpFyZQYhl2Y7Oy/Nrp69BJYuDyhYHVQwOqlG61HhQzuKgvMVBBYuDEouDWi0OyuIVXSxe0cXiFV0sXtFXi1f01eIVfbV4RV8tXtFXi1f01eIVfbV4RV8tXtFXi1f01eIVPVq8okeLV/Ro8YoeLV7Ro8UrerR4RY8Wr+jR4hU9WryiR4tX9GTxip4sXtGTxSt6snhFTxav6MniFT1ZvKIni1f0ZPGKnixe0bPFK3q2eEXPFq/o2eIVPVu8omeLV/Rs8YqeLV7Rs8Ureta4oue0H10W931QZbE4KGdxUN7ioILFQYnFQa0WBxUtDiopD8r5g0FpXNHz/nWxUPzyy6C+H533r0zl8PjGlP/jO1rfjr3dyr+OLeXXY++TLdNM1i/LMtNk3UyT9TNNNsw0WZlpsutMk40zTTbNNNl5OqjbZGfqoNxMHZSbqYNyY3VQcTv2Nk5/MNuxWqjabGWq2Y7VRNVmO1YXVZvtWG1UbbYafVTxaZ/tmiqzPf+N4G0GpfcZ+KX7GbjuZ+C7n0HofgbS/QzW7mcQu59B6n4G3d+TQ/d3tGD/jna688BtBvavRbUZ2L8WJf+YgU/fZ2D/WlSbgf1rUW0G9v1BZQZi/2pam0EHV1OJ+wxWeZ7B94O97APxIvJ9uvbNRNPp2nceTacrc023gz6i5XQ7aDpaTreDDqXldDtoZ1pOt4Pe57em6/Njut8Nw9pBo9RyuqN1VZXpDtZVrevWM/s1hvOD47JsP8eIt7XW72wGa8F+h81aUjllI4Ox2dcK/Zrc+cF52V44y9PGl7J8oRmst2uJZrA+sCWawXrGlmgG6y9bohmsF22IJo7W2fwOmnVbh8kp/oLm4IVd2Mbs3fp4YfFHB+ethQjLL4fekY/WMHWAXED+aeQz93dKyGfuG5WQz9yPKiGfuc9VQj5z/6yDPA2WJ/eAfLBMuwfkuM+PI8d9fhy5gPzTyHGfn0aeqfKfIV+K35E/ffX4EHnO2yB+2czp8IXd7b23V779nZ5+clfyl0Z8LOxrRIpjXyNiH/sakRPZ14hgybxGhSTKvkZEV/Y1IuuyrxHhmH2NBI3Ma0TOYF8jcgb7GpEz2NeInMG+RuQM1jVyCzmDfY3IGexrRM5gXyNyBvsaCRqZ14icwb5G5Az2NSJnsK8ROYN9jcgZzGvkyBnsa0TOYF8jcgb7GpEz2NdI0Mi8RuQM9jUiZ7CvETmDfY3IGexrRM5gXqMOHq2HRuQM9jUiZ7CvETmDfY0EjcxrRM5gXyNyBvsakTPY14icwb5G5AzmNerggcdoRM5gXyNyBvsakTPY10jQyLxG5Az2NSJnsK8ROYN9jcgZ7GtEzmBeIyFnsK8ROYN9jcgZ7GtEzmBfI0Ej8xqRM5jXaB35c5TPD05xOzalX6jfyYxcvX+NzMjZ1F8j00Mi5B5kKpM9e+n7fHtIV1rOt4ekouF8Yw+uv+V8e3DQLefbgxttOd8enN3P5ytLKF8Hy1JK5aWD7M1gkPw07PXr7hUFOid0eugH9ej00BPq0RmrL2xNZ6wusjWdsXrOxnTSWB1qazpj9bOt6YzV/bamQ698RkemoXOf7zzd732+8/Sz9/nO06He5ztPz3mf7zxd5J/zzYP1hW5f0JDgpPLSeZGvg3N4sPE5HBxb8vbCpfx67J3jYB2kGsfBek01joN1pWocBY5NOA7WF6txHKzfVuM4WB+vxnEwf6DGcTDfocWx4GfacMTPtOGIn2nDET/ThuNo/aPb1h/E+YN8q4tnw7ec72j9WG2+o/VN5/P1XTz/u+V8R+tDavMdrV+ozXe0+3ptvjLZfEfL/Wrznau/8l08E7flfOfqr3wXz2ptON8unnvacr6T9VddPI+z5Xwn66+6eE5ky/lO1l918fzClvOdrL/q4rl6Lec7WX/VxfPeWs53sv6qi+eQtZzvZP1VF8/HajnfyfqrLp7b1HK+k/VXXTxPqOV8J+uvunjOTcv5TtZfdfH8lZbznay/6uK5IC3nO1l/1cXzKlrOd7L+qovnKLSc72T9VRf7+7ec72T9VRf7zrec72T9VRf7obec72T9lUzWX8lk/ZVM1l/JZP3VOll/tU7WX62T9VfrZP1VF8/JaDnfyfqrLp5p0XK+k/VXgz2poj7fyfqrwZ5UUZ/vZP3VYE+qqM93sv5qtGdPVOc7WX812vMhqvOdrL8a7RkO1flO1l+N9pyF6nwn669GexZCdb6T9VejPa+gOt/J+qvRnldQne9k/dVozyuozney/mq45xXU5jtZfzXc/v+1+U7WXw23n35tvpP1V8PtT1+b72T91XD7vdfmO1l/Ndz+6bX5TtZfDbcfeW2+k/VXRSab72T91WT7t/vJ9m/3k+3f7ifbvz1Mtn97mGz/9jDZ/u1hsv3bwyKTzXeu/ipMtn97GG7/9rc9Vylux94Q+F8OvoPkQYiNQPIkxDYgh9vKXg0kz0JsBJKHITYCKdOAvM93nqeH3+c7z1O+7/Odpwu9z3eeZvE+33l6uj/nO9wu97X5ztMh3ec7TyNzn+88T1++z1cmm+9k/dVwu9zX5jtZfzXcLve1+U7WXw23y31tvpP1V8Ptcl+b72T91XC73NfmO1l/Ndwu97X5TtZfDbfLfW2+k/VXw+1yX5vvZP3VcLvc1+Y7WX813C73tflO1l8Nt8t9bb6T9VfD7XJfm+9k/dVwu9zX5jtZfzXcLve1+U7WXw23y31tvpP1V8Ptcl+b72T91XC73NfmO1l/Ndwu97X5TtZfDbfLfW2+k/VXw+1yX5vvZP3VcLvc1+Y7WX813C73tflO1l8Nt8t9bb6T9VfD7XJfm+9k/dVwu9zX5jtZfzXcLve1+U7WXw23y31tvpP1V8Ptcl+b72T91XC73NfmO1l/Ndwu97X5TtZfDbfLfW2+k/VXw+1yX5vvZP3VcLvc1+Y7WX813C73tflO1l8Nt8t9bb6T9VfD7XJfm+9k/dVwu9zX5jtXfyXD7XJfm+9c/ZUMt8t9bb5z9VeyyGTznau/kuF2ua/Nd67+SibajP4+38n6q4m2dr/Pd7L+aqKN0u/znay/mmz/dpls/3aZbP92GW3/9hjKNt+8hMpL/9aDHfI2w1J+PfbOcbC+TY3jYP2gFsfR9rF/H8fzB7bIaBvk64EcrDPWAzlYy60HUgDZBuRgJkEP5GDuI+8vLVlqIFMMXwen9Jii+C80gxmVlmgG8x4t0QxmJ07Q/Dnf0R6vUJ3vYN15db5jNdGrk3U72MWDeGqwxyvU5yuTzXeszrE+37EavPp8x+ra6vMdqxWrz3es/qo638Eer1Cf71j91fN8vfMH8x23vzqe77j91fF8ZbL5jttfHc933P7qeL6D9VfJpf3gXA7mO1h/VZ3vYP1Vbb6DPV6hPt/B+qvqfAfrr6rzHay/qs5XJpvvYP1Vdb6D9VfV+U7WXw32eIX6fCfrrwZ7vMKaw7IdXGKuvLSUHc7zV6GzPzjWp8V/HeyTfziv+MVxsL5NjeNg/aAax8H6zEYc72wENi/ZDNa/NmUzWK/blM1gfXFTNoP10E3ZDNZv/xabW4S/HSz5O5vBHs3Rls3M/XaNzcw9dI3NzH1xjY3A5iWbmfviGpuZ++Iam5n74hqbmfvidd374nzQFw/2mJSmbAZ7pEpbNlP3xRU2U/fFFTZT98UVNgKbl2ym7osrbKbuiytspu6LK2zoi1+zmacv/nO+gz3epj7fefrX+3zn6Unv852nz7zPVyab71j9YFyWbSAxRHcw37F6vPp8x+rb6vMdqxerz3es/qo233Wwx9vU5ztWf1Wf71j9VX2+Y/VX9fnKZPOdq79aB3u8TX2+c/VX62CPt6nPd7L+arDH29TnO1l/Ndjjberznay/GuzxNvX5TtZfDfZ4m/p8J+uvBnsMTX2+k/VXgz3WpT7fyfqrwR6SUp/vZP3VYI8cqc93sv5qsAd41Oc7WX812KM26vOdrL8a7PkZ9flO1l8N9vyM+nwn668Ge35Gfb6T9VeDPT+jPt/J+qvBnp9Rn+9k/dVgz8+oz3ey/mqw52fU5ztZfzXY8zPq852svxrs+Rn1+U7WXw32/Iz6fCfrrwZ7fkZ9vpP1V4M9P6M+38n6q8Gen1Gf72T91WDPz6jPd7L+arDnZ9TnO1l/NdjzM+rznay/Gux5FPX5TtZfDfYsiPp8J+uvBntmQ32+k/VXgz1boT7fyfqrwZ6BUJ/vZP3VYM8qqM93sv5qsGcK1Oc7WX812N7/9flO1l8Ntkd/fb6T9VeD7aVfn+9k/dVge97X5ztZfzXY3vT1+U7WXw22h3x9vpP1V4Pt9V6f72T91WD7t9fnO1l/Ndj+7fX5TtZfDbZ/e32+k/VXk+3fvk62f/s62f7t62T7t8fJ9m+Pk+3fHifbvz1Otn97XGSy+c7VX8XJ9m+Pk+3fHifbvz1Otn97nGz/9jjZ/u1xsv3b42T7t8fJ9m+Pk+3fHkfbv13ydnBcnT+Y72D9VUi7vrcTKy+dF/k6OIeyH+tzODi25O2FS/n12DvHwfo2NY6D9YNaHEfbx16N42D9qxrHwfpiNY6D9dtqHAWOTTgO5g/UOA7mO9Q44mfacMTPtOGIn2nCcbTnRqhxxM+04YifacMRP/NDjnE79obAH4AUQLYBiaNpBBJL0wgknqYRSExNG5CjPXVjzWUDeVvhr7y0W8sStmmuxYX9+PhFZ7Bb8Qmd+3wHu2NW5zvWjS2ltB2c0lOPfvzSPsX162ifUnh+6TucsW5WjeGMdQNqDGesqKwtnMGeO9EYzljtSGM4YyVVjeGMFT81hiNTwyl+g5OfusAdzlhNb2M4c3fIFTgzd8jBL5u5Ct6n73Bm7pCrcGbukGtwBntySGM4M3fINzjLKRyZGY647eggfvkOZ+Y+pwpn5j6nCmfqPqcGZ+o+J5S8w3HL+UuvJW23trWUg6v31E3R75CMy34fjMuBMRns2SCfqcljklO3WxL2XlRW99c+3YM9z+QzJI9rcuaoM8j+VYkgJX+HI8B5DWduC1CBM7cFqMCZ2wI84KxP36La4UxtAWpwpu7qK3AGe8hMYzhT997hMZDVpfOXdrdC2pAkedocRpYvlFO3jGnfOiekEv6ajRnssTJvJFkLKQZ7YM1navKY5NSd6+Olw98t0h9cKJeyf+HbheXgQjl1n5u97ChL5aVlJyL+1zvOAfZHJOducfp+dNixT91B62GfujdXwz7Yo4+6wT61n9DDPnXwr4d9asunh13A/kPsYbOH8jzDHeTU9rAlyMF+dN72J76jPQarMZ3BNr1qSieN9oitxnTYWuCMzmDbTjWmM9hmUo3pCHRO6MyzicUVOoPt5fS7dII86Kz+ic7x0f7p6PiN5eSddVOWk/fhTVlO3rX/Bktxe54j/ulrFl8kR3vImyLJyd1AQ5KTO4eGJCd3GQ1JCiQbkZzcvTQkidNpRRKf04okLqcVSTxOI5KjPWBQkeTsHudVKnHw2nn/xUIKTz/SfvHaJW+TvGF/etjvTa87+dk9kR752T1UG/J3lgLLZixn91GnCXGjh8K5/UkEwftSoePysm1S6rJ7ZlkO6SwPOkt8pnOfQbE/A/+YwffNylKjB6FpzsB1PwPf/QxC9zMQ+zOQ+LhSV35i5mW/ZXgR+T7dda7pxrmmm+aabgd9RMvpdtB0NJyudNChtJxuB+1My+l20Pv81nR9fkz3u2GQDhqlltOVuaY7WFe1rlvP7Nf41zbaSDJYC/Y7bCpbZyQZrF9bXdjZpMo+k3nZXjjL05i/fjeWZLDeriWawfrAhmjWwXrGlmgG6y9bohmsF22JZrTO5nfQrNswcoq/oDl4YRceK5VPWyz/sR3e94Mfu28tvxx6Rz5aw9QB8pn7MCXkM/d3Sshn7ht1kMeZ+1Ed5GnmZu53kC+Px0u6p684HCLPeRtEcdVNim7vvX/9I9/02I/3JX9pNFgaOqRGgkbmNcKd2dcIO2dfI/yffY0wjPY1wmGa1yhjSe1rNPNaTS8akTPY14icwb5GgkbmNSJnsK8ROYN9jcgZ7GtEzmBfI3IG8xoVcgb7GpEz2NeInMG+RuQM9jUSNDKvETmDfY3IGexrRM5gXyNyBvsakTNY1ygv5Az2NSJnsK8ROYN9jcgZ7GskaGReI3IG+xqRM9jXiJzBvkbkDPY1Imcwr5EjZ7CvETmDfY3IGexrRM5gXyNBI/MakTPY14icwb5G5Az2NSJnsK8ROYN5jTw5g32NyBnsa0TOYF8jcgb7GgkamdeInMG+RuQM9jUiZ7CvETmDfY3IGcxr1MMD4KfXiJzBvkbkDPY1Imewr5GgkXmNyBnsa0TOYF8jcgb7GpEz2NeInMG8RkLOYF8jcgb7GpEz2NeInMG+RoJG5jUiZ7CvETmDfY3IGexrRM5gXyNyBvMareQM9jUiZ7CvETmDfY3IGexrJGhkXiNyBvsakTPY14icwb5G5Az2NSJnMK9RJGewrxE5g32NyBnsa0TOYF8jQSPzGpEz2NeInMG+RuQM9jUiZ7CvETmDeY0SOYN9jcgZ7GtEzmBfI3IG+xoJGpnXiJzBvkbkDPY1ImewrxE5g32NyBnMa5TJGexrRM5gXyNyBvsakTPY10jQyLxG5Az2NSJnsK8ROYN9jcgZ7GtEzmBeo0LOYF8jcgb7GpEz2NeInMG+RoJG5jUiZ7CvETmDfY3IGexrRM5gXyNyBusalYWcwb5G5Az2NSJnsK8ROYN9jQSNzGtEzmBfI3IG+xqRM9jXiJzBvkbkDOY1cuQM9jUiZ7CvETmDfY3IGexrJGhkXiNyBvsakTPY14icwb5G5Az2NSJnMK+RJ2ewrxE5g32NyBnsa0TOYF8jQSPzGpEz2NeInMG+RuQM9jUiZ7CvETmDeY0COYN9jcgZ7GtEzmBfI3IG+xoJGpnXiJzBvkbkDPY1ImewrxE5g32NyBnMayTkDPY1ImewrxE5g32NyBnsayRoZF4jcgb7GpEz2NeInMG+RuQM9jUiZzCv0UrOYF8jcgb7GpEz2NeInMG+RoJG5jUiZ7CvETmDfY3IGexrRM5gXyNyBvMaRXIG+xqRM9jXiJzBvkbkDPY1EjQyrxE5g32NyBnsa0TOYF8jcgb7GpEzmNcokTPY14icwb5G5Az2NSJnsK+RoJF5jcgZ7GtEzmBfI3IG+xqRM9jXiJzBvEaZnMG+RuQM9jUiZ7CvETmDfY0EjcxrRM5gXyNyBvsakTPY14icwb5G5AzmNSrkDPY1ImewrxE5g32NyBnsayRoZF4jcgb7GpEz2NeInMG+RuQM9jUiZzCuUVgWcgb7GpEz2NeInMG+RuQM9jUSNDKvETmDfY3IGexrRM5gXyNyBvsakTOY18iRM9jXiJzBvkbkDPY1Imewr5GgkXmNyBnsa0TOYF8jcgb7GpEz2NeInMG8Rp6cwb5G5Az2NSJnsK8ROYN9jQSNzGtEzmBfI3IG+xqRM9jXiJzBvkbkDOY1CuQM9jUiZ7CvETmDfY3IGexrJGhkXiNyBvsakTPY14icwb5G5Az2NSJnMK+RkDPY14icwb5G5Az2NSJnsK+RoJF5jcgZ7GtEzmBfI3IG+xqRM9jXiJzBvEYrOYN9jcgZ7GtEzmBfI3IG+xoJGpnXiJzBvkbkDPY1ImewrxE5g32NyBnMaxTJGexrRM5gXyNyBvsakTPY10jQyLxG5Az2NSJnsK8ROYN9jcgZ7GtEzmBeo0TOYF8jcgb7GpEz2NeInMG+RoJG5jUiZ7CvETmDfY3IGexrRM5gXyNyBvMaZXIG+xqRM9jXiJzBvkbkDPY1EjQyrxE5g32NyBnsa0TOYF8jcgb7GpEzmNeokDPY14icwb5G5Az2NSJnsK+RoJF5jcgZ7GtEzmBfI3IG+xqRM9jXiJzBukY35GhkXiNyBvsakTPY14icwb5GgkbmNSJnsK8ROYN9jcgZ7GtEzmBfI3IG8xo5cgb7GpEz2NeInMG+RuQM9jUSNDKvETmDfY3IGexrRM5gXyNyBvsakTOY18iTM9jXiJzBvkbkDPY1Imewr5GgkXmNyBnsa0TOYF8jcgb7GpEz2NeInMG8RjKyh83nB6e4HZvSL9TvZEZ2jn+NzMh+7a+RkQ7IuAeZymTPXvo+3x4cR8v59tC9t5xvD51wy/n20FW2nG8PHVrD+a49rKr8znzX7Tbnig+Vl76pXbaj16de8PbSdzg9tIJqcHroBtXg9NAQvguOz2lvH3MplaPDzXltk7xdf/ejN5ICyUYkR2tN9UiO1vS+kWSIZSeZ0xPJ78eK26mLd+kb9dFa7z6oj2YAfo/6Pktf3FI5Ou9zzOExRZ/DwbElb8Mo5ddj79RHsyFdUI8zmyE96jO7LD3qM9s3Pepz+0It6gJ1Bepz+00t6nN7Uy3qc3tTLep4Uw3qeFMF6glvqkEdb6pBHW/6FupxO/YGzB9gx5yqYBewa2DHnqpgx5+qYMegqmCf2qGWxyr0UsXuJO0sV/f02vloJHHZFq2jf8KX1y/uU3tUPe55apeqyH1qn6rIfWqnqsh9aquqyH3q7v2d3GU7OK7ugDv9zJu47z8HjjF/597Fw9qNcF/dPuw1yC/c7yzpUdqxpO9ox5Jeoh1LgeWP71P7QG4s18p96vb2WR5DKd++p9/FI8LHJE9PrEV+6lBblTy5thb5mZ1gWELayZfaQM5/2ea7eEB2HyRndnZtSc7s636PpHNx3aG4+LT9nHNH28Sd/6bbd/EI6THJC+SVyM/sGd9Mvtkv8H0XD3xGpZm96O+qlPz+4rclllBRyae0f30rPW1HuZGf2YvqkseLKpHv4qHLfZJv+X0J38WDl9HJd/HwZXTyXTyAGZ18Fw9hRiffxYOY0cl38RDZKXQ6/Z6m7+IBmFPodPq9Tt/FQzA71anyHTHfxcMtR2UvsFdjT6+lx541lPfdl1t+v8l38ahJlPpDKTxJL0qxTtOJUoF1nV6Uwun/WCm/rDv629KlVJTyN2W/Dr8FX09Qcj46Oi370cn7bzrh9PvQiVSgD50EnRR0urMnQdBjT4Kgx55MQI89Ll+PPb5djb3gxN/G3u9fdrgtxC4H7PHWeuzxy3rs6e/12NPnvI39KsvGfl2P2NPnqLFf6XPasL/TpHNpSZNepCVNEvaf0/Su7DT983Xzyu/sV4G8Enk6ai3y5OVvI99u14KVZL0HlfCmF1WK7qAPwm02pBnxjy1p4h9/TjPkvNMUqe6oEf2eAMbwdHQJX+xxm59hnw7Y400/wl78AXuB/dvY72PxMa6/sD8aS1z2scQnhMUdzjPtgU/OoXJ09ts0s7hfjr3XAD6ZGsCxUwPkAdQAaQM1QEYyfQ0kkh1qgDyKGiAXm6AG1u3r8HlNBzVAPjdBDch+HXgC+KgBoQZmqoEYDmqAfKDHGvBr2KD4dfUHuuL5+9T18ZSA6NYDXfHxQ+qa8eZj6orfHlNXPPSYuuKLx9RV0HVIXfE5XWYY5fHF2XKUUWd8zpC6FnzOmLric8bUFZ8zpq74nDF1FXQdUNew0DcZ0dXLuiPMa0XXEHPYjo65HOhK3zSmrvRNY+pK3zSmroKuHeoqYX8sqIQcDnTld5Bd6lr23F9Kzge68tvGznVdl+XoOsz3EcfUlXW6MXVlnW5IXR1505i6kjeNqSt505i6kjeNqaug65C6kjeNqSt505i6kjeNqSt505i6kjcNqasnbxpTV/KmMXUlbxpTV/KmMXUVdB1SV/KmMXUlbxpTV/KmMXUlbxpTV/KmIXUN+Bwjurr9aVa3xdPq7zjCrmsIR98LD4KuvetaDn7HEfA5Y+qKzxlTV3zOmLric8bUFZ8zpK7CuvqYurKuPqaurKuPqSt505i6CroOqSt505i6kjeNqSt505i6kjeNqSt505C6ruRNY+pK3jSmruRNY+pK3jSmroKuQ+pK3jSmruRNY+pK3jSkrhGf8xFdk6/omuK2YX9KD9ziv2TCtnQhEy6kC5kEmd4lU0rb4T4voSJTCXlDWGRJj6Pz4b0sl8e97OngdDSOkt0+y8WfH+zcknZx3C9Q8lfFYFc0KubOHkvxNvbZl539uhywZ9nqfeyj7OyfEW7sE3epn7Nfwz5uvyZXYV/S9hQlt7inm8Nt4Hf0XO5/jj4ubkefngd+iP72kvuN2T+73RddX96eKnp77VI72rn9VuIkVY7OZYNS3MGlL3HboQZIvagBvpE1fg2UEvaGYMm/FMH3g2PZZxmLq7jWfGsFvw7OPvpvzjLRYVNe7yuvzPfTKK83lhfLR5TXG8uLZS/K643lxXId5fXG8hLKi/J6X3kRUlNebywv8u+py+teBATgFEEmAacIMjn1+EXgFr/sVSBLpd1wJe5feCllmO/6FUKnCSr9Fv481PTfr3eFbIgqCEWogsmqoBxUAUkLVXBTmCqgCgqJCFUQCpEI3eGtMqiC6atAFr5iRxXIwjfhqAJZyA6pAlnIDqkCWYQqoAoWskOq4LbeSRVQBQupUZdV4Jd9lxTvf62Cu67kQEPq6kh2xtSVrGZMXUlfxtSVPGVMXQVdu9RV1l3XtBzoSuYxpq58A2pMXfGvQ+rq6Yf71HX/PYsPfzeSu670w13qGtb98/rLwzh2XQVdh9SVfnhMXemHx9SV1doxdWX9dUxd8a9D6hpYfx1TV9Zfu9RVwvb9Ji85VI6Osj1jJcbH2k+IR7PM64Yk5/LLsfd6IceiXn6nXsjHqJffqRehXqiXp2PL40luiyuVg9dbcWzauCyVo2MMyz6O4A6KkbCQYjRTjCScFKOZYiSWpRjNFCNZMsVophgJwClGK8UopPYUo5liZKmBYjRTjKxjUIxmipFFEorRTDEKxUgxWilGVmAoRjPFyAoMxWimGFmBoRjNFCMrMBSjmWJkBYZitFKMKyswFKOZYmQFhmL8UDGmsFdJuhE5KEZWYChGM8XICgzFaKYYyRkpxo8VY173YnzC/ShGoh2K8VPFKH6/Mt7G/70YIwaGYjRTjEIxUowfKsa8bkBSjkfFyBclKMbrxSj79vCruOWgvLAklNcby4svM1BebywvPCzldb280h6RrHk5WFaLfOGA8npfeSW+QkB5/YXyisteXr7mM11Y/K5OWP7OaR4Bf0h/+zu62vHrujN0a1wObtYJJ0u52y33fZZ/lHttNE7yug9ecjpYX8lCuVPunyp35/cXD249uPpmrr6Uo6FyJHekHA2VIzkl5WioHMk1Kce/UI7P2qSD8iLXpLzeV16FXJPyemN58V1ByuuN5cXPlyivN5YXP0iivN5YXkJ5UV7vKy9yMsrrenmV/Rlha8nrQXmRe1Febywvci/K623ltS7kXpTX5fKKy/510ehcOigvci/K643lRe5Feb2xvMi9KK83lpdQXpTX+8qLb89SXm8sL74NS3m9sbxI7Smv95WXE8qL8rpcXk7SXl4HOyCtjt6L8npjedF7UV5vLC96L8rrjeXFNyYorzeWF9+YoLzeV16eb0xQXn+hvPajo/+7n9F+Pzp72aok++gfg85ftcjXK6hFK7XIdzGoRSu1yBc3qEUrtSjUIrVopBZZlqAWrdQiaxjU4odq0cV1f8DN7e+nanzEOqx5UI6GypE1EsrRUDmypkI52inHwBoM5fi5ckzuUY75qByJGynHj5VjzLKXY1oOvtschHKkHD9Vjsk/btZJ4kE5EjpSjobKkdyRcjRUjuSOlKOhciR3pBwNlSO5I+VopxyF3JFyNFSOfP2bcvxcOeb4KMcn4I9y5BvglKOhcmRVhnI0VI5COVKOnyrHvCx7OWbnDsqRVRnK0VA5sipDORoqR1ZlKMfP9Y5PXzDLzteO9w/pb39HVzt+XfMeJK1rKQflzqoP5T5RubOqRLnPU+4rq1aU+0TlzqoY5T5RubPqRrlPVO6s6lHuE5W7UO6U+zzlzqok5T5Que/LTGtcloNyZ9WTcrdb7vss/yj32mic5IdA8vev/2e5R5IZyn2ccl/zo9zTwTf+IskM5T5RuZPMUO4TlbtQ7pT7POXONyIp98+V+/r0a5p4VI58Y5FyNFSOfKOQcrRTjolv/FGOhsqR3JdyNFSO5LKUo6FyJDelHA2Vo1COlKOdcuQbYZTjx8ox77xvf68Hz1ZIfGOLcjRUjqzKUI6GypFVGcrRUDmyKkM52inHTAxOOX6sHMvjxyqxRDkoR2JwytFQORL0UI6fK8f4uFmXVL6XY+ErFJTjp8oxebc/0/X293pQjiwSUo6fK8c1PMoxH/xwuQjlSDleLke/pr0cc/oLR9+Lkc6RYjRTjCwQUowfKkaX4+NnXre/D1x1YYGQcjRUjiwQUo6GypEFQsrRTDnGhcyRcjRUjqxXU46GypH1asrRUDmyIkM5GipHoRwpRzvlyJoM5fixckzuIXxa3UE5sipDORoqR1ZlKEdD5ciqDOVoqBxZlaEc7ZSjY1WGcjRUjqzKUI6GypFVGcrRUDmyKkM5GipHckfK8WPlmJf98ao5u+WgHHHWlOPHyrE8XR1LOLg6epy1kXJMIns5yq9H35XCdPaiFH6sF6WwKr0oJSjViVJ87agXpXDGVpRKDyuS3IFSfFmlF6X4HkcvShHEdKJUIKPoRSkyil6UEpQyolR5dOklHihF72dEqSxbUu/zGg6UovfrRSl6vzZK/UlT6M9a0qSHakmTtZiWNFkvaUlToNmQJusOP6dZ/P41JV9KqvRTcXlsXf0EMK9f5FlH0CKPN9Qij9fTIo93UyK/4vO0yNN3v438/iWJ+PTrgQd5epu3kY+PL0nnA/L0Nj8mH0LyOxRZfYW8uw1m3zzK5fT4mUI8XKFYthf3yfunY+860Qn1oRN9Uxc6RbosDZ3u7Mne9diT1Ouxx1/osRfYq7FnzUCPPc76jez33zY7VxZ32o8Wl7aRF/f0m+JNJ3x4Hzrhw7vQKeEx+tBJ0MmGTn7PS4r3+ZtO9HB96ES/14dO9HttdLrTpCtrSZM1jIY0MysNLWnS17ekyWpAS5rk+z+nuboHzfUpt3zQFGg2pIl/a0kTl9WSJl6oJU28UEuaeKGGNAteqCVNvFBLmnihljTxQi1pCjQb0sQL/Zzm7Z69Q0nuV5oHr+7L9hOrENzjcdlfqx4F36RFHo+lRR4/9jbyt+N38r98t+T7seJ2lcS7b99DKfg8+yqlBf94USX/vQ9KC/7xN2jm8kQzHtDEP/6cZgruQXN1f+kOmxa8phZ5gbwSeTzs28g37Ffwuz2ohDe+qFJ0B30Qfvd3usr8RNMf0MSX/pimLGkftzj5a7tB3Xwt5JXI40u1yONhtcjjYbXIC+SVyNN3v4386X6LieeRv4/86X6LieeL/wb5EPYVDAl/99Sm78f7lLZXv/3597+4TDwvXI08vY0WeYH8m8i7FMM+zxTlO3sSej325O567Onq9diTvaux56m8b2SfHrsc3v4u39gL7N/HPuUH+xy/safP+Tl7ebCU1csv7O806Vxa0qQXaUmT7qIlTVb2G9Lk6chNadLLtqRJ8tySJmlyS5oCzR/TjLL/BkRiDr/Q/N3j7/TxTpr08Vqa9PFm76J/A7EN3Ifl6RsLuXyxx8npscf3qbHn2cqK7PGUH2Hv/AF7HKgee/yqHnuB/bvYhz1a8KGsv7A/OPr0abxpxQf3oROOuQ+d8NYaOt3Z46312OOt1dhHvLUee7y1Hnu8tR57vPXb2K+yTdOvz/u87OwF9mrs8ct67PHAeuzp79XYJ/qcd7G/rZf5/dWfj97Z0+fosZeZ2QfZ2d8uv5WjS9zmeIPwCCX9Desd5dRtS1uUU3chbVFOHZb/FsqnXdD/+OHf06XVfbGcOvxuzHLqZrcty7kfwt6Y5dRhc2OWU5uqxiynNkmNWQosm7HE9bRjie1pxxLf044lvqcdS3xPM5ZzP3C9MUt8TzuW+J52LPE97VgKLJuxxPe0Y4nvaccS39OOJb6nHUt8TyuWee4Hhf8WS1nctreuOJEDlviedizxPe1Y4nt+zNKlsrMsyy8sD1779NHTeRG4q3DHT+lwx3u9iXuzR3jnuR/h3YlGeMUfa+TD3vv4p8d6HWskuWyvLcX7ytFr2l56LU/48pdImFD7Is39aPJeRMI2dyASfrwDkTD6bxKprA+RYvkescz9bHRV8pj9d5Ev+7Vm8QexosPuv42838lLPiCPiX8b+X3YyxoPyGPNtcjjt5XIe0z0j8mHfbdRCX/H8veOvpPHGWuRx+5qkcfDvoe8k7Rv77C65/1bjsYdl22FIvqnV87rl0qCSh2ohDfuQSV8dA8q4bl7UAl/3oFKAV9jQiXZDo6rO1BJUMmCSnF76RjzgUr0eG9SaXX7JNcgv6h0J0/fpkWeXkyLPP2VFnnWP951N96HfSO/Vu7Gt8FmeQy8fPvyrrBa0odOeJA+dGIlpg+dWLfpQyeZWqe8HR3Er78cfacztbPI+3ctQ1nkO5115t5G3H60uBIP6Mx8BbxdpPbvHCW3HNCZ+bpTpzNzilenM3PSJunxbb68LJWj8z7HW2KwH/vHIzy+H1v2m2Epvx57pz7zvVCP+swJmx71mdM1NepTPwlbj/rMyZce9ZlzLD3qU3syNeoCdQXqU3tINep4Uw3qeFMN6nhTDep4UwXqCW/6FurnzxjOCXOqgh13qoIde6qCXcCugR2DqoJ9aq9U+9ZGmtrTVOlM7T1qdPLUHsHvsxQv+YDO1K18lc7UHXeVztSNcZWOQOeEztRtZpXO1OsVYd2GLfLUKx8fHeO+i0F+NOzef+1UNfVj4duSnLoHb0py6n795HvEB7Z533fdufL00usXyqmfCN8Y5dS/4av9qmbux5JX6Qh0TuhMvftL2fdMuE2ydrRL253TL49jjyPVhuvIcz+QvAuFpv7NZxcKTb3rjA2FKotMcz+TvQeJytyPeu9Doqk3pelDoqm9bB8STW2o+5BIppZo3/9VnNTCNZ/CtluQT8+PoV7SoUjrFtzdWMovR9/Jz50YaJKfOwnQJD+3w38jebdvIZ69iwfk53bumuTnNuSK5Od+6Lwq+bntsyb5uV2xJvm5za4meYG8Enk8rBZ5PKwWeTysFnk8rBZ5PKwS+bmf+a5KHg+rRR4Pq0UeD6tFXiCvRB4Pq0UeD6tFHg+rRR4Pq0UeD/sm8nGfZE7Zfycf8LBa5PGwWuTxsG8if6O2kS/ZHZDHw2qRF8grkcfDapHHw2qRx8NqkcfDapHHwyqRFzysFnk8rBZ5PKwWeTysFnmB/FvIl8UvX0eXJawH5PGwWuTxsFrk8bBa5PGwWuTxsErkVzysFnk8rBZ5PKwWeTzsu8inspH/8/W+kRfIK5HHw2qRx8NqkcfDapHHw2qRx8MqkY94WC3yeFgt8nhYLfJ42J+SD49n9AafY4W8S4+RpCjPw76DF8DrgMfBKoHHwCqBx78qgce+KoHHveqAT5hXJfB41zeBL2U72i9LZdhxWbYlw7i4A5XwuQZUWstuio9VwhO/S6X9GbN+Cf582LLTFv/083NZDq+OxT0uj8U/hu1L/hJVEHU8UfHyA4pKTjCgqGQQA4pKvjGgqGQn44mayWUGFJXMZ0BRiYgGFJVEaUBRBVHHE5VEaUBRSZQGFJVEaUBRSZQGFJVEaTxRC4nSgKKSKA0oKonSgKKSKA0oqiDqeKKSKA0oKonSgKKSKA0oKonSgKKSKI0mqiwLidKAopIoDSgqidKAopIoDSiqIOp4opIoDSgqidKAopIoDSgqidKAopIojSeqI1EaUFQSpQFFJVEaUFQSpQFFFUQdT1QSpQFFJVEaUFQSpQFFJVEaUFQSpfFE9SRKA4pKojSgqCRKA4pKojSgqIKo44lKojSgqCRKA4pKojSgqCRKA4pKojSeqIFEaUBRSZQGFJVEaUBRSZQsiBq2xyZKyr+IehdJEMm+SCQ+7xHJu32S3j2N5P64yht4Uhkl8CQnSuBJN5TAk0C8C3wIO/hSGrbAoeRtiuLcfnTYbttC/jCcpKQPw0lK9jCcpCQPw0kqSDqapKQaw0lKXjKcpCQxFiQ9D4iF1Ma+SOvUcUDIO3bx6y9H3+lM7ayrdKY2qVU6U/s9CQ86KVaOdmm73d9WJfdjfQ4Hx+adRw6lcmzZJSrl12PvCgkKGVdoajfWhUJTmysbCsXt2BtcfyDR1GapD4mmtkp9SDT1UngXEsWpvWwfEk1tqPuQaGpXfyLRnQ6u/oyOQOeEztxuNm+zDFlc7eLn836VCkEeR7tDJLcAbicv8Zej7+Tndqma5Oc2n5rk5/aUbyS/7j8yC2teDsjPbRUVyae5HaAm+bmNnSb5uf2aJvm5vaAmeYG8Enk8rBZ5PKwWeTysFnk8rBZ5PKwS+YyH1SKPh9Uij4fVIo+H1SIvkFcij4fVIo+H1SKPh9Uij4fVIo+HVSJf8LBvIl/C/jP6peQD8nhYLfJ4WC3yeNj3kBf/IO9Xf0BeIK9EHg+rRR4Pq0UeD6tFHg+rRR4Pq0P+BhLySuTxsFrk8bDvIp/KRj78HfnfO/quE463D50EnbrQCTdtQScn+6aZbnVP485Hs4zLtkFC9E/S5PVLU3z6eJqSAIynKdnCeJqSWgynqSMPGU9TfGSHmsp2cFzdgab0vR1qGv2macwHmtL3mtB0dTuS9fm1c/zSiV62D53oT7vQydNz/nMXOrFiZ0In2Sd502mt9By3qT2GUnxJ+/GbqqwGjqgqnm9EVQVVB1SVdckRVSWh+bGq4UE+Pm2D/0Knk6Pv5MlRtMiTjGiRJ+t4D3nvl+3Rql7CwbeKAumFFnnyCC3yZAZa5PH1WuQF8krk8cda5PGwWuTxsFrk8bBa5PGwSuQFD6tFHg+rRR4Pq0UeD6tFXiCvRB4Pq0UeD6tFHg+rRR4P+ybyq9+O9uvRHgOCh30TeQllJx+XytF555fDA5/P4eDYkrcplvLrsX8quuKNR1MUzz2aonj50RQlIxhNUUHRwRQl0xhNUbKS0RQlgxlNUbKd0RQlMxpM0UhmNJqiZEajKUpmNJqiZEbdKRr331Aviz+QVJB0NElJjYaTlNhoOEnJjYaTlOBoNEkTrvRNkq4x7ZKW+s6JZQnbi6/laR/gr72A0jw9z32+8zQE9/kOdrcsYS/nIlJ5aZ/iNhCfUnh+6Tucwe47beEMlv03hZMHi9Hbwhns3t8WzmDhbls4g+WkbeEIcF7DGayP/U04ZXt8h89OvsMZrOltC2fuDrkCZ+YOOfilPIadvsOZuUOuwSkzd8hVODN3yFU4M3fI4fED2mM4M/c5t6B0e+kgfvkOZ+Y+pwpn5j6nCmfqPqcGZ+o+J5S8w3HL+UuvZX+sw1rKt6v37doOyZ+RjMt+H4zLd2Pil6k7qIs1eUxy6nbrsUAe5Olpttc+3TOnl1dJHtekTE0yxZ1kyd/hzG0BKnDmtgAVOHNbgAqcuS3AA8769H2uHc7UFqACx03d1dfgTN2o1+BM3XsHv39LcnWp8tIxb37QJXn62qMsXyhlZpQp7wlOKuGv2Rg3dX/5OyRrIYWbuhm9WJPHJKfuXB8vHf5ukf7gpZeyv7QLy8GFcuo+N/t92LlUXlp2IuJ/veMcDOMRyblbnL4fHXbsU3fQatj91L25Hvapu3497FP7CT3sUwf/etgF7BrYp/aHv4U9bPZQUv7eifup7WFLkPx+/Auk6R8b36CiUw86BTYJ7EMnNlkwolOQh05PD9+JL472T0fHb6qy/d+IqrIF4IiqCqp2p+ofX/ff7fDTwvOmKdsAjqcp+wCOpykbAY6nKUnOeJqS+gynqZAQjacpadJ4mpIljacpSdJ4mgqaDqcpOdJ4mpIjWdH0VS5/8No57L/Ccs/iHL922Wd5K4CnWd4q514D5E7UADnVWDVwV5WkakBVV7Iq66redcLX/lgnn/eWNgSpkBe//7hSwlrVSdKjXX76zpnLhz+Ble3g+LTpz23uX5oKmvanadr4xZuO3zXF146nKb52PE3xqeNpiu/sUVO3axoPNMV1DqdpxHOOpynfj+hQ07hlDjHmA035fsR4mpIjjaepoOlwmpIjjacpOdJ4mpIjjacpOdJwmqap/WmQXdOQYuVoCYt/qPT8nQH311U6XxFNUztOOyqd5+xpag/ZjUqCSh2oNLXP60alqZ2bIZVO1yDS1F6sG5WmdlfdqDT1ursdlc5dbZ56Jb0blcgeelCJ7KEHlcgeelBJUKkDlcgeelCJ7KEHlab2S0vYVVpKbSBOomzLgLe/8/MvKf3B8X7N264Ttz+foNz+/pN9mdoFKbOf2tsos5/asSizn9qHKLMX2Kuxn9ozvJd92rfiui3eLwfsp3YCyuynXltUZj/1iqEye3ytFvtbmAH7d7GPZRv47c9wwJ4+523sc94Ov0U36wF7+px3sb9dUx6v7ssBe/ocPfb0OXrs6XPexz75/dXzr/fa3zv6T6UcaX8vSrE2YEOpmNf9Z1f5acfm+KUTPqMPnVhz6EMnQScbOpUdSiw+fdMJj9+HTuQBfehEdtCHTuQMfehEJtGFTp5Eog+dyCOs6PTYBqas33Uij+hDJ/KIPnQSdOpCJ/KIPnQij+hDJ/IIDZ3+ZB/wRO9iX/3uWsDn6LHHu+ixx4+8jf0v31WWA/YCezX2+AY99ngBPfb09+9j7x/sQ82HBV+2X43emk/5ex8WWG/sQyfWG7vQSfDWRnQKsew65ef86XeOvWuKZx9PU7KA8TQlY+hPU3H7/VS8+66poOlwmpKJjKcpWYuGpnf2ZC3vYx/Tzj7lA/bkJ+9jn/c1pVTKAXsykY/U/RH7lZxDjz15hB57gf272Od1m+btzyP2+AY99vT3euzp7/XY09+/j734U/aRPud97Cv7/EXWR/TYs46hx15gr8aeHlOPPVnaz9mHsOzsb1Qq7F1Ka9iOv/39wPK1dpLI0vTY02PqsafHfCP7lB/sn54ivrGnx9RjL7BXY0+GrMee/l6PPRmyHnsyZD32+Fo19hlfq8ee/v7n7Je0j1ucpAr7+NjYZnVPSdr6RV4g/y7y+9Exrwfk6e21yNPZa5Gnr9ciT1f/PvJuJx8PyNPTK5EvdPRa5Fmnehv5uH0NLcZ8QJ5VKi3yeFgt8gJ5JfJ4WC3yeFgt8nhYLfJ4WC3yeFgd8rLQz/+YfAj7VvIuyOor5J3LeV/FcmV5fvrq96OLS9vIi/u2m5MsdP996CToZEMn7zYoxfvvOuEs+tAJH9KHTriWPnTC41jRKbhdp1C+6YQj6kInxxpgHzqxYtiHTuQRfehEHtGHToJORnRa/KMvz990Io/oQyfyiD50Io/oQyfyiD50Io/oQidPHtGHTuQRfehEHtGHTuQRfeiEf/qxTr74fVdDX8pf+yW2eBzR28if/jZSPB5HizyuRYl8wIdokcdZvI/82a9SJeAVtMjT/WuRF8i/i/z5LzcCK4Za5PGwWuTxsFrk8bBa5PGwSuQFD6tFHg+rRV4g/2PycXE7+fQ88EPyt5d0O5S4Vo72qTyec/93O+DelaL/N6JU9tvymM8hHyiFX+hFKfxFL0rhR6wotRP32aUDpfAvnSi14nd6UQp/1ItSrAn2ohRriL0oJSjViVJkFL0oRUbRi1JkFL0oRUZhRan9Bw+3Pw/SpJWMohOlIhlFL0qRUfSiFBmFFaX2kd+UKgdKkVH0opSgVCdKkVFYUUryrtQaDpQio+hFKTKKXpQio+hFKTKKTpRKZBS9KEVG0YtSZBS9KIWfMqJU3Ldtur12qR0tIWxHSw6Vo6M8fkXyWPkK8WiWJW8F45anYRwfHP26AYw+1176j52p9h+/5OyWX46/lyOmkXL8XDnKQ/jnq+OjHHHGlKOhcsT+U46GypGMg3LUKcfov5djJsihHD9YjvIox7TWXr3svGN5/vZhPjg4+/21s3+q9NvB90InB6PQ/3WGQidGpNCnKHS+KUahT1HoQqFT6DMUOutqFPoUhc6KHYU+RaGzFkihT1HorDJS6B8r9OJ3gLe/4y/H/1mOhbSbcvzcdbc8vqFWloNvqBWhHCnHj10d3UP4EtxBOdKVUo6Gro70jpSjTu8YjsqRb6hRjmbKcV34hhrlaKgccdaUo6Fy5NtelOPnyjE8AvYiclCOfCeLcjRUjkI5Uo52ypHvN1GOhsqRbyFRjobKkVUZytFQObIqQzl+rhwra9brwqoM5WinHB2rMpSjoXJkVYZyNFSOrMpQjobKkVUZytFQOQrlSDnaKUdWZShHQ+XIqgzlaKgcyR0px+vl6Pajb5W51Mox+bC/eLpN4Xs5enJHytFQOZI7Uo6fK8cYHuWYykE5kjtSjobKkdyRcjRUjkI5Uo52ypHckXL8WDmGZVcn3QrloBzJHSlHQ+XIt8EpR0PlyLfBKcfPlaM8leO6HpQjqzKUo51yDKzKUI6GypFVGcrRUDmyKkM5GipHVmUoR0PlKJQj5WinHFmVoRw/V47huRzjQTmyKkM5GipHVmUoR0PlyKoM5fi5ctzn+Mff5aAcWZWhHO2Uo7AqQzkaKkdWZShHQ+XIqgzlaKgcWZWhHA2Vo1COlKOdcmRVhnL8XDmmp3IsB0/dElZlKEdD5ciqDOVoqBxZlaEcP1aO4vYHeSTxB3v0CKsylKOdclxZlaEcDZUjqzKUo6FyZFWGcjRUjqzKUI6GylEoR8rRTjmyKkM5fq4cl+dyPHhi68qqDOVoqBxZlaEcDZUjqzKU48fK0efH7rcS1trxEtx+vBxuwLeyikP52i3fsD7Kd3XV4/O6D15yyt/LPbJKRLnbLfdVHuUeD5KByKoS5dvH1fqwfFmFonw7Ll9WrSjfjstXKF/Kt9/yZVWM8rVbvik+yrf4BkkFq26Uu91yL4+r9W2J5KB8WaWjfLu4Wh+XL6t6lG/H5cuqHuXbb/kmVuko347Ll1U6ytds+YpLj/IN4a8nFYlVPcrdbrmHp6u1HDyZJLGqR/n2cbU+LF+hfCnffsuXVT3Kt+PyZZWO8u24fFmlo3xNlO+9HFl1oxwNlSOraJSjnXLMrIpRjp8rx/VRjj4fbEecWeWiHA2VI6tQlKOhcmRViXI0VI5COVKOdsqRVR/K0VA5sopDORoqR1ZlKEdD5ciqDOVopxwLuSPl+KlyjCXuVRVLKgflSO5IOX7s6rg8hL/9HQ/KkdyRcjRUjkI5Uo52ypHckXL8XO9Ylqdy9AflSO5IORoqR3JHytFQOZI7Uo6GypFvg1OOZsoxLnwbnHI0VI6sylCOhsqRVRnK0VA5sipDORoqR3JHyvFyOa634ti0cVkqRyeJ22vf/iwHxUjqSDGaKUYyR4rRTDGSOFKMnyrG6DbdU/TpezE68kaK0UwxkjZSjGaKkayRYjRTjCSNFKOZYiRnpBg/VYxr3qokreUg9Ha4aYrxU8WYyjbolIP7XoweN00xmilG3DTFaKYYcdMUo5lixE1TjGaKUShGivFDxZhXtxdjDAfFyC+pKUYzxUjOSDGaKUa+z0gxmilGvs9IMZopRlZgKEYrxRhYgaEYzRQjKzAUo5liZAWGYjRTjOSMFOOnivH5+4xHKzCBnJFiNFOM5IwUo5liJGekGM0UIzkjxfixYoz7t3Ziyt+LUYRipBg/VIxp55eSk4NixE1TjGaKETdNMZopRtw0xfixnrGkRzGuB8WIm6YYzRQjbppitFKMK2vTFOPHesb9UdS3Pw96xpVfB1KMHyvGp18HulA52kle96FIPsolV6F4Kd4PFW92cS/eoxWblVySYtS4kh4WI7kkxWimGMklKUYzxUguSTGaKUZySYrRSjFGfk1IMZopRnLJLovRy4bQ+7T8cvRdV0HXHnUNfnttHyQc6Er6NaauBElj6kom0+f9NT90/buR3HUl3hhTV5KCIXVNmO4xdWU3nDF15ct7Y+pK3jSmroKuQ+pK3jSmrvjXn+u6rA9dbzOusl/yns37p2w+5y/2eEw19hkfqMcer/Y+9rIvTvs1/ML+YCy+bEqF8PQL5/ilE96rD53wUkZ0CrHsOuX0pNPvHHvXVNB0OE3xUONpynp9f5qK2++n4t13TVmrH09Tco7xNCU/eZum4fG90pCWiqZr2gpgLU8Av+x+IWrpQiZSmS5kIpTpQiYymS5kEmR6l0zyWHqU51c/lOnWJWxH3+5E6Vmo7wdnLxvv7KP/ripBy4iqErWMqCphy4iqEreMqCqBy3iqpoV8ZkRViXNGVFVQ9V2qrn5fxlj9+ouqd/Z0qu9jL/uXmtf1+1cGk+Me9T72++F+jfmAPXcSPfak/XrsifA1rvdX7g6CUp0oRTJvQ6mY1w1hzOmxIVz80omsvQ+d8CR96EQebkSnskOJxadvOpFwd6GTJw/oQyeygz50ImfoQycyiT50EnTqQifyCCs67QufsazfdSKP6EMn8og+dCKP6EMn8ogudArkEX3oRB6hodOdvcD+p+zdrePdXtyVpfaUKSdpg+JW9/wT/KORx8dHZHVPx65fOuGJjOiUduua1wOd8ER96IQn6kMnPFEfOuGJrOi0/7Ahx+86CZ6oD53wRH3oxBqtEZ3i45m++UAn1mj70EnQqQudyCP60Ik8og+dyCP60Ik8og+dyCO60Gmd2T/58th2eXFLTaeW60nrzH7ordzPc9JV4K7CfWa/osl9Zv+hyX1mP/Fe7qd58DqzP9DkPnO/r8g9zrye+Fbu574pzrw+qMkdv6rDHb+qw13grsIdv6rDHb+qwx2/qsI9HXNP+8Pin5YDfA4Hb5B35DmUyrElb1RK+fXY+2CypcEUQ4PJi6XBOEuD8ZYGEywNRiwNZrU0mGhpMJauwNnSFTh/9goc97vqsvjvoymLqdE4U6PxpkYTTI1GTI3m+Gojpewt5erPe9u8bJ/aLE8ttixf75Df/g7lze+QXzx9p+U7uLe/g3/7O4S//g7r5sByir+8w4FLWspmZbxbHkfL0ZeUct6eG1Kcr73wzVluLyzLYzE17BOVWSa6zjLROMtE69f79MtE72flS2eVK2e58O7rlJO3v8P69neIb3+H9PZ3yG9/hzLJx9ovs0zUzTJRP8tEw5W7hJdLZ61Xzjreayf4slm2ENxj46XtpHjlpHTlpMPLaAiPNYSQn/fY+sffOPb+BuXNb3C8CUHLN3B/9Q3E7RqId9/fwL/7DcKb32A91MDfFoS2T+9tOebbSe7KSf7KSS+uEr+z9HU74uvg9Xkt8GvpK7/4Kn7Tt1jf/xbx/W+Rmr6FLAdvkd//FuXtb/Hiy5BN38L99beIy3ZhiD4evIV//1uE97+FvP8t1ve/RXz/W6T3v0V+/1uUt79FWt7/Fu//dKf3f7rT+z/d6f2f7vT+T3d6/6c7vf/TnVt8Lk5/rZpzi4o6/SJUfvFtidXtXxFbg/zyFvfT1munxWunpWunvbj+7l9ou522VvC54vNOu/jyzVC8WK1v+yYvFuEbv4n7xJv4T7zJ+vaPZmlxDTv9LWMu6f1vkd//FuXdb1GW5f1v4d7/Fv79b9HifnL6w7iyyPvfYn3/W8R333jLkt7/Fvn9b1He/hZuef9buPe/hX//W4T3v4W8/y0Oi3Zdt9R0zc+dnv86qVw46XgxsXbScaksaZ/VH3+Xv+tIyotlriWVvYVdbovd304L106Ta6et1047vlguOYTHaU8P4dhOS9dOy9dOK5dOCy90K4/HkSwlum+nvSBZ8vZYEueW5RvJF09RqJ6Wrp1WLs3txVba1dNefHBKCU+DXL+d5q+dFq6dJtdOW6+dFq+dlq6ddvzBuR1aHqf55yr5x9+vqRf7z7V9k+M1vNZv4v76m5yvRZYXm8A1fYvw/reQ332L+2nrtdPitdOuXSJfrM9VTyuXTovLtdPctdP8tdPCtdPk2mnXbqTx2o30xVJHWvcLa0rPP1M9+rT4tOzfMEref3sL9/638O9/i/D+t5D3v8X6/reI73+L9P63yO9/i/L2t8jv/3Tn93+68/s/3fn9n+78/k93fv+nO7//053f/+nO7/905/d/ustvf7rvp7lrp/lrp4Vrp8m109Zrp8Vrp6Vrp+Vrp5ULp63Lslw7zV07zV87LVw7Ta6dtl47LV47LV07LV877VqVuGtV4q5VibtWJe5albhrVeKuVYm7ViXuWpW4a1XirlWJv1Yl/lqV+GtV4q9Vib9WJf5alfhrVeKvVYm/ViX+WpWEa1USrlVJuFYl4VqVhGtVEq5VSbhWJeFalYRrVRKuVYlcqxK5ViVyrUrkWpXItSqRa1Ui16pErlWJXKsSuVYl67UqWa9VyXqtStZrVbJeq5L1WpWs16pkvVYl67UqWa9VSbxWJfFalcRrVRKvVUm8ViXxWpXEa1USr1VJvFYl8VqVpGtVkq5VSbpWJelalaRrVZKuVUm6ViXpWpWka1WSrlVJvlYl+VqV5GtVkq9VSb5WJflaleRrVZKvVUm+ViX5WpWUa1VSrlVJuVYl5VqVlGtVUq5VSblWJeValZRrVXIte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV/ciey37NwxdEXdw2osq2bf0c6X4X0472sq30YNCbsMppobzKivWGo6zNRxvazjB1nDE1nBWW8OJtoaTbA3H1lU527oqF1tX5WLrqlxsXZWLratysXVVLrauyuXTV+XTZ1zdxpOMjScbG08xNR6/LMbG44yN53gD9Vtj/3Wa926tjOeWBzyepBzT3+9ecHuT8Ik3kU+8ydrkTUJ8vEkMT29y8Iu8HLaNgcLyvO/Tcryd6rLvubaEx2/vi/8afzQ+/nXnH9cQvo8/dT7+3Pn4S9/jP/7iQ0fjd52P33c+/tD5+KXz8Vu//9bG3/n913V+/3Wd339d5/df3/n913d+//Wd33995/df3/n913d+//Wd33995/df3/n913d+/w2d339D5/ff0Pn9N3R+/w2d339D5/ff0Pn9N3R+/w2d339D5/df6fz+K53ff6Xz+690fv+Vzu+/0vn9Vzq//0rn91/p/P4rnd9/187vv2vn99+18/vv2vn9d+38/rt2fv9dO7//rp3ff9fO779r5/ff2Pn9N3Z+/42d339j5/ff2Pn9N3Z+/42d339j5/ff2Pn9N3Z+/02d339T5/ff1Pn9N3V+/02d339T5/ff1Pn9N3V+/02d339T5/ff3Pn9N3d+/82d339z5/ff3Pn9N3d+/82d339z5/ff3Pn9N3d+/y2d339L5/ff0vn9t3R+/y2d339L5/ff0vn9t3R+/y2d339L3/ffsPR9/w1L3/ffsPR9/w1L3/ffsPR9/w3m97+qjb/v+2/ofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1Xo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","names":["sync_notes"],"brillig_names":["sync_notes"]},{"name":"withdraw_public","hash":"16601576353969289929","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1bzW8bRRSftdd2/JE4KSCQ+A84+TN2DqBUTUtB4kOtEGfHXkuRQlulaaFISHuDP4AbN8QdcYBrkLj2xA0h8bfQbfbZP//8drKb7DhplZGiHWdmfu9j3rz3ZmbXM6el+OLPi+s+PbFIn9342bpYaeeI1XLJp/eK8Fl4RfgsOuJzwWgjpiOFFE1yEcH+iyvV+HcB2nNktl0lunniD1u9/aoiX478d6sxZskNfk/wy27wW5UY58Nwjo+yCF2xmbvhXJd3acx6XPfmXWa40lYwy+PXQS4pH1Eb2vHHcdvai79NM6+/FderxIcLm0JZ8p6TNxT+CyBbVG6Fc30I3W5ru9cLBp2g3W2PWp2d/WG/1evvbw/bw3Z/2J90ht1uMOwNBzv7O4PWTrvXDdrT/k53GtMV7L3QjVyCfxvwjcnfl9xxw3+7bk7tbBgz3jBz+xs9/eqzR+OHk+DmZHIUPH6Ma4DXlK1kwSxnwHyHMT99cnh4MD0Ijm5/c/D4eAm7omBLvWB02Zgv7IelRDTejZ+Rbj9wrNsmY94PHkyCo/OqVlzBGvTPe8lEmDU3+F1xMxgmi4pMQl/ccYX0pT0Fi9uEVs0sm1qey9UmG/IvZrpJ/VkHSVjVjFhVpc3FnK5Z5Eb6TUXWCsmtYa1Z5K6sXu624Ncd67Wm6AJlEvrrip6yrhWhVTNO/UzbJpttntEvoQ6SsGoZsa6q/9N41eQor0aOfeGrbpaLtDXgf3vhYts68FWhcRsw7g6Na8I41BcX3nKiLqJxN705LvdjOTA2N6gNbVCwNP/GtprVv9n8uqM5nvm3hhv82VqoK7qoWXR+Ef8mtFbl3zTZbPOMsQR1kIRVz4h1mTELdc0xS+NVk8NbjRxjzYcZ4hl9WJnaNqCtSm1NwGL/tgnjsvo30UVW/4brY53a0AZFJvFv6BfZVstmkVf+ny0WlxPGeWZ5K8j/K5pFmZCWyFYMl/mWOfKhLU9/EM3JIcwJ2kVUSuFiG67rctymrQfRTdMszyXHHPaNSXraTBh/FlZBwdJ0jrlWVHxoc61z9Evn1bmsvSbJra2DQko9aesAj+CQrqs47zomaDkvysQxgde69jQm3Z7f1XWCTTbbPPOeVOpJWGn3/IK1qj1/0SK3Fvs0XjU5fJLjqsR5j9owzvOeLW2cR31xyTPOo51xnEfdc5x3HVOqyrjd+Nk6Z+n1B/3pqNux+eGiwudlx6tfHMQrj+qaf9HOSZpm2W74nMTRuuzY7Es7+2qY+dzNjtpvjQ4PDZUS/cZ7Lf7tmeW7hgIoiZVbTKChFelfMMsLPxLmzbg+vzd4Mh6/uIu49fDRM49wkAej1Bn7bca+Fxw/OXowGR2P7h98GzBMIQFeu9YX22S1IavaPhb7s/1hTiRjHZ9NdGxrBW1e6J+h1mjWOJ0pgrhs1jVo4zGaxfDN1164OK5gwcP6VTvy0Sw7zbGOo7cjZuleQ+FfM+FNRR7eImhYjYxYWohnOkWgYQuBJbPoVU7iZ7TV/COua6lBiehprtuWGvB4rGvL0OYytBTU8XFp6pAl9NXb4XvB0+Do2FA5y3WgumxLXXMd0bSeQD/E841uKnvh6ZNN5a/46fqFlRuAy3JnucjX3ItWNLPiG8usO/2Kwvuqdvqud4UlRRdaFpnHTl9orWqnr8lmm2cORVJPwiplxHL8QmDqnb7QX7fwanP1juXY0U5dDfGMu6C9cLENsz6+scRwzTt9PD3IutMXXVzkRN+WIohMmn9jW83q33C8LTyvXZDOmkJHbMnRmz6ZbAnnQ7OlIrWltaWst0Oii6y2pJ1ua2ucbUnz0ZxfCK/8vyypoYaV9iZCcC/jJgLnqBQutuHbYnyygzbNtz+u129VGbdrctFRyxYTNdvQ5hNjYlR8atvNh1d1PvF287zzyX4SbR1vQc+zhni86InH7ZqL6Wg43gn6vYH15FXLcbT5xLeZouJDm+uT1zzWJ/sq7VZc24I3zbLf4ze7HMU26zYWbUjoOzt51b4kMkbf9JYSaGhFFPaanryy2pBVtNui0p/tT5tvx2+gd2xxQHvLN4eTV22ZXdbJqyO1dm0mgNPMaSW7AW4TPNl++274n22/tRcnNRPWtgccArO+hKlhadsqpnPek9duXInw3ovrWmrgEz3NddtSAx6PdW0Z2lyGdiTg+JtCa8jS1vYVOnmVKWYRsp68DuLKZZ681o3bTG0wPN0lRKUIetCioQ/t2P/9GAB35/L0L8DndDBqT7uj6ag/mkx64xHryZCe8qa/H7SD7nQ67Qaj3nR7eiZ9/KxQ28F4Cc+XurRg23YbfDqVBx3NDjVXxC4u627YV+hod9174ekzkv8TT6dZMrp7wtcHsP8XEAY+95Jl5NMAPgFAnj2LPNopQl3h68sYJLKlf8n/XEYag3PEp4pnfZtWIt1pJ5RNZRzrnOliW57f+dm+LUn7/aG248ZvS6LiQ5vrE5Q83nWy+SH+bgrXQJr3dnGd88lsSeEBfYCkG5UQcMP5mKjUw0Wa2MeYRf8WlTVoq6fAqluwqhasWkosG23k1Sf8Rvy7nIBfpf7r8W8f+lcUfkqE/zX40R+8xT6C+Qz6fAf2+bJvOKfBc7eBbUp/tEvuL7JGNL8HPxqVJtDJ248m8Y22IPQ1HWSN3UKrRlh5+5Y858SGtZESS/SJ8xvVf1zNXHdYhoLR15nQn/lJN/zMbK8Z2nUq9POwPaG1KtvTZLPZHvZn29OwmimxRJ+ava270UGX/bpJ0AHSx9/o1zH+yVj22T97iziavjCGSSwSu9qEthq1bUFbg/i9ES7zi1hN4vcG8SuxV7P5TYX+BtFHWhp9jstbSv8tpX9kKz+RTsvKWJxf0WmUi13nOvP/+YS/qlznV4gzfybkOr9Bn98vIdc5uc51Xutc5wTs6/l1rmNsOr3OdZKxzpPrPH9Fch3sjxg+9d8g/qOCcYbjkqZHpJkml6hZ+stvPH/X8qgS9f+Hch/MPzj3QRm2Evj1TLrcp6n01+wqsp2/KRZi7iNz5OIMf9zf3h/3+qNW0I5+ds46w/8fbp32hTxYAAA=","debug_symbols":"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","names":["withdraw_public"],"brillig_names":["withdraw_public"]},{"name":"update_accumulators","hash":"10900224325530215840","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"12348881442450494403":{"error_kind":"string","string":"Function _compute_utilization_rate can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17134621154673181869":{"error_kind":"string","string":"Function _compute_borrow_rate can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["update_accumulators"],"brillig_names":["update_accumulators"]},{"name":"get_accumulators","hash":"3590572983931561812","is_unconstrained":true,"custom_attributes":["utility","view"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]},{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"7f3druw8dqUJ34uPfSD+k30rjQ+F+nEXDBh2wVX1AY2C771jv7GkiJ1LIa7NZMScJJ8Te2emFEE+Yy5pjkEF9X/+4b/903/53//9P/3zv/4///Y//+H/+r//zz/8y7/91//8v/753/719p/+z3/84z/8l3//53/5l3/+7//p+b/+h+3X/zEu/HXC//wf//lff/3n//m//vO//69/+L/M5o37x3/4p3/9b3/9O9nbh/w///wv//TrP23/8Y/fjk85fh2dN38cG9PJocGGr0ND2B4f6+1//P/+8Tac2GM42aV9OKFcD8e78nWoj/n7cFKX4WS/D6fk6+HEbacTbfw+nNxjOMXar6OLC5Xh5O3r0LSdiFVOh+PytuO/HRJjZTi2bObrcLf9dvT9W/z2kW8xH/kW+5FvcR/5Fv+Rbwkf+Zb4kW9JH/mW/JFv+cjffvjI3374yN9++MjffvjI3374yN9++MjffvjI3374yN9++MjffvjI3378yN9+/MjffvzI3378yN9+/MjffvzI3378yN9+/MjffvzI3378yN9++sjffvrI3376yN9++sjffvrI3376yN9++sjffvrI3376yN9++sjffv7I337+yN9+/sjffv7I337+yN9+/sjffv7I337+yN9+/sjffv7I3375yN9++cjffvnI3375yN9++cjffvnI3375yN9++cjffvnI3375xN++3baPfEuXv323hXh8S0lPR4f7t9iPfIv7yLf4j3xL+Mi3xI98S5e/fXdby9u/xdry27d8P/oWY+5jumVaz0uA5WzVM+8LhsE9jSN8/Y1kgfHnY+Xz1pvnyvhDTMcqcszuODrE+wTK4BMw2+gTMKNPwI4+ATf6BPzoEwijTyCOPoE0+gRGvxMb/Xfi5PfGKaTgnydw4i7C8aSVDclcH5zDPoycnmboT22LOR5Zu103Hh/s7dnB+WFxfjv0F3Grv3WYjbj+Xmc24vqbs9mI6+8mZyPuIf5h4vr79dmI6zcYsxHX74hmI67fws1GHM/5YeIOz/lp4njOTxPHc36aOJ7z08Q9xD9MHM/5aeJ4zk8Tx3N+mjie89PE8ZwfJu7xnJ8mjuf8NHE856eJ4zk/TdxD/MPE8ZyfJo7n/DTxETyneRDP1xBNPn5xYop1lY82vuyb2pnwtB3c1zOZfgR3KMVmBB8nxCaM4Lik2IzgjaTY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zPLXNr1xpH4ry+9J/ZaWn9RvaflJ/ZaWn9Rvafk98q8sP6nf0vKT+i0tP6nf0vKT+i0tP6nfyvIHUr+l5Sf1W1p+Ur+l5Sf1W1p+j/wry0/qt7T8pH5Ly0/q9w8ry0/qt7T8pH4ryx9J/ZaWn9RvaflJ/ZaWn9Rvafk98q8sP6nf0vKT+i0tP6nf0vKT+s0sf+1Vd5HUb2X5E6nf0vKT+i0tP6nf0vKT+i0tv0f+leUn9VtaflK/peUn9VtZ/jyV74/WH/KnqqJl24+2JbjK0X7b9mrxm38ura93oeepbqN/RNJtmzkGkqvcnT3+krw3o/wl1XbIzFPdR9H/j/Wf6kaK/n+s/1TrZ+j/x/pPtYCG/n+qf1m3k0b/X/pPtYSG/n+s/1RraOj/x/pPtYiG/n+sv0f/pfUn/1tbf/K/tfUn/1tbf/K/tfUn/1tZ/7SR/62tP/nf2vqT/62tP/nf2vp79F9af/K/tfUn/1tbf/K/qfWv7J+RNvK/tfUn/1taf0P+t7b+5H9r60/+t7b+5H9r6+/Rf2n9yf/W1p/8b239yf/W1p/8b239yf+W1t+S/62tP/nf2vqT/62tP/nf2vp79F9af/K/tfUn/1tbf/K/tfUn/1tbf/K/pfV35H9r60/+t7b+5H9r60/+t7b+Hv2X1p/8b239yf/W1p/8b2r9K2/SSo78b239yf+W1t+T/62tP/nf2vqT/62tP/nf2vp79F9af/K/tfUn/1tb/4XzP7PlfSAmpMrRPpV9ID777elo90Vy4SStM8mFM6m+JMPC6U5nkgvnJCYdJK2tkbQmHvdJ69Io98naPrlh4ZwE/W/6L5yToP9Nf4/+S+u/cE6C/jf9F85J0P+m/8o5CfqnsHK6g/4prJxJoX+KKydp6J8i+d/a+pP/ra0/+d/a+nv0X1p/8r+19Sf/W1t/8r+19Sf/W1t/8r+l9U/kf2vrT/63tv7kf2vrT/43tf61fXKSR/+l9Sf/W1t/8r+19Sf/W1t/8r+19Sf/W1r/TP63tv7kf2vrT/63tv7kf2vr79F/af3J/9bWn/xvbf3J/9bWn/xvbf3J/5bWv5D/ra0/+d/a+pP/ra0/+d/a+nv0X1p/8r+19Sf/W1t/8r+19Sf/W1t/8r+V9c8b+d/a+pP/ra0/+d/a+pP/Ta1/5T15efPov7T+5H9r60/+t7b+5H9r60/+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zem8IlI5TsonJ51WRDQ7vejKyUmx8k1nf0/nGyNV/gjPtyOqndTy536++YuxYZ+UsfEERfZtp4W202LbaanttNx2Wmk67fxH5vXTTNtptu20F1WS03Ha04Odj9N8/bSTNr+EttNi22mp7bTzKrnZt/00d3bhOX98uXZa2La200zbabbtNNd2mm87LbSd9kK3eMjt0ve7TDhf3jOPHs8Eb09Oe4GkHH9vfgsnp/n6aeXktNB2Wmw7LTWdZre2085JPgcxzpyc5ttOOyfp43acFuPJafnFaY+5pe834eBezO14FP4WBJ3UpPNtp4W2086r5HaRP/4CtrO5pbbTcttppem089jn9td96HariJPTTNtptm2Qru0033ZaaDstNl0nz5OM+mm57bTSdFqwTVeu0HblCm1XrhBaTovn94Bg96mFk3fCxfM7QO2k3HJSaTjp/E5TO8m0nGRbTnItJ/mWk0LLSS0VYc8rouzNVXxaWnmclFtOKg0nua3lJNNykm05ybWc5FtOCi0nxZaTWirCtVSEa6mIF/erxyLcbW3x7LTUdtr5/ermVPbTnpf8HqeVptPOg+/6aabttPO7o4kHEpNPkIRXnuXhx8rZt8W201LbabnttNJ0WtzaTjNtp53rdvNpj2YonZzm2k7zbaeFttNi22mp7bTcdtqLbvRhGkMu309LW9tppu0023aaazvNt50W2k6Lbae9SgCP05w9+XtLpem0vLWdZtpOs22nubbTfNtpoe202HZaajutrUpyW5W8WE1wx/KtceHkEvRiNaF6mm07zbWd5ttOC22nxbbT2hqM0tZglKYGI21b22mnAtTeHJ9eBPXxkaXeLqUnp8W201LbabnttHMBUtp//2VS+b4vSTr//Vf9NNN2mm07zbWd5ttOC22nxbbTUttpue20tiqxbVVi26rEtlWJbasS21YlL9ZlyuO2WOzZabHptPMYwmazP9dkc3xc8M4fFc7uSF6ze1ozOj+69oRuOg85RId0vngiOySjb0hW35CcviF5fUMK+oYU9Q0p6RuSvqu373H1tsczntmbVDv6D3dfO96f429t4/cJhG30CZjRJ2BHn4AbfQJ+9AmE0ScQR59AGn0CefQJjH4njqPfiePod+I4+p04jn4njqPfiaP6+8D1bswpab8K1RxZ+vxVSMvm6aY8NmrYvq9vp2RB8wqNA80rNB40r9AE0LxCE0HzCk0CzSs0GTSv0BTQvECTN9C8QkM3/BIN3fBLNHTDL9F40LxCQzf8Eg3d8Es0dMMv0dANv0RDN/wKTaEbfomGbvglGrrhl2johl+i8cuise6Bxp88al7W7YaraNbthqto1u1rKmjytu4dqvKDvLyte4eqoln3DlVFs+4dqopm3TtUFc26eU0Vzbp5TRXNun1NDY1ZN6+polk3r6miOe2G3Xb8ANptT3t6nU/WmGiOX2ebaGtwrD12Q7t164+tv9zt3/dBuR6DCo99a018enXG2FlJPt9GATh3OAE4r+FE4LyGk4DzGk4Gzms4BTgv4ZxvVQOcOxwDnNdwLHBew6FDvoDjgfMaDh3yBRw65As4dMgXcOiQL+DQIb+G4+iQL+DQIV/AoUO+gEOHfAHHA+c1nJU7ZJv3WVq3nTw95VbukKtwVu6Qq3BW7pCrcFbukGtw/ModchXOyh1yFc7KHXIVzsodchWOB85rOHTIF3DokC/g0CFfwKFDvoBDh/waTqBDvoBDh3wBhw75Ag4d8gUcD5zXcOiQL+DQIV/AoUO+gEOHfAGHDvk1nEiHfAGHDvkCDh3yBRw65As4Hjiv4azcIdd+lRtX7pCrcFbukKtwVu6Qq3BW7pBrcNLKHXIVzsodchXOyh1yFc7KHXIVjgfOazjrbh7mjtcjWmfMCZp1Nw+roll387AqmoU3Ra248YVffVRFs+7mYVU0626lW0Wz7la6VTQeNK/QLLzZew3Nwpu919Cs2w1X0azbDVfR0A2/QiPwEps/e3l9Kjua2z8f091fXp8FXjXzZxPIRyXc/llOJuC1T8C6YwLOnkwgjD6BOPoE0ugTyKNPoIw9gbJt2iewpWMCdjuZgBl9AtrvxNUJqL8T1yag/k5cm4D6O3FtAurvxLUJqL8TVyZwviNQ8vuIko/fTEQ53+/kYWpKyCcnlYaTzvfHqJ1kWk6yLSe5lpN8y0mnOpnteN2E2WI4OS22nZbaTsttp5Wm085/GVo/zbSdZttOc22n+bbT2qoktFXJ+U9WKteO859ylOMyVezJSbHlMnD+AHftm3zLSaHlpNhyUmoB0XK5ji2X6/MH7UrcK6KkkzI6fwCtdpJtOal2uT49qeVynULLSbHlpJaKSC0VkVoqIrf85eaWG3huuYHnlht4/tOK+I/bf/z//+d//+f//F/+5Z/+5+2UX//r//7X//q//vnf/vXrP/6v//d/7P/Lf/n3f/6Xf/nn//6f/se//9t//af/9r///Z/+07/823/99b/9w/b1f/7vFFL4xxRKvA3nF6pUjPvHW4dlbv/Z/fW/R3P739Ov//zXu9N8sds/3v5P+PVf/HVGNPYfb//H38Z2G9//Bw==","names":["get_accumulators"],"brillig_names":["get_accumulators"]},{"name":"_deposit","hash":"10264973027141936381","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"951653053333916160":{"error_kind":"string","string":"Deposit cap exceeded"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5235018679007078561":{"error_kind":"string","string":"Invalid asset or market id"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"16022896159229267359":{"error_kind":"string","string":"Function _deposit can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1dTYhkWVa+8ZuVP5ERmdldUyKCi1EUUeIvMyMFIaWr7D+ne5hBFEGGqMxIKWy72+rqGR1BY+HGPwRdaCsIbmY2DiojsxBcCK7cuBhBcONCcGXBOOIsXMjUrXon4osvvnfzvYh3IyOz8kLyIt+97/zdc889575z7yu5F6Xy7K+U/K7SFYu1OU2u7eVKp0BY7Zh0lq4JneVrQmclEp0zSuuJ9gKpuPRijH2j/uK6mfxfhvoCie1sEt4i4Q/ahxP4Lg79vc0EZi0O/L7Br8eB395I4HxmPIWPvBhe05l3xlNZvkPPNJLfpWmTCVyrK7v55xvAl5V3qQ71+LNJ3Z1nfy03/f29ye9NoiOGTiEvRffJgaC/DLz58tp4Kg/D22sf9fuj4+6o0+sM292Th4PDdv/w4dGgM+gcDg7Pu4NebzToD45PHp4ct086/d6oc3F40rtI8Brs++MofPUM/gOA7wqUm8H/qTj0T+C/Pp6XfXvJYrDfiCObiR18M45sJvDfKlw2R12D/XbxsI8N9k8vD7vLN7bdC7v01cR4mS2rT1HNjHG8Oje1h3jP7EBLwLJxZXg2CsSDsF4nPHcKwGM2Fefr0+TaXq50W0Qn4tlx0zlk+MVffvfDsw/ORz95fv549NFHJeJrU9CvSh6YWzlg3mOY73z83nuPLh6NHj/41UcfPZmDvS1g2++y07wxXdgOS41w/Ehy9TL+WnVKc5Np/vzo/fPR43USrSNWaoKmLaqztuZse7b/moY5i9S5qZojbUW6i1mGHeLfErwWOS2UCJ/Rw/IxNWu4edW1Z1tU54uZopKoq4h75RXDarh5/lkXkNcCZX+YVRcM/5aLqpudkFy3hFxNdjuC1hbV+cL9tyPw7Ag81wmWuSk8Tgy+uhoevpemvzg2Q7ZsUTzKrobGyaJ4EJaFBKxTReBBWOaC2dhuQN1pcm0vVybh5y7QVuA4vTAZNd18sboW4N6muj2oYz3ahzru+wOo26G6V6CuAb+58NIWysnP0V+HOZrbWXnZ5at03koR8m26efmijUfZVAUeX2yc1aj9+8nV+hDlWORSAMrZEa6XSX8W0ZGnC+rINtU1BR9W1xJ8qHlul+pwbmpSHfpFLarDOQCXcHgeqrj5vrMlmaZLnx/5f45RfEnzX6sp8HgMWfvfSq6+r34wWQu+Qj82c0xz68euBlbI99x087xeRUxj+LdcVN3shOSqYkWTnZr7Wm5+nuP+2xV4dgWe6wSLY5oYvrmaz2LEGmq+jRGj+cIxzW6BeJSvZWMb593ixlKnzb4LFuW7sA+b1Xfh/kHfd5fqXoW60Bql8nlMTnnjjkhrcbn9RpYvyp7li7Jn+aLsWb4oe/RTuCj5mpzyxh2bgh6zYyruQB+LfSZr/w/JdR3ijpdBfxbRkacL6sgO1TUFHyruSPPxEL6aPzjuQN+F4w6009c97vjX5LomccdJlrkT8d/GHbewbiqs2O8bTH8jvx8dGB81oMv8aJ9K8W3Ai7KouansaoLuGrX/k+oU5v8m95ri+W3Cp8Y20hqy2dskw0h2sWu07gZoRfxNN2+H2A9UsUvceOMFH4jP+MB7iH/LzfsgMex7U8hVxdLK52LfQflj6xbH5fXpMK76YfATuB3jRP3bI1lE6tPDkpCFGiuGX/mYLeIjNFYixR2Zx4rhX9VYUXINjZU9QWtL1DVXItdOh+nComKjvGMF06PzjBXUv32SRaQ+PSoJWWQZK9g3e8RHaKzsxeEj81gx/KsaK0quobGyL2htibrWSuTa6TJdWIpYKzC6844V1L8DkkWkPj0uCVlkGSvYN/vER2is7MfhI/NYMfyrGitKrqGxciBobYm6vZXItdNjurCE1r2zjhWjO+9YQf1D/Fl0mdfadgU9Kr5jXY4UW2bWZc69jbR1LJh7i/IJ2X3OnVC+SFxbl9/uozy5XJabkkeXUY8OqK3RoHLJq1Rnbd8tTenoJDfz5LuH+MYSeW6a5CcexIHfy2KjEf+yOaxq/omdL694U/nyoXEZgrWfE1ZkP2DSp7sBvpWdV7S2Umj1Rc0dCD+NhlAuw+bq5TUZY6/EgT/pjwMhC+TJ8C+bg4C4VuXjKd5C/ax8vBCsg5yw1tVuZvVtq8RHHN3sHHJuBharuwv3bM3c6j4FdHH+673Ac98Dz+X1l00Wfm7v5/AxUM/uUh3K3nhi2ftymlzbC5bjztGofXI+sTl3AW+B/XrM/eOEPO4JmWbtA6Pb98EXcvQB5gAZ/qagAfuD+6Ai7oVswispz7Hel8S90Bxv/FbG83TbWKhCXZF218v9nN7r4zitjWfrUA/qSV3LzY9hjiOV3O8KWTRdutw3BZ4Y79CULUZ+DP+Om/bdJA54bfjee45Kjf7HcyL4/5KbD5RfBSGxATpIwaGKCczgYPHMGJPTfcEfn509C2pe++DDXys5TSPfV8XD/hTD/tzoyceP3z8fPhl+/tGXRwxmPwV8RYDntRN8zvoU9TY07k3/0J6yHb9H9Jwm/7eXK92Q3UCdN/yXiNX3WplEcgDsshm9C3WOWFQaw7vQ7ZW9PbcfgIe/I4u1F1IB7GbEj1fntGts8Mw1juT2T1zje4L+0NSF/CCfabDu5YSlXB7GcwA4Qi44L7v8VSJon6rxleS3StXgaaYm+KoF+MLnawRLvfIPmQx8lb2aV5VTk6H4Vq+r5ekPnxt9cfT4iaNymelAce2kPJNmOny3WhczC1WnVcXMC6vK1xM4kXe5yCxfzqYNrXBHoivzTizefRN7hVtluIVWuJuC1pabH4qcSaeGaVPgWRWs0I6ZyNlTmXdicfZUJN0MZk+pbMc82VO+cP+pzJOWwHOdYPFOLJRlKeVqePhemv7i2AzZskXxqLki5s4yX3gnVqtAPAjrwfjFlTMtfDlNru3lymDd3kw3qQ7DCNYjdAm57zGq4Yw6dDnxDTWXy96E59nltS5ZMixf5aYq2bN8UfYsX15Fsd9cLsvKybPLS2X6mY002VQFHl9snNWo/X+T/xdppV76f5xZ9DLozyI68nRBHWlS3b7gQ60YpvmPCF/NTfwmBf2iA6rDOYB3eSnfF/uOdwyo+ZH/57jHlzT/tZoCj8eQtd9IJji1y+sK/NjMMc2tH7saWCHfM/ISR+aYhrPcI+lmMMtdxYp5stx94f5TGcJ7As91gsUxTQzfXM1nsU6x4Pk2RozmC8c0ewXiUb7WusUd7MNm9V24f9D35d0JGHfkzVpcNO6IsxaX329k+aLsWb4oe5Yvyp7li7LPe7qEySlv3FET9JgdU3EH+ljsM1n7+8kAWoe442XQn0V05OmCOtKiun3Bh4o7Qjs9a1SH8wfHHei7cNyBdvq6xx0/L+IOnYjw5IPHw1989qZqeF5KoZP1g9uFbDnSpNqb/uSlrZaRtmZKuwbhxzbruhO7EYeeYAyG8lkkBkM9Wred2ChPLsr+FbkTW71KRp3Gd7UNQYNzcXZLhE4bDelJ6F2eOmVU4dldEs+uwLNO64e+cJYtzuOcnftq4Dmcx5fZ+ZknO1fNncoWGE9Z1qbzxrpq93NF4ME5MrIf2TX4r8aBP0mzUpmeyJPhVzpZSrkaLK4zXFsEK9bco3gL7dopMhNZwVrXHSeKVsXHXoEyaZBM4oyjTr8h6HLEf9bYJvROjk/cw3UJlR1rRdlSk0VeW4pzOo9b7DvjiU858uU0ubYXLIOzXrtz0ulHPvUjd6yrPuRkRfUBnvrxhSXns6aggcdS3i/l4PPbKc8hPYgrj0/+vM14nu6r2OmAPnhtPFuHesA7HdTJmCFfQb1vsT7EMbaakwimaaNKR9RpFCvb6dAEIbFwGyk4VDGBqeTTNdvpkPZBuIoAf9n7BdbbUDwSOn0kti9qtKp3aGpzywI7HRrALk8be1DniMVFdjpsB+Dh76vcTIrdjPjx6px2s3mjfexXq8rdDIXU6jCXEKysm4D51UUjgKcBOEJTIC+nfjOp8Cnx/5T8VsuzTcKXd6dD2hJO2jAMmQx1+PEqDvBK41uN7SV2OrDpUOdn5tnp8M0r6la1owJV0lZrWCX/jd5sRTqzVL7ZynL2Kqrm/fGLa+gcV7VCWaPfytNtCNxp58TWUmiuiefKxKPhqae052+gWvv/gLcnf1abhYln3dQEvVsp9P0nwPxz8pZDu1vW7dup63Z+0+23U2+/narcCD77HW0O95+yR8rFuE6wVvXt1FXtbrmqb6c2CsSDsB6MX1z5ragvp8m1vVyJvbKX+zzf0LdOWI9wBZr7HleBG1SnstNKbr5ctpKYJ8tsXd5os3xVVr+SPctXrf4r2Sudt3LZG/Q8WWZNQY/ZSJNNVeDxxcZZjdp/OiEwcnglfXFejXwZ9GcRHXm6oI7wtxhUtphapQt9O5UzXFRWG88nCF/NAVm+YYR9F8oyu+wbRqEss0W/YfTjSQfefjtVD0CWr9HD8rmpfmzI9+Rvxhcs+8wxjeFf1bdTlVxD305Vc5/awZCWOYp4rvL0hiJgcUwTwzdX89lN+3ZqrF00Nk+sW9zBPmxW34X7J2v2Sd7dLYvGHZF2JyycSatkv+i3aUMnIVzF7hZ+n6DijtDuFmv/pTWKO14G/VlERxbd3dKgupbgQ8UdaT4ewlfzB8cdKmtJ2enrHnf8vog71m3OqVMd6u0G1aHe3qG6LCfA+PL2eLYOMx7V3G7lsvnoLyCu43aO6EHd5LPrUTc5exz1nTNecRybLK5qt5DaTb2u39eKMw7C39dS2XhqbIS+r1VbiVwX34GZdQwt+n0t1FXORud1rFO3nCx6D0+GZ8N2m/u07KY2t5wiA6SvAu2znkRUc/My5lQea/83YO8f1mdhli+hYYdowJ0hWXIIjIe0HALezWntvwE0Ww5BJfC8S36bjWO79rOPHz0ZOSqcLJO21ZLz7Kyw0tlzvtwer5ktAaEpaL2OCzQNN88/60Kk/MTb4zUFHjWZXidYt8drZsdzQ4/XPLo9XnP6m4tyGm+P15yXfWgrX94EhEWP16wIekoEsyro8sXGGTun36GFwEhbkuRCIG9HqUTBnX/RhPUna4JQ6AicvIGb3cu7EFgRfKjFPk5AUEfgqHmuQnXq6CWeTxC+mgN4IVAlyWPf8UJgRfDF/9fc/JhgP8PozbqYbu13kgfUQuC62EReCES95YVA1FteCOQPkWEdfoHlrfFsHc5HeV+coL3MsxCoFjHYb0JZhBb7lG9tssi7EJg2X3C7NJthtFTFs6Z3dcJ3mvzfXq5kXgg0/Ftuvs9jxEh1ooflwzHShqC1JeoqK5Fr/jkq7xgyuvMuBGLf8gc4Ub410Z4XsYyGekp7/kiztf8xsK+8iFUWz/uy9CIWBzxl0c4RwqznICHRoaImOD4HCTu7Iu5x8MVfUU7Ds7sknl2BJ/IgyvXG1xdzJNQA43OQsp6flPccJByY/QUHJm9kReNgPDXdvOyxXZoRxXvcx1XBh/UxG9HT5P/2cmXyRdRIXwOfbLK+I2SBPLF+oJxKKVeDxXWGa8tFnbw7Id5C/XwH6EEZpMG6kxPWpqiL0acbAb4RfyNAq+KjtBI+8me0sIOuHIi89g3lxUXZN5NFXvuG44PtG+pg2iKCL6fJtb1gGXa7vcHFYLRO8xbbfi6XzTF5ziZS32pRvgLbhLy+gnK4Ky7dQURcVYGrJHAZv3g2EdofX6rjWTpOk/vt5Yo8mwjtbW08W4f2s57UKbtTIVmE7BvKItSHkW3x5KCHkqAV9cDwRzubiB3+KgiJDVAlBYcq1r7s5gdo3rOJkAYnfjPsnGcTlVPAVwT40KJDyBdQQbjpn+rvyP5dN+Tros4b/gXOJqoAuzxtbEAdP6M0hsNNey9nz5UD8PD3urnNSrOzuMax15E2Bf1KhVU4zdOggrWZE5YK99Km24oLT7d4iIkvf5Qw5vXzd5LfTTdveThMVKa7FOCLn8ffaq0/ZDLQZHGSXsw1zzS+cY3Z8C9xNhGbDhRXaKgr0+HJsS5mFvDMIFQVMy+sKn+cwNl0890Q+zWh4fK5u6YGuHzP5wDhCgxP2CU3nwKCw86ezbukn7bqU0rBze2Ud4on1vtShboCZX7iTeyoPqWDZVQDvP4v63Fi1j6Uo4t91KL2KNfQXugSyQvxYP9zVKvSarwYvp38jin348GLfNfntCbw7ZwqLlWox/Z/mYxJzHe3a3UJOi+Oh52L3vBieDg8P++fDdVpxDgmi8b/cNQZ9S4uLnqjYf/i6GLl+M9Hh2dnve7JRe8Z9+cnF5fh9+PnqzR98lSEdRtEp/1GdwfvY1T3YPziWqP2f0f2OZKbJ+0zv5HYAB5UFHp/PMuDtf8XcEf+PiBPw63kye6Cipabgm7uB9w/pFY1mQdr/4/wqurXwab6grYdV8t9qY5n6TxN7reXK31l23FvE9v2rGcEhGwu2miTmUoJqREs5QqizN8kWvF1oorgOPXD2v+zeJ3YcrO6hXxbHfLOq8EqBUW5v5tA83/RmI3kvh7zqikWtdJdojocJ/wanc+swDrUg2VeV+dJfyrCTuDK+HP6xvN0XcW4xdCRx63aO6lCzazj3OKA0FlrasxsUl2WMePLm4QP9cX6BscMz7sq7dp48M99i+Ig60e07/js/fG0fkYfa1OY/0NzFNszrEO9DK2C8Ryl9FLNX6z3eZce8HlrF9mX6Kv5qES4b8+a1Cv4q9gW5f8agh7lD/iYbdfN9xnSZ7DUfKhsCdsZtCU8N6vlsZAtwbUE5auXCJayE2rcqVVlFYOy79sAu/Lp5LeyD2xX0D6wXQll+qAes++rfDr1Rj+kI8rPU8eLNzLA2gjg3hXtGwHcSBc+y7jT9Fj5BPjmwpcq1BVps5RPMHMW9XhWNiHf3JcsslT9qDK8GlSH45jHI+LlMydUppsax6a/OF7Uug7GCN+KtF7S7p6fHY26z5Z0jo863ZPzPOsFJeLbOb2kzinvvP6Kz6EMebmcYafhZt1AGCpDI+Z6TH8wPBocnrVPumfto8Gwk0e+y2ZnIWzlK1k7lkkReJR8Vf+z/S4THr4Xej3D8V2aP31a0zjT5kl8gY7t34B577VaOo914p/naaS5FOBHjZttQddbCS24jnOVWWrKhynR/9gefQaeA8sClvI1WOZqjUD5Gtwubyyi3sKHYCn/4Arn6efZPr+RYc1NzeGc7YM+SJaYLbSOFbIPWd+T2LNoA9DeqjmI5xo1x4TmP9XW/HdfNsbw7Hjazpft8SxcbOPcrF19zgvUbWeAtR2AtRmAtZURVgg30lol+DvJ//UU+JvUvpH8X4X2G4KeGsH/AOz3uDbbxmD+CrT5GHy1523HUxzcd7tYJ9rjeOD2xqvH+ZuwJc+XJuAp2n6n0Y26YPiVDEopV4SF9wzXFsEq2qYV2SchWLsZYZk8sX/9799bTV93mYey0+PM8E/scxx6JrrXHIdlaviL0D3DtSrdU7yFdA/bs+4pWM2MsEyeSt8acWTQY7vuUmSA+PF/bI8wqtR+l+j3BecZnpeUHBEnwvOlJdpvBdrb/5gbgTC2oB7bfwKxhC978Iw9r/p2L4XeUgr+NHlge6VXXnf+kObCOrSzPooSTx8Oj8+Gx53OSb8z6ncOV51f0T7v9S96R4OLzlG3P5zPKWD8Kp4PneW+bkeFxT7LPes6n8muIWjlM199eX08bcd1FXGvvGJYvJXf4Puyruf6xz4qLLQWj3I12YXWcHE9mPtPrRXvCjzXCdaqzvVfxXn72O+hcbIontBRYfxeRV2z4kFYD8Yvruv2vaIG1WX91hj3j9pFro5kyZtLM1nbcPmO84q01eJC5Rg74hfzg1m+Wb8VxfJF2bN8l9nhanLKe5xXVdBTIhqqAo8vNhY4P+Xf6fihSEdlyjzQybqXe3n0ZxEdebqgjjSori74sLrQcbANQZeaP/hYHPRd+FhRtNN8nNdlOS38brMq+NoUz50m1/ZS5bDDuNT5yvz+sE5tcWyaT1IjuD+TPOQv36Fxul08X2dG606AL+bZ2n4GaP2/+LSOlqH1AdD6/9FpPWovQ+tPAK1lUKqQ/vlix6mxTh0CvFo9Ou+Hy/D+o0DrZg7e307h/QcA3k583ofL8P59QGsrPq3ny9D6KtEXKYaWPgTngxm96qQhXx6MNX/3kkbqm5Aqn07lwXOsrPLpVB680epJ+IV6Mfx8/w3j54duGD/tG8bP4Ibxc3rD+HnjhvHz2RvGz8+tGT8NqsNnVN4cHz+hcsYaRAvSGOO90VH/qDMYDAdnR2cXJ/2zh5e9N7IYFd+rcY6J5bhg3gu257wXa/8I/LlfAhk/byvw+SZfDrQrpVyfwxD3quPZe5hfovKcrP3kfcR4nkarw/yFGuGx95IoL4RldHCe0JcS3lWelT3fEvjvEH6VN4X3suRNqTwrT96HCY2rymeoE3y8x7SZ7sQYV2eHRw/Pnr0Ubo86/t9u1nF1m3d3dXl3vw3250/rs20M5u9Cmz/IYKOMpqLy7j6BONKX27y73GWt8+4+Af36ymr6+jbvzt3m3Sl9W9e8O7TrOP/Zs2yz/7Y+C0fJC+cwm4smuRtQt0V1mAO3Q/Tuj+fpRVhNonef6LW5V+l8S+DPkhcYyrPbE+33RHtP3tdIpnXxLPavydT7Ot8Fh11V45wWAQA=","debug_symbols":"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","names":["_deposit"],"brillig_names":["_deposit"]},{"name":"_withdraw","hash":"4557201320735915032","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5235018679007078561":{"error_kind":"string","string":"Invalid asset or market id"},"6787403583199288031":{"error_kind":"string","string":"Insufficient balance"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"10435052277855889085":{"error_kind":"string","string":"Function _withdraw can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"15333773746166717806":{"error_kind":"string","string":"Insufficient collateral"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_withdraw"],"brillig_names":["_withdraw"]},{"name":"_repay","hash":"17925370460584879180","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5235018679007078561":{"error_kind":"string","string":"Invalid asset or market id"},"6787403583199288031":{"error_kind":"string","string":"Insufficient balance"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13135008234568508716":{"error_kind":"string","string":"Function _repay can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1dT4ikSVaP/Ftdf7Iyq7q6e9xF2IMKsir5r7KyQKFkpp2dXWdGZg+es7IytaGdWXp6Rt2DpCh7Eb0IXsQVFBRcdj0IgijCsuLFiyD45yAe1MMiKIy7592O7u9l/uqXvy/q+zIzsrK6K6DIyoz43nvx4r0XL168iK/gXpTSs79C8n+ZPrFYm7Pks7lcaa0QVjMmnYUbQmfxhtBZikTnJaH1RHuGlFx6sY79ePXF53byvQj1KyS2tU14Vwm/3zyewndx6O9sJzArceB3DX41DvzmVgLn7ckMPvbF8JrMvDOZ8fIdeqaW/F+YNZnCtbqim3++Bv2y8i7VoRz/XFJ359lfw83+/3Ty/zbREUOmsC+rHpO7gv4i9M2X1yczfhjeTrPX7Y5O2qNWpzVotk/P+8fN7vF5r9/qt477xxftfqcz6nf7J6fnpyfN01a3M2qNj0874wSvwX5jEqVfHYP/EOC7FfLN4P9MHPqn8N+czPO+uWQx2J+Lw5upHXwrDm+m8D+/ct4cDwz2F1YPe2ywf3Z52G3+Yde9sEufSYyX2bLqDNUlHcdP52b2EH8zO9AQsEyvDM/WCvEgrDcJz50V4DGbivP1WfLZXK60G0Qn4tlzszlk8PEvvful4QcXo5++uHgy+vDDAvVrW9CvSh6YOzlgvsYw3/no8eNH40ejJw9/5dGHT+dg7wrY9n/R6b4xXdgOS4VwfDb59Dz+kfKM5jrT/MXR+xejJ5vEWkddqQiadqjO2pqz7bv9o6TmzFLnZmKOtK3SXcyidoh/R/R1ldNCgfAZPcwfE7Oamxdde7ZBdb6YKSqIupL4rbhmWDU333+WBezrCnl/nFUWDP+OiyqbrRBfdwRfjXd7gtYG1fnC47cn8OwJPDcJlrkprCcGX30aHv4tTX5RN0O2bFE8yq6G9GRRPAjLlgQsU6vAg7DMBTPdrkHdWfLZXK5Ml5/7QNsK9XRsPKq7+WJ1DcC9S3UHUMdydAh1PPZ3oW6P6o6grgb/c+HQFvLJz9E/BnM0t7PyqvNXybyVVfC37ub5izYeeVMWeHwxPatQ+/eTTxtD5OMqQwHIZ0e4XiX5WURGxgvKyC7V1UU/rK4h+qHmuX2qw7mpTnXoFzWoDucADOHwPFRy82NnIZm6S58f+TuvUXxJ81/LKfBYh6z9byaffqz+kNY01+DHZl7T3Pqx64EV8j233Xxfr2NNY/h3XFTZbIX4qtaKxjs19zXc/DzH47cv8OwLPDcJFq9pYvjmaj6LsdZQ822MNZovvKbZXyEe5WuZbuO8uzpdajXZd8GifBf2YbP6Ljw+6PvuU909qAvFKJXPY3zKu+6IFIvL7Tcyf5H3zF/kPfMXec/8Rd6jn8JF8df4lHfdsS3oMTum1h3oY7HPZO2/mXxuwrrjVZCfRWRkvKCM7FFdXfRDrTvSfDyEr+YPXneg78LrDrTTN33d8S/J54asO06zzJ2I/3bdcQvrZYUVe7/B5Dfy/mjf+lEBusyP9qkUnwBe5EXFzXhXEXRXqP1BeQbzu8lvdfH8LuFTuo20hmz2LvEwkl1sG637AVoRf93N2yH2A0OxhEhx1HZW+2741xVLUHwNxRLqgtaGqNtbD18Xjk8XRPurYsl/lMGnU/Mg+8wx9+CZF1l0BcemTv0I6UqctXl2XTH869IVxdeQrjQErQ1Rt78WvuaPeeTVFYxB5NEVlL8D4kWkMe0VBC+y6AqOTYP6EdKVSGv0zLpi+NelK4qvIV05ELQ2RF19LXxttZguLKE4QlZdwaMEeXQF5e+QeBFpTE8KghdZdAXH5oD6EdKVgzj9yKwrhn9duqL4GtKVQ0FrQ9Q11sLXVpvpwhKKiWfVFaM7r66g/CH+LLLMsbZdQY9a37EsR1pbZpZlzr2NdHQsmHuL/AnZfc6dUL5IXFuX3+4jP7koWTa688oyytEhtTUaVC55meqs7buFGR1/Bin0WfPdQ/3GEnlumuYnHsaB38lioxH/sjmsav6JnS+v+qby5UN6GYJ1kBNWZD9gOqa7gX4rO69obaTQ6ouaOxB+Gg2hvP/t9fNrqmN348Cfjseh4AX2yfAvGx9GXOvy8VTfQuOsfLwQrMOcsDbVbmb1bcvUjziy2epy7gAWztvwxWLmVncf6OL81weB516D5/L6y8YLP7d/PYePgXJ2j+qQ99anupvnPbbDOqOVfwvJqrXbFs+dJZ/NBctJqzdqnl5M9fNI0KnmLeNjaTLfZxvfMtSt0pb48fxX2qtG2atMLtfdh7pqUtdw83LJayM1ZvcEL+ru6jFDPDH2hZR9wf4Y/j03G7upb/v64PFjR6VC3/HuA/5ecPOLvyNgEivVYQoOVYxhBgfLHuCZnXX9aDh85qi//sGXfrXgNI38uyoe9gOG/d7o6UdP3r8YPB188dGXRwzmIAV8SYDneAA+Z2OKchuyGSZ/mDdnz5r8PSB6zpLvzeVKO2Q3UOYN/xVs9aNWJJYcQncRFXaZn0mTGD5ZbdvQ9txBAB7+H5mtnZAI4DAjfvx0Trt7Bs/cvUiu7HQ6eSDoD0172B/sZxqsBzlhqWmc8RwCjpBbyaGEP00Y7dMPvpr8r9IPeJqpiH5VAv3C5ysES6WdhEwGhlPWtFXdDvVbpSvIGw3eG308evLUUbnKdKjIZlbT4YfVhpi7UHZaVMy8sKh8LYETOToqM1c5C/QaorYL35iwaVFbddLhJmeahTI+N+10UeyMT8XXUMbn7emiWVnX6SLTzZAtWxSPmitinmLy5bpPF/lylnw2lyvHm5aZwCcjlBulTsjw2KO7yBmVuOLBDAUuV2VC5Dm5dBNOhjF/kffM36wnw5TMW7kqKyvPySWV6Wk20nhTFnh8MT2rUPtvk/8XacdC+n8c+X4V5GcRGRkvKCN8cqkh+mF1oV3/PUGXmps4Swz9It45yHtyCceOs+DV/Mjfed3jS5r/mvXkkrX/XjIQeU8uRfJjM69pbv3Y9cAK+Z6RQxyZ1zR8yiGSbAZPOai1Yp5TDr7w+KkM8brAc5Ng8Zomhm+u5rNYNybwfBtjjeYLr2nqK8SjfK1NW3ewD5vVd+HxQd+XT6fguiNvJt6i6444sbj8fiPzdxW3sTF/kfd5b0wwPuVdd1QEPWbH1LoDfSz2maz9TyYKtAnrjldBfhaRkfGCMrJPdeo2NrXuSPPxEH6e29gQvrLTN33d8V6iQ7ju2LQ5p0p1KLdbVIdye4fq0O7xGhy3pu0lAZzRZbx2Lrsu4HxUr8zgcjtH9KjMcLVPw9mTKO9HVId6bLzQSSdPP3gy+IVnu5KDiwLRmTYfc7s0m6HsmbXZ1JNCkU75BTO1kT+LnhSqrIWv+U8KIT+5KB1a9KSQSlO4Rvnrvkry5wvPUYtmOMeCpeYhloVImdSZYyqc0R7rNECIr2kZs6zX9iyn9vjC45c3g/gmwOKYCp/oUp+Gh38LZVDzCfXGCvGETvcerBAPwuKYSloW6SJ4ENbDyYtP023M8jxLPpvLlVODzXt7q4Hf6il/1YryV9l3xBMILEc/AHU89p+COp5LPw116H9zUXO78SlvvIZvmz9LvjeXKq1jXitgUfEp5i/ynvmLvGf+Iu+Zv5+ivtr/XBR/jU954zVHgh6zkcabssDji+lZhdp/g+I1kU4RyHgNZ5C/CvKziIyMF5SRQ6q7J/phdfdFP9Q8d0R1ODfdozr0i+5THc4BHK9Rvq86+RW6/YK/c5zSlzT/tZwCj3XI2v+diNdcox+beU1z68euB1bI94x84jfzmsbw77iostkK8VWtFVUM0Z5tuPl5jsdPnRo6EnhuEixe08TwzdV8FmOtoebbGGs0X3hNc7RCPMrX2rR1B/uwWX0XHh/0fTmejeuOvDHFRdcdkfZEcvuNzF/kPfMXec/8Rd4zf5H3efeJ8+7DK/8K7TDypizw+MI+01QXEgI3Yd3xKsjPIjIyXlBG7lLdPdEPte5I8/EQvpo/eN2hblBQdvqmrzseJAOI6468e4fqRDl/v8qWI02qvclPXtpqLhtthyntsuwrRfJzM+9r8hos9r6SWoOF9pWyrMFQjuLytdVRPq8jmtHm5fVBjO68+5qoR0fEC87PP3PL8aJzfjoYDppNHtOim9mIYgoPkL6Sm7cpqr3xugztkcd8XN3a/wTYp3+sXIZZvIIGvompATg494b7i89n9UusfQdo/qeKpqGQk4aq0+PCtwla+xOg4Z+TRiWBD/vjbavNVWxbf/7Jo6cjR6UI/3tgnDRbEe2w8Ia+PedL5GvLMwe4+Nry2Ie7Q9fBIy95YsJnObDqCzsMDYFHGfF1wQolXke+ljtzgMvw77ioshm8llsdBFATSJqz6wuP36LXQG4yLA5wxdpMX9fhbk72jnVAgQNcsZIDbPJkZ8+Xs+SzuVw52aTrBlFuQgci1MKdxz5v0K3g5otyXPEqwjzBs01z1PMkBiv+Zg2a5N20x4VBnuBZSdBTIJhlQZcvpmfsIP8yBc8ibR7J4BlfO1iKgnvxBFYlWyw/WQ86pQVHnNMyYr/lDZ6VRD/UlY98uPuu6Iea50pUh3MTL+rRL+KNNpwDOHim7trCsePgWUn0i79X3LxOsJ+hXu0aOqhk7X9bBM82zSbyIQuUWz5kgXLLhyz4DkGsew1o+Pzkch3OR3k3G9Be5jlkgbKZ5bCEWkvdpzrUY7wmMk8wMm2+4HZpNsNoKYtnTe6qhO8s+d5crmQORhr+HTc/5jHWSFWih/nDa6QtQWtD1JXWwtf8c1ReHTK68wYjcWw5UZDtJLfnIJbRkBbEsmcr1P7PA0EsfB7He+kgFi94iqKdI4QNRpjyHg4kOlTUBMfvIsDBLonfePHF76VIw7O7JJ5dgSeyEuU6eeiLORJKwfje96PAcziZ5r33HRXz6wsqJu/aomLyDiryHtulGVH8jce4LPphY8xG9Cz53lyutCK/w356mfEdwQvsE8sH8qmQ8mmwuM5w7biok3cr1LfQON8BepAHabDu5IS1LepijOlWoN+IvxagVfWjsJZ+5D9ZzQ66ciDy2jfkFxdl34wXee0b6gfbN5RBtm+oXyyreeewkCOIz50ln80Fy6Dd7vTH/RE7VkhnQdBpfMT3WqBO+VKeXO7D2ZK0mjCq91qgDalMLtehTagmdUqXcPyu0lnkRWj8I9uX6SXhBUErypDhj/ZeC3Ziy8AkVir0tq8q1r7o5hU/73stkAYn/mfYOd9rUUwBXxLgQwvp0PymFpYmf2q8I/ss7ZD/hjJv+Bd4r0UJusvTwBbU8TNKYngJZXtN9lwxAA//3zRXUEl2FncvdmxkW9CvRFgtEXkKVbC2c8JSS5i0qbrkwlN1xV22KntJx7x8lpL/627e8vDSR5nuQqBf/Dz+r+LXIZOhEnnWEcdL6zfGTQ3/Eu+1YNOB7AqpujIdnhwbYu4CvtcCRcXMC4tKg0L1HIo6S743lyxq68tw+WiBiQHe+2NRBOuPuucK+cVpAKh2+GqSPGHqtPuICym4uZ3yTvG1Lb6UoW6FPD/1JvbfYKuAeVQBvP4va4qNtQ/dqYJjpHLM+W5SjBjx3XnqPlwcf16poeras15nPkn+j8n3k/6LPNLntCbwK057XmWox/Y/nOgk3o9ln+Ul6ByfDFrjzmA8OB5cXHSHA5USgTq5avzno9aoMx6PO6NBd9wbrx9/r9sfDXvHg5Puae+4PbwKv9efz9D0yVMR1m0RnfY/ujv4O67qHk5efFaofYfscyQ3T9pnjrJvQR/UKvSNyeU+WPu3wR3pBfhpuBU/2V1Qq+W6oJvHAe8bVJE67oO1/6kEkG/7f7T9irYdI8C+lCeX6TxLfm8uV7rKtuNdiGzb1dua1Z3iIZuLNtp41nDz83aFYClXEHn+FtGKW2RqBcfpDNb+czBGn1Qu04dyzff2Y985wqnSKpT7uw00j0hnI7mvJxwJxKKitwWqQz3hrWG+4x7rUA6W2YLNk9KzCjuB0d7n9E3m6boOvcWlI+utumtVLTWz6rmtA5TfxfKt5oI8OuPLW4QP5cXGBnWG512VSmx98M89onWQjSPad3z2jcmsHtv/OsxRj2mOYnuGdSiXoSgYz1FKLtX8xXKfN/SAz1u7yL5EV81HBcId6a31mY8vGP51vdND6aWK4K/jnSf+ryboUf6AX7Ptu/kxQ/oMlpoPlS1hO4O2hOdmFR4L2RKMJShfvUCwlJ1QeqeiymoNyr7vV8Cu/AHZFQ73YR3aB7YroewVlGP2fZVPp3apQzKi/DzDjfJRywBrK4BbvfekFsCtXkPLtDiXLsfKJ8CdC1/KULdKm6V8ArQX7BOEfHNfsvBSjWOD2iPvlB6zPiLeXapT2VtKj01+UV9UXAfXCI8ixUua7Ythb9R+FtI56bXapxd54gUF6rdzOqTOadwqFZDjudyuImCn4WbZQBgq6yBmPKbbH/T6x8PmaXvY7PUHrTz8XTbjCGErX8naMU9WgUfxV40/2+8i4eHfQtszvL5L86f/qqxxps2TuIGO7b8J897flNP7WKX+8zyNNBcC/VF6syvo+paI41xn5pXyYQr0Hdujz8BzYFHAUr4G81zFCJSvwe3yrkXULnwIlvIPrnGefp7t890MMTc1h3O2D/ogWdZsoThWyD5k3SexZ9EG2D7M1gTgTmbP+LI7uYwT2zh32b75cgfqdjPA2g3A2g7A2skIK4QbaS0T/L3kezUF/ja1ryXfy9B+S9BTIfj/CXb0O+XLbQzmf0Obb1NMrQI4eOz2sU60R7nk9tZXj/P/Id7pSx3wrNqOptGNsmD4FQ/yzt2Ga4dgrdq2rHJMQrD2M8IyfuL4PrdLMGf6Emms29yHotN6ZvindjIOPVPZq0/CPDX8q5A9w7Uu2VN9C8ketmfZU7DqGWEZP5W81eLwoMN23aXwAPHjd2yPMMrUfp/o9wXnGZ6XFB8RJ8LzpSHa7wTa23fMUUAYO1CP7WvJDzYXH8Az9rwa24MUegsp+NP4ge2VXHnZqdI+bRXa2RilrSvRdzPc64jNIj7ndOya30cdKZYefB+1ijcZ72qC1gbV+fLmZNaO60rit+KaYdXcfP9ZFrCv17GPYfjX9T7qUEwY+Wq8C8USb9K7yVcBi69h4ri0+jQ8/Fua/KJuhmzZonjSYudperIontD7qGO8x9uXh5MXn3Gv28v/vtsa1WGclMc66/tu+R26y7wvebq2d/muSoqU8j9Wua6O+qvu01W8Z/4i75m/yHvmr7qGJCt/jU95r0oqC3oKRENZ4PHFdIHzJN6mmGmka/9kPuI07uNeHflZREbGC8pIjeqqoh9WVxf9UHNRmepw/uArR9B34euX0E7zVUlX5VbwHltZ9GtbPHeWfDaXKt1zxqXuuuV9rCq1Rd00n6RCcL+VAPTPXpCe7q68X8c9o3Uv0C/us7X9a6D1F+PT2l+G1r8AWh9DQD00pr7Y9U88Tl8DeB/E7/twmb7/MdD6YY6+f2Gi+/77AO/j6H3vtZbp++8CrV+OT2t3GVp/C2j9tfi0nixD628QfZHW0NKH4Lwko1fd4uIL+0HW/ivJP+oddSqvS+Vj81pZ5XWpfGyj1dP5D5XV9Od3XrL+/N5L1p+vvmT9+ZOXrD/feMn685cvWX/+9iXrz99vWH9qVIfPqPwtvgZB5S7ViBakMUY+Yq/ba/X7g/6wNxyfdofn6z6fejzqtM47p6fNznB0OrgYrxt/u9/vnbbPm92Ti+H4otu5Cr+t0XFfjXNMLMcF816wPee9WPt/B3/2P0DGnrcV+Hy7/w20K6R8PochfitPLv+G+SUqz8naT/djJvM0Wh3mL1QIj+1LIr8QltHBeUL/Q/uxuKdszzcE/juEX+VN4W9Z8qZUnpUfn/9KaFxXPkOV4ONvTJvJTgy9Gh73zofd40Fz1HquZuvW62eoT4aDk1brtNsadVvHWfX6Nu/v+vL+zAnwHwfVy20MZhHaVJP/15n310hw3ub9LVw2Ou+vAfL1g+sZ69u8P3eb96fkbVPz/tCu4/xnz7LN/mz1MhzFL5zDbC6a5s5A3Q7VYQ7eHtF7OJmnF2HVid5DotfmXiXzDYE/S15iKM/vQLQ/EO09eT9EPK2KZ3F8jafe1/k+C2xVyMr+AAA=","debug_symbols":"7Z3bjtw2s4XfZa59wUPxlFf5sRHk4D8wYNiB42xgI8i7b3X36ODp6qGHRbVVzXVjeGyVtPiNKK7FbpH/PP3+/te///j5w6f/fv7r6af//PP08fNvv3z98PnT9NM//757+vXLh48fP/zx8/afn8zpD5fPx//15y+fTj/+9fWXL1+ffkopu3dP7z/9/vRTttZNZ/jvh4/vn36yxvz7P++eXGko8qalyLYUuZYi31JELUWhpSi2FKWWIvaOsN5ReK6y3mfzTdm76+ONmy9iDa0XKYk5mIpJzwdTsXE5OAbm4EyUZ/kUaXvwSX3po76U+XBry93Uk+mjPuSFfa6wtyHN6m30/nX1JXh6PrhMdS/V297qrftG/eka7g7XYB8F031Q/FzkjLWVawSTzfPh019z5bYIdtafgzcvwbKPmZOItAryqSKo530avoOQLy8fLRTbylJbGfsgo2Tnrk2J1vs9ePY+iX59DqwH21DYrhSfD3Zmvae8s8yxqSw3bCplPdplYo72YX6Y0uYX5wx3rLPFzjKcKZWjg5tpbG+707EnggUEZQSDAUEhQQuCQoIOBIUEPQgKCRIICgkGEBQSjCAoJJhAUEgQmURKEJnkOwiWOelHG14SjMgkUoLIJFKCyCRSgsgkUoIEgkKCyCRSgsgkUoLIJFKCyCRSgsgkQoIJmURKEJlEShCZ5CXBExXkDI4KgQpDBXmAowKPz1GBb+eowItzVOCvGSoZnpmjAh/MUYG35ajA23JUaEwqLs8NdH6jY6YyqLetUBnU21aoDOptK1QG9bYVKoN629eplEG9bYXKoN62QmVQb1uhMqi3rVAhUGGowNtyVOBtOSrwthwVeFuOCrwtQ8UamFsWC9wtiwX2lsUCf8tiIWDhsAzqcJNdZKQX71K97egzxEEN8Zsg2hjnZV9sTPka4qD+uS/EQe12X4iDuvOuEO2gXv5tEFNaWpjK9ehsB3X+fSEOmhP6Qhw0VfSFSIAoh4jE0gEiEksHiEgsHSAisXSAiMQih+iQWDpARGLpABGJpQNEJJYOEAkQ5RCRWDpARGL5DojFLNszFMdARGLpALFDYrF52WbBUahADKEsGyaUsDnacOeOyw4daQPmdOaz+KJYvDeaxVvN4uuONKQHfHD0W57Veg+EUoQEhFKEAQilCCMQShEmIJQizEAoRViAUIiQDBBKEVoglCJEOhEjRDoRrpJpCelEjBDpRIwQ6USMEOlEjBDpRIwQ6USKMCCdiBEinYgRIp2IESKdiBESEEoRIp2IESKdMAvL2oDEwWJBimCxIBlwWL5j+9YhscDBs1jgylkscNosFgIWDgscMYsFLpfFApfLYhnU5VZWJouDutwKljSoy61hGdTl1rAM6nJrWAZ1uTUsBCwclkFdbg3LoC63hmVQl1vDApfLYoHL5bBkuFwWC1wuiwUul8UCl8tiIWDhsMDlsljgclkscLkslkFdbtftFPKgnrjr+utlUAfdF+KgfrsvxEHdeV+Ig3r5rmvIfccmp4BYhThoTugLcdBU0RfioBmkL0Qklg4QkVjEEJ1BYukAEYmlA0Qklg4QkVg6QCRAlENEYukAEYmlA0Qklg4QkVg6QERiEe8E4CwSSweIHRJL67r4MTtaj2bXxU9xfnknbablbcwX8U6zeK9ZPGkWzzvSbOYiypvFM26IX7q3tcl8cwlGTvaz+JSDXY6OgTuY1r0ggjHbg8/io2bxSbP4rFl8USz+xt6QSsRbzeKdZvFes3jSLF7zCOs0j7BO8wjrNI+wTvMI6zWPsF7zCOs1j7Be8wjrNY+wXvMI6zWPsF7zCOs1j7B07EdlcHER79KV+GN32GiXGbNor8Xfv8O6VXyMr4u30wT7Osld/Gbh23KZ8aOkXH9Wrr/o1h+Mcv1WuX6nXL9Xrp+U6w/K9Ssff4Py8TccevylVOKiw+dr9YcefWvq46HH3qr6Q4+8VfWHHner6g896lbVH3rMrapXPuJG5SNuVD7iRuWJNypPvEl54k3KE29SnniT8sSblCfedOjxt+Ye0qFH36r6Q4+9VfWqs25SnXWz6qybVWfdrHzEzcpH3Kx8xM3KE29Wnniz8sSblSferDzxFuWJtyhPvEX1XHNRPddcVM81F9VZt6jOukV11i2qs27RPeJ6o3vE9Ub3iOuN7sTrje7E682hR93v0K878XqjO/F6ozvxeqM78Xqjea7ZW81zzd5qnmv2VnPW9VZz1vVWc9b1VnPW9Vb5iGuVj7hW+YhrlSdepzzxOuWJ1ylPvE554v0Bi9r01a969HWaZ5q90zzT7J3mmWbvVCddrzrpetVJ99byNp6Wqo2gSf25yLcUUUsR/0AvbikqRK/DpWLScrCt4MpE86KnmSJtDz7L4Z/QxS7LA5dYWVY1+vkCMawLGpd4OX/a+fx55/OXfc9PZufz253P73Y+v9/5/LTz+cPO59+5/9LO/Zd27r+0c/8NO/ffsHP/DTv33yDvvy4ua3y7mNaD7WVBeR9o/0uE/S8R979E2v8Sef9LlN0vEc3+l7D7X8Ltf4n9e3fcv3fH/Xt33L93x51H6rjzSB13HqnTziN12nmkTjuP1Glnp512dtppZ6eddnbaaef+m+r9t+TXz29NifPcy/T3vJmnSJdrlP2vkc0drmHl17DOpmUKbLvdzGmbmqvDvaF5ds2b8M2czlmQO5ogfzRBdDRB4WiC4tEEpaMJykcTVO4vqMxHT59/1T6+NNPc/vIcdf5qdrkY5fqtcv1OuX6vXP/9B6Upp836J9dQ05/8shulSeFa//3HMFrWEJ/m5lNNfzarj8veXOm//5BHy7Lmk/5c019sWH1oyFf6k3L9Wbn+olo/GaNcv1Wu3ynX75XrJ+X6g3L9usdfMrrHXzK6x18yysdfq3z8tcrHX3uk5/9Z0JEe6GdBR3pCnwXd/5Eblu9e+lCNnHYKNcu5yfkr/Vm5/qJbvzPK9Vvl+ntEhunTnPUaxm31n69Bd7hGuMM14h2uwT5Pg4nzQziYUvm+uTVxmSWcrrccbEPhjg7zlJzbqPHOMsemsrwmkEpZj3anj2S5G3XmsvnWuzPcsc6WuYHOmVI5OixvYYXNJKK7fLOG+DdpgPAtCAsQChHy7xQB4VsQWiCUInRAKEXogVCKkIBQijAAoRRhBEIpQqQTMUKkk+9AuHyrJ25eXV8QIp1IERLSiRgh0okYIdKJGCHSiRghAaEUIdKJGCHSiRgh0okYIdKJGCHSiRRhQDoRI0Q6eYnwjAWJg8WCFMFiIWDhsMDts1jg4FkscOUsFjhtFgvcM4clwhGzWOByWSxwuSyWQV2uy8tKdH6jY8FCwMJhGdTl1rAM6nJrWAZ1uTUsg7rcGpZBXW4FSxrU5dawDOpya1gGdbk1LHC5LBYCFg4LXC6LBS6XxQKXy2KBy2WxwOVyWDJcLosFLpfFApfLYoHLZbHQmFiSXWSkFy9dve3oM8RBPfGbINoYl7WUY8rXEAd10H0hDuq3+0Ic1J33hTiol38bxJSWFqZyPTqXQZ1/X4iD5oS+EAdNFX0hDppB+kIkQJRDRGLpABGJpQNEJJYOEJFYOkBEYhFDDAaJpQNEJJYOEJFYOkBEYukAkQBRDhGJ5TsgFjN/2meLYyAisXSA2CGx2LxssrDdv4GHGEKZp9pDCZujDXfuWGb1aQPmdOaz+KxZfFEs3hrN4quO1Jr8gA+Ofuu4BuuAUIrQA6EUIQGhFGEAQinCCIRShAkIpQgzEEoRFiAUInQGCKUIkU7ECJFOhCtoBod0IkZIQChFiHQiRoh0IkaIdCJGiHQiRoh0IkXokU7ECJFOxAiRTsQIkU7ECAkIpQiRTpiFZoNH4mCxIEWwWJAMWCxw+xwWgoNnscCVs1jgtFkscM8sFgIWDgtcLosFLpfFMqjLfX1lskCDutwalkFdbgVLGNTl1rAM6nJrWAZ1uTUsg7rcGhYCFg7LoC63hmVQl1vDApfLYoHLZbHA5XJYIlwuiwUul8UCl8tigctlsRCwcFjgclkscLkslkFdbs/tFEIc1BP3XH89xEEddFeIaVC/3RfioO68L8RBvXzXNeTSoM6/L0QCRDnEQVNFX4iDZpC+EJFYOkBEYukAEYlFDjEjsXSAiMTSASISSweISCwdIBIgyiEisXSAiMTSASISSweISCzynQAyEoscYumQWH7YuvjFahbvNIv3msVTVbyLW/HnotBSFFuKUktRbikqby+K9T3muCLbUuRainxLEbUUhZai2FKUWopySxF/R9g8D5PB2VLr18vIZ21axycbMzdOZj/365SDXY6OgTs4Lqvophjz6wdPOso6uIdNW6fDT229sSXMYdpq7dJWm67EW83inWbxXrN40iw+aBYfNYtPdxfvVvHx+tGdD6anHEuPMwfTYw+mxx1Mjz+YHn6YcMu35IIr5gGnVvpt6RBvrAQPhG9AGIFQijABoRRhBkIpwgKEQoQ3VoIHwjcgtEAoReiAUIrQA6EUIQGhFCHSiXAx/eiRTsQIkU7ECJFOxAiRTqQICelEjBDpRIwQ6USMEOlEjJCAUIoQ6USMEOlEjBDpRIwQ6YTZcyISEgeHJSBFsFiQDFgscPssFjh4FgsBC4cFTpvFAvfMYoEjZrHA5bJY4HI5LHFQl/v62s0xDupya1gGdbk1LIO63BoWAhYOy6Aut4ZlUJdbwzKoy61hGdTl1rAM6nIrWBJcLosFLpfFApfLYoHLZbEQsHBY4HJZLHC5LBa4XBYLXC6LBS6Xw5Lhclksg7rcnvvwxTyoJ+65cVfMgzrovhAJEOUQB3XnfSEO6uV7Lj4e86DOvy/EQXNCX4iDpoquEMugGaQvRCSWDhCRWDpARGLpAJEAUQ4RiaUDRCSWDhCRWDpARGLpABGJRQwxGSSWDhCRWDpARGIRbyGXDBJLB4gkh/ijNlRLJmgWHzWLT5rFVx2pP/Wlh3tw9FvHNZkChEKE1gChFKEFQilCB4RShB4IpQgJCKUIAxBKEUYglCJMQChFiHQiRoh0IlxBMzmkEzFCpBMxQqQTMUKkEzFCAkIpQqQTMUKkEzFCpBMxQqQTMUKkEylCj3QiRoh0IkaIdMIsNJs8EgeLhYCFw4JkwGKB22exwMGzWODKWSxw2hwWgntmscARs1jgclkscLksFhoTy+srkyUa1OXWsAzqcmtYBnW5NSyDutwalkFdbgVLGNTl1rAM6nJrWAZ1uTUsg7rcGhYCFg4LXC6LBS6XxQKXy2KBy2WxwOVyWCJcLosFLpfFApfLYoHLZbHQmFh6bqeQ4qCeuOf66ykO6qD7QhzUb/eFOKg77wtxUC/fdQ25NKjz7wtx0JzQF+KgqaIvxEEzSF+IBIhyiEgsHSAisXSAiMTSASISSweISCxyiBmJpQNEJJYOEJFYOkBEYukAkQBRDhGJRb4TQEZi6QCxQ2JpXRc/Zreeml8XP8X55Z20mZa3MV/EZ83ii2LxxWgWzztSH9MivlTFL93b2mS+uQQjJ/tZ/PTot8vRMbDal6VCp4+R8+sHTzrK+gSb+G8PP7fVHbut5Na2pivxfqBfFN29rW5ta4wV+dMYto4jxW/WlinPnSoo1x+V60/K9Wfl+otq/fnGXoN69Nsj66fp+TI7/OzztXqnWr1Xrf7QI29V/aHH3ar6Q4+6VfWHHnOr6vkRl9yinsI36s9FpaHoxs5hlSLbUuRainxLEd0oiktRdldFfGcNZonNga6vFFuKUktRbini74hoF3oxmpdFN3ZrqBTZliLXUsTfESEtm3jEzTwd37HJzHMQdrqTKh07ezufOntXKmZo3UzETjfccrD35aKe7q3eZbeo38z7sOqn5878xJt6Xs332Wjc8nyM5F/E5nxjnfZkl1s2Ufn38SaB+20+k2+s0w6Eb0CYgFCKMAOhFGEBQiHCG+u0A+EbEFoglCJ0QChF6IFQipCAUIoQ6USMEOlEuO1H9kgnYoRIJ2KESCdShIR0IkaIdCJGiHQiRoh0IkZIQChFiHQiRoh0IkaIdCJGiHQiRoh0wuyOkwMSB4sFKYLFgmTAYoHbZ7EQsHBY4MpZLHDaLBa4ZxYLHDGLBS6XwxLhclksg7rc11eZz3FQl1vDMqjLrWEhYOGwDOpya1gGdbk1LIO63BqWQV1uDcugLreCJQ3qcmtY4HJZLHC5LBa4XBYLAQuHBS6XxQKXy2KBy2WxwOWyWOByOSwZLpfFApfLYhnU5fbcMTTnQT1xzy0Gcx7UQfeFOKjf7gtxUHfeF+KgXr7nNgk5D+r8+0IcNCd0hVgGTRV9IQ6aQfpCRGLpABGJpQNEAkQ5RCSWDhCRWDpARGLpABGJpQNEJBYxxGKQWDpARGLpABGJpQNEJBbxZpfFECDKIXZILK1bP4YSNkezWz/GsmzKtwFzOvNZfNQsPmkWnzWLrzvS6LfiT0XWtBTZliLXUuRbiqilKLQUxZai1FKUW4pa7gjXcke4ljvCtdwRruWOuLHZTHZzVw05Uq1f69ijtdzYbOYwbbXLrsfRpivxUbP4pFl81iy+KBZ/YzsPJeKtZvHu7uJvbo141uMPpocOpiccTE88mJ50MD35YHr4YWIKDGsGSy+94431zCtFtqXItRTdeGakZYvPYn2F8Q/bBbLcWCB5R/U/bBfIcmMl45Jn+dEY+3pbaZpemWfUiq0IykRzP8sU6UoO//AqsSxyXHhdTvTzBWJYm1vi5fxp5/Pnnc9fxOd3cekqLqbNrfk8S3lj4dKul7D7X8Lt+4u4sTJlv/PTzucPO59/544cdu7IYeeOHMq+549m5/Pbnc+/c/+NO/ffuHP/jTv33xh3f0THtP8l8v6X2H9ETvuPyGn/ETm5/S/h978E7X+JsP8l9u/daf/enfbv3Wn/3p13HqnzziN13nmkzjuP1HnnkTrvPFLnnZ123tlp552ddt7ZaZed+2+p999Ym42KNE9dnd6+XQ6m5yu43a/gd78Cya9gnU3LXNn2azKnCc6rw6eJunmOzJtwNa1bwtEExaMJSkcTlI8mqBxLkDXGHE6RPZwid39Fyw5d3qXaRwJm+shqPrdxnq4b4LU3gLQ3IGhvQNTegPsPTj7OLtD77GoNSH75wp1JgWnA/QczWr4E44lSrQHZLH7O5M1365cG3H/wo+WLOVMDal95NMUuXwIw0+cFVw2wRnsDrPYGOO0N8NobQNobELQ3IGpvQNLegKy9AdpHYqd9JHbaR2KnfSR22kdip30kdkcaBy6KjvRgvyg60pP6rMjf/9Eb3PzVZB+qMdT6srwZa8n56wZY7Q1w2hvgtTeAtDegR4bwmdaLbNZ0mBpwuUi6x0XyPS5S7nAR/mUOyst7B5RtqF1kv3fcgptn96a/pqs7in+r5DDqY5g7W4qRUe+PrZ7cq+rp2Oo7vnc+NTYcu7GvvQo6qY+q1SfV6rNq9UWzev4dJDXqjz0019QffGiuqD/40Py6ev5lgtP02TI1Elf1z+uKTZ//mrYy9j6drKdZnWdmylxbmW8ro7aywJfF9W3YzCFhH/pTQFrC15SVmLLSVMZ/9bteZtvKXFuZbyujtjL+9xaWV+jtNs+uZbGtLLWV5bay0lTGf8G4Xmbbyvi7JMT1lflcmDLfVkZtZaGtLLaVpbay3FZWWsqsufFQWJek9C4zZa6tzLeVUVtZaCuLbWWprSy3lZWmMmvaytruEtt2l9gbdwktU1s+JKaM2spCW1lsK0ttZbmtrDSVuSaDYZ1tK3NtZb6tjEWS1rkvitdF/Ich6/rB2w8e1yLfUkQtRaGlKLYUpZai3FLUlGksmbYy21bm2sp8Wxm1lYW2sthWltrKcltZ210S2u6S0HaX8JMLlUcOv5LLumZScVxRy4OAX7OkdqXSUMSvLlIrsi1FLQ/s2PLAji0PbH4ZjrLMMpTE3Eb82hq1otRSVHtgs0WlAQQ/BVUrsi1FLXdEarkjUssdkVp6bmoZwlPLEJ5ahvDUckfcmFuJ6/cY4qbDP6+9d1qovq2sVMs2b/ksZTfmVqpltq2MbxutLp62Lj7G57LSUub4dzXrZbatzLWV+bYyuvELKOtdsv4CaK4KTVWxqaq0VN0I2q+++z5V+aaq1KQwN1U10XCmqco2VbmmKt9U1XT3uqa71zXdva7p3nC55T50paXKm6Yq21TV1Ct9U6/01FQVmqpiU1Vqqbox965xU6hp+J9lTI/5ytHrWsPhxQZSFywJWDgsGVg4LAVYrrH4G053eCwWWDgsDlg4LB5YOCwELByWACwcFrhcFsuoLnf5DDvawGAZ1eVWsIzqcl/HYkd1uRUso7rcCpZRXW4Fy6gut4KFgIXDMqrLrWAZ1eVWsMDlsljgclkscLkcFjeEy700dQjnemnqEG700tQhHOalqTROU4dwgpemDuHuLk0dwrFdmjqEC7s0dQhndW6qH8ct+XHckn8ct+Tysvmd3+hYm/o4bqnaVBqnqY/jlqpNfRy3VG3q47ilalMfxy1Vm/o4bqnWVHoct1Rt6uO4pWpTx3FLNI5bonHcEo3jlmgct0TjuCUaxy3ROG4pjOOWwjhuKTyOW0p2kZFefOv4bUdfwDyOt3oTmNPbmnMLY8oMGAIYHszj+LbOYB7H5XUG8zie8G1gUlpamAo3Kj2Og+wM5nH8Zl8w8XHcaWcwj+NlO4MZ1PnWwYzqfKtgCGB4MKM63yqYUZ1vFQyc7w0wcL43wMD58mASnO8NMHC+N8DA+d4AM6rzLevOHcVxYAhgeDA39hXLyw7K282ZT2AuZbGtLL217LpJIZR5UjLmzaKd1nCb36W4bFC3mcA8bX13FnRjx7JaO27sWFYto7aytt/RjZWna2WlrW039tmqlrW1rTS2rbSUkXFtZb6tLLaVpbay3FbWRtKatjJ7rOcGWXc0Qf5ogsrBBDlzNEFHu6ndwUZncvlogo52U/twNEHxaIKOdlPT0Z7UREcTdLSbOhztSR2OZj/C0W7qcLQndTya/YhHu6nj0Z7U8Wj2Ix7tpk5He1Kno9mPQ814/Tv9+L+/fPnwy68f3/81lZz+9+9Pv3398PnT849f/+/P+X9+/fLh48cPf/z855fPv73//e8v73/++Pm30/89mec//mOppHc22Dw19WQibHBh+jmb6efTnTG1zbyzrtAJxbnATHOo06yrPf2DvZyB3k1/xEnbpO//AQ==","names":["_repay"],"brillig_names":["_repay"]},{"name":"_liquidate","hash":"9601692889037806180","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debt_token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"user","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debt_to_liquidate_amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"1840251649407153602":{"error_kind":"string","string":"Insufficient borrowed amount"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14434150440419769526":{"error_kind":"string","string":"collateral >= debt"},"15333773746166717806":{"error_kind":"string","string":"Insufficient collateral"},"16523063005220065570":{"error_kind":"string","string":"Function _liquidate can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_liquidate"],"brillig_names":["_liquidate"]},{"name":"borrow_private","hash":"5990837159010202138","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","names":["borrow_private"],"brillig_names":["discover_new_messages","decompose_hint","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","store_in_execution_cache_oracle_wrapper","call_private_function_internal","directive_invert"]},{"name":"deposit_public","hash":"6236631132068823921","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"field"},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["deposit_public"],"brillig_names":["deposit_public"]},{"name":"get_total_deposited_assets","hash":"11477870056684752501","is_unconstrained":true,"custom_attributes":["utility","view"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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6HGzYuhxs2LocbNS6ANuVgw9blYMPW5WDD1uVgy9nxm98xt6l2Lt6JhX8u62sPoE3txRTu1O26Kc2m22RTm1e2yLcmo32Bbl1O6uKco4tVtri3Jq99UW5dRuqi3Kqd1RW5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKhNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKjNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKgttphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxHKvOB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFsuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mEsiy4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4nZaoTS4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4na+i9K7xX4c7V2In1DujMSnFYkJ5mkkeW/ccckfB0f79Mk5/BbJ4qM6EAmH1oFIeL8ORMJVdiCSRyT9IuGEOxAJj92BSLj3DkQiF+hAJBIH/SI5EocORCJx6EAkEocORJo7ccjr0c7b8Ono33A8cI7hzO2wK3DmdrYVOHM7ygqcuZ1cBc7cDuocjp/buVTgzO0YKnDm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","names":["get_total_deposited_assets"],"brillig_names":["get_total_deposited_assets"]},{"name":"withdraw_private","hash":"18339564046988728698","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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dcNs3TCqG+bqhvm6YaFuWKwbVpclui5LdF2W6Los0XVZouuyRNdlia7LEl2XJbouS3Rdlpi6LDF1WWLqssTUZYmpyxJTlyWmLktMXZaYuiwxdVli67LE1mWJrcsSW5clti5LbF2W2LossXVZYuuyxNZlCdVlCdVlCdVlCdVlCdVlCdVlCdVlCdVlCdVlCdVliavLEleXJa4uS1xdlri6LHF1WeLqssTVZYmryxJXlyW+Lkt8XZb4uizxdVni67LE12WJr8sSX5clvi5LfF2WhLosCXVZEuqyJNRlSajLklCXJaEuS0JdloS6LAl1WRLrsiTWZUmsy5JYlyWxLktiXZbEuiyJdVkS67Ik1mVJqsuSVJclqS5LUl2WpLosSXVZkuqyJNVlSarLkrreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qut6rruu96rreq67rveq63quu673qk95r2r9hqBPpzLCTLNm39NMpmW/Dclv5Mh0UcgsnjBVOHCucNFQ4Z73tXuHoscIxY4VjxwqHxgrHjRXOWHflONZdOY51V45j3ZXTWHflNNZdOY11V05j3ZVT67vyyzOubvG4weLxg8UTBosnDhZPGioek3+Ca26l69cwY7QrxHNz6GoP34c/dy+4vYlu8SamxZtYljex/vEm3h7eJPOLvGi3jYGsOu77pPLbqap9zzVlH7+9T+Yrfho8frfz987a5/id8Pi98PiD8Pij8PiT7Pi1Eh6/Fh6/ER7/6OtvKX7h668Wvv5q4euvFr7+auHrrxa+/hrh668Rvv4a4euvEb7+GuHrrxG+/hrh668Rvv4a4euvEb7+WuHrrxW+/lrh668Vvv5a4euvFb7+WuHrrxW+/lrh668Vvv6S8PWXhK+/JHz9JeHrLwlff0n4+kvC118Svv6S8PWXhK+/Tvj664Svv074+uuEr79O+PrrhK+/Tvj664Svv074+uuEr79e+Prrha+/Xvj664Wvv174+uuFr79e+Prrha+/Xvj664Wvv0H4+huEr79B+PobhK+/Qfj6G4Svv0H4+huEr79B+PobhK+/Ufj6G4Wvv1H4+huFr79R+Pobha+/Ufj6G4Wvv1H4+huFr79J+PqbhK+/Sfj6m4Svv0n4+puEr79J+PqbhK+/Sfj6m2Svv1bJXn+tkr3+WiV7/bXD739Vil/2+muF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/ZYXvf2WF739lhe9/RcL3vyLh+1+R8P2vSPj+V6Rkr78kfP8rGn7/q8dL+5D0Mf7cxVvUPvrHC0f3NdfR12rOuY6+rnPOdfQagHGuw+/XxTnX0WsLzrkOXoe45OJjrub1XCmkLQ6KNu4XmxSzYeuwR21pv9ra9MVm8BqnKxsCm1M2g9dmwZH5ujp45V+zsXa71tIh6NylzrstZBfU4eJf9d9zzCntr6xU/Hb1HePgJaIUjINXn1IwDl7YSsE4eM0sBOPo2/dJwTh4pS8F4+AmQgrGwf2GFIwEjBwY4WJYMMLFsGCEi2HBCBfDghEuhgPj6JugSsEIF8OCES6GBSNcDAtGAkYOjHAxLBjhYlgwwsWwYISLYcEIF8OBcfStpKVghIthwQgXw4IRLoYFIwEjB0a4GBaMcDEsGOFiWDDCxbBghIvhwDj6hvxSMMLFsGCEi2HBCBfDgpGAkQMjXAwLRrgYFoxwMSwY4WJYMMLFcGAc/VgTKRjhYlgwwsWwYISLYcFIwMiBES6GBSNcDAtGuBgWjHAxLBjhYjgwjn44lBSMcDEsGOFiWDDCxbBgJGDkwAgXw4IRLoYFI1wMC0a4GBaMcDEcGEc/Yk8KRrgYFoxwMSwY4WJYMBIwcmCEi2HBCBfDghEuhgUjXAwLRrgYDoyjH1QqBSNcDAtGuBgWjHAxLBgJGDkwwsWwYISLYcEIF8OCES6GBSNcDANGN/pxz1IwwsWwYISLYcEIF8OCkYCRAyNcDAtGuBgWjHAxLBjhYlgwwsVwYBz9EHopGOFiWDDCxbBghIthwUjAyIERLoYFI1wMC0a4GBaMcDEsGOFiODAauBgWjHAxLBjhYlgwwsWwYCRg5MAIF8OCES6GBSNcDAtGuBgWjHAxHBgtXAwLRrgYFoxwMSwY4WJYMBIwcmCEi2HBCBfDghEuhgUjXAwLRrgYDowEF8OCES6GBSNcDAtGuBgWjASMHBjhYlgwwsWwYISLYcEIF8OCES6GA6ODi2HBCBfDghEuhgUjXAwLRgJGDoxwMSwY4WJYMMLFsGCEi2HBCBfDgdHDxbBghIthwQgXw4IRLoYFIwEjB0a4GBaMcDEsGOFiWDDCxbBghIvhwBjgYlgwwsWwYBzcxbjk4oYx6lTAGOJ2sY2HsEmpXNhktkA0hYdCMeZeWke1vbROj4uNz0Vtldmxa3pgtzoXSNSevq6O5iCSiZS5moKyX1dT+JUi22s7/yXp4I4Kkn4uKUHS2SQd3GlC0s8lHdz1QtLPJR3cgUPSzyUdvBsAST+XdPDOBCT9WNI4eJcEkn4u6eAdG0j6uaToHk0nKbpH00lKkHQ2SdE9mk5SdI+mkxTdo/ckJZ22l6ZoCpI6pfcnoIrCY44bdTR4elBHD6YD9YQ2SQ/q6GT0oI5mQw/q6Af0oE6g3oE6XHUP6jC+PajDm/agDm/ag/pQ3vRXSF4NZdzuIQ3lau4hDVXy30Maqh6+h0TjhTRUJXUPaagy4x7SUGvwPaShFqh7SOPdvfV4d2893t1bj3f31uPdvfV4d++xzri/hzTe3Xuss9fvIY139x7rTPDfIY11vvY9pPHu3mOd+3wPaby791jnEd9DGu/uPdY5ufeQxrt7j3V+6z2k8e7eY50reg9pvLv3WOdd3kMa7+491jmM95DGu3uPdT7gPaTx7t5jnVt3D2m8u/dY56ndQxrv7j3WOV/3kMa7e491/tQ9pPHu3mOdi3QPaby791jn9dxDGu/uPdY5MveQxrt7j3W+yT2k8e7eY527cQ9pvLv3WOdB3EMa7+491jkF95DGu3uPtX/+PaTx7t5j7et+D2m8u/dY+43fQxrv7j3WPtj3kMa7e4+1P/M9pPHu3mPtG3wPaby791j72d5DGu/uPdZ+oveQxrt7j7Wf4z2k8e7eY+2ndw9pvLv3WPuZ3UMa7+491n5S95DGu3uPtZ/PPaTx7t5j7adyD2m8u/dYm2XcQxrv7j3WNgv3kMa7e4/1A/17SOPdvcf6afc9pPHu3mP9KPge0nh377F+TnoPabi7dxjvt5ZhvN9ahvF+axnG+61lUMPdvcN4v7UM4/3WMoz3W8sw3m8tw3i/tQzj/dYyjPdbyzDeby3DeL+1DOP91jKM91vLMN5vLcN4v7UM4/3WMoz3W8vA9AMiFR4h6XAI6febfP5jl/swWzeM6oa5umG+blioGxbrhqWqYZ//GOA+TNcNq8sSqssSqssSqssSqssSqssSqssSqssSV5clri5LXF2WuLoscXVZ4uqyxNVliavLEleXJa4uS3xdlvi6LPF1WeLrssTXZYmvyxJflyW+Lkt8XZb4uiwJdVkS6rIk1GVJqMuSUJcloS5LQl2WhLosCXVZEuqyJNZlSazLkliXJbEuS2JdlsS6LIl1WRLrsiTWZUmsy5JUlyWpLktSXZakuixJdVmS6rIk1WVJqsuSVJclqSpLolJ1w3TdMFM3zNYNy2YJ+X3Yt2NxHsNcfph+DDPqv173BG7v/XVxtI9tam/tiMy1KW4NjZS+X3sPx48VThgrnDhWOGmocPIPJ/qFo8cKx4wVjh0rHBornLHuynqsu7Ie666sx7or69Z35f2YPq2UeY7HqMHi0YPFYwaLxw4WDw0Wz8f35vswXzcsVA1j2gXv5aO+yLSvXeFNbIs3oRZv4lq8iW/xJjzfACD9eBOXDm/y2ZPwe0hxvJDScCEx7fj2QUik03YuDZnnTGLa740xIDNaQM2/uVVaANtv9VaMyA0XkR8uojBcRHG4iNJoEbXf5K0YkR4uIjNcRMPds91w9+wO+7s5pbbXdpRKr53c/tIp6sME6GsCfvAJxGS3q5X9PoGMQzZ6t8jGla6+PZPcvmp6exZnCldbZ7YCR/vHtSp3rdHpwU+lb1ffsQdg74E9AnsP7AnYO2DvsDsjsN+wa2Dvgd0Aew/sFth7YCdg74F9dL83KXa41C7Y4VK7YIdL7YIdLrUH9gCX2gU7XGoX7HCpXbDDpXbBTsDeAztcahfscKldsMOldsEOl3oFdhPTFrU9fuNkxw6X2gN7hEvtgh0utQt2uNQu2OFSu2AnYO+BHS61C3a41C7Y4VK7YIdL7YIdLrUH9gSX2gU7XGoX7HCpXbDDpXbBTsDeAztcahfscKldsMOldsEOl9oFO1xqB+xJwaV2wQ6X2gU7XGoX7HCpXbATsPfADpfaBTtcahfscKldsMOlXoE96A2ICVZlsMOl9sCu4VK7YIdL7YIdLrULdrjULtgJ2Htgh0vtgh0utQt2uNQe2E37e3u022St0rbw2i657aSMqNLj6hule/xOePxeePxh7Pi924818s5m4o/C40+y47dKePxaePxGePxWePyDr7/F+Adff4vxD77+FuMXvv5a4euvFb7+kvD1l4SvvyR8/SXh62/7gw2Z4xe+/pLw9ZeEr78kfP0l4euvE77+OuHrrxO+/rrB199D/9DHkIl/8PW3GL+c/nM+fjn953z8g6+/xfgHX3+L8Q++/pbi94Ovv8X4B19/i/EPvv4W4x98/Q2OtqfFwSt/jD/zZNlu11o6BJ271Pn9qGQX1OHiXzXKc8y3p9p7zCp+u/qOcfDbyBgYrUrbd87tNx7Zq8MecdivpC/eYfDb3nS8B79NT8d78GVlOt5YBtvyJvBuyntwmz8d78HbEtPxHryNMh3vwds+0/GGv2zKO8JftuUNf9mWN/xlW97wl215E3g35Q1/2ZY3/GVb3vCXbXnDXzblnUavB030e/SH82mzvPWN3BZH8IcfRtvsE3K1/S7akfp27Z3M6JVbPzIEMidkRq+G+pEZvW7pR2b0CqMfmdFrgX5kRu8KdyLjlRq9f9uPzOid1n5kFq6B/bbbz816Fa4l4zaM9HuDn4PpuHNcdyWL+8XH79rmrzXWbBcbIjEbMun0kPEA72tDppv6667WUF+pdSsSqK/0ulUX1Fd63coS6iu9bvUM9ZVet0sO9VWHDbah/jjqr/u0A+orve4THaivNHp9K6uPXt/K6qPXt7D6Br2+ldVHr29l9dHrW1l99PpWVp+g/sLqo9e3svro9a2sPnp9K6uPXt/K6qPXN7H6Jm4/IzVWmWf1Rz/kEOpfqj56fSurj17fyuqj17ey+gT1F1Yfvb6V1Uevb2X10etbWX30+lZWH72+hdUf/UB1qH+p+uj1raw+en0rq49e38rqE9RfWH30+lZWH72+ldVHr29l9dHrW1l99PoWVt+h17ey+uj1raw+en0rq49e38rqE9RfWH30+lZWH72+ldVHr29l9dHrW1l99PomVj/oDZ4JVj2r79HrW1l99PpWVh+9vpXVR69vZfUJ6i+sPnp9K6uPXt/K6qPXt7L66PWtrP66vb5ktjkm5wrXOhX2g8+1OubK11nmYd2uGS/HdftPvBzX7eTwcly4JxLtdrFSvrQ8ar8vj8YGKctjaTvbQJB/ZfkX7opAfhUWbotAfhUW7otAfhUWboxAfhUW/hYU5Fdx4a9BQX4VF/4eFORXceEvQkF+FdH1W1p+gvwry4+u39Lyo+u3tPzo+i0tP7p+S8uPrt/K8id0/ZaWH12/peVH129p+dH1W1p+gvwry4+u38zylza9Sej6LS0/un5Ly4+u39Lyo+u3sPy3iUP+leVH129p+dH1W1p+dP2Wlp8g/8ryo+u3tPzo+i0tP7p+S8uPrt/S8qPrt7L8Gl2/peVH129p+dH1W1p+dP2Wlp8g/8ryo+u3tPzo+i0tP7p+S8uPrt/S8qPrt7L8Bl2/peVH129p+dH1W1p+dP2Wlp8g/8ryo+s3s/yFo+60QddvafnR9VtafnT9lpYfXb+V5bfo+i0tP7p+S8uPrt/S8qPrt7T8BPlXln8q3+8N7fKHoqJJbVeb5GzhalJqyxZSdEyt+1nomqZaRj8iaZXSeyCxyN2a/ZNEpKV8kgo7ZGqaah2F/h/rP9VCCv0/1n+q52fQ/2P9p3qABv0/1n/dShr6/9J/qkdo0P9j/ad6hgb9P9XfTfUQDfp/rP9UT9Gg/8f6o/+3tv7o/62tP0H/pfVH/29t/dH/W1t/9P/W1h/9v7X1R/9vaf09+n9r64/+39r6o/+3tv7o/62tP0H/mfUv7Z/h0f9bW3/0/9bWH/2/tfVH/29t/dH/W1r/gP7f2vqj/7e2/uj/ra0/+n9r60/Qf2n90f9bW3/0/9bWH/2/tfVH/29t/dH/W1r/iP7f2vqj/7e2/uj/ra0/+n9r60/Qf2n90f9bW3/0/9bWH/2/tfVH/29t/dH/W1r/hP7f2vqj/7e2/uj/ra0/+n9r60/Qf2b9SydpJfT/1tYf/b+19Uf/b2390f9bW3/0/1bW3yj0/9bWH/2/tfVH/29t/dH/W1t/Wld/reIWiHahcDWFtAVCkdThavtFcuFOGjPJhXtSzCQX7u4wk1y4T6LDTtKYEkmj/b5OGhukrJOFfXJv/x/0X1l/vXCfBPrf9F+4TwL9b/ov3CeB/jf9F+6TQP+b/gT9l9Z/5e4O9L/NCvovrf/KnTTofxMa+i+tP/p/S+tv0P9bW3/0/9bWH/2/tfVH/29t/Qn6L60/+n9r64/+39r6o/+3tv7o/62tP/p/S+tv0f+bWv/CPjnGov+3tv7o/62tP/p/a+tP0H9p/dH/W1t/9P/W1h/9v7X1R/9vbf3R/1taf0L/b2390f9bW3/0/9bWH/2/tfUn6L+0/uj/ra0/+n9r64/+39r6o/+3tv7o/y2tv0P/b2390f9bW3/0/9bWH/2/tfUn6L+0/uj/ra0/+n9r64/+39r6o/+3tv7o/y2tv0f/b2r9S+fkefT/1tYf/b+19Uf/b239CfovrT/6f2vrj/7f2vqj/7e2/uj/ra0/+n9L6x8G9/8uuU2kEHVBfxvirmg8hE1K5cK2NmxR3y7fr44xczHZTU+KBx5OfWEc3EZLwUjAyIFxcFMnBePg3kgKxsEthhSMg1fqo2B0bpuh8zmMgxe8QjDGwZ8bD4MxqA1jSBmMgz9+lYIRLuY9jGlbYryyGYxwMSwYCRg/xKh1BiNcDAtGuJi3MPqwAfFRZTDCxbBghIt5D2PcgvaJMhjhYjgwJriYtzDenrxsYeiYwQgXw4IRLuZTjMZnMMLFsGAkYOTACBfzHsa0BR1VbqWGi2HBCBfzFsa4f6hjdqWGi2HBCBfzHkZrN4xknjBaBRfDghEu5lOMTmUwwsWwYISLeQtj0tu1KVN+W0XAyIERLuY9jHYDkkhnMMLFsGCEi3kP4/4dnuRzH2q4GBaMcDGfYgzPrQmr4WJYMMLFvIVRK7d9pewWaKYA1/AxTCAXdjJktkA0HX6QlgVpddxAWp0eFxufi/pWSz7mePhO5O0+mg1bbV8SsuFQUv26+i4SQaTxRVrYhckRaWGPJ0ekhR2kHJEW9qdyRFrY/YoRySzsreWItLBzlyPSwl0BOSKh4yBAJIJI44uEjoMAkdBxECASOg4CRELHQYBI6DiML5JFx0GASOg4CBAJHQcBIqHjIEAkgkjji4SOgwCR0HEQIBI6DgJEQsdBgEjoOIwvEqHjIEAkdBwEiISOwyUiGbNfTbEgUtT+cYCMelydPxKGgtp+TE5BP/Y2sM5/SYr+xHSSEiSdTVL0PqaTFJ2S6SRFX2U2SR28ozhJ940Ob3/6jKSoeKVJGtX2q3O6XZ6RlCBpd0lHOdhUp4fqh3Nht4NNrUMtjWR5O1lQpSNZ3k4W1P9IlreTBc93kSxvJwueMyNZ3k0Wj54FkuXtZMFzdyTL28mC5/9IlreTBX1WJMvbyUJIFiTLu8mCDi6S5e1kQQcXyfJ2sqCDi2R5O1nQwUWyvJ0s6OAiWd5NloAOLpLl7WRBBxfJ8nayoIOLZHk7WdDBRbK8nSyEZEGyvJss6OAiWd5OFnRwkSybMsY+VCeTSRZ0cJEsbycLOrhIlneTJaLPgmR5O1kIyYJk+VIm6E1GE6zKJAvcEJLl7WSBG0KyvJ0scENIlreTBW4IyfJ2suD7LEiWd5Ml4fssSJa3kwV9FiTL28mC77MgWd5OFnyfBcnydrIQkuWtZDFm25zP2hgLySLmSwcJPdml5UeXdWn50TddWn50QpeWH73NheW/gYH8K8uP/uPS8qOjuLT86BEuLT9B/pXlR9dvafnR9VtafnT9lpYfXb+l5UfXb2X5Nbp+S8uPrt/S8qPrt7T86PotLT9B/pXlR9dvafnR9ZtZfhPTpqNVJiM/un5Ly4+u39Lyo+u3svwGXb+l5UfXb2n50fVbWn50/ZaWnyD/yvKj67e0/Oj6LS0/un5Ly4+u39Lyo+u3svwWXb+l5UfXb2n50fVbWn50/ZaWnyD/yvKj67e0/Oj6LS0/un5Ly4+u39Lyo+u3svyErt/S8qPrt7T86PotLT+6fkvLT5B/ZfnR9VtafnT9Zpa/cJQTEbp+S8uPrt/S8qPrt7L8Dl2/peVH129p+dH1W1p+dP2Wlp8g/8ryo+u3tPzo+r0nP9ldfoq6IL/Var9a04FfFl+gDbYO/nBxyFx8s+pf13pnj5fe1UQTbyY10ZOTpeYujD8sELuaaLEJU1NtONTzZ9OjY/ammjo91DQFNZ3ayxWnKBzVvFNHo6oHdfSHelBHW6YHdQL1DtTRhOhBHd6/B3V49B7U4aV7UIfn7UA9wJv2oA5v2oM6vOkF1CmluFN36b9edtVunc2ti32zT+pZIhjZ4SUiSDS6RLDIw0sEPz28RDDfw0sEpz68RLD1o0sU0QMYXiI0DIaXCN2FsSSyzxKhuzC8RASJRpcI3YXhJUJ3YXiJ0F0YXaKEiq5CIl+QSNP+LWxNNr6WyCvaXtqrpF5frG9XbFff/nb+WVEUgLMpSlB0MkVRXs6mKKrR2RRF8TqboniSJlrR9KwoHrzNpahTeE43m6J4rDebougZzaYoekaTKWpWXkdVPFH0jmblBamAZuU7ewHNVLfI6GhHE1QJjVbb1i9aHyZpde5q0vt2bESPa7OvfOFGbzo9hFHp29V3PQl6TqXnVC116GmmaqhDTzNVOx16mqma6dDTTNVKh552qgYA9LRTdS2gp52q1QI9LfpDc+lJ0HMqPdEfmktP9Ifm0hP9obn0RH9oLj3RH5pKT0J/aC490R+aS0/0h+bSE/2hufQk6DmVnugPidLTxO0L0MYqk9ET/aG59ER/aC490R+aS0/0h6bS06E/NJee6A/NpSf6Q3Ppif7QXHoS9JxKT/SH5tIT/aG59ER/aC490R+aS0/0h6bS06M/NJee6A/NpSf6Q3Ppif7QXHoS9JxKT/SH5tIT/aG59ER/aC490R+aS0/0h6bSM6A/NJee6A/NpSf6Q3Ppif7QXHoS9JxKT/SHROkZ9EbaBKsyeqI/NJee6A/NpSf6Q3Ppif7QVHpG9Ifm0hP9obn0RH9oLj3RH5pLT4KeU+k5V38o7S+dDBX0tPsr0yGM/AGs2Us1pS+IUzVlkt0+FKR8CWI0ers6GqcLqdtxo604VaNlUo2map5MqtFUDZE5NUpTNTkm1WiqxsWkGk3VjJhUo6kaDJNqRNBoeI2magRMqhH6DONrhD7D+BqhzzC+RugzjK6RV+gzjK8R+gzja4Q+w/gaoc8wvkYEjYbXCH2G8TVCn2F8jdBnGF8j9Bm6a1T4gaRX6DMMr5FGn2F8jdBnGF8j9BnG1wh9hvE1Img0vEboM4yvEfoM42uEPsP4GqHPML5G6DMMr5FBn2F8jdBnGF8j9BnG1wh9hvE1Img0vEboM4yvEfoM42uEPsP4GqHPML5G6DMMr5FFn2F8jdBnGF8j9BnG1wh9hvE1Img0vEboM4yvEfoM42uEPsP4GqHP0F2jwsbB3qLPMLxGhD7D+BqhzzC+RugzjK8R+gzja0TQaHiN0GcYXyP0GcbXCH2G4TVyQ9V195CGKmPuIfVdtW0pk3Xck1NHio/kNF/xO+Hxe+HxB+HxR+HxJ9nxeyU8fi08fiM8fis8fuHrrxe+/nrh668Xvv564euvF77+BuHrbxC+/gbh628Qvv4G4etvaL7+Wm23k5KtTqrw2saabbaGqNQuErP5Z/DA3gN7APYe2COw98CegL0D9qiAvQd2Dew9sBtg74HdAnsP7ATsPbDDpXbBDpfaBTtcahfscKldsMOl9sCe4FK7YIdL7YIdLrULdrjULtgJ2Htgh0vtgh0utQt2uNQrsJe2v0hwqV2ww6V2wB4UXGoX7HCpXbDDpXbBDpfaBTsBew/scKldsMOldsEOl9oFO1xqF+xwqT2wa7jULtjhUrtgh0vtgh0utQt2AvYe2OFSu2CHS+2CHS61C3a41C7Y4VJ7YDdwqV2ww6V2wQ6X2gU7XGoX7ATsPbDDpXbBDpfaBTtc6hXYCxvRBwOX2gU7XGoP7BYutQt2uNQu2OFSu2CHS+2CnYC9B3a41C7Y4VK7YG/vUo2xG3YTTQm79jt2Y4MU7IWfA4f2x7ID+y/sCdg7YG9/eDqw/8Kugb0HdgPsPbBbYO+BnYC9B3YH7D2we2DvgR0utQt2uNQu2OFSe2B3cKldsMOldsEOl9oFO1xqF+wE7D2ww6V2wQ6X2gU7XGoX7HCpXbDDpV6BvfSzAg+X2gU7XGoX7HCpXbDDpXbBTsDeAztcahfscKldsMOldsEOl9oFO1xqD+wBLrULdrjULtjhUrtgh0vtgp2AvQd2uNQu2OFSu2CHS+2CHS61C3a41B7YI1xqF+xwqV2ww6V2wQ6X2gU7AXsP7HCpXbDDpXbBDpfaBTtcahfscKlXYC9t0ZbgUrtgh0vtgh0utQt2uNQu2AnYe2CHS+2CHS61C3a41C7Y4VK7YO/gUtN2sbWHrcF/vfavkKIy44VkxwuJWodEym6vTcqVPi+vrr5PwEmfgB97Aj667R7kY9CHV76HH2SHH2WHnwYPP6ltSfLJhD/D10p2+Fp2+EZ2+FZ2+IOvvKXwB193S+GPvuoWwh991S2EP/qqWwhf9qprZK+6Rvaqa2Svukb2qtv+FHre8GWvukb2qmtkr7pG9qprZK+6Vvaqa2Wvulb2qmuHX3Vpb1Ml9xz+8Kvu6/CHX3Vfhz/8qvs6/OFX3dfhD7/qvgz/6mMk72/S/PZmbh/qr4ut0rbw2i65+HV1uLn//epfD1mfLrYhbhfbeAiblMqFTfsRx5rC40FsjLmX1vFwevLhqa3PPvxTxuxXU9yvtlqN/KzZqu15urFaf7v6niyEZEGyvJssDsmCZHk3WTySBcnypUzhhzmx/fGISBa5yRKRLEiWd5MlIVmQLG8mS/sDNJEscpNFI1mQLO8mi0GyIFneTRZ0cJEsbycLIVmQLO8mCzq4SJa3kwUdXCTL28mCPkv/ZNH+kSwqFuSnkLawb38+IrHu64sEHt0QaZLG/W5BRyIPSdGzECfpviMCRWsykqKzMJ2k8P/TSUqQdDZJ4aWnkxSOdzpJ8c0icZKqsEtqVEZSfP9nOknRPZpN0oDu0XSSons0naToHk0nKbpH00lKkHQySfPHFdxmuI96hK+T/hpENYNczaBsJ8TpLeGcsd8G5TLosTlzjIfdcuPXO4TL3yFe/g7p4ndISl3+DvrydzCXv4O9/B3o8ndwl7+Dv/wdwuXvcPVnOuV3QnX7vg6OwtPtMuV3wHRh3wyCVGZQrHmn/C1nX3+dp+dB+U0KXdyWP5dsZpCuGWRqBtmaQVQzyNUM8jWD8h+FvT5xKadTrBmUKgZZ9XqQV5k55betciHtg2JmUDYjvN7oeZsyg2zhnXKfp/zGSIUPYX47otKgmo97fvMXbdw2KW18BgXpumGmbpitG0Z1w1zdMF83LNQNi3XDUtUwd5IlMezDDl/sfAzT5WE+M8zUDbN1w6huWD5LbvZtG2ZzN57815fLw0LdsFg3LFUNy381szxM1w0zdcNOdPO73DZkVpn84z39qPG0o8wnIJwgSfvnjZTLDNPlYZmPaTB1w2zdMKobFqqGxTzJYyPG6swwXTcsT5K82of5zE0hf0z77drH3EJmEU4nc9u/Cn9rBGVyMum6YaZuWD5LKNH+CVC5uVHdMFc3zNcNCyef7l03ZzIf0xTrhqWKIINSqm6Yrhtm6obZivvkbRjVDXN1w3zdsFRx5wpK19y5bsN03TBTNSzk/ZrZpuaez4QLKn9PLg3SNYNMzSBbM4hqBrmaQb5mUKgZFGsG1WREfiVzaSuu/OHRymOQrhlkagbZmkFUM8jVDPI1g0LNoFgzKH0+SCtVM0jXDDI1g/L39MdDuNuzxcywk3t6cVj+nn5zKtuw4yO/xzBTN8zWDaO6Yfm1WPsdiY45JCcWNT38WMq9W6oaZlTdMF03zNQNs3XDqG7YSQ1l1KMYCplhvm5YqBsW64alqmH5PnR5mK4bls8S9zCNLqbMMFs3jOqGubphvm5YqBsW64alqmF01rfah1mT+byRqRtm64ZR3TBXN8zXDQt1w2LdsFQ1zKm6YXVZ4uqy5KQHbvfHt7cPcuYWdNIDLw5zdcN83bBQNyzWDUtVw3xdgeHrCgxfV2D4ugLj5FdLr0+Ov/3XvAD+0Uv1IfduqWrYSce9OEzXDcsLEML2+y8dkskMs3XDqG6Yqxvm64aFumGxbliqGnbyNKE4TNcNq8uSWJclsS5LYl2WxLosiXVZku9k6fRYFpPJDUtVw/I9JhP19r0mE/3jhpf/qnC0e+c12sMzo/zVhW/o3kKy44VE44XkxgvJjxdSGC+kOF5IabSQTL6n2jckPV5Iw929jeK4e5v9O56RdChd/eHua/v5OXTrnmUmQNIn4KRPwEufQJA+gSh9Akn4BLSSPgEtfQJG+gSkr8Ra+kqspa/EWvpKrKWvxFr6SmyGXwde7sZ8m8Dod6GSIzPt70KjbJ6u02OjBvX8fNsYDzRnaALQnKGJQHOGJgHNCRqrgOYMjQaaMzQGaM7QWKA5Q0NAc4YG1fApGlTDp2hQDZ+iQTV8igbV8BkaQjV8igbV8CkaVMOnaFANn6IhoDlDg2r4FA2q4VM0qIZP0axbDd/aeDsaMhk061bDJTRu3Wq4iGbduqaIZt0VqvCDPOPWXaGKaNZdoYpo1l2hSmj8uitUEc26/ZoimnX7NUU069Y1RTQENGdo1u3XFNFkq2Gr9h9AW3XY0ys/Wa293n+drb0pwTFm3w3tVq0/tv6yt7/vQQWOoNxj31rtD0dnCO+V5HfNAJw7nAQ4p3DyO6AAzh2OBpxzOAZwzuFYwDmHQ4BzDscBzjkcDzjncFAhv4CDCvkFHFTI53AiKuQXcFAhv4CDCvkFHFTIL+AQ4JzDQYX8Ag4q5BdwUCG/gIMK+QWclSvk2+w3OFZlvj2VVq6Qi3BWrpCLcFaukItwVq6Qi3AIcM7hrFwhF+GsXCEX4axcIRfhrFwhF+GgQj6FYxUq5BdwUCG/gIMK+QUcVMgv4BDgnMNBhfwCDirkF3BQIb+Agwr5BRxUyOdwNCrkF3BQIb+Agwr5BRxUyC/gEOCcw0GF/AIOKuQXcFAhv4CDCvkFnJUr5MKvcq1ZuUIuwlm5Qi7CWblCLsJZuUIuwiHAOYezcoVchLNyhVyEs3KFXISzcoVcgrPw0Ud2Px7R3BqiGTTrbh5WRLPu5mFFNAtvilpw4wsffVREs+7mYUU0626lW0Sz7la6RTQLb/ZeQrPwZu8FNAsffVREs241XESzbjVcRINq+BRN+7rms8PrQ9rQ3P58THc7vN52OGrmswnEPRNuf6bMBOLoEzB2n4A1mQkk4RPocLgK8wS09AkY6ROw0idAo09AhX0CRmUm4KRPYPSVuDiB4Vfi0gSGX4lLExh+JS5MwA+/EpcmMPxKXJhAfkegQFtEgfyzicjvd/IwNcnFzCBbM4hqBrmaQb5mUKgZFGsGZXXSaj9uQivvnoZR/hfb5WG6bpipG2brhlHdMFc3zNcNC3XDYt2wuizRdVmS/8nK63sH5X/KkfbbVDK5QRW3Acp/gbv0TrFmUKoYlP8ibGmQrgBhTM0gWzMor5PfMiKFTBrlv4BWGuRrBpVu19lBsQZEqhiU/1ZMaVBNRtiajLA1GWFrPrnW1QzyNYNCzaBPM+L2L/3ryvzvbaLay7/DR/5XIfh0qaet9vPOHi+9xZW/3XG9ePzpi8dtZ0of458vnn784mpbctSfkedvsywvfvuH+XUhZdPV7Yf1unB4C7K/osq34V8PCZ8PiZ8PSR8Ouf3L/s7t7EAKG2dv6DBQ/x5IoPfXv7hfV+bXQG+3hzlRPVYmbdPvxPafDwmfD4mfD0kfD8mvfK+HZNe9aPYhh2/XbkPM50Ps50Po8yHu8yH+8yHh8yH5237cOxApfRuSeXjpt1XRhscN4Na5+v3y6dKXz3+vgu/l9bUvb659eXvty9O1L++ufXnP+PLRPr18uPbl47Uvn/c2ZvvKf7Lhz/tI/onr6yH68yHm8yH28yH0+RD3+RD/8ZD80bKvh8TPh3yufvhc/fC5+uFz9fPHG5rdyBkf/kz+/KF/r4e4z4fknw2GrTdk0tOnMn9s2ush8fMh6eMh+YOnXg/RHw75r9s//99//Pe//eM//f1f/uM25Nd//T//+s//+bd/+9evf/7n//e/t//yT//+t7///W//6x/+97//2z//y//8P//+L//w93/751//7S/q63/++83pmb8G5ez/+O3c//vtQU/46+1hifsfv93O7b/fHvAEZeKv//5rAAUf/0oh/B7we4Ty6XZF0A/z/+s6Q381aTeOv17q9kZktpdx+q/OPyzV7xH6r8bvZul8hNtHePVX77Y4YvhrvL3hf90Y/f8=","names":["withdraw_private"],"brillig_names":["discover_new_messages","decompose_hint","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","store_in_execution_cache_oracle_wrapper","call_private_function_internal","directive_invert"]},{"name":"deposit_private","hash":"5685006292149290530","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"field"},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"fromPublicBalance","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"7b3dris9c517Lz7+DvhT/MutBEHgON6BAcMObGcDG4HvfWstzW5pvrNblLiqSRZrnBjr9deUis+o2axR3SL/79/9z3/8H//nf/33f/qX/+df//3v/st//b9/98//+g9//x//9K//cvuv//t3Nvz+//37//77f/n1n//+H3//b//xd//FBUp/+7t//Jf/eftntO4///Z3/88//fM//t1/scb8599+Xu3IbFe7+Lg62YOLvSnh62JvY359sQ3Fblff/u0el7tMR9fHkLfLY0r71d4cfrqPfruarPl29X/729/ZCDRnaBLQnKHJQHOGpgDNCRpngOYMjQWaMzRucjTBPdDEWEHjrItbJJbCH6LxQHOGhoDmDM3s1fBANMfVMGX7QOMraMha+rqabHh8RaTf35Au/4bD2sx6R/st3PtsKt9xu97ul4eHCCUdXFxK2XLn9mmWniM6UozCk2Q5/HUCRfgEvDmeQDb7l/jnxP41gV/DDmsAG8nvfw8xmMeXBX+UG/vFRI88Cu73F7irv8Bf/QXE8QW7eJR+fEG4+gvi1V+QOL7Ale0L8o8vyAxfEOz2pxCoPH/Bz0tTttstO+XkasuBf/xp+qfYbTlamCJt9wgfMz1f/GuiZZ2JJtoEvd2F7F8mSkaJomS1KOqmnmhM29UuOf/X2E8WkRDNHns0sRb7XhUGHx/Rl3jE0u7FrLfhiUrqbpyD3YuW4Omv5SkR0JyhCUBzhiYqRvNZJ+rmw7arbzepHyATQPKAzADJA7IAJAvIYACSB6QFSB6QDiB5QGr2E6wgCSB5QGr2Kqwg4WyYQMLZMIGEs2ECCWfDAzLC2TCBhLN5G2TeJmlvsfwACWfDBBLOhulPmwCSByScDRNIOBsmkHA2TCDhbJhAwtnwgExwNkwg4WyYQMLZMIGEs2ECSQD5JsjXvwxJcDZMIOFsmEDC2TCBhLNhAqnZ2STaW7WJfqzDWbNXqaDR7D4qaDT7iQoazQ6hgoaA5gyN5iq+gkZzXV5Bo7nSrqDRXDvnuP0E0+by4+l81lwNv0ZTNFfDFTSaq+EKGs3VcAWN5mq4goaA5gyN5mq42L3xVXz+gUZzNVxBo7karqDRXA1X0Giuhl+jsUZzOVxjo7kerrHRXBDX2GiuiGtsCGxO2WAfofvlP/cRskZzUVxjo7kqrrHRXBbX2GiuiytsrOa6uMYG72zfJ/mnb8hai5e2uUjirW0ukgSSTCTx3jYXSby4zUUSb26/TfLlBgjW4tVtLpL4VSoTSYefpXKRhMfhIgmPw0USHoeLJIEkE0l4HKbK3MHjcJGEx+EiCY/DRRIeh4mkh8fhIgmPw0USHoepnvTwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TSYLHYarMCR6HiyQ8DhdJeBwukgSSTCThcbhIwuNwkYTH4aon4XG4SMLjMJHEsddsJOFxmFYcHHz9NsnX2zFbnHzNRpJAkokkPA4XSXgcLpIcHsdmQ9vV2eZnkr+/I3f4Duy///vyg31qrepjkGtssAP/ORtswX/OBnvwn7MhsDllg134z9lgG/5zNpp70a+38rWqj+etscFO/KdsVB+iW2ODvfjP2WAz/nM22I3/nA2BzSkbzXVxjQ025P99+dGetapPgq2xwZb852ywJ/8pG9UHttbYYE/+czbYk/+cDfbkP2dD2Ov49+UHex2rPrW1xgZ78p+zwZ7852ywJ/85G+zJf8pG9dGtrO+5qj7plZck3hjmIok3hrlIEkgykcQbw1wk8cbw2yRf/9pH9Rm4vCTxq0gukvhVJA9Jp/o8Xl6S8DhcJOFxuEjC43CRJJBkqcyd6lOHeUnC43CRhMfhIgmPw0USHoeJpOqzlXlJwuMw1ZM4iZmNJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw1SZ4yRmNpLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh6mexEnMbCThcbhIwuMwkcRJzGwk4XG4SMLjcJGEx+EiSSDJU5njJOa3Sb7ed97hJGY2kvA4XCThcbhIwuMwkVR9EvPrfYOc6rOVa2xwdsPvyw/2Uneqzz+usSGwOWWDsxvO2eDshnM2miv0GhvNNXeNDc40O2Wj+vTe1/uFO9Xn8dbY4OyGczY4u+GcDYHNKRuc3XDORnNdXGODM83O2eBMs3M2OLvhtO+n+qzfGhv0i8/Z4OyGczY4u+GcDYHNKRvNdXGNDc40O2ezVl0c3INNjBU27hG2sxS+sTn49Mr7WoudDDyS5Fo190CSi506PJLkWvX8SJJrVf8jSa7lFS4l+fqt9cVOSx5Jci0fMpLkWq5lJEl4HC6S8DhcJOFxmKqgxU6QHkkSHoeLJDwOF0l4HC6SBJJMJOFxuEjC4zDVk4udwT2SJDwOF0l4HCaSi50GPpIkPA4XSXgcpiposdPAR5IkkGQiCY/DRRIeh4skPA7X2g2Pw0USHoeHpF/sNPCRJOFxuEjC43CRhMd5l+TrXdq8IZBkIgmPw0USHoeLJDwOF8l3PE6okPTe7XCeSR7DSZt9JW/3Sy35ezyFJZ60/Vzdk4+v47HRpR1RpPwIP9LvkN46nLpzSLZ7SOlpE9UUc/gRkpsvJM8cUjT2dUi3NtZ2rXn82d/+pH+HQ8fhJJv2cLKthGNtDvtWDDZnV/lji367t/hkbfVONG5fXX92Ii/w3PFE4HmFJwHPKzwZeF7hKavhCdbul3v6MeGzw2jXnbDVNmGn+y/+9VMyf3ZeK/Dc8RDwvMKjvFat4VFeq9bwKK9Va3iU16qVZ0RuuVqVFY9frrLlxbNcHcyLB1Xzq1uzR9X8Eg8Bzys8qJpf4kHV/BIPquaXeFA1v1zYUTW/wkOoml/iQdX8Eg+q5le3ZkLV/BIPAc8rPKiaX+JB1fwSD6rml3i0V80VPKiaX9U9AVXzSzyoml/i0V41V/Cgan51aw7Kq+bKG30BbxO/xIO3iV/iwdvEL/HgbeKXeN6omlP0FTzZ0HZ1to8JlPuPSaLp8B3L1W+vj7D3cbmKrDbh5Wqs2oRJ24SXq4NqE16usqlNeLlapTbh5aqP2oSX68K9Pk7cp+X6arUJL1dp1Sa8XKVVm/BylVZtwqRtwstVWrUJL1dp1Sa8XKX1+thrn5artGoTXq7Sqkw4L1dp1Sa8XKVVm/BylVZtwstVWrUJk7YJL1dpVfZyyMtVWrUJL1dp1Sa8XKVVm7C2HXeKth13iva3v16/v1Pwm4mXePD210s8BDyv8OA3Ey/x4DcTL/Fo/83E6xdzC35p/BIPfjPxAg8Z/GbiJR78ZuIlHvxm4iUe7VVzBQ8Bzys8qJpflIVkUDW/xINfGr/Eg18av8SjvWp+jcdqr5oreNBrfokHVfOruseian6Jh4DnFR7tVXMFj/aquYIHveaXeFA1v1zYUTW/wrPeKUe8eFA1v8SDNzRe4sEbGi/xEPC8woOq+VXdo/4EpQoeVM0v8eANjZd48IbGKzw4Qek1Hryh8RIPes0v8aBqflUWaj9B6fXOcqT9BKUaHuxq+RIPdrV8iQe7Wr7Eo2xvBFrvTKTahJXt90nrnVtUm7Cy/T5pvbOFahNWtt8nrXf+T23Cyvb7pPXO6KlNWNl+n7TeOTq1CSvb75PWO+umNmFl+33SeufR1CasbL9PWu/MmNqEl6u0ahNWtt8nBW09raitp7XeGTa1CSvb75PWO8OmNmHSNuHlKq3ahAVUWsE9JhxjZcLu9rD/63JnKXyb8MGnV14SkHDizUg8Aqq4kXgE1HwD8Ug4e2ckHgH15Eg8AqrPS/G8fvtPwilAI/EQ8LzCI6AOHolHe9VcwaO9aq7gQdX8cmFH1fwKj4RzlEbiQdX8Eo/2qrmCR3vVXMFDwPMKD6rmV3WPhLOlRuJB1fwSj/aquYJHe9X8Go+EM7FG4kHV/Gphl3CC1kg8qJpf4iHgeYVHe9VcwYOq+eXKhar5JR5UzS/xoGp+gSdIOEFrJB7tVXMFj/Kq+fUuF0HCCVoj8RDwvMKjvGqu4VFeNdfwMFXNZZ+CLb5U8KTN55B/wLHk7xHxFKqFHoKVp9+dHUZkSyiPt+OjfVCNxxJQeNIgf7v89xyK/DkwHf80dg52gTm4EXNIzuxzyMm/nkMJ+y9R7NMPUW43nPsMTuqbHPbvSMbQ0FvwuE3OwtlZR8BzxxOA5xWeCDyv8KT58Qws/87OOgKeO54CPC/wnJ11BDx3PJYHD5+3Ojte6MOIhtbDzi8wB1pgDmGBOcQRc+D0Vi71n4EzJm03PmesqczgFgt9XR1zetyU4n0CWfoEivAJeCN9Anb+CRSz/RnH4tJfJ+CkT8BLnwBJn0CQPoEofQICVuLXExCwEr+egICV+OUESMBK/HoC0ldikr4Sk/SVmKSvxCR9JSbpKzFJX4mPTx8ItyC2Meap3WiNuY8qLaOO98GvjrJNo1zTKN80ippGhaZRsWlUahrVlBuhKTdiU27EptyITbkRm3IjNuVGbMqN2JQbsSk3YlNuxKbcSE25kZpyIzXlRmrKjdSUG6kpN1JTbqSm3EhNuZGaciM35UZuyo3clBu5KTdyU27kptzITbmRm3IjN+VGbsqN0pQbpSk3SlNulKbcKE25UZpyozTlRmnKjdKUG6UlN6IxTaNs0yjXNMo3jaKmUaFpVGwalZpG5aZRTblhm3LDNuWGbcoN25Qbtik3bFNu2KbcsE25YZtywzblhmvKDdeUG64pN1xTbrim3HBNueGacsM15YZryg3XlBu+KTd8U274ptzwTbnhm3LDN+WGb8oN35Qbvik3fFNuUFNuUFNuUFNuUFNuUFNuUFNuUFNuUFNuNPVFY1NfNDb1RWNTXzQ29UVjU180NvVFY1NfNDb1RWNTXzQ29UVjU180NvVFY1NfNDb1RWNTXzQ29UVjU180NvVFY1NfNDb1RWNTXzQ29UVjU180NvVFY1NfNDb1RWNTXzQ29UVjU180NvVFY1NfNDb1RWNTXzQ29UVjU180NvVFY1NfNDb1RWNTXzQ29UVjU180NvVFY1NfNDb1RWNTXzQ29UVjU180NvVFY1NfNDb1RWNTXzQ19UVTU180NfRFb//1P/7tn/75n//pf/33f/7Xf/j7//inf/2Xf/811vz6P/a4zeKKsV8f6M3T77Kscb/CsMdtluoo3zSKmkaFplGxaVRqGpWbRpWWUcdtluqoptzwTbnhm3LDN+WGb8oN35Qbvik3fFNu+KbcoKbcoKbcoKbcoKbcoKbcoKbcoKbcoKbcoKbcoKbcCE25EZpyIzTlRmjKjdCUG6EpN0JTboSm3AhNuRGaciM25UZsyo3YlBuxKTdiU27EptyITbkRm3IjNuVGbMqN1JQbqSk3UlNupKbcSE25kZpyIzXlRmrKjdSUG6kpN3JTbuSm3MhNuXHcZvFm/7W6NyU9jQr3UdQ0KjSNik2jUtOo3DTqMDe8Ndsvhb1z5duoo/1B4vYdt3XDPV1dDq6mvL3hH/yTpuGu6XED58N48v6zgFs+5ko84dZe3QK6de72q0O8B2RnC8jNFpCfLSCaLaAwW0BxtoDSbAHl2QIqcwXkzGR3amf636kTbQtfSIGeAzr4bVuw+0/bwtPuG4cX532/mpyeFkkyh/vz+G0PU3fz9PvV5I4uzo+S6tulvwk6EPxDgh4E/5AggeAfEgwg+IcEIwj+IcEEgn9IMIPgHxIsIPhnBK0BwT8kCE/ypwThSf6UIDzJnxIkEPxDgvAkf0oQnuRPCcKT/ClBeJI/JQhP8ocEHTzJnxKEJ/lTgvAkf0oQnuRPCRII/iFBeJI/JQhP8qcE4Un+lCA8yZ8SHOFJ7INgfg3F5v0NVlucr3y0pbLvNx2Se/7oX3P1RtFcraK5OkVz9YrmSormGhTNNSqaa1I016xororqJlJUN5GiuokU1U2kqG4iRXUTKaqbSFHdRIrqJlJUN5GiuikoqpuCoropKKqbgqK6KSiqm4KiuikoqpuCoropKKqbgqK6KSqqm6KiuikqqpuioropKqqboqK6KSqqm6KiuikqqpuioropKaqbkqK6KSmqm5KiuikpqpuSoropKaqbkqK6KSmqm5KiuikrqpuyoropK6qbsqK6KSuqm7KiuikrqpuyoropK6qb8kp1kytxm6v/fmThMZlEOxn79Nn5KJJo8tfF0T393DH/PpnClZVKsoEYV6r2BmJcqZAciHGlGnUgRgJGDowrVdYDMa5UtA/EuJIfGIhxJasxECNcDANGb+BiWDDCxbBghIthwbiSi7nNJu0YSy0Qa5PbP9wW8/Tp1l2NnYB9BPaVXJIg7Cu5KkHYV3JhgrCv5NoEYV/J5cnBbldyhYKwr+QiBWFfyXUKwg6XOgQ7AfsI7HCpQ7DDpQ7BrtilOhO2SKy7zbiC3d1k+rrc2fwEJeejq5PZr07u8W5fvGNX7FJHYlfsUgdid4pd6kjsil3qSOyKXepI7Ipd6kjsBOwjsCt2qSOxK3apI7HDpQ7BDpc6BDtc6gjsSx3pJwi7Zpfqc96xE9Uavy7usbgYw+Pq4o9isW778NtDjeer7dHVPu2R++K/Xf1bJs2uVpBMml2wIJkIMkmQSbPLFiSTZlcuSCbNLl6QTJpdvyCZNHcJ5Mi01IG3C8uELoQImdCFECETuhAiZCLIJEEmdCFEyIQuhAiZ0IUQIRO6ECJkQhdCgkxLHR+/sEzoQoiQCV0IETKhCyFCJoJMEmRCF0KETOhCiJAJXQgRMqELIUImdCEkyBTRhRAhE7oQImRCF0KETOhCiJCJIJMEmdCFECETuhAiZEIXQoRM6EKIkAldCAkyJXQhRMiELoQImdCFECETuhAiZCLIJEEmdCFEyIQuhAiZ0IUQIRO6ECJkQhdCgkwZXQgRMqELIUImdCFEyIQuhAiZCDJJkAldCBEyoQshQiZ0IUTIhC6ECJnQhZAgU0EXQoRM6EKIkAldCBEyoQshQiaCTBJkQhdChEzoQoiQCV0IETKhCyFCJnQhBMhEBl0IETKhCyFCJnQhRMiELoQImQgySZAJXQgRMqELIUImdCFEyIQuhAiZ0IWQIJNFF0KETOhCiJAJXQgRMqELIUImgkwSZEIXQoRM6EKIkAldCBEyoQshQiZ0ISTI5NCFECETuhAiZEIXQoRM6EKIkIkgkwSZ0IUQIRO6ECJkQhdChEzoQoiQCV0ICTJ5dCFEyIQuhAiZ0IUQIRO6ECJkIsh0jUyOwo4w12SisssUjCk/ZUIXQoRM6EKIkAldCBEyoQshQiZ0ISTIROhCiJAJXQgRMqELIUImdCFEyESQSYJM6EKIkAldCBEyoQshQiZ0IUTIhC6EBJkCuhAiZEIXQoRM6EKIkAldCBEyEWSSIBO6ECJkQhdChEzoQoiQCV0IETKhCyFBpoguhAiZ0IUQIRO6ECJkQhdChEwEmSTIhC6ECJnQhRAhE7oQImRCF0KETOhCSJApoQshQiZ0IUTIhC6ECJnQhRAhE0EmCTKhCyFCJnQhRMiELoQImdCFECETuhASZMroQoiQCV0IETKhCyFCJnQhRMhEkEmCTOhCiJAJXQgRMqELIUImdCFEyIQuhASZCroQImRCF0KETOhCiJAJXQgRMhFkkiATuhAiZEIXQoRM6EKIkAldCBEyoQshQKbb/w8ySZAJXQgRMqELIUImdCFEyESQSYJM6EKIkAldCBEyoQshQiZ0IUTIhC6EBJksuhAiZEIXQoRM6EKIkAldCBEyEWSSIBO6ECJkQhdChEzoQoiQCV0IETKhCyFBJocuhAiZ0IUQIRO6ECJkQhdChEwEmSTIhC6ECJnQhRAhE7oQImRCF0KETOhCSJDJowshQiZ0IUTIhC6ECJnQhRAhE0EmCTKhCyFCJnQhRMiELoQImdCFECETuhASZCJ0IUTIhC6ECJnQhRAhE7oQImQiyCRBJnQhRMiELoQImdCFECETuhAiZEIXQoJMAV0IETKhCyFCJnQhRMiELoQImQgySZAJXQgRMqELIUImdCFEyIQuhAiZ0IWQIFNEF0KETJq7ENHYXab0HPihTLePtDuUZ5lORM1mEzXZUrvambJd7Vz6dvVvmTR3IQTJpLkLIUgmgkwSZNLchRAkk+YuhCCZNHchBMmkuQshSCbNXQg5MiXNXQhBMqELIUImdCFEyIQuhAiZCDJJkAldiClkIu+3qynXHqlEcl8Xx/iQ1MejWZbHwxrzFMbxxdHuV0cXTOVqm2zceN/+XXzt08vOOxb7lIv54OJ8e7T0dXF20T1f/Dtv0ZZB3krMW/SpkLcS8xaNO+StxLxFJxN5KzBvM1q7yFuJeYteN/JWYt6i+Y+8lZi3eBqCvJWYt4S8Rd4KzFs8L0PeSsxbPC9D3krMWzwvQ95KzFs8L0PeSsxbPC9D3grM24LnZchbiXmL52XIW4l5i+dlyFuJeYvnZchbiXlLyFvkrcC8xfMy5K3EvMXzMuStxLzF8zLk7eODXUh73ubaR9sc96h//Zu+Xf87u/BUC9l1XXbh2ROy66rsigZPiJBd12UXnuMgu67LLjxtQXZdl114JoLsui67CNmF7Losu/B8Adl1XXbhKQCy67rsQq8e2XVddqFXj+y6LrvQq0d2XZZdFr16ZNd12YVe/UXZlfZ3U27//H71b/BoYw8Cjw7vIPAE8GPAoy84CDxaZoPAo5s0CDwaLYPAowcxBryDPR8EHs51EHg410Hg4VwHgSeAHwNesXP1Pm09ZOspuApKewtmb/XanB4/zIuH4I3bwTv3dO1v7Ip960jsil3rSOyKPSuZtMdNllIFezSPn/7Gx7U53EEq9qCsIL1iT8kLUrFH5AWp2PPxglTs4XhBEkDygFTssXhBKnZNvCAV+yBekHA2TCDhbHhAEpwNE0g4GyaQmp1NpLKDjNWXmp1PG0nny1O3PpePm26k2QcNxE7APgK7Zo81ELtmRzYQu2b/NhC7Zrc3ELtmbzgOe9DsJAdi1+w7B2KHSx2CHS51CHYC9hHY4VKHYIdLfRs72X3LBiLzDftvlHCebCjhJtlQwiFyoYxwfWwo4eTYUMKdsaGE42JDSUDJhRLOiA0l3A4bSrgdNpRwO2wo4Xa4UCa4HTaUcDtsKOF22FDC7bChJKDkQgm3w4YSbocNJdwOG0q4HTaUcDtcKDPcDhtKuB02lHA7bCjhdthQElByoYTbYUMJt8OGEm6HDSXcDhtKuB0ulAVuhw0l3A4bSrgdNpRwO2woCSi5UMLtsKGE22FDCbfDhhJuhw0l3A4TymTgdthQwu2woYTb+RculHA7bCgJKLlQwu2woYTbYUMJt8OGEm6HDSXcDhdKC7fDhhJuhw0l3A4bSrgdNpQElFwo4XbYUMLtsKGE22FDCbfDhhJuhwulg9thQwm3w4YSbocNJdwOG0oCSi6UcDtsKOF22FDC7bChhNthQwm3w4XSw+2woYTbYUMJt8OGEm6HDSUBJRdKuB02lHA7bCjhdthQwu2woYTb4UJJcDtsKOF22FDC7bChhNthQ0lAyYUSbocNJdwOG0q4HTaUcDtsKOF2uFCGpdyOpx2lT7F2dcwbSX9rNj6BtHc0S7kXXjRLuRFeNEu5C140BDRnaJaq/nnRLFXN86JZqjrnRbNUtc2LZqnqmRVNRDV8igbV8CkaVMOnaFANn6IhoDlDg2r4FA2q4VM0qIZP0aAaPkWDavgMzVpnsfOiQTV8igbV8CkaVMOnaAhoztCgGj5Fg2r4FA2q4VM0qIZP0aAaPkOz1lndvGhQDZ+iQTV8igbV8CkaApozNKiGT9GgGj5Fg2r4FA2q4VM0qIbP0Kx1ljMvGlTDp2hQDZ+iQTV8ioaA5gwNquFTNKiGT9GgGj5Fg2r4FA2q4RM0ea2zfnnRoBo+RYNq+BQNquFTNAQ0Z2hQDZ+iQTV8igbV8CkaVMOnaFANn6FZ6yxYXjSohk/RoBo+RYNq+BQNAc0ZGlTDp2hQDZ+iQTV8igbV8CkaVMNnaNY6K5QXDarhUzSohk/RoBo+RUNAc4YG1fApGlTDp2hQDZ+iQTV8igbV8Bmatc6S5EWDavgUDarhUzSohk/RENCcoUE1fIoG1fApGlTDp2hQDZ+iQTV8hmatswZ50aAaPkWDavgUDarhUzQENGdoUA2fokE1fIoG1fApGlTDp2hQDZ+hwVl052hQDZ+iQTV8igbV8CkaApozNKiGT9GgGj5Fg2r4FA2q4VM0qIbP0OAsunM0qIZP0aAaPkWDavgUDQHNGRpUw6doUA2fokE1fIoG1fApGlTDZ2hwFt05GlTDp2hQDZ+iQTV8ioaA5gwNquFTNKiGT9GgGj5Fg2r4FA2q4TM0OIvuHA2q4VM0qIZP0aAaPkVDQHOGBtXwKRpUw6doUA2fokE1fIoG1fAZGpxFd44G1fApGlTDp2hQDZ+iIaA5Q4Nq+BQNquFTNKiGT9GgGj5Fg2r4BE3BWXTnaFANn6JBNXyKBtXwKRoCmjM0qIZP0aAaPkWDavgUDarhUzSohs/Q4Cy6czSohk/RoBo+RYNq+BQNAc0ZGr3VMHnjvq4mH+I3NAeRUNqQ2GCfIslHcUeTvy6O7umTc7hD11tnD4Sut4IfCF2vNxgIXa/rGAdd8WmCA6HrdUoDoev1YAOh63V3A6EToPeHDkc6ADoc6QDocKQDoMORDoC+liPN29WeXPh29a/JLnaSZmWyazmwymTXcj6Vya7lOCqTJU2TXavCrkx2rcq2Mtm1KsrKZNeq5CqT1VRBLXb6YmWymiqoxU5IrExWUwW12CmGlclqqqAWO2mwMllNFdRipwFWJqupglrsxL7KZDVVUIudqleZrKYKarGT7yqT1VRBLXY6XWWymiqoxU6Qq0xWUwW12ClvlclqqqAWO4mtMllNFdRip6VVJqupglrsRLPKZDVVUIudOlaZrKYKarGTwSqT1VRBLXZ6V2WymiqoxU7YqkxWUwW12ClYlclqqqAWO6mqMllNFdRip0lVJqupglrsxKfKZDVVUIudylSZrKYKarGTkyqT1VRBrXW6EfnHZKu/CbRp+92eM49PdtkfXJt3HtmXyrVlJ17K92t/A1+qihMAfK2TmCQAX6qalQB8qYpaAvClqnoJwAnA+wJfyt1IAL6Uw5IAfCmXJwE4nGZn4HCaXYFbs9YxZ5T3DZYy2Rpxl/ctk7ynx9XWHH12sLuaIZtvV99JruUhR5JcyxyOJLmW6xtJkkCSieRaPm0kybUM2EiSazmrkSTXskwjSa7lhQaSXOvwuqEk4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XGYSK51oN1QkvA4XCThcbhIwuNwkSSQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCTXOqptKEl4HC6S8DhcJOFxuEgSSDKRhMfhIgmPw0USHoeLJDwOF0l4HCaSax2mOJQkPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TybWOOx1KEh6HiyQ8DhdJeBwukgSSTCThcbhIwuNwkYTH4SIJj8NFEh6HieRaBxIPJQmPw0USHoeLJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0RyrSPDh5KEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EimeFxuEjC43CRhMfhIgmPw0WSQJKJJDwOF0l4HC6S8DhcJOFxuEjC4zCRLPA4XCThcbhIwuNwkYTH4SJJIMlEEh6HiyQ8DhdJeBwukvA4XCThcXhIWgOPw0USHoeLJDwOF0l4HC6SBJJMJOFxuEjC43CRhMfhIgmPw0USHoeJpIXH4SIJj8NFEh6HiyQ8DhdJAkkmkvA4XCThcbhIwuNwkYTH4SIJj8NE0sHjcJGEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2Ei6eFxuEjC43CRhMfhIgmPw0WSQJKJJDwOF0l4HC6S8DhcJOFxuEjC4zCRJHgcLpLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwkAzwOF0l4HC6S8DhcJOFxuEgSSDKRhMfhIgmPw0USHoeLJDwOF0l4HCaSER6HiyQ8DhdJeBwukvA4XCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8DhPJBI/DRRIeh4skPA4XSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4lkhsfhIgmPw0USHoeLJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0SywONwkYTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTH4SHpDDwOF0l4HC6S8DhcJOFxuEgSSDKRhMfhIgmPw0USHoeLJDwOF0l4HCaSFh6HiyQ8DhdJeBwukvA4XCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8DhNJB4/DRRIeh4skPA4XSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4mkh8fhIgmPw0USHoeLJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0SS4HG4SMLjcJGEx+EiCY/DRZJAkolkAEkmkvA4XCThcbhIwuNwkYTHYSIZ4HG4SMLjcJGEx+EiCY/DRZJAkokkPA4XSXgcLpLwOFwk4XG4SMLjMJGM8DhcJOFxuEjC43CRhMfhIkkg+RZJcql8XU0+uMrVltL+2cE+xZ2PZhlN/ro4uvh0bfjSCO5pfo3gy+bXCI5vfo3gJefXCC51eo0S/O/8GsFZz68RPPv8GqEbML9GBI2m1wh9hvk1Qp9hfo3QZ5hfI8V9Br8HYqPxFerOGfN1tSP/XaM7ScXdAF6SWbFnZyap2Fkzk1Tsf5lJKnapzCQJJJlIKnZ8zCQV+zJmkordEzNJeBwukvA4TCQLPA4XSXgcLpLwOFwk4XG4SBJIMpGEx+EiCY/DRRIeh4skPA4XSXgcHpLewONwkYTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSJp4XG4SMLjcJGEx+EiCY/DRZJAkokkPA4XSXgcLpLwOFwk4XG4SMLjMJF08DhcJOFxuEjC43CRhMfhIkkgyUQSHoeLJDwOF0l4HC6S8DhcJOFxmEh6eBwukvA4XCThcbhIwuNwkSSQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCQJHoeLJDwOF0l4HC6S8DhcJAkkmUjC43CRhMfhIgmPw0USHoeLJDwOE8kAj8NFEh6HiyQ8DhdJeBwukgSSTCThcbhIwuNwkYTH4SIJj8NFEh6HiWSEx+EiCY/DRRIeh4skPA4XSQJJJpLwOFwk4XG4SMLjcJGEx+EiuZTHyWEnWQx9u/r3bNNSPqQ626W8QnW2S9Xz1dkuVXNXZ0uqZrtU7Vqd7VL1ZXW2S9WA1dkuVadVZ6uqllrrzPPqbFXVUmudHV6drapaaq0zuKuzVVVLrXWWdXW2qmqptc6Ers5WVS211tnK1dmqqqXWOqO4OltVtdRaZ/1WZ6uqllrrzNzqbFXVUmudPVudraZaitY6w7U6W021FK11Fmp1tppqKTKkaraaaila62zO6mw11VK01hmX1dmqqqXWOiuyOltVtdRaZy5WZ6uqllrr7MLqbFXVUmudAVidrapaaq2z9KqzVVVLrXUmXXW2qmqptc52q85WVS211hlp1dmqqqXWOmusOltVtdRaZ3ZVZ6uqllrr7KvqbFXVUmudIVWdrapaaq2zmKqzVVVLrXWmUXW2qmqptc4Gqs5WVS211hk71dmqqqXWOqumOltVtdRaZ74UG/bZxtrVNuWvi93TDjgu+4Nr884j+1K5tuQt5FK+X3snvlQ9J4L4UjWlCOJL1bUlbWGTJVO52iXvNuSpPF+djpjfWG3QnY3frr6TXKpmHkpyqXp8JMm1zpoZSnIpHzGU5FIeZSjJpfzPUJIEkkwk1/JMI0mu5YVGkoTH4SIJj8NFEh6HieRaZ80MJQmPw0USHoeLJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0RyrXNshpKEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2Eiudb5UkNJwuNwkYTH4SIJj8NFkkCSiSQ8DhdJeBwukvA4XCThcbhIwuMwkVzr3LehJOFxuEjC43CRhMfhIkkgyUQSHoeLJDwOF0l4HC6S8DhcJOFxeEiGtc5jHEoSHoeLJDwOF0l4HC6SBJJMJOFxuEjC43CRhMfhIgmPw0USHoeJ5FrnpA4lCY/DRRIeh4skPA4XSQJJJpLwOFwk4XG4SMLjcJGEx+EiCY/DRHKt84uHkoTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSK51rniQ0nC43CRhMfhIgmPw0WSQJKJJDwOF0l4HC6S8DhcJOFxuEjC4zCRJHgcLpLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwkAzwOF0l4HC6S8DhcJOFxuEgSSDKRhMfhIgmPw0USHoeLJDwOF0l4HCaSER6HiyQ8DhdJeBwukvA4XCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8DhPJBI/DRRIeh4skPA4XSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4lkhsfhIgmPw0USHoeLJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0SywONwkYTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTH4SEZDTwOF0l4HC6S8DhcJOFxuEgSSDKRhMfhIgmPw0USHoeLJDwOF0l4HCaSFh6HiyQ8DhdJeBwukvA4XCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8DhNJB4/DRRIeh4skPA4XSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4mkh8fhIgmPw0USHoeLJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0SS4HG4SMLjcJGEx+EiCY/DRZJAkokkPA4XSXgcLpLwOFwk4XG4SMLjMJEM8DhcJOFxuEjC43CRhMfhIkkgyUQSHoeLJDwOF0l4HC6S8DhcJOFxmEhGeBwukvA4XCThcbhIwuNwkSSQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCQTPA4XSXgcLpLwOFwk4XG4SBJIMpGEx+EiCY/DRRIeh4skPA4XSXgcJpIZHoeLJDwOF0l4HC6S8DhcJAkkmUjC43CRhMfhIgmPw0USHoeLJDwOE8kCj8NFEh6HiyQ8DhdJeBwukgSSTCThcbhIwuNwkYTH4SIJj8NFEh6Hh2Qy8DhcJOFxuEjC43CRhMfhIkkgyUQSHoeLJDwOF0l4HC6S8DhcJOFxmEhaeBwukvA4XCThcbhIwuNwkSSQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCQdPA4XSXgcLpLwOFwk4XG4SBJIMpGEx+EiCY/DRRIeh4skPA4XSXgcJpIeHoeLJDwOF0l4HC6S8DhcJAkkmUjC43CRhMfhIgmPw0USHoeLJDwOE0layeOQ3a8mW+K3q++zXcmH1Ge7kleoz3aler4+W1I125Xq4vpsV6pd67Ndqb6sz3alGrA+25XqtOpslzpPvT5bVbXUUueS12erqpZa6nzv+mxV1VJLnZNdn62qWmqp86brs1VVSy11bnN9tqpqqaXOP67PVlUttdQ5wvXZqqqlljqPtz5bVbXUUufa1merqpZa6nzY+mxV1VJLnbNan62qWmqp80rrs1VVSy117md9tqpqqaXOz6zPVlUttdQ5lPXZqqqlljrPsT5bVbXUUuci1merqpZa6nzB+mxV1VJLndNXn62qWmqp8+7qs1VVSy11blx9tqpqqaXOX6vPVlUttdQ5ZvXZqqqlljoPrD5bTbVUXupcrfpsl6qlyPpttsmag9kuVUtVZ7tULVWdLama7VK1VHW2S9VS1dkuVUtVZ7tULVWd7VK1VG22S53fU5+tqlpqqXNw6rNVVUstdZ5MfbaqaqmlzmWpz1ZVLbXU+Sb12aqqpZY6J6Q+W1W11FLnbdRnq6qWWurcivpsVdVSS53/UJ+tqlpqqXMU6rNVVUstdR5Bfbaqaqml9vWvz1ZVLbXU/vj12aqqpZbaZ74+W1W11FL7tddnq6qWWmvf8+psVdVSa+17Xp2tqlpqrX3Pq7NVVUutte95dbaqaqm19j2vzlZVLbXWvufV2aqqpdba97wy2zKgwxrTdnWI2T/P9h7RgGwzD/4m/oyIDiNyfhPC+5QrEflYzHZ1Ns8/8EhfXxJ6fEns8SWpx5fkHl9SOnzJiS9n/hLb40tcjy/xPb6kx1889fiLpx5/8dTjL556/MVTj7/40OMvPvT4iw89/uJDj7/40OMvPvT4iw89/uJDj7/40OMvPvT4i489/uJjj7/42OMvPvb4i489/uJjj7/42OMvPvb4i489/uJjj7/41OMvPvX4i089/uJTj7/41OMvPvX4i089/uJTj7/41OMvPvX4i889/uJzj7/43OMvPvf4i889/uJzj7/43OMvPnP8xee0X12MPfiS3ONLSocvKabHl9geX+J6fInv8SXU40sC85dYd/AlHH/xeX/844sz377k59V5f8SS/eMJi/v1jObHtbcb0te1pXy/9h58khx8lhx8ERu8M8ZIDt5KDt5JDt5LDp4kBx8kBy93hb0FL3eFvQUvd4W9BS95hbVzr7Bxu9beVqSD6OdeYmvRz73G1qKfe5GtRT/3KluLfu5lthY9xzpbXNqjD6kS/et3DG8RpekiytNFVGaLyJnpIrLTReSmi8hPFxFNF1GYLqLp7tluujuk63+HfPmmujPeTxdR/7+15B4RufQzojBdRHG6iNJ0EeXpIhrw109xjyjQc0Q/L3a0B+KI6Ef4ZGSHb2WH72SH72WHT7LDD7LDj7LDT5OH7/Ij/J8FGWXZ4c++6r4OP0y+6oaw1TwuRP/64nh7XP91cbz1V3/OdfIl+pO5hpLKy7lOvp6HvffrQrKvL85m++BMTz+0JvM11cnXfs6pkp6pTl5TcE518vqDc6qT1yqMU42zr6yfTDVsfcec4repHnyw9VvMzobHB5M7ujhvS5433y69I5x9wRaAcKU6YBDCleqLQQgJCP8U4Ur10CCEK9VZgxCuVL8NQjh5v0sCwsl7bgIQJriTP0YId/LHCOFO/hgh3MmfIsxas9AUtyN8elXqEGHOWxDffhx8+MH29t3bJ9/+nZ5ewS75i7nWtB3JnMC8O3Ottn0kc60+fyRzrY2Bkcy1dhJGMtfaehjIvGjtVYxkrrW5MZI5fGh/5vCh/ZkTmHdnDh/anzl8aH/m8KH9mcOH9mcOH9qbuTXwof2Zw4f2Zw4f2p85fGh/5gTm3ZnDh/ZnDh/anzl8aH/m8KH9mcOHdmdu4UP7M4cP7c8cPrQ/c/jQ/swJzLszhw/tzxw+tD9z+ND+zOFD+zOHD+3O3MGH9mcOH9qfOXxof+bwof2ZE5h3Zw4f2p85fGh/5vCh/ZnDh/ZnDh/anbmHD+3PHD60P3P40P7M4UP7Mycw784cPrQ/c/jQ/szhQ/szhw/tzxw+tDvz2U8wXZI5fGh/5vCh/ZnDh3ZnLuoMxfz64hS3a1P6RvE+U0nZ9WczJTUzHeHoHwfUh0rwrz76Hn8UHn8SHn8WHn+RHf+Q8yM547dTx0/Gbwcokyml8tGe9mLBU34KO3zdbYecszhutl7VbEnVbOeuG7hnO3eVwT3buWsS7tnOXcFwz3bueod5tmnu6oh7tqpqqSS3lrrHL7c6usdPwuOXW8Hc45dbk9zjl1tl3OOfvG6we0ORvKXKR2dDW7PdP+bqsj+4tuTtg0v5fu2dy+QVxiguefJaZBiXyauWYVwmr2+GcZm8bhrGhcDlkMvkdd4wLpPXj8O4TF6XDuOCeveYC+rdQy4F9e4xF9S7x1xoci5260eSdQf9gDJ7nVGLf/Z6oBb/7Ot2Lf7Z19da/LOvg6/jd2b29aoW/+zrSi3+2fsdtfhn70vU4pe9/joje/11Rvb664zs9dcZ2euvM8LXXyt8/bXC118rfP21wtffIfv7c8YvfP21wtdfK3z9tcLXXyt8/XXC118nfP11wtdfJ3z9HbKvMWf8wtdfJ3z9dcLXXyd8/XXC118vfP31wtdfL3z99cLX3yH7OXLGL3z99cLXXy98/fXC118vfP0l4esvCV9/Sfj6S8LXXxK+/pLw9ZeEr78kfP0l4esvCV9/g/D1Nwhff4Pw9TcIX3+H7DnIGb/w9XfynQTr8QtffyffSbAev/D1d/KdBOvxC19/Z98bsBq/8PV39v37qvELX39n32OvGr/w9Xf2ffCq8Qtff2ffq64av/D1d/b95KrxC19/Z99Prhq/8PV39v3kqvELX3+n30+uFr/w9Xf6/dlq8Qtff6ff76wWv/D1d/r9w2rxC19/p9+Pqxa/8PV3+v2tavELX3+n3y+qFr/w9bcIX3+L8PVX+P5XTvj+V074/ldO+P5XTvj+V074/lde+P5XXvj+V174/lde+P5X3shef/30+19dtq9o3K61xrhvF9/BqN3ougZG7U7XNTBqt7qugVG713UFzPSblw0DI/cUk3v8ck8bucdPwuOXW9Xc45dbfNzjl1sj3OOXu5Tf45e74v6Of/pdxWrxyz2t4R6/8PV3+l3FavELX3+n31WsFr/w9Xf6XcVq8Qtff6ffVawS//S7itXiF77+Tr+rWC1+4evv9LuK1eIXvv5Ov6tYLX7h6+/0u4rV4he+/k6/q1gtfuHr7/S7itXiF77+Tr+rWC1+4evv9LuK1eIXvv5Ov6tYLX7h6+/0u4rV4he+/k6/q1gtfuHr7/S7itXiF77+Tr+rWC1+4evv9LuK1eIXvv5Ov6tYLX7h6+/0u4rV4he+/k6/q1gtfuHr7/S7itXiF77+Tr+rWC1+4evv9LuK1eIXvv5Ov6tYLX7h6+/0u4rV4he+/k6/q1gtfuHr7/S7itXiF77+Tr+rWC1+4evv9LuK1eIXvv5Ov6tYLX7h6+/0u4rV4he+/k6/q1gtfuHr7/S7itXiF77+Tr+rWC1+4evv9LuK1eIXvv5Ov6tYLX7h6+/0u4rV4pe9/tL0u4rV4pe9/tL0u4rV4pe9/pKRvf6S4F3F7vHLXn9J8B5d9/hlr78keMer3/EL3pjqHr/w9Vf4/lckfP8rEr7/Fc2+/1X0ZYs/G1/56I82lsvbDEv5fu2dy+Tr+jAuk9cLw7hMXodcx+X1Bo00+wZjw8DMvnPZODCTl2TjwExe640DM3kROQ4MzQ0m7x9NmWpgUvRfF6cU92vJfU118kKWc6qT16acU5283Hwx1Xv8k5eF1fgnr95q8U++PV2wFLaLbTyw55NvT1ePf+6SpR7/3JVFPX4SHv/cq3o9/rmX6nr8c6+/9fjnXn/r8c+9/j7H76z7Gf/k29PV45ez/h7HL2f9PY5fzvp7HL+c9fc4/snX32TTfnEuB/FPvv5W4598/a3GP/n6W41/8vW3Fv/k29PV4598/a3GP/n6W41/8vW3Gv/k6281fuHr7+Tb09XjF77+Tr49XcjebBeXmCsfTWWf7POrTNkdXOuS2Y4zdsk9Ktv4xWXydX0Ul8m30xvHZfI6hInLfa6T1yysc528vmGdKyma6+R1E+tcJ6+xWOc6eT320VxvLbftYsoHc12pdqvNdaV6rDLXybdM5J3rSnVTba4r1U21ua5UN9XmSormulLdVJvrSnVTCHvdlA/qpsm3meSd61J1U2WuS9VNr+c6+VaXvHNdqm6qzHWpuqky16XqpspcSdFcl6qbKnNVVDdNvj3oq7ne45dbC93jl1vf/I5/8u1B6/HLrUPu8cutLe7xz10vRGO2QKKP9iB+Eh7/3Ot6Pf651+p6/HOvv/X4515/6/HPvf7W4g+Tbw9aj3/u9bce/9zrbz1+2etvMLLX3zD59qD1+GWvv2Hy7UHr8ctef8Pk24NW4598e9B6/MLX38m3B63HL3z9nXx70Hr8wtffybfxrMcvfP2dfFvMevzC19/JN5msxy98/Z18y8Z6/MLX38k3QKzHL3z9nXyrwnr8wtffyfcfrMcvfP2dfP/BevzC19/J9x+sxy98/Z18/8F6/MLX38n3H6zHL3z9nXz/wXr8wtffyfcfrMcvfP2dfP/BevzC19/J9x+sxy98/Z18/8F6/MLX38n3H6zHL3z9nXz/wXr8wtffyfcfrMcvfP2dfP/BevzC19/J9x+sxy98/Z18/8F6/MLX38n386vHL3z9nXwvvXr8wtffyfe8q8cvfP2dfG+6evzC19/J95Crxy98/Z18r7d6/MLX38n3ZKvHL3z9nXzvtHr8wtffyfc4q8cvfP2dfC+yevzC19/J9wyrxy98/Z18b696/MLX38n34KrHL3z9nXyvrHr8wtffyfe/qscvfP2dfP+revzC19/J97+qxy98/RW+/1UQvv9VEL7/VRC+/1UQvv9VEL7/VRS+/1UUvv9VFL7/VRS+/1U0stffKHz/qyh8/6sofP+rKHz/qyh8/6sofP+rKHz/qyh8/6sofP+rOPv+V5S3i2Ow7iD+yddfn3b+t4GVj86Gvi7O/nFWuMv+4NqStw8u5fu1dy6Tr+vDuExeLwzjMnkdMozL5PXNKC6z71s2jMvk9dgwLpPXecO4TF4/DuNC4HLIBfXuMRfUu8dcUO8ec0G9e8wF9e4hl9n3CRzGRW29G7drrTHuAIzagrcGRm3FWwNDAHMMRm3NWwOjtuitgZm8igm5bGBuT2AqH21DMX6bbijW79fH+2xn38PvxWzv8U++IlTjn/vGnVLaLk7pqYY7/miXYvi62qXknz/6Ptm5b8bMk537Bss82blbBcyTndv/M0927uWQd7KT72jIPNm57TfzZOeucz6dbHHbZPNTVbFPdu6iiHmypGmyK1VQ3pmtOPbOpZ+TXamCqk52pQqqOtmVKqjqZFeqoG6TNa8mO/meiB9Olux2tSdnfk52pXW2OtmV1tnqZJdaZ2uTXWqd9SXvk7Xm9UeHkrZbdyjl4G621KL8CZlo9vt8NAeF6OR7T/bJmWMySy335PfahoL9s7+myffL7EPmMGcm34nzUzL7oztPJf+c7FolYmWya5WIlcmSpsmuVSI+Jhuenorvk12qRKxNdqmqrzbZpQq52mSXqs38I5Bg0+uPtjFv9bxN9PRjWDJ3NJNvRvohmrT/9Nen4v+sbJ18m9MLydRM4OQbqPbJmWMytBSZ/aP9Xx5KHdxoTNlfOLPeHNxolqqbsqMdTal8NJktaHLf78AHGB8tCXtr3+1X+x3jUhXZOIxL1XrjMC5VRY7DuFR9Ogzj5BsTi8G4lCUYh3Ep//ARRr/ZB3qe4Q5mKfvACWbyHy3x/gRl9m2cmWc7+Y/qmWc7+U/lmWer6adjafbtp5lnO/mP1ZlnK/dngS2zlfsjwpbZ0lqz9fSYbXBPsz2+2j1dHX+wWazyYmWzWJ3Gymaxqu4DNmR3/0vu6THkRmaxCpCRzGLVIh+Z2TdWH0hmsSqUkcxiFSsjmcWqW0YyBDInZPTWwTUyeqvgGhnUwGdkUAOfkVmtBj5ziQefnfc3MpN/+tHRyWeXvE3yhvHpMJYb/98kZ99UXxDJ1WpsHpJ3NqtV2ZxsVquzX3a8TjZNt/tOjN65UpmtzWbbtMdm+8ymHM7WPGZr4vNs7xGl/hG5R0Q/N0NIJxuFj4yozBbRyebYIyOy00Xk+kdE8XFnqbzy7Wi/xTki+hm+lx0+yQ4/yA4/yg4/yQ4/yw6/iA6fzOThu/wI/2dBRlZ2+LOvupXwJ191Q9hqHhfin/0QMdHkS/Qnc638tDDR5Ot5sH6fa6rsi5L3E4YzPcX89R50osnXfs6pTl4ncE518pqCc6qT1x+MUw2T1yqcU519Zf1kqmELI6f4baoHH2z9o3P+tOXVr+0kfl78+DW9+XbpHeHsC7YAhCvVAYMQrlRfDEK4Ut0yCOFK9dAYhGml4uMThOZxXIB9eiR2iDDnLYhiqz9qvn33/vgvp/R0TlrJX8wn7+4syXzyltSSzLVW+yOZE5h3Z67VT4xkrtWAjGSu1bGMZK7V4oxkvlLvWQjzDB/anzl8aH/m8KH9mcOH9mdOYN6dOXxof+bwof2Zw4f2Zw4f2p85fGh35gU+tD9z+ND+zOFD+zOHD+3PnMC8O3P40P7M4UP7M4cP7c8cPrQ/c/jQ3syzgQ/tzxw+tD9z+ND+zOFD+zMnMO/OHD60P3P40P7M4UP7M4cP7c8cPrQ7cwsf2p85fGh/5vCh/ZnDh/ZnTmDenTl8aH/m8KH9mcOH9mcOH9qfOXxod+YOPrQ/c/jQ/szhQ/szhw/tz5zAvDtz+ND+zOFD+zOHD+3PHD60P3P40O7MPXxof+bwof2Zw4f2Zw4f2p85gXl35vCh/ZnDh/ZnDh/anzl8aH/m8KHdmc9+wO2SzOFD+zOHD+3PHD60P3MC8+7M4UP7M4cP7c8cPrQ/c/jQ/szhQ7szX+rwcinM4UP7M4cP7c8cPrQ/cwLz7szhQ/szhw/tzxw+tD9z+ND+zOFDuzOP8KH9mcOH9mcOH9qfOXxof+YE5t2Zw4f2Zw4f2p85fGh/5vCh/ZnDh3ZnnuBD+zOHD+3PHD60P3P40P7MCcy7M4cP7c8cPrQ/c/jQ/szhQ/szhw/tzjzDh/ZnDh/anzl8aH/m8KH9mROYd2cOH9qfOXxof+bwof2Zw4f2Zw4f2p15gQ/tzxw+tD9z+ND+zOFD+zMnMO/OHD60P3P40P7M4UP7M4cP7c8cPrQ382LgQ/szhw/tzxw+tD9z+ND+zAnMuzOHD+3PHD60P3P40P7M4UP7M4cP7c7cwof2Zw4f2p85fGh/5vCh/ZkTmHdnDh/anzl8aH/m8KH9mcOH9mcOH9qduYMP7c8cPrQ/c/jQ/szhQ/szJzDvzhw+tD9z+ND+zOFD+zOHD+3PHD60O3MPH9qfOXxof+bwof2Zw4f2Z05g3p05fGh/5vCh/ZnDh/ZnDh/anzl8aHfmBB/anzl8aH/m8KH9mcOH9mdOYN6dOXxof+bwof2Zw4f2Zw4f2p85fGh35gE+tD9z+ND+zOFD+zOHD+3PnMC8O3P40P7M4UP7M4cP7c8cPrQ/c/jQ7swjfGh/5vCh/ZnDh/ZnDh/anzmBeXfm8KH9mcOH9mcOH9qfOXxof+bwod2ZJ/jQ/szhQ/szhw/tzxw+tD9zAvPuzOFD+zOHD+3PHD60P3P40P7M4UO7M8/wof2Zw4f2Zw4f2p85fGh/5gTm3ZnDh/ZnDh/anzl8aH/m8KH9mcOHdmde4EP7M4cP7c8cPrQ/c/jQ/swJzLszhw/tzxw+tD9z+ND+zOFD+zOHD+3M3BsDH9qfOXxof+bwof2Zw4f2Z05g3p05fGh/5vCh/ZnDh/ZnDh/anzl8aHfmFj60P3P40P7M4UP7M4cP7c+cwLw7c/jQ/szhQ/szhw/tzxw+tD9z+NDuzB18aH/m8KH9mcOH9mcOH9qfOYF5d+bwof2Zw4f2Zw4f2p85fGh/5vCh3Zl7+ND+zOFD+zOHD+3PHD60P3MC8+7M4UP7M4cP7c8cPrQ/c/jQ/szhQ7szJ/jQ/szhQ/szhw/tzxw+tD9zAvPuzOFD+zOHD+3PHD60P3P40P7M4UO7Mw/wof2Zw4f2Zw4f2p85fGh/5gTm3ZnDh/ZnDh/anzl8aH/m8KH9mcOHdmce4UP7M4cP7c8cPrQ/c/jQ/swJzLszhw/tzxw+tD9z+ND+zOFD+zOHD+3OPMGH9mcOH9qfOXxof+bwof2ZE5h3Zw4f2p85fGh/5vCh/ZnDh/ZnDh/anXmGD+3PHD60P3P40P7M4UP7Mycw784cPrQ/c/jQ/szhQ/szhw/tzxw+tDvzAh/anzl8aH/m8KH9mcOH9mdOYN6dOXxof+bwof2Zw4f2Zw4f2p85fGhv5tbAh/ZnDh/anzl8aH/m8KH9mROYd2cOH9qfOXxof+bwof2Zw4f2Zw4f2p25hQ/tzxw+tD9z+ND+zOFD+zMnMO/OHD60P3P40P7M4UP7M4cP7c8cPrQ7cwcf2p85fGh/5vCh/ZnDh/ZnTmDenTl8aH/m8KH9mcOHdmfuJXmi/PriFLdrU/pG8fdMSZIT+bOZSqr//2ymI6pu+5hpJfhXH32P3wuPn4THH4THH4XHn4THnyePP2y3ZVucr3y0pVK2q8NTrXD76Ptki6LJDjlvethk7UKTdTnt5UUupXK1v1XC2yRvKb5fvZGZvcAYR2b20mUcGdJLxseyk8npiczPa8nuFMnZ9IPi7KWZDIqzF4ifUTRpo1isqVyd9zlm/5iiy/7g2pK3MEr5fu2d4uxlqgyKKxXL4yiuVIUPoxhXKu/HUVzLN4yiuJbHGEVxLT8yiiKBIgPFtbzLKIrwLhwU4V04KMK7cFCEd2GgmOBd3qIYt2utMe4AI8wLC0a4FxaMsC8sGAkYOTDCwLBgXMrBlMdTKVPFaCntbIJ9+ux8FEk020Os6J7els3hi+NSHmYgx6VczECOS/mYcRzzUk5mIMelrMxAjgSO73Gk7eIY7AFHrNdvctx/nhNjPuCoeL0Odg87ePrG8c5G8RpcY1MUr6tVNorXyiqbpXp5H96390BubELlvn37+kyPUMqP9y7LUu28oSQJJJlILtXUG0pSc1+Pl+RKTsEbn3aSpRZI5c39slLtz0tmpcqfk4wzK9X9n5GxNobt8tu/n7bnsPZoG43Xv+FyZiWXMJbkSp5iLMmVPMXFJNl+QecMgfoA6it5lU+pJ7d/+K2V5yvUXUr76w3paTudjeRKXmUsSb1ehZukXm/zKUnO55vO6HVOQ7lbzb5sJHfNLm4kd82ebyR3zQ5xJHfU2Bdxf/mekbOoZy7i/vK9JOdQz7zNvfLOhXOoUfhYou7gY4lago8lgeXb6xTn+wXOoY88ijxq4lHk0aceRR597VHkFTvB28PSHeWt1UwV8renrY/TZvITlJwPn+SY/erk3F+5e8VOcCh3xa5xKHfFDpOR+52lYofJzpLAko2lYs/IzlKxC2RnqdjXsbNU7NQ+Zen2h5+3Brs5YAnvxcaS4Kf4WKK+5GOJdfxtloHMxjKEI5ZYx/lYYh0/Znmng5X5BZ2ljnjkp6O5w+jsfl7m7RGyqdylKr/bW+oMybEkNVd0vCQJJN8lyferxqXOtJRDXbN3+UY92oN1XrMbqdPR7C/qdDT7C5/zToeo+ovY6PYOS/RPV5f7XvFuqRMpe7JMByw1e5c/YEnugKVm9/Ipyz0WF2P4xvIolmj2WOITwmIP55l2w56zr1yd3TbNTPbbtXdNNfuoVTUlaLqcppr94qqaanajq2qq2UOvqqlm57+qpuhXLKfpUqfhqtE0bK9n5pAONEX/RqCmtP+dPgF8aIo+kmhNoz/QFP50Bk1d8BuU2yNmd6ATPOccOj12RY02HOgEHylDJ3hDGTrB74nQaalzgFfWCb5Mhk7wWjJ0Ql0+hScujxfdylGPcanzrFfWCXW5DJ1Ql4vQaalzxFfWCXW5DJ1Ql8vQCXXERTo5CjvCHCo6+Zj9dnXM5UAn1BESdPKazyUWpRPqCBk6oY6YQSfy+zE55LM/0Am/s5lCp7L3YankfKATQae5dArGHN338L6RDJ3wXEOGTniuIUMn9CNk6IR+hAidNJ/HLUon9CNk6IR+hAyd0I+QoRNBJxE6oR8hQyf0I2TohH6EDJ3Qj5ChE/oRInRy6EfI0An9CBk6oR8hQyf0I2ToRNBJhE7oR8jQCf0IGTqhHyFCJ4+6/CKd7H46wK3ZXX1v2e86eX/0nqVHXT6dTuXgvWWPulyGTgSdROiEulyGTqjLZeiEulyGTnhOKEMnPCcUoRPhOaEMndCPkKET+hEydEI/QoZOBJ1E6IR+hAyd0I+QoRP6ETJ0Qj9Chk7oR4jQKaAfIUMn9CNk6IR+hAyd0I+QoRNBJxE6oR8hQyfU5U06JVfRKcVtw9eU4n4tuTv2iDJ7CHZUzUOwowh+G3tK2+UuG1/BXnzeEBYyT8eu58O1IJfHWvB0cTqKo2S7z9K41xdba9Iujv0GJX9lAMprjgy4sySwfJdldmVnGcwBS7T532cZaWcZ40+WSfNdPvg9bheSrbAsadtl3hr7dHO9BX5Hqfl2GY3dUabnwA9R3j5yX6jcs3s6qWrydqrQ7bNL7Wpr91uxpVS5OpcNSrEHt5qk+ba9qqaauxyraqr5DQ2pmpbi9wXV5G+i/rw4ln2WsdiKa8q30ujr4uyi++FskuYKEunycbpofl8F6fJxumhuzyNdPk2XrPmxAtLl43TR/DgE6fJxumhu8CFdPk4XNDGRLh+kCyFdVkqXu6hokC4oKjqkC4qKPqY8Ua1xZleVTGW5tiXuD/xLWebdooKmh8DMvdmDLXBf3M/7UUFvYkVV0UKQrmo5UBVOf0VVCaouqCoc+YqqwpKvWC3Bk6+oKl4BWlFVvKmznqpk0FtaUVX0llZUFb2lFVVFb2lFVdGFWFFVdCGmUNWZ/Vfvzn1X9a4T+goydEKnQIZO8P4idLJw8zJ0gj+XoRMc9xw67Udv32QyBzrBQ8vQiaCTCJ3gn0To5FDvzaHT/r6383+J5K4T6r0pdPJh/3v6tln0rhPqPRk6od6ToRNBJxE64WmVDJ3w/EmGTvBPMnTC8ycZOuH50xQ6kd/ej3CUfeXqSNse4DE+eus+Hs0yhw1JzuXbtb/19+hz6NYf/RPd+qMvs7b+5XFSh7GlcnGwfntsG2ymytUxerPH4e1BcqGZhOS6LLkIyYXkuiq50LZDcl2WXOg1IrkuSy40SJFclyUXurpIrsuSC61oJNdVyUXocyO5LksuNNGRXJclFzr0SK7LkgsdeiTXZclFSC4k11XJhQ49kuuy5EKHHsl1WXKhQ4/kuiy50KFHcl2WXOjQI7kakyv5PUvSjcjP5Aro0CO5LksudOiRXJclFyG5kFytyZXDnlxPuB/JhVYEkqs1ucjtd65b/AfJhYIeyXVVckU8uEZytSZXDhuQlONRcuHBNZLroQ3t280GsuYgXQjpgnR5P13wcBnp8kG6wKMhXZ602S19yObgMUrEA2Ckywfpgke6SJcnbaLZ08XVfJT1xu3qePMXJ3UE/CH97d/R1q4PYWdoQzQHi2OCU0P69kvffZa/0rcWjaUc9uApp4P+e0YXC+nbnL7W7R/ubTi4O2bcHZFeF6YXIb2QXtelF/pkSK8L0wt9NaTXiTbpIF3QV0O6fJAu6KshXT5IF7wrhXR5P10Kfs6AdPkgXfADBaTLB+mCrjTS5YN0QZ8G6fLQpuxngoSSw0G6oO+CdPkgXdB3Qbp8kC7ouyBdHh9s9tfforVHtQv6LkiXt9MlGPRdkC4fpAv6LkiXD9IFfRekywfpgrf7kC4fpAshXZAu76cLurpIl/fTxaJ2Qbo8PthS2tPlYIeNYFG7IF0+SBdCuiBd3k8X1C5Ilw/SBU+kkS4fpAueSCNdPkgXPJFGujyly351dH/5WdrPq7OjLUuyi+4RdP7KLTy+Rm5dlFsOz7qRW1flFh6MI7euyi10opFbV+UW2tbIratyi5BbyK223LIx7Bvg3/79lF17G8KhJ470ujC90ENHel2YXui5I70uTC/06JFe7emV7CO98kF6ebS7kF7N6RUz7emVzMG7lx4dL6RXc3ol91gcE8WD9ELTC+l1YXoR0gvpdV16oe+F9LowvdD3QnpdmF7oeyG9Lkwv9L2QXhemF15PRXq1p1eOj/R6Ar6nF+ENVaTXhemFrj3S68L0Qtce6dWcXtnsJ+PGbO1BeqFrj/S6ML0I6YX0ui690LVHerXXXk8v5GTratc3HEu/Nz5CKOUgffFUAOkrOH3x1AHpKzh98VQD6Ss4ffHUBOkrN30DnsogfQWnL576IH0Fpy+eKiF9BacvnlohfSdO3/2xRYjGHKQvIX2Rvt3Sd5/lr/StRWMpPwSiv37+PX3ReUD6zpu+IT/SNx28URXReUD6Ck5fdB6QvoLTF50HpK/g9MUbZ0jf9vQNT2/7x6P0whthSK8L0wtvbCG9LkwvvFGF9LowvdB3RHpdl14JfUGk14Xphb4d0uvC9EJfDel1YXrhjRukV3N65Z337d/hYG/qREgvpNd16YWuPdLrwvRC1x7pdWF6oWuP9LowvdBWRXo1p1d5vBwfS6Sf6ZXRVkV6XZheaEwgvdrTKz4Wx5LKQXrhkTbSqzW9krP7mWy3f4ef6VXwUAjp1Z5ewT/SKx/80LDgoRDS6/HBLqQ9vXL6g6vvyYXKC8l1WXIRkgvJ1ZZcNsfHzz5u/z5wjQUPhJBeF6YXHgghvS5MLzwQQnpdmF7oeSG9LkwvPG9Eel2WXtHgeSPS68L0Qsce6XVheqFjj/S6ML3Qs0d6NadXsg/hU7AH6UVIL6TXdemFrj3S68L0Qtce6XVheqFrj/S6ML3QtUd6XZhe6Nojva5LL4uuPdLrwvRC1x7pdWF6EdIL6dWaXtnsx53lbM1BesE5Ir2a06s83b2KP7p7wTlelF6JaE8v+n71nTxM1SDyDn5jFHmU4qPI492SUeTx2sUo8gTyF5FPj9I52QPyeFg/ijyeY48iD6M+ijw87Cjy8LCDyHvU81eRL4+qssQD8qhtLiKfaeuEuhz8AXnUNqPIo7Y5Jn+ng/rjFR3UCC/oEHrRr+igX/yKDmrAV3Q0912L218rcKWkyvofzWPryaeKN4cvkgSSTCQ1ewdekpq9AC9JzbU9L0nNPoCVZNBc931Icn8IGp/eTn2QxNr9Nsn4eGkvH5BUvHZ7nzY21lNwFZL2Fsy+GYXN6fFaazzsuBq3d1yde7r2zl3xSj+Uu+K6YCh3xVUEI/c7S8W9R26WUXGnkp2l4vqWnaXiLig7S8U9U3aWBJbvs9x/i2VtMfZl/VRs2iIv9uk3UBt3+LQx3OHTxnBHjTuEe0LdcRF3t/vj4lz+wR01yhjuBO5DuKOeOeZ+p4Oq4xUd9HBf0UGn9RUd1JUv6GR0Q1/R0dzfDPZBJzz1hR50NDuHOh3N9X2dDoHOCzqaa+U6Hc21cp2O5lq5TkdzrVyno7lWrtIpmmvlOh3Uyq/ooFZ+RUdzrXy7r+x0kv1O5+DTXdleOffePo5H++qyFgJJJpKaa3Bekprr9Q9J3q7fSX57VvvzWrI7dXL2x3PdotkHjKOu2V98o+6O1nnN/uLmrp7o/NyRJ2k+9dsnbx90gv2jFSdpPuCamaRm38JLUrPH+ZAk23qcDIH6AOqavdM36tEerPOq/dDjmJAbHXdAR7FvIZP2uMnSn+0+kDSfpslMUrFv4SWp+YxEZpKKPQ4zScUeh5mk4rrvU5Iv97tJms8z+5Tky/1ukubzycj7vSNL/i+7gP+83qW0ffrtn3/9BUfSfN4YM0nNazcvSc1r92ckbYp+n2eK9JOl4g4lO0sCSzaWmqtKbpaKe4/sLFFZvs8yPXaZuf27/JWl5nOAPmeZ8oNljj9Yal7H6cGGgqNvLO90NK/MdTqa19o6Hc2rZ52O5id3dTqaO3p1OpprqSodzacrvUFHczetTkdzZR1pf+eWYva1yvrl9XeammtrfpoEmow0Ndfun9G8gdgCd948PWHM5Yul5kqfm6VmX8DNUrOL4Gap2XP8AUvrfrIMmh0KN0vNfoabJdzP2yz9biWdL+Eby4OrX57+c3vaA+5DuBO4D+EO78XB/c4S3ouPJbwXH0t4Lz6W8F5sLDWfaMfOEt7rbZaBtmm68Pw7550lvBcfS/gpPpYElmwsUV+ysUxYx99leevnu/3Tn6/eWWId52O51DruaWd5u31Vri5xm6M15tH0cTdMdzRLLcu8aJZaZXnRLNUs/AjN0y6Iv142f7o12S82SzX/mNksVWwxs1mqOcfMZqlmGy+btQ5AY2azVBHNzEZvUVxno7cqrrMhsDllg7r4nA3q4nM2qIvP2aAuPmeDuviUzVqHnTGzQV18zgZ18Tkb1MXnbAhsTtmgLj5ng7r4nA3q4nM2eutiMnbbi4ss0QEbvXVxjU1e65AuZjZ662KyqexsivnG5uCzXx4Vldc6dGsgR731Ni9HAsf3OLIdoZXXOkJLCHO9XoKc39d297TN+jFzymX7bCrOVa4OafvoUJ7w5S/oek3KQOiK3c846Ipt1TDoax04JgW6YiP4GfQSHtBj+Wmp1zqbbChJxWbwQ5Jl/9s27qDNYwkk3yXpdpKUD0gqNnmfktzDNiEekIR14yIJP8ZFUrHJ8vtuSeT/wuazq+8kFTsnXpJrneE4lKRij/MRSUtp/zlksM+/Lz6K+/UJw3mt8x7FUFfsnQZSJ1AfQF2xJxtIXbF/G0gddfUl1Gm7OAb7k/paZ13OQz1uHx1jPqCOGuZN6sHukwyevlG/kySQZCKJWoOLJOoHLpKK+78frk572DeSobI63YLN9Ai8/Hj5bK3zQQVxRw08hPtaZ5oK4o6+9Rjua7m+vF3tyYVvV99nu1Rlm/d3i3wxdDDbldZusvvVZEv8Odulzie7/ZHvz/yTNQezXenvtj7blbok9dnSSrNNj7dXsjGVq/M+x1sFvF/7a4van9eW/WZfyvdr7xRXutePo7hSB2McxZW6F+MoLlXPDKO4UmdhGMWlTrcaR3Gpmn0YxaW8wDCKS3mMYRQJFBkowrtwUIR34aAI78JBEd7lLYqvzyjKEeaFA+NSZ/oNxAj7woIR/oUFIwwMC8alau/aU9OlDrarz3apWrY626VqTmf2nVQc5YPZLlUa1ma71AFx9dkuVWhVZ7tUPVSd7VJlS3W2tNJsfdjCJnqqpY6vjnH/1V9+FHTOfe1csNQxa7xklqrRWMksVc+9eC/swMbs+yJaW54+Omxolir+WNGsdYhY7S3gtY4Fq852qffZq7Nd6tfDZf8NoC+xdrVN28rgjK+0fBif46x1IJgI4kv9ZkME8aV+tTwH8UrTea0z0WQgX+qXzTKQL/WjZgnIy1oHw8lAvpThkoF8KddX9v2lyFKt2eGS33497tLzsVQmHUIPWyMlm0Tfrr6TXMtRjiRJIMlEci0HeCFJu2/xl52NByTXcnYjSa5l2EaSXMuHjSS5lr0aSHKt49mGklzLDI0kCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EiudaZa0NJwuNwkYTH4SIJj8NFkkCSiSQ8DhdJeBwukvA4b5KM+yRzyu6AJDwOF0l4HCaSHh7nTZIlbpHkku0BSXgcLpLwOFwk4XG4SBJIMpGEx+EiCY/DRRIeh4skPA4XSXgcJpJrnVg4lCQ8DhdJeJz3SBbjzNfVxTyf5riThMfhIkkgyUQSHoeLJDwOF0l4HC6S8DhcJOFxmEgGeBwukvA475JMZSP5+/N+kITH4SIJj8NFkkCSiSQ8DhdJeBwukvA4XCThcbhIwuMwkVzqROmxJPV6HP84E8i7HCskbXpEkiI9h30HqdfiMIPU63CYQRJA8oDU62+YQeq1N8wg9bobZpB6zQ0zSL3e5kOQpWxXO2MqYUdjtkcU0dif1Jc6m3oa6qHspumYOjzTu9T3M3mc8e512PR0GuDTz9N+hXRwNyr2cTsq7hG2K/lLJPgxASLB6wkQiSDS/CLBowoQCf5XgEjw1gJEgm8XIBJ6AvOLlNFCECASOg4CRELHQYBI6DgIEIkg0vwioeMgQCR0HASIhI6DAJHQcRAgEjoO84tU0HEQIBI6DgJEQsdBgEjoOAgQiSDS/CKh4yBAJHQcBIiEjoMAkdBxECASOg6zi0TGoOMgQCR0HASIhI6DAJHQcRAgEkGk+UVCx0GASOg4CBAJHQcBIqHjIEAkdBzmF8mi4yBAJHQcBIiEjoMAkdBxECASQaT5RULHQYBI6DgIEAkdBwEioeMgQCR0HOYXyaHjIEAkdBwEiISOgwCR0HEQIBJBpPlFQsdBgEjoOAgQCR0HASKh4yBAJHQc5hfJo+MgQCR0HK4QyW/HslDK30S6Q0cHYQB0dATeg+7sPklnnyK5H29zA0kAyQMSzpoJJNwvE0g41HdBer+DLIWxZPMlb1Mka/er/b6MwZ9OLxHc6ewSEbzp9BLBmU4vEXzs9BLB9U4vEUGi2SWCU79CotcNO4KrHwB9KXvp846RXPh29X22Szm12mzDUqanOtul/AP5x2xTrFxt07ac3Z6a7Ne67A+uzTuP7Evl2rIjL+X7tXfiS9kBEcSXqu5FECcQ5yYet2utMe4A+VLFtwzkS5XeMpAv9ehNBvKlvI4M5EsZLhHI41Ku7wXy+2y1uL77bLU4rvts13I7eWtQ+0y2dvNwef8r954eV1tz+Nku7CQpfrv6TpJAkonkWuZkJMm1PMeFJMP+Ur8P2RyQXMtKjCS5lkMYSXKtwn8gybRWPT+S5FpeYSTJtXzISJLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TyQyPw0USHoeLJDwOF0l4HC6SBJJMJOFxuEjC43CRhMfhIgmP8ybJ4vefzZmSD0jC4zCRLPA4XCThcd4jSe5B0gV3QBIeh4skPA4XSQJJJpLwOFwk4XG4SMLjcJGEx+EiCY/DQ9IaeJx3SaaykfR/IfnZ1XfucERjuMM/jeEOt3UFd0v7pkU22Ke489Eso9l+4Bjd0+87cvjSiKDR9BrBIc6vEbzn/BrB1c6vEfzy9BpZ+JgJNKLt4hjsgUYEjcZrFN2mUcwHGqGuu0SjYHck4fmzc/zijlptDHfUX2O4o6Yawx1PLK5Zg/dJ3riHyhp8m9ojlOJK2q//UsnhaYgEleA5JKiEJy0SVMJzGQkqkV6V/INkfNqW84T7i6vvJBX7bGaSip0zM0nFXvgjks6Z7WgcR/7gLQOn2N0yk1TsV3lJesWekpmkYt/HTFKxN2Mmqdg/MZMkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwkCR6HiyQ8DhdJeBwukvA4XCQJJJlIwuNwkYTHeZNkcNvVLhz9xpHgcd4kSb7sJKOpXM13NrQleKfZFYInm1yhAK83u0LwkLMrBG86u0LwvLMrRFBocoXg0WdXCN5/doXQU5hdIfQUZlcIPYXJFYroKcyuEHoKwxWK+2/EjHEHEqGpML1E6CpMLxFBotklQl9heonQWJheIriiNyUKMe0SlfpOQMX47cNDedoX7uu3/EluDXCPX+4CeY9/8tWj+D19ClHlo12KWyAuJf/80ffJTn4f5p3s5L1S3slO3nbknezkaxXrZPPkzTDeyU7eV+Kd7OQdGt7JTl7nfDjZsm3f67Kln5MlTZNdq4KqTHalCso7Ux5hp5+TXamCqk52pQqqOtmVKqjaZGc/uPvTyZqXk11pnb01ZraP9uTMz8mutM5WJ7vSOlud7FLrbG2yS62zvuR9sta8/uhQ9m1UQykHd7OlFuVPyESz3+ejOShEZz/ztkvOHJFxs59h++GtY38g5OnpNJ+WvyY3+ymzXcgc58xKrRhPKe5kSv452bVKxMpkSdNk1yoRK5Ndq0R8TDY8PZ/fJ7tUiVib7FJVX22ySxVylcnapWoz7/a3TIJNlY+OeavnbaKn10bIfKFZqgRJeXe8qfg/K1vtUvXKJ2QqJtDNfpRnl5w5JrNUJfT4aP+Xh1IHH23K/tHWm4MbzVJ1U3Z72LlUPprMdr8m9/0OfBDGoyVhb+27/Wq/Y1yqIhuHcalabxzGparIYRhnP/FRCsalGo3jMC5lCcZhXMo/fITRb/aBUv5ZCc5+juA4MPi90q/P7v1jGIej7wZxx6YlY7jjR3cXcff04P60OXM8udo9XR3/qhKO7BOhErYkkaASdiUZr9Kv9+p2e2XTD42wLcn8GhE0ml4jbEwyv0Zw+vNrhK7A/BqhgzC/Rug2TK8Rjs4UoBE6DfNrhD7D/BqhzzC/RgSNLtLorE968NnZ72/V2xhrn132Wd4EfZrlLRPumqIvsZ6m6GPMreldJXQyJKiEXkZvlX5z13xQpct7yeY9VUiS23/8Qj5UuVN6lINP76DYfPiTI9oujk8/qr/N/Usjxb5qHo3Sxi/edPmpkWJfJUYjgkbTa6TYJ4nRSLHvmUgju2sUDzRS7HrEaKTY84jRSPHz23k0ipuHjTH/1Ejz0ZViNEKfYX6N0GeYXyP0GebXiKDR9BqhzzC/RugzzK/RUv7I066RT7FyNXnjHtSfn2naP6f++olQWsrxzEP9dd8zLeVhxFBfypWIob6UzxBDnUD9Euove7yzH0e8KPWlqnsx1Jd6LjgP9dcuafaTohelDm86gPrsZ2cvSh3edAR1eNMR1OFNR1AnUB9Afal63fiduim1QCxF2h5r3P6dn38Z4w6udyFvv6q9/fMJyu3fd5ZLVeGDWS5VW49lOftZ6aJYLlUHD2a5VHU7mOVSNeu1LNO+lcbtgYg5YElgycZyqWcfg1ku9URjMEv4Hi6W3qC+fJtlLFvgt3/6A5ZYx99mmfN2+c3ihAOWWMffZXlrQD0+3ZUDlljH+VhiHedjiXX8fZbJ7Z+ev689n119J49u5yjy6I1eQz7msL8Wn5925LvvZXUDDO5DuKPnOoY7+rMXcS87lFhc+sEdHnAMdwL3IdzhLcdwhw8dwx2edQx3ONYx3OFXr+L++Bl3CT+4O/jVMdzhV8dwh18dwx1+dQx3Avch3OFXObjfWaImf5dl9d0RhzqbjaVH7czHEvXw2yy/vWtHByxR4/KxRN3Kx5LAko0l6sv3WboHS1+r628V0vYrmtuiRH+t6z2eh4zhjuchY7jDe13E3ceyc8/P/YNPrr1rBE83vUYErzi/RvCg4zV6fS69J3jb+TWCZ55fI4JGDBrdWcKLv8/ycXJ4SvmAJfz1+yzz3lNPpRywhGduystDlvDBfCzhV9lYBtTDb7PMYZvm7Z9HLFG38rEksGRjifqSjyXqy/dZknvNEuv4+ywr+9CsdX70YJbo4/KxRH3Jx5LAko2l5t6G92Zn6UussLQpBb9df/v3A8tXLzhq7m1ws9RcEzGzXOuE2atZpvxg+XTq2sZSc03EzVJzTcTNUnPPjZslgSUbS809N26Wmntu3Czhe/hYwvewsVzr7McPWZr9RHVLllKFZXz8cDzYp85G+CKpubr8kOTLk+z9Wmc0DiVJIMlEUnNdyUtSc1X5KUm7k4wHJDXXlLwkNVeUvCQ199E/JPny9F6v+mRPXpLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4PSdJ8kqf3+1aV1lNwFZLW5rx32W0xz6fn/Ly62LRFXuyP3QnIKK4+h3JXXKtey93ZDUpx7id3xZXtUO4E7kO4K66ah3JXXGNfzN3bnbsvP7grrsiHclf8jGIod8VPNEZy13wi71Du8KtjuMOvXsXduEcdmX9wh18dw53AfQh3+NUx3OFXx3CHXx3DHX51DHf41SHcNZ/IO5Q7/OoY7qSXuytu3xXHlfJnvxwjzWeOfkry5W9LyCmusZlJKq6amUkqroOZSSqubD8m+epXOqT5BFxmkoqrT2aSip9/fEry9Zu+ms++ZSZJIMlEEh6HiyQ8DhdJeBwukvA4XCThcZhIaj5x0kVjd5LpOfBDkrePtDuUGCpXu1Qe5+r9ZQeyO3nN9eel5LPb2vcu+3xAnkB+EHnN9e1Y8prr4WvJm/0Mu2zTAXnN9fNY8prr7bHkNdfnQ8kHzc8sxpLX/IxjLHl42FHk4WFHkSeQH0QeHnYUeXjYq8inx1m46aB7EOBhR5GHhx1FHh52EHnNp0VfTH6P/Ea+HJCHhx1FHh52FHl42KvIU97JB39AnkB+EHl42FHk4WFHkYeHHUUeHnYUeXjYQeQTPOwo8qjnLyIf920Rbp9daleT99vVlH3l6kiPt5QfnX8fj2ZZ8n5Wr3kK4/ji6MIGMLpc++hfOz/sL1fnbM236+/pRUgvpFdzetFD+Oe71yO94MyQXhemF+wn0uvC9ILHRnrxpFd0B+mFRgLS6w/Six7plULt08vOO5bnt5HywcXZ7Z+d3VPm3i6+Jy76MEhciYmb0cZC4opMXLzJgsQVmbh4EQiJKzJx8dwFiSsycQmJi8SVmLh4VoTEFZm4eAqFxG1O3OJ2gLd/x2/X39ML3VakV/t9sTzeACrm4A2gAoeO9Gq/e9mH8MXbg/RCVYf0uvDuhdoL6cVTe/mj9MIbQEivC9MLbwAhvS5MLzhHpNdl6RUM3qZBerWnl380bAvRQXrhnRek14Xphb4X0uvC9ML7I0ivC9OLkF5Ir+vSC117pNeF6YWuPdKrPb0qzxyDQdce6XVheqFrj/S6ML3QtUd6XZdeFl17pNeF6YWuPdLrwvRC1x7pdWF6oWuP9LowvQjphfS6Lr3Q90J6PT7Y7lffMs3U0is5v394uk3hIL3Q90J6XZhe6HshvdrTK/pHeqXyM70c+l5IrwvTC30vpNeF6YW+F9LrwvRC3wvp1Zxe3uzqpFuiHKQXIb2QXtelF95WRXpdmF54WxXp1Z5e9JReIRykF7r2SK8L0wtde6TXhemFrj3S67r08ujaI70uTC907ZFeF6YXuvZIrwvTC117pFd7evnn9IoH6UVIL6TXdemFrj3S68L0Qtce6dWeXvscf/27HKQXuvZIrwvTC117pNeF6YWuPdLruvQidO2RXhemF7r2SK8L0wtde6TXhemFrj3Sqz290lN6lYNTOYiQXkiv69ILXXuk14Xpha490qs5vcjuG48ncgd7TBC69kivC9MLXXuk14Xpha490uu69Aro2iO9LkwvdO2RXhemF7r2SK8L0wtde6RXe3qZ5/Q6OBEtENIL6XVdeqFrj/S6ML3QtUd6NaeXy4/dCcmH2vXk7X49HW7YFNDlRzr2S0cfHukYbPX6HPbgKad8kL54ioD07Ze+gR7pG4+cL546IB3H3E2P0jHiKQXScaJ0xFMNpONE6YinIEjHidIRT02Qjv3SMcVHOhb35048EtIX6dstfcvjbnpruR+kI57iIB2H3E2P0xFPfZCOE6UjnvogHSdKRzzFQTpOlI54ioN07JaOZNMjHb3/cyee8NQH6dsvff3T3ZQOdl5PeOqDdBxzNz1MRzz1QTpOlI546oN0nCgdCemIdJwnHfEUB+l4STre0wtPZZBeF6YXnrIgvS5MLzw1QXq1p1d4pJfLB9tLJjwFQXpdl14ZTymQXhemF546IL0uTC88RUB6XZheeCqA9LowvQjphfS6Lr3QtUd6XZhe6NojvS5ML/S9kF6t6RVL3B9px5LKz/Qq6HshvZrvXuYh/O3f8SC90PdCel2YXuh7Ib0uTC/0vZBe7bVXMU/p5Q7Si5BeSK/r0gt9L6TXhemFvhfS68L0wtuqSK8L0wtvqyK9LkwvdO2RXpelVzTo2iO9LkwvdO2RXhemFyG9kF67NtaXTRubqXJ1orh99u2f5SC50PVCcl2WXOh5IbkuSy50vJBcrckV7aZ7ii4dJBf6XUiuy5IL3S4k11XJZdHrQnJdllzodCG5LksuQnIhuRqTK+QtS1IoB01UC7eI5GpNrlS2oFP29iC54BaRXJclF9wikuuq5HJwi0iuy5ILbhHJdVly4beMSK7W5MrB7sl1cJp7dPglI5LrsuQiJBeS66rkwvtcSK7LkgvvcyG5LksudOiRXJclFzr0SK7LkgsdeiTXVcnl0aFHcl2WXOhzIblak+v5fa6jDr0nJBeS66rkQp8LyXVZcqHPheS6LLnQ50JyNSdX3N+KiCn/TC7CWxFIrtbkSju/lCwdJBfcIpLrsuQiJBeS66rkgltEcjXXXCU9kiscJBfcIpLrsuSCW0RyXZVcAc8WkVzNNdd+FOPtnwc1V8Cvf5Bczcn19Osf6ytXW8phD4XyUV8soC+GZGxNxmzjnoxHHf2AvhiSi+NOd5hchORCcl2VXOiLIbkuSy70xZBclyUX+mJIrsuSC78WQnJdlVwRfbEpksvRhtC5ZL5dfdcJLaMpdPJu+2znyR/ohO6LDJ0IOonQCT2BOdan/NDpL5HcdYK9lqETnKoMnWD6ZOiE3RZE6JTwcpEMndCPkKET+hEydEI/QoZOmv2TCQ+dbjOusjR575W6p15pzl8sNXscbpaafQg3S81e4VOWtD9sc8F/Y3kQiysbee+ffnEX79yz5tp/JHfNtfyl3G+Pb3fuOT1x/+Tau0aa63gpGmmu4aVoRNBouEZk9/WInP2pkeZniVI0gg+eXyP467c18o/3unwyFY1C2gQN5Qngl33MsOJDsMO1j8BeYNqHYIdnH4IdNvxt7PR4lELPn36I/XYf2a6+5XZ6Bv/z4uxo451ddD9VghGXoBJBJQEqwYxLUAl2XIJKMOQSVIJ/l6AS7P78KiUDv/S2SsHtbeLgwjeV7ixRib3PkvaX/kIwByxxj3+f5X65CzEfsMSdmI2lRTeVjyVapBz3y4a7q8WqP4o8Op/XkI85bAhvz9UfG7TEL+4E7kO4oyYewx39xou4lx3K7WFj+sEdHcQx3OEXx3CHtxzC3cGHjuEOzzqGOxzrGO7wq1dx3x/MxBJ+cidwH8IdfnUMd/jVMdzhV8dwh18dwx1+lYP7b5ZecU1ubyvW9uG2mNou9pbSBsUG+/wTw6PI4yOFg326NnxxV1yTX8s97VYohwPuBO5DuCuuyYdyV1yTD+WuuCa/mPv+4uyv//0Hd8U1+VDuimvykdxJ8TOka7nHx5lV+YC74mdIQ7nDr47hDr86hjuB+xDu8KtjuMOvjuEOvzqEe1ipfnflsa2esabGnbOfHlaqxy/l+LpvFVaqr0dyXKleHsmRwJGF40r17LUcX/bbwkr16UiOK9WbIzmu9LzjUo6VOnyl5xcDOUb4GR6O8DM8HOFneDjCz/BwJHBk4Qg/w8IxHXK0aT+876kd6rI/+IK8I8++VK4teaNSyvdr78HEmYJJMwWTZwqmTBTM8XmGo4KxMwXjZgrGzxQMzRTMTHfgPNMdOPe9A8d9VTXGHUSTp4qmzBRNMVNFY6eKxk0VzfHdhkrZS8rgXte22Wx/tZmeSmwyX98QL/+GdPk35Mu/oVz8DdmYy7/B/vk3hM2B5RS/fcOBSzJlszLOmsfVdPSSRs7bPs/FutoH+7LN05F5PDzz+0Sdlol6LRMlLROt3+/Tt4neR8WmUalllLVX36esu/wb/OXfQJd/Q7j8G+Ll35CU/FnbrGWiRclEndEyUduySjjXNMq3jDrZm8Ht50B7bx8bb2yDqGVQaBl0/ArSB0dan197/4J09Rfkq7+g/OkXvD71O5/87JLxC+zVX3Cogbs99tj+em8PHX4MKg2Djl9xrw06uUt88ujrdsXXxeH5WeDXo68c3PVf4a//Crr+KwLrV5A5+Ip4/Vek678iX/8V5c+/IprtxhDdz1cKczTXf4W9/ivc9V/hr/8Kuv4rwvVfEa//inT9V+Trv+L6v+50/V93uv6vO13/152u/+tO1/91p+v/uhPH38XLX/flzJFRL1+EyidvSwS7vyIWPH37ivsw3zaM2oaFtmEn99/9hbbbsFDBZ4vLO+3iyg9DcfK0nvlLco8vKR2+5OSROfOX+Mv/NAvHPezlb9dyCdd/Rbz+K9L1X5Gv/4py9VcUY67/Co715OUPs4px13+Fv/4r6OqFt5hw/VfE678iXf8V+fqvKJd/hTXXf4W9/ivc9V9xmLQhbF3TkJ8rPfc1KLUMyi2DjlPFpH1Wv/5d/lKRlJPHXCaVvYQ1twfFP4bZtmGubZhvG3Z8szS3B0qPYU+bsG/DQtuw2DYsNQ3zJ7qVx3b0pkT7Y9gJyZK3bemtNeYHSU9tw0LbsNQ2t9w27OQPpxT/FGT46zAybcNs2zDXNsy3DaO2YaFt2PEfzu3S8hjmnrPkb5/n1PF+Wtxfknt8SfnzL3n9LLIcPyHk/Qp7/Ve4T7/iPsy3DaO2YW23yJPnc9VhqW1YbhtWmoZF0zbMtg1zbcPaFtLYtpCePOpIYb+xpvT8M9WjvxaXzP6GUXLux1eUy7/i5FEH61fY67/CXf8V/vqvoOu/Ilz/FfH6r0jXf8X1f93p+r/ufP1fd77+rztf/9edr//rztf/defr/7rz9X/d+fq/7vzxX/d9WGkaVkzbMNs2zLUN823DqG1YaBsW24altmFtWVJasiQYY9qG2bZhrm2YbxtGbcNC27DYNiy1Dcttw9qyxLZliW3LEtuWJbYtS2xblti2LLFtWWLbssS2ZYltyxLXliWuLUtcW5a4tixxbVni2rLEtWWJa8sS15Ylri1LfFuW+LYs8W1Z4tuyxLdliW/LEt+WJb4tS3xblvi2LKG2LKG2LKG2LKG2LKG2LKG2LKG2LKG2LKG2LKG2LAltWRLasiS0ZUloy5LQliWhLUtCW5aEtiwJbVkS2rIktmVJbMuS2JYlsS1LYluWxLYsiW1ZEtuyJLZlSWzLktSWJaktS1JblqS2LEltWZLasiS1ZUlqy5LUliWpLUtyW5bktizJbVmS27Ikt2VJbsuS3JYluS1LcluW5LYsKW1ZUtqypLRlSWnLktKWJaUtS0pblpS2LCltWdLWe7VtvVfb1nu1bb1X29Z7tW29V9vWe7VtvVfb1nu1bb1X29Z7tW29V9vWe7VtvVfb1nu1bb1X29Z7tW29V9vWe7VtvVfb1nu1bb1X29Z7tW29V9vWe7VtvVfb1nu1bb1X29Z7tW29V9vWe7VtvVfb1nu1bb1X29Z7tW29V9vWe7VtvVfb1nu1bb1X29Z7tW29V9vWe7VtvVfb1nu1bb1X29Z7tW29V9vWe7VtvVfb1nu1bb1X29Z7tW29V9vWe7VtvVfb1nu1bb1X29Z7tW29V9vWe7VtvVfb1nu1bb1X29Z7tW29V9vWe7VtvVfb1nu1bb1X29Z7tW29V9vWe7VtvVfb1nu1bb1Xe9J7LfsbhraQPRh2kiX7ln62FPdt2NFWvkwHhdzCSXOFk+cKp0wVzllve1Q4dq5w3Fzh+LnCobnCCXOFM9ddOc91V85z3ZXzXHflMtdducx1Vy5z3ZXLXHfl0vuu/PKMq1s8YbJ44mTxpMniyZPFU6aKxx0/wXW30vVrmHM2VOK5OXSzhx/TX3cvuH2J7fElrseXeJYv8fHxJdE/fcnBL/Ky3zYG8uZ53ydzvJ2q2fdcM/7x2/vivuKnyeMPO/8YvP8ZfxAefxQefxIefxYef5EdvzXC47fC43fC4599/a3FL3z9tcLXXyt8/bXC118rfP21wtdfJ3z9dcLXXyd8/XXC118nfP11wtdfJ3z9dcLXXyd8/XXC118vfP31wtdfL3z99cLXXy98/fXC118vfP31wtdfL3z99cLXXxK+/pLw9ZeEr78kfP0l4esvCV9/Sfj6S8LXXxK+/pLw9TcIX3+D8PU3CF9/g/D1Nwhff4Pw9TcIX3+D8PU3CF9/g/D1Nwpff6Pw9TcKX3+j8PU3Cl9/o/D1Nwpff6Pw9TcKX3+j8PU3CV9/k/D1Nwlff5Pw9TcJX3+T8PU3CV9/k/D1Nwlff5Pw9TcLX3+z8PU3C19/s/D1Nwtff7Pw9TcLX3+z8PU3C19/s/D1twhff4vw9bcIX3+L8PW3CF9/i/D1twhff4vw9bcIX3+L7PXXG9nrrzey119vZK+/fvr9r2rxy15/vfD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a+88P2vvPD9r7zw/a9I+P5XJHz/KxK+/xUJ3/+KjOz1l4Tvf0XT73/1+OiYin2O/+jiLeqY4+ODc/ia6+xrNedcZ1/XOec6ew3AONfp9+vinOvstQXnXCevQ0IJ+TFX93qulMoWB2Wf94tdyYdh27RH7Wm/2vvyxWbyGmcoGwKbUzaT12YpkPu6OkUTX7PxfrvW01PQR5eGGLaQQzJPF/+q/37GXMr+ycbkb1ffMU5eIkrBOHn1KQXj5IWtFIyT18xCMM6+fZ8UjJNX+lIwTm4ipGCc3G9IwUjAyIERLoYFI1wMC0a4GBaMcDEsGOFiODDOvgmqFIxwMSwY4WJYMMLFsGAkYOTACBfDghEuhgUjXAwLRrgYFoxwMRwYZ99KWgpGuBgWjHAxLBjhYlgwEjByYISLYcEIF8OCES6GBSNcDAtGuBgOjLNvyC8FI1wMC0a4GBaMcDEsGAkYOTDCxbBghIthwQgXw4IRLoYFI1wMB8bZjzWRghEuhgUjXAwLRrgYFowEjBwY4WJYMMLFsGCEi2HBCBfDghEuhgPj7IdDScEIF8OCES6GBSNcDAtGAkYOjHAxLBjhYlgwwsWwYISLYcEIF8OBcfYj9qRghIthwQgXw4IRLoYFIwEjB0a4GBaMcDEsGOFiWDDCxbBghIvhwDj7QaVSMMLFsGCEi2HBCBfDgpGAkQMjXAwLRrgYFoxwMSwY4WJYMMLFMGAMsx/3LAUjXAwLRrgYFoxwMSwYCRg5MMLFsGCEi2HBCBfDghEuhgUjXAwHxtkPoZeCES6GBSNcDAtGuBgWjASMHBjhYlgwwsWwYISLYcEIF8OCES6GA6ODi2HBCBfDghEuhgUjXAwLRgJGDoxwMSwY4WJYMMLFsGCEi2HBCBfDgdHDxbBghIthwQgXw4IRLoYFIwEjB0a4GBaMcDEsGOFiWDDCxbBghIvhwEhwMSwY4WJYMMLFsGCEi2HBSMDIgREuhgUjXAwLRrgYFoxwMSwY4WI4MAa4GBaMcDEsGOFiWDDCxbBgJGDkwAgXw4IRLoYFI1wMC0a4GBaMcDEcGCNcDAtGuBgWjHAxLBjhYlgwEjByYISLYcEIF8OCES6GBSNcDAtGuBgOjAkuhgUjXAwLxsldTCghbxizLRWMKW8X+/wUNhlzFDa5LRBL6aFQzkcfbbPZPtqWx8UuHkXtjduxW3pg9/YokGwjfV2d3ZNILtPB1ZSM/7qa0q8U2T47xC9JJ3dUkPRzSQmSribp5E4Tkn4u6eSuF5J+LunkDhySfi7p5N0ASPq5pJN3JiDpx5LmybskkPRzSSfv2EDSzyVF92g5SdE9Wk5SgqSrSYru0XKSonu0nKToHr0nKdmyfTRlV5E0GLs/ATWUHnPcqKPBM4I6ejADqBe0SUZQRydjBHU0G0ZQRz9gBHUC9QHU4apHUIfxHUEd3nQEdXjTEdSn8qa/QopmKuN2D2kqV3MPaaqS/x7SVPXwPSSaL6SpKql7SFOVGfeQplqD7yFNtUDdQ5rv7m3nu3vb+e7edr67t53v7m3nu3vPdcb9PaT57t5znb1+D2m+u/dcZ4L/Dmmu87XvIc13957r3Od7SPPdvec6j/ge0nx377nOyb2HNN/de67zW+8hzXf3nutc0XtI89295zrv8h7SfHfvuc5hvIc03917rvMB7yHNd/ee69y6e0jz3b3nOk/tHtJ8d++5zvm6hzTf3Xuu86fuIc13957rXKR7SPPdvec6r+ce0nx377nOkbmHNN/de67zTe4hzXf3nuvcjXtI89295zoP4h7SfHfvuc4puIc03917rv3z7yHNd/eea1/3e0jz3b3n2m/8HtJ8d++59sG+hzTf3Xuu/ZnvIc13955r3+B7SPPdvefaz/Ye0nx377n2E72HNN/de679HO8hzXf3nms/vXtI892959rP7B7SfHfvufaTuoc03917rv187iHNd/eeaz+Ve0jz3b3n2izjHtJ8d++5tlm4hzTf3XuuH+jfQ5rv7j3XT7vvIc13957rR8H3kOa7e8/1c9J7SNPdvdN8v7VM8/3WMs33W8s0328tk5nu7p3m+61lmu+3lmm+31qm+X5rmeb7rWWa77eWab7fWqb5fmuZ5vutZZrvt5Zpvt9apvl+a5nm+61lmu+3lmm+31omph8QmfQIyaankH5/yec/drkP823DqG1YaBsW24altmG5bVhpGvb5jwHuw2zbsLYsobYsobYsobYsobYsobYsobYsobYsCW1ZEtqyJLRlSWjLktCWJaEtS0JbloS2LAltWRLasiS2ZUlsy5LYliWxLUtiW5bEtiyJbVkS27IktmVJbMuS1JYlqS1LUluWpLYsSW1ZktqyJLVlSWrLktSWJaktS3JbluS2LMltWZLbsiS3ZUluy5LcliW5LUtyW5bktiwpbVlS2rKktGVJacuS0pYlpS1LSluWlLYsKW1ZUpqyJBvTNsy2DXNtw3zbsMMsobgP+3YszmNYOB5mH8Oc+c/XPYHbd39dnP1jm9pbO+Lg2pK3hkYp36+9hxPnCifNFU6eK5wyVTjHDyfGhWPnCsfNFY6fKxyaK5y57sp2rruyneuubOe6K9ved+X9mD5rjPsZjzOTxWMni8dNFo+fLB6aLJ6P7833YbFtWGoaxrQL3stHfZlpX7vKl/geX0I9viT0+JLY40t43gAg+/iSUJ6+5LMn4feQ8nwhlelCYtrx7YOQyJbtXBpyPzOJab83xoDcbAF1f3OrtgD23+qtGlGYLqI4XURpuojydBGV2SLqv8lbNSI7XURuuoimu2eH6e7ZA/Z3C8Zsnx2o1D67hP2jS7ZPE6CvCcTJJ5CL3642/vsEDhyys7tFdqF29e2Z5Paq6e1ZnKtc7YPbChwbH9eao2udLQ9+pny7+o49AfsI7BnYR2AvwD4A+4DdGYH9ht0C+wjsDthHYPfAPgI7AfsI7LP7vUWxw6UOwQ6X+i8jsMOlDsEOlzoCe4JLHYIdLnUIdrjUIdjhUodgJ2AfgR0udQh2uNQh2OFSh2CHS70Cu8tli9o/v3GyY4dLHYE9w6UOwQ6XOgQ7XOoQ7HCpQ7ATsI/ADpc6BDtc6hDscKlDsMOlDsEOlzoCe4FLHYIdLnUIdrjUIdjhUodgJ2AfgR0udQh2uNQh2OFSh2CHSx2CHS51APZi4FKHYIdLHYIdLnUIdrjUIdgJ2Edgh0sdgh0udQh2uNQh2OFSr8Ce7AbEJW8OsMOljsBu4VKHYIdLHYIdLnUIdrjUIdgJ2Edgh0sdgh0udQh2uNQR2F3/e3v222S9sb7y2aGE7aSMbMrj6hule/xBePxRePxp7vhj2I81isEfxJ+Fx19kx++N8Pit8Pid8Pi98PgnX3+r8U++/lbjn3z9rcYvfP31wtdfL3z9JeHrLwlff0n4+kvC19/+Bxsyxy98/SXh6y8JX39J+PpLwtffIHz9DcLX3yB8/Q2Tr79P/cOY00H8k6+/1fjl9J+P45fTfz6Of/L1txr/5OtvNf7J199a/HHy9bca/+TrbzX+ydffavyTr78p0Pa0OEUTn+M/eLLst2s9PQV9dGmI+1HJIZmni3/VKD9jvj3V3mM2+dvVd4yT30bmwOhN2d459994HF6d9ojTfiV98U6T3/aW4z35bXo53pMvK8vxxjLYlzeBd1fek9v85XhP3pZYjvfkbZTleE/e9lmON/xlV94Z/rIvb/jLvrzhL/vyhr/sy5vAuytv+Mu+vOEv+/KGv+zLG/6yK+8yez3octyjfzqf9pC3vZHb4kjx6YfR/vAJudl+Fx3IfLv2Tmb2ym0cGQKZEzKzV0PjyMxet4wjM3uFMY7M7LXAODKzd4UHkYnGzN6/HUdm9k7rODKKa+C47fZzs16Va8mFDSP93uDnyXTcOepdyfJ+8fO7tsfXOu+2ix2RmA2ZbHnI+ATva0Omm/p6V2uob4zeigTqG6u36oL6xuqtLKG+sXqrZ6hvrN4uOdQ3AzbYhvrzqK/3aQfUN1bvEx2obyx6fZrVR69Ps/ro9SlW36HXp1l99Po0q49en2b10evTrD5BfcXqo9enWX30+jSrj16fZvXR69OsPnp9C6vv8vYzUueN+6n+7IccQv1L1UevT7P66PVpVh+9Ps3qE9RXrD56fZrVR69Ps/ro9WlWH70+zeqj16dY/dkPVIf6l6qPXp9m9dHr06w+en2a1Seor1h99Po0q49en2b10evTrD56fZrVR69PsfoBvT7N6qPXp1l99Po0q49en2b1CeorVh+9Ps3qo9enWX30+jSrj16fZvXR61tY/WQ3eC5581P9iF6fZvXR69OsPnp9mtVHr0+z+gT1FauPXp9m9dHr06w+en2a1UevT7P6ent9xW1zLCFUrg0m7QefW/OcK19nmSe9XTNejnr7T7wc9XZyeDkq7olkv11sTKwtjzbuy6PzScryWNvONhHk1yy/4q4I5DdJcVsE8pukuC8C+U1S3BiB/CYpfgsK8pus+DUoyG+y4vegIL/Jil+Egvwmo+unWn6C/JrlR9dPtfzo+qmWH10/1fKj66dafnT9NMtf0PVTLT+6fqrlR9dPtfzo+qmWnyC/ZvnR9VtZ/tqmNwVdP9Xyo+unWn50/VTLj66fYvlvE4f8muVH10+1/Oj6qZYfXT/V8hPk1yw/un6q5UfXT7X86Pqplh9dP9Xyo+unWX6Lrp9q+dH1Uy0/un6q5UfXT7X8BPk1y4+un2r50fVTLT+6fqrlR9dPtfzo+mmW36Hrp1p+dP1Uy4+un2r50fVTLT9Bfs3yo+u3svyVo+6sQ9dPtfzo+qmWH10/1fKj66dZfo+un2r50fVTLT+6fqrlR9dPtfwE+TXLv5Tvj452+VNV0WK2q10JvnI1GbNlCxl6Tq37WeiWllpGPyLpjbF7ILnK3bv9L4nISvlLquyQaWmpdRT6f6z/Ugsp9P9Y/6Wen0H/j/Vf6gEa9P9Yf72VNPT/pf9Sj9Cg/8f6L/UMDfp/qn9Y6iEa9P9Y/6WeokH/j/VH/0+3/uj/6dafoL9q/dH/060/+n+69Uf/T7f+6P/p1h/9P9X6R/T/dOuP/p9u/dH/060/+n+69Sfov7L+tf0zIvp/uvVH/0+3/uj/6dYf/T/d+qP/p1r/hP6fbv3R/9OtP/p/uvVH/0+3/gT9VeuP/p9u/dH/060/+n+69Uf/T7f+6P+p1j+j/6dbf/T/dOuP/p9u/dH/060/QX/V+qP/p1t/9P9064/+n2790f/TrT/6f6r1L+j/6dYf/T/d+qP/p1t/9P9060/Qf2X9aydpFfT/dOuP/p9u/dH/060/+n+69Uf/T7P+zqD/p1t/9P9064/+n2790f/TrT/p1d+avAViQ6pcTalsgVAm83S1/yKpuJPGTFJxT4qZpOLuDjNJxX0Sm3aSztVIOhv3ddL5JGWdrOyTe/v/QX/N+lvFfRLof9NfcZ8E+t/0V9wngf43/RX3SaD/TX+C/qr119zdgf63WUF/1fpr7qRB/5vQ0F+1/uj/qdbfof+nW3/0/3Trj/6fbv3R/9OtP0F/1fqj/6dbf/T/dOuP/p9u/dH/060/+n+q9ffo/y2tf2WfHOfR/9OtP/p/uvVH/0+3/gT9VeuP/p9u/dH/060/+n+69Uf/T7f+6P+p1p/Q/9OtP/p/uvVH/0+3/uj/6dafoL9q/dH/060/+n+69Uf/T7f+6P/p1h/9P9X6B/T/dOuP/p9u/dH/060/+n+69Sfor1p/9P9064/+n2790f/TrT/6f7r1R/9Ptf4R/b+l9a+dkxfR/9OtP/p/uvVH/0+3/gT9VeuP/p9u/dH/060/+n+69Uf/T7f+6P+p1j9N7v9DCZtIKduK/j7lXdH8FDYZcxS292mL+nb5fnXOBxeT3/Sk/MQjmC+Mk9toKRgJGDkwTm7qpGCc3BtJwTi5xZCCcfJKfRaMIWwzDPEI4+QFrxCMefLnxtNgTGbDmMoBxskfv0rBCBfzHsayLTHR+AOMcDEsGAkYP8Ro7QFGuBgWjHAxb2GMaQMSsznACBfDghEu5j2MeQs6FjrACBfDgbHAxbyF8fbkZQvD5gOMcDEsGOFiPsXo4gFGuBgWjASMHBjhYt7DWLagszlaqeFiWDDCxbyFMe9/1PlwpYaLYcEIF/MeRu83jOR+YPQGLoYFI1zMpxiDOcAIF8OCES7mLYzFbteWg/LbGwJGDoxwMe9h9BuQQvYAI1wMC0a4mPcw7u/wlHj0Rw0Xw4IRLuZTjOlna8JbuBgWjHAxb2G0JmyvlN0CPSjALXwME0jFTobcFoilpx+kHYL0Nm8gvS2Pi108ivpWSz7m+PRO5O0+ehi22V4S8umppPp19V0kgkjzi6TYhckRSbHHkyOSYgcpRyTF/lSOSIrdrxiRnGJvLUckxc5djkiKuwJyRELHQYBIBJHmFwkdBwEioeMgQCR0HASIhI6DAJHQcZhfJI+OgwCR0HEQIBI6DgJEQsdBgEgEkeYXCR0HASKh4yBAJHQcBIiEjoMAkdBxmF8kQsdBgEjoOAgQCR2HS0Rybr+ackWkbOPjABnzuPr4SBhKZvsxOSX72NvAh/glKfoTy0lKkHQ1SdH7WE5SdEqWkxR9ldUkDfCO4iTdNzq8/TMeSIqKV5qk2Wy/Oqfb5QeSEiQdLuksB5va8lD96VzY7WBTH1BLI1neThZU6UiWt5MF9T+S5e1kwfNdJMvbyYLnzEiWd5MlomeBZHk7WfDcHcnydrLg+T+S5e1kQZ8VyfJ2shCSBcnybrKgg4tkeTtZ0MFFsrydLOjgIlneThZ0cJEsbycLOrhIlneTJaGDi2R5O1nQwUWyvJ0s6OAiWd5OFnRwkSxvJwshWZAs7yYLOrhIlreTBR1cJMumjPMP1ckdJAs6uEiWt5MFHVwky7vJktFnQbK8nSyEZEGyfCmT7CajS94cJAvcEJLl7WSBG0KyvJ0scENIlreTBW4IyfJ2suB9FiTLu8lS8D4LkuXtZEGfBcnydrLgfRYky9vJgvdZkCxvJwshWd5KFue2zfm8z7mSLGJeOijoyaqWH11W1fKjb6pafnRCVcuP3qZi+W9gIL9m+dF/VC0/Ooqq5UePULX8BPk1y4+un2r50fVTLT+6fqrlR9dPtfzo+mmW36Lrp1p+dP1Uy4+un2r50fVTLT9Bfs3yo+unWn50/VaW3+Wy6eiNO5AfXT/V8qPrp1p+dP00y+/Q9VMtP7p+quVH10+1/Oj6qZafIL9m+dH1Uy0/un6q5UfXT7X86Pqplh9dP83ye3T9VMuPrp9q+dH1Uy0/un6q5SfIr1l+dP1Uy4+un2r50fVTLT+6fqrlR9dPs/yErp9q+dH1Uy0/un6q5UfXT7X8BPk1y4+un2r50fVbWf7KUU5E6Pqplh9dP9Xyo+unWf6Arp9q+dH1Uy0/un6q5UfXT7X8BPk1y4+un2r50fV7T37yu/yUbUV+b81+taUnfof4Em2wbYpPF6eDi29W/evaGPzzpXc10cRbSU305GSpuQsTnxaIXU202ISpaTYc5uffZkTH7E01bXmo6SpqBrOXK8FQelbzTh2NqhHU0R8aQR1tmRHUCdQHUEcTYgR1eP8R1OHRR1CHlx5BHZ53APUEbzqCOrzpCOrwphdQp1LyTj2U/3zZVbt1Nrcu9s0+mZ8SwchOLxFBotklgkWeXiL46eklgvmeXiI49eklgq2fXaKMHsD0EqFhML1E6C7MJZH/KRG6C9NLRJBodonQXZheInQXppcI3YXZJSqo6BokihWJLO1vYVvy+bVE0dD20dEU8/pie7tiu/r27xB/KooCcDVFCYoupijKy9UURTW6mqIoXldTFE/SRCtafiqKB29rKRoMntOtpige662mKHpGqymKntFiijrN66jJJ4re0WhekCpoNN/ZK2iWukXmQDuaZGporNm2frH2aZLeHl1Ndt+Ojehx7eEnX7jRmy0PYUz5dvVdT4KeS+m5VEsderqlGurQ0y3VToeebqlmOvR0S7XSoadfqgEAPf1SXQvo6ZdqtUBPj/7QWnoS9FxKT/SH1tIT/aG19ER/aC090R9aS0/0h5bSk9AfWktP9IfW0hP9obX0RH9oLT0Jei6lJ/pDovR0eXsB2nnjDvREf2gtPdEfWktP9IfW0hP9oaX0DOgPraUn+kNr6Yn+0Fp6oj+0lp4EPZfSE/2htfREf2gtPdEfWktP9IfW0hP9oaX0jOgPraUn+kNr6Yn+0Fp6oj+0lp4EPZfSE/2htfREf2gtPdEfWktP9IfW0hP9oaX0TOgPraUn+kNr6Yn+0Fp6oj+0lp4EPZfSE/0hUXomu5F2yZsDPdEfWktP9IfW0hP9obX0RH9oKT0z+kNr6Yn+0Fp6oj+0lp7oD62lJ0HPpfRcqz9U9o8ujip6+v2T6SmM4wNYDy+1VL4gLtWUKX77oyATaxCzs9vV2QVbSd2BG23lpRoti2q0VPNkUY2WaoisqVFZqsmxqEZLNS4W1WipZsSiGi3VYFhUI4JG02u0VCNgUY3QZ5hfI/QZ5tcIfYb5NUKfYXaNokGfYX6N0GeYXyP0GebXCH2G+TUiaDS9RugzzK8R+gzza4Q+w/waoc8wXKPKDySjQZ9heo0s+gzza4Q+w/waoc8wv0boM8yvEUGj6TVCn2F+jdBnmF8j9Bnm1wh9hvk1Qp9heo0c+gzza4Q+w/waoc8wv0boM8yvEUGj6TVCn2F+jdBnmF8j9Bnm1wh9hvk1Qp9heo08+gzza4Q+w/waoc8wv0boM8yvEUGj6TVCn2F+jdBnmF8j9Bnm1wh9huEaVTYOjh59huk1IvQZ5tcIfYb5NUKfYX6N0GeYXyOCRtNrhD7D/BqhzzC/RugzTK9RmKquu4c0VRlzD2nsqu1rmWzznpw2U34kp/uKPwiPPwqPPwmPPwuPv8iOPxrh8Vvh8Tvh8Xvh8Qtff6Pw9TcKX3+j8PU3Cl9/o/D1Nwlff5Pw9TcJX3+T8PU3CV9/U/f111u/nZTsbTGVz3bebbN1RLV2kZjNP1ME9hHYE7CPwJ6BfQT2AuwDsGcD7COwW2Afgd0B+wjsHthHYCdgH4EdLnUIdrjUIdjhUodgh0sdgh0udQT2Apc6BDtc6hDscKlDsMOlDsFOwD4CO1zqEOxwqUOww6Vegb22/UWBSx2CHS51APZk4FKHYIdLHYIdLnUIdrjUIdgJ2Edgh0sdgh0udQh2uNQh2OFSh2CHSx2B3cKlDsEOlzoEO1zqEOxwqUOwE7CPwA6XOgQ7XOoQ7HCpQ7DDpQ7BDpc6AruDSx2CHS51CHa41CHY4VKHYCdgH4EdLnUIdrjUIdjhUq/AXtmIPjm41CHY4VJHYPdwqUOww6UOwQ6XOgQ7XOoQ7ATsI7DDpQ7BDpc6BHt/l+qc37C77GrYbdyxO5+kYK/8HDj1P5Yd2H9hL8A+AHv/w9OB/Rd2C+wjsDtgH4HdA/sI7ATsI7AHYB+BPQL7COxwqUOww6UOwQ6XOgJ7gEsdgh0udQh2uNQh2OFSh2AnYB+BHS51CHa41CHY4VKHYIdLHYIdLvUK7LWfFUS41CHY4VKHYIdLHYIdLnUIdgL2EdjhUodgh0sdgh0udQh2uNQh2OFSR2BPcKlDsMOlDsEOlzoEO1zqEOwE7COww6UOwQ6XOgQ7XOoQ7HCpQ7DDpY7AnuFSh2CHSx2CHS51CHa41CHYCdhHYIdLHYIdLnUIdrjUIdjhUodgh0u9Antti7YClzoEO1zqEOxwqUOww6UOwU7APgI7XOoQ7HCpQ7DDpQ7BDpc6BPsAl1q2i71/2hr812f/CikbN19Ifr6QqHdIZPz22WRC7e/l1dX3CQTpE4hzTyDmsN2DYk726ZPv4SfZ4WfZ4ZfJwy9mW5Jicemv4VsjO3wrO3wnO3wvO/zJV95a+JOvu7XwZ191K+HPvupWwp991a2EL3vVdbJXXSd71XWyV10ne9Xtfwo9b/iyV10ne9V1slddJ3vVdbJXXS971fWyV10ve9X106+6tLepSvgZ/vSr7uvwp191X4c//ar7OvzpV93X4U+/6r4M/+pjJO9f0v325m5/1F8Xe2N95bNDCfnr6nRz//vVvx6y/rjYp7xd7PNT2GTMUdi0H3FsKT0exOZ89NE2P52e/PTUNh4+/DPO7VdT3q/21sz8rNmb7Xm689Z+u/qeLIRkQbK8mywByYJkeTdZIpIFyfKlTOWHObn/8YhIFrnJkpEsSJZ3k6UgWZAsbyZL/wM0kSxyk8UiWZAs7yaLQ7IgWd5NFnRwkSxvJwshWZAs7yYLOrhIlreTBR1cJMvbyYI+y/hksfGRLCZX5KdUtrBv/3xE4sPXiwQR3RBpkub9bkHPRB6SomchTtJ9RwTK3h1Iis7CcpLC/y8nKUHS1SSFl15OUjje5STFm0XiJDVpl9SZA0nx/s9ykqJ7tJqkCd2j5SRF92g5SdE9Wk5SdI+Wk5Qg6WKSHh9XcJvhPuoRvi32axC1DAotgw47IcFuCRec/zboKIMemzPn/LRbbv76hnT5N+TLv6Fc/A3FmMu/wV7+De7yb/CXfwNd/g3h8m+Il39Duvwbrv6bLsc7oYZ9X4dA6cftshzvgBnSvhkEmYNBueWbjm85+/obIv0cdLxJYcjb8heKPxhkWwa5lkG+ZRC1DAotg2LLoOM/hb0+CeVIp9wyqDQM8ub1oGgO5nS8bVVIZR+UDwYdZkS0G73oy8EgX/mmo7+n442RKn+Ex9sR1Qa1/Lkfb/5iXdgmZV08QEG2bZhrG+bbhlHbsNA2LLYNS23Dctuw0jQsnGRJTvuwpxc7H8NsfVg8GObahvm2YdQ27DhLbvZtG+aPbjzHry/Xh6W2YbltWGkadvxqZn2YbRvm2oad6BZ3uX06WGWOH+/ZR41nAx38BaQTJGX/eyMTDobZ+rCDP9Pk2ob5tmHUNiw1DcvHJJ8bMd4eDLNtw45JUjT7sHhwUzg+pv127WNu6WARLidz21+FvzWCDnKy2LZhrm3YcZZQof0vwBzNjdqGhbZhsW1YOvnr3nUL7uDPtOS2YaUhyGSMaRtm24a5tmG+4T55G0Ztw0LbsNg2rDTcuZKxLXeu2zDbNsw1DUvHfs1tUws/z4RL5vieXBtkWwa5lkG+ZRC1DAotg2LLoNQyKLcMasmI45UslK24ik+PVh6DbMsg1zLItwyilkGhZVBsGZRaBuWWQeXzQdaYlkG2ZZBrGXR8T388hLs9WzwYdnJPrw47vqffnMo27PmR32OYaxvm24ZR27DjtdjGHYnNR0hOLGp5+LFy9G2laZgzbcNs2zDXNsy3DaO2YSc1lDOPYigdDIttw1LbsNw2rDQNO+5D14fZtmHHWRIepjHkcjDMtw2jtmGhbVhsG5bahuW2YaVpGJ31rfZh3h38vZFrG+bbhlHbsNA2LLYNS23Dctuw0jQsmLZhbVkS2rLkpAfu98e3tz/kg1vQSQ+8Oiy0DYttw1LbsNw2rDQNi20FRmwrMGJbgRHbCoyTXy29Pjn+9r8eCxAfvdSYjr6tNA076bhXh9m2YccCpLT9/sum4g6G+bZh1DYstA2LbcNS27DcNqw0DTt5mlAdZtuGtWVJbsuS3JYluS1LcluW5LYsOe5k2fJYFos7Glaahh33mFy223tNLsfHDe/4VeHs985r9k/PjI6vrryhewvJzxcSzRdSmC+kOF9Iab6Q8nwhldlCcsc91bEh2flCmu7u7QzH3dvt73hmsql29Ye7r+3n59Cte3YwAZI+gSB9AlH6BJL0CWTpEyjCJ2CN9AlY6RNw0icgfSW20ldiK30lttJXYit9JbbSV2I3/Trwcjfm2wRmvwvVHJnrfxeaZfN0Wx4bNZifz7edi0BzhiYBzRmaDDRnaArQnKDxBmjO0FigOUPjgOYMjQeaMzQENGdoUA2fokE1fIoG1fApGlTDp2hQDZ+hIVTDp2hQDZ+iQTV8igbV8CkaApozNKiGT9GgGj5Fg2r4FI3eavjWxtvRkDtAo7carqEJeqvhKhq9dU0Vjd4VqvKDPBf0rlBVNHpXqCoavStUDU3Uu0JV0ejt11TR6O3XVNHorWuqaAhoztDo7ddU0RxWw97sP4D25mlPr+PJWhvt/utsG10NjnP7bmi3av2x9Ze//fseVOIIKjz2rbXx6egM4b2S410zAOcOpwDOKZzjHVAA5w7HAs45HAc453A84JzDIcA5hxMA5xxOBJxzOKiQX8BBhfwCDirkczgZFfILOKiQX8BBhfwCDirkF3AIcM7hoEJ+AQcV8gs4qJBfwEGF/AKO5gr5NvsNjjcHb08VzRVyFY7mCrkKR3OFXIWjuUKuwiHAOYejuUKuwtFcIVfhaK6Qq3A0V8hVOKiQT+F4gwr5BRxUyC/goEJ+AQcV8gs4BDjncFAhv4CDCvkFHFTIL+CgQn4BBxXyORyLCvkFHFTIL+CgQn4BBxXyCzgEOOdwUCG/gIMK+QUcVMgv4KBCfgFHc4Vc+VWud5or5CoczRVyFY7mCrkKR3OFXIVDgHMOR3OFXIWjuUKuwtFcIVfhaK6Qa3AUH33k9+MR3a0heoBG7+ZhVTR6Nw+rolG8KWrFjSs++qiKRu/mYVU0erfSraLRu5VuFY3izd5raBRv9l5Bo/jooyoavdVwFY3eariKBtXwKZr+dc1nh9ensqG5/fMx3e3wej/gqJnPJpD3TLj9sxxMIM8+Aef3CXh3MIEifAIDDldhnoCVPgEnfQJe+gRo9gmYtE/AmYMJBOkTmH0lrk5g+pW4NoHpV+LaBKZfiSsTiNOvxLUJTL8SVyZwvCNQoi2iRPGniTje7+RhakrIB4N8yyBqGRRaBsWWQallUG4ZdKiTNftxE9bE8GMYHf9iuz7Mtg1zbcN82zBqGxbahsW2YaltWG4b1pYlti1Ljn+y8vreQcc/5Sj7baq4o0ENtwE6foG79k25ZVBpGHT8ImxtkG0A4VzLIN8y6FinuGVESQdpdPwCWm1QbBlUu10fDsotIErDoOO3YmqDWjLCt2SEb8kI3/KX60PLoNgyKLUM+jQjbv9lf115/HubbPby7+lP/lch+OPSSFvtF4N/vvQW1/HtjuvD859+eN52pow5//XDyx9/uNmWHPPXyI9vsywffvsP9+tCOkzXsB/WG9LTV5D/FdVxG/71kPT5kPz5kPLhkNt/+V9XHt/Fo98eR2TzuLdaX35LEz8fkj4fkj8fUj4ecnzvfj3k8M6d3T7k6f3QbYj7fIj/fAh9PiR8PiR+PiR9PuT4xpV3D13KtyEHj9/idl/3if7zYaDvH18u/fjjNwP4Pt5e+/Hu2o/31348Xfvx4dqPj4wfn/2Pj0/Xfny+9uOPq3O3vbRefPrrfeT4meHrIfbzIe7zIf7zIfT5kPD5kPjxkOPDUV8PyZ8P+Vz99Ln66XP10+fqHx/Q53Yr4mL6a/IfH1v3ekj4fMjx0620dTdc+fFXeXzw1+sh+fMh5eMhx0cnvR5iPxxy+y+Cl7jdNX775MOBlDbPFh09DbS3gbf//H///t/+6e//xz//47/fhvz6X//Pv/zDf/zTv/7L13/+x//3v7f/5X/82z/98z//0//67//73/71H/7xf/6ff/vH//7P//oPv/63vzNf/+e/3pye+1sywf+33879v94e9KS/3R6WhP/22+3c/vfbA55kXP71v/8aQCnmv1FKvwf8HmFiuV2R7MP8/7rO0d9c2Y3jr4+6fRG57WOC/VuIu6X6/f+K5m8xbJ+a099y2XPlfHh4fKH9m7v9v/7zxuj/Bw==","names":["deposit_private"],"brillig_names":["discover_new_messages","decompose_hint","store_in_execution_cache_oracle_wrapper","call_private_function_internal","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","directive_invert","directive_integer_quotient"]},{"name":"_compute_collateral_debt_value","hash":"6926501876322722265","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8945853978429536226":{"error_kind":"string","string":"Function _compute_collateral_debt_value can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_compute_collateral_debt_value"],"brillig_names":["_compute_collateral_debt_value"]},{"name":"repay_private","hash":"441099522481573682","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"field"},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"fromPublicBalance","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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D72eOT70eub40OuZ40MvZ27wodczx4dezxwfej1zfOj1zAXmlzPHh17PHB96PXN86PXM8aHXM8eHXs7c4kOvZ44PvZ45PvR65vjQ65kLzC9njg+9njk+9Hrm+NDrmeNDr2eOD72cucOHXs8cH3o9c3zo9czxodczF5hfzhwfej1zfOj1zPGh1zPHh17PHB96OXPBh17PHB96PXN86PXM8aHXMxeYX84cH3o9c3zo9czxodczx4dezxwfejnzGR96PXN86PXM8aHXM8eHXs9cYH45c3zo9czxodczx4dezxwfej1zfOjlzD0+9Hrm+NDrmeNDr2eOD72eucD8cub40OuZ40OvZ44PvZ45PvR65vjQy5kHfOj1zPGh1zPHh17PHB96PXOB+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczj/jQ65njQ69njg+9njk+9HrmAvPLmeNDr2eOD72eOT70eub40OuZ40MvZ77gQ69njg+9njk+9Hrm+NDrmQvML2eOD72eOT70eub40OuZ40OvZ44PvZi5myZ86PXM8aHXM8eHXs8cH3o9c4H55czxodczx4dezxwfej1zfOj1zPGhlzM3+NDrmeNDr2eOD72eOT70euYC88uZ40OvZ44PvZ45PvR65vjQ65njQy9nbvGh1zPHh17PHB96PXN86PXMBeaXM8eHXs8cH3o9c3zo9czxodczx4deztzhQ69njg+9njk+9Hrm+NDrmQvML2eOD72eOT70eub40OuZ40OvZ44PvZy54EOvZ44PvZ45PvR65vjQ65kLzC9njg+9njk+9Hrm+NDrmeNDr2eOD72c+YwPvZ45PvR65vjQ65njQ69nLjC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYeH3o9c3zo9czxodczx4dez1xgfjlzfOj1zPGh1zPHh17PHB96PXN86OXMAz70eub40OuZ40OvZ44PvZ65wPxy5vjQ65njQ69njg+9njk+9Hrm+NDLmUd86PXM8aHXM8eHXs8cH3o9c4H55czxodczx4dezxwfej1zfOj1zPGhlzNf8KHXM8eHXs8cH3o9c3zo9cwF5pczx4dezxwfej1zfOj1zPGh1zPHh17N3Ez40OuZ40OvZ44PvZ45PvR65gLzy5njQ69njg+9njk+9Hrm+NDrmeNDL2du8KHXM8eHXs8cH3o9c3zo9cwF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68T0okdPeuWnVzCP9Io76eVod5Fe2enlo2zpFaaddy8dHS/SKzu9gn0sjkH8TnrR9CK9TkwvIb1Ir/PSi74X6XVietH3Ir1OTC/6XqTXielF34v0OjG9eD2V9MpPr+gf6fUEfEsv4Q1V0uvE9KJrT3qdmF507Umv7PSK03Yyro/G7KQXXXvS68T0EtKL9Dovvejak175tdfTCznR2NT1GcfSb42PeV6WnfTlqQDp23D68tSB9G04fXmqQfo2nL48NSF9203fmacypG/D6ctTH9K34fTlqRLp23D68tSK9K04fbfHFrOfpp30FdKX9L0sfbdZ/krfVDRG4kMg+fPn39OXzgPpW2/6zvGRvmHnjSpP54H0bTh96TyQvg2nL50H0rfh9OWNM9I3P33np7f9/V568UYY6XVievHGFul1YnrxRhXpdWJ60Xckvc5Lr0BfkPQ6Mb3o25FeJ6YXfTXS68T04o0b0is7veLG+/bveWdv6iCkF+l1XnrRtSe9Tkwvuvak14npRdee9DoxvWirkl7Z6bU8Xo73i5ev6RVpq5JeJ6YXjQnSKz+9/GNxXMKyk1480ia9ctMrWLOdyXb79/w1vRYeCpFe+ek1u0d6xZ0fGi48FCK9Hh9s57ClVww/uPqeXFReJNdpySUkF8mVl1wm+sfPPm7/3nGNCw+ESK8T04sHQqTXienFAyHS68T0oudFep2YXjxvJL1OSy8/8byR9DoxvejYk14nphcde9LrxPSiZ096ZadXMA/hw2x20ktIL9LrvPSia096nZhedO1JrxPTi6496XVietG1J71OTC+69qTXeell6NqTXiemF1170uvE9BLSi/TKTa84bcedxWimnfTCOZJe2em1PN29Frd398I5npReQWRLL/l89Z08pqoQeYvfKEWeUrwUed4tKUWe1y5KkRfIn0Q+PErnYHbI87C+FHmeY5cij1EvRR4PW4o8HrYQeUc9fxb55VFVLn6HPLXNSeSjrJ1QG2e3Q57aphR5apt98nc61B+v6FAjvKAj9KJf0aFf/IoONeArOiP3XRe7vVZglyUk1n8/PbaefKp44/xBUiCpRHJk76BLcmQvoEty5Npel+TIPkCV5Dxy3fcmye0hqH96O/VBkrX72yT946W9uENy4LXbubCyMU5mmyBpbsFsm1GYGB6vtfrdjutkt46rtU/X3rkPvNIX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ZOLy3IXEbTJxhcQlcVtMXJ4VkbhNJi5PoUjc7MRd7Abw9m//6fp7etFtJb3y74vL4w2gZdp5A2jBoZNe+Xcv8xB+cWYnvajqSK8T717UXqSXTu3l9tKLN4BIrxPTizeASK8T0wvnSHqdll7zxNs0pFd+erlHw3YR2Ukv3nkhvU5ML/pepNeJ6cX7I6TXieklpBfpdV560bUnvU5ML7r2pFd+eiWeOc4TXXvS68T0omtPep2YXnTtSa/z0svQtSe9Tkwvuvak14npRdee9Doxvejak14nppeQXqTXeelF34v0enyw2a6+ZdqUSq9g3fbh4TaFnfSi70V6nZhe9L1Ir/z08u6RXmH5ml6WvhfpdWJ60fcivU5ML/pepNeJ6UXfi/TKTi83beqEW6LspJeQXqTXeenF26qk14npxduqpFd+eslTes3zTnrRtSe9Tkwvuvak14npRdee9DovvRxde9LrxPSia096nZhedO1JrxPTi6496ZWfXu45vfxOegnpRXqdl1507UmvE9OLrj3plZ9e2xx//XvZSS+69qTXielF1570OjG96NqTXuell9C1J71OTC+69qTXielF1570OjG96NqTXvnpFZ7Sa9k5lUOE9CK9zksvuvak14npRdee9MpOLzHbxuNB7M4eE0LXnvQ6Mb3o2pNeJ6YXXXvS67z0munak14nphdde9LrxPSia096nZhedO1Jr/z0mp7Ta+dEtFlIL9LrvPSia096nZhedO1Jr+z0svGxO6G4OXW9OLNdL7sbNs10+UnH69LRzY90nE3y+jhvwUsMcSd9eYpA+l6XvrM80tfvOV+eOpCOZe6me+noeUpBOlaUjjzVIB0rSkeegpCOFaUjT01Ix+vSMfhHOi72507cC+lL+l6Wvsvjbnprue+kI09xSMcid9P9dOSpD+lYUTry1Id0rCgdeYpDOlaUjjzFIR0vS0cx4ZGOzv3ciQee+pC+16Wve7qbys7O64GnPqRjmbvpbjry1Id0rCgdeepDOlaUjkI6ko71pCNPcUjHU9Lxnl48lSG9TkwvnrKQXiemF09NSK/89Jof6WXjzvaSgacgpNd56RV5SkF6nZhePHUgvU5ML54ikF4nphdPBUivE9NLSC/S67z0omtPep2YXnTtSa8T04u+F+mVm15+8dsjbb+E5Wt6LfS9SK/su9f0EP72b7+TXvS9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","names":["repay_private"],"brillig_names":["discover_new_messages","decompose_hint","store_in_execution_cache_oracle_wrapper","call_private_function_internal","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","directive_invert","directive_integer_quotient"]},{"name":"emit_position_update","hash":"14252606296936532450","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"user","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6828137438660822608":{"error_kind":"string","string":"Function emit_position_update can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1da4gkVxWunu6amZ7HTmcfyWbzWoxEAgrd8x4UHZOZZJPd7GZnn9lNTHqne5aVJBsma0yikjIoSgSVgAoKEUTJHwV/BCWBYFAihqBEUJRIRNBEEQNB8QUqbs3U6f7661O9dXfunanp1IWhuvvc/s7jnnPuqXvr9uS81dZz/i8XvS5E17zX3qTPbHQtr61VLGKVXcqZ2yRy9jiSs8UZcpHDxDVR6lTv6rUYve8Bet6i0kXiaxN/ujxZLir6WZR/rBhhFhzj+27wy30Rzl1BEx91Eb7D0fsc2FK+IzT0qw8RDX3w7ojWf/5vi9d8fX30uki8XPgEymvbptsU+XtAt7DdGDjhPSb4c4DvWdRN8OfdyN/AvynCdyH7zW5s08hle9zYpoF/i3XbjC4J9q3Wsccacu+1j93w9332sScE+zb72JOCvd8+9rRgH7CPPSPYt9vHPiXYB+1jLwr2gn3sumAfso493shZh+1jjwr2EfvY44J91D52I3aO2ceeEuzj9rEbcXmHfexGXJ6wj92InZP2sRvzzp1rxx7lDwa91brymWiil1rUb7JqqdHwGra88pnUcSUFay5o5dNrkQ9i3UR8+izwkZq4H2iz0bW8tjZaIjmRz1CkY9iqD9134IHFs7X6B2u15fqDD+ZIr35Ffq2ZYBYNMHcy5v6P3HvvmaUz9eX5h888eK4Ne0DBltc9nq4byxV3r+4Tj5noGuI8l2vKPMIyH6rfX6svp8m0HqniKzIViSZ93x9dw77PR4wcuvK4YG8B2SyW+EsS0iNeexNaCXjz7fklQOsl2lag9RFtG9D6ibYdZJAyW2g74HtaypHG65Fow5DfC5CiuZ9H8qBflYiGIXcJ0QaBtpVoQ0DbRrRhoIktil67Te35QWWMx8VT7LAdeBeJhuMyQLRLgTZItMuANkS0nUAbJtrlQMNlFW6aH4gNQz/4Yk8Tl/t5xBPzw3aiYXzuINoI0C4lGsbWZUTD2BJbiB+gj1j0g1GOXU+xQ5LYRZtoPjJCNPQRjjH0EY6xnWQHec1N8wOxYajDPfkmLvfziCfmA45dzAfsI5gP2EcwH4gthgCjOZ2eO7tcPV1fqFdrPP/FzancbyimH8uCfdz6XXlUy+U8nsh/QNHF5tJXjviJPGyfHrLdFkXWkkLrXx+71lkubFp+ivMN0R8bx9CuQhOX+zFP9NURsgXadza6ltfWJtI2f3IdhbmR6yjMjVxHJZk/wyZLitr8qcWetAvNny8Y1FFaXbNR8yfa1KIfTPG4eIodktY1PH/uAhrPn1cAjefPK4HG8+dVQDOto8SGpnUU5pidRMP4vJxoWHfsIhrG1hVEw9gSW4gfoI9Y9INJjl1PsUPS2pfvHdBHuP5AH+EYQx/hGLuS7CCvuWl+IDY0raMwH3DsYj5gH8F8wD6C+UBsYVpHxc2B3K8U049lwT5u/S55HSX8BxRdXNRRl5A8bB+uo7YqspYU2tC62NX8vijON0R/bBxDJnWUto5Q9NrtOxtdy2tr02mbP7mOwtzIdRTmRq6jksyfYZNtSG3+1GJP2oXmz3cYjLlW12zU/In2tugHVR4zT7EDjhnXNTif8fyJY8bz59VA4/nzGqDx/LkbaKZ1lNgw9IO/GvgB5hgeM4zPK4mGdcdVRMPYElvIWKP/WBzrGY5dT9EVY5fjE/2A7w/QD7jGQD9AvblpYya2CMfs234Tl/uxHhi7HIMYu6KTw1w+U1R038hx5VyO48q5HMeVczmOK/vK1SCDPPahxbdpLhcbmuZymzlZi32Ob4x9ju+0+AHnZPQDzsnoB5yT0Q84L2Ce57yAfmCay9EPTHI5Pm7LftALNPYD3OJmP8D5QWwhY43+s5H3vRzz6IMc81hrcMxr80PSMRNbmOZyjF32IYzdncCbx7qfZOPxHlLoOObafRWurW5V6No9A9LRfrgXO6zwFLu4XV8tV7V8rN3XCv8BktWyPI37Ws2+aB++r92myFpSaKhb3DhtU/hoWDmLWD0WsXyLWL0WsfosYvVbxBqyiMV1EcYVx7SjYwunksa08B/w2v3ZRUz3KHbNKXYd9tpjlW2O8408RpdTaHnlswwrw9poLPFxfnxQu3peskdLeQ4Jm8sjWOdb4x6kAHLNB6vXcO7Yn2uVSfTwvabtCorcPvX/Vq6JeTB6PaJ8nx+Dxcd6Z9eoc22sNjNdmRqXGjYfNPkWgG/YCoETe58K570XoZbGOXrFbkGrLfGR4rzSn31Gq5t53g5byWufh32iITbfc6AfZ/NiqzwXmhc1fy957XHIeaug8CkofDKsDGujsLpkXqxyDRs2nBcfpXlRbIHzYl6R26f+X4Z58RM0L2r1s+Nj6FXOaXmvfX3GU+TpcyPPmMiDc15esQGve6Fvmvgf8hrw2vO1i/lD061T3OE9Pa8VaFi9hlgbOaZoa65btFpIq9u1+q6PaAWg9RLND9ptEtZJv/Fb5Uk6biNe+1jJdx3bejTntduJ/QL5h2spspbeeCZo/r4z547cX79/cfmRB87Va/vOnvaocbrPweecyvyY7+S91p/QkTYImH4HNRCzk8tw6gybdivSRzT8XidXwzAKWyFo5TcbfV5eW1NvJVBfdOPwr9Otgee1266o9MfbBbFdifqjHbUpnMNaKzvQXeVXHLRlJfkuTsmdps9OoastT3fyo15FDs1XOPWgr4iM3X7byf5getvZKY2h/7Cv8NTtea3LGi7tPjVdLudE1gjf91p18Ii/T/2fjQD4BKvoNnuRci5NVStLY9Wl6kS1VhtfrG4l/LDJOAw64H+qXqmPLS0tjdWr40uTS+vOf6K+ODpZrY0uLtYXpycnyhfir51e34DjQOM5RU6thBX+m/k4UNj4FnWLwmeLwme9sPiRbcEPm+MjyhNJfUH4D3hOfbPSya7Dil21x9bluyWihY3Hb0ThM6Lw2UxY8usbHCeCr12FD38W578Ym51y2cXywVwzTHyGLfJBrPmglc+IRT6INResXvnxQ7uxVKloj5RI0x6L5CNR2va49ggOj0/So8hYV3Hj+gbtFM6jbyR4lMjtrzlWyvwoGDa2vWZf7aiFZnu2L9qe7asddUxqX7FTUvtq97uYh1GGgsInbHPB6tWn/v+LGLmNkXJbzYa83k7+czE+sru3icv9pGk+soVo2iN5QispemhzEd8b4vzRSzSsXUpEwzx9c9Dsx/Obdj8r942azjw3yvfE73FN6pagte8Q9dW2TDh+PhlNQOH77T3Jed8ag/cw4F1mgLcvBu8s4O0ywLstBm8J8K4ywNsfg3cX4O02wDsQg3cY8K41wLs9Bm8v4F1ngHcwBu8GwLveAO9oDN4M4L3bAO94DF45wnB8b6zOB8gL5Y2L77lA128s0iHMnXdA7gz7aI9XCA3Xufi+p0h2QBqudxSIJj+XEjb5BcNQpCd67Oj6vpTqesyBrvMp1XXBga77U6rrIQe6Hkuprocd6HpPSnU94kDXMynV9agDXZdTqutxB7p+LKW6nnCg66dSqutJRVdtH41/xjAHNH4MB/fy+CfxcI+Uf/4Q1+VEt2wfJrZl+zBeu/7sC9k+TLYPk+3DxMfJxfLJ9mGavLN9GCP7ZvswXrt9be3D/IzW3bJ9mGwfJtuHaY+fuH2Yg9Hghe//YLAOHrcPswfw/mhhH+YDgPdnC/swk4D3poV9mPcA3lsW9mHeCXh/s7APcwXg/cPCPsxWwPu3hX2YIuD9x8I+jCSjzbwPk490SPM+zIm8HV2HUqrrMQe67kiprgsOdL06pboecqDru1Kq62EHupZTqusRB7rOpFTXow50vSGluh53oOvelOp6woGuh1Oq60lF182wD4M6iCz8r0sEczZ6X15bS7wPI/wHSFbL8jTW3rX7XLQP+82wIqu2vspr3Np+j7bGv15YG7gnl3gfJtuT2zxYvA/jYt9Cy3uDFvlgrlmP/Z6wzQetfFzsX4VtLli9SmzjWuhGrvPyei2uSfBYJ92j6fRv+0z3YcRO6diHMf93p2xftD3bN+kaO9sXbb8R+zCYh1EG032Yp2jdzU2M6Otu/C/k3g7+czE+shvqf+4nTfORYaL1KnoITft3gtpcxPswOH/wPgzWLiNEwzzN+zA4v5nuw/Dc2Gktem/Q2neQ+ibZhxmOOoXvn8kn570Qg+cD3vcN8A7F4P0X1umfM8A7HIP3d8B73gDvSAzem4D3ggHesRi81wHvRwZ4d8TgvQZ4PzbAOxGD90vAe8kA72QM3k8pfzu6X1DzN/+0tbbWgfE4F+j6vZKCtY6Q7Y6CHX1+3WX6/K7L9PlTl+nzVpfp868u00e+0C369HeZPqWU6eNyPT3JmnmO+npesw7PwWdch/coOucVvtjPV7DjeOP3coSh2aUnRr8NXAfOzmYofLKzGa164GfIPzubkX6s7GxGcj6INR+08snOZjRp2dmMNvtmZzO8dvvaOptxT9QpO5vR5J2dzVht2dmMZovbE/g9rOE/VEjOO+5sxquA94gBXtzZjJ8D3scN8OLOZvwE8B4zwIs7m/EDwHvcAC/ubMb3AO/TBnhxZzO+A3ifNcCLO5vxTcD7nAFe3NmMrwHe5w3w4s5mPEnzgaP7D6dnM76UgjUe7fkdPJvxlwTrWUl0fSqluh5zoOvTKdV1wYGu302procc6PpsSnU97EDXH6ZU1yMOdH05pboedaDrL1Kq63EHur6WUl1POND1jZTqelLR1eVekg+07GzGmlp2NsNr1599wdF9R3Y2Q+GTnc2I54N+mJ3NSM4nO5ux+j47m6HbPjub0dq/HPHPzmY0ebv0n4vxkd1Q/3M/adnZDH1udH024+sRYPj+Jj8577izGV8BvFsM8OLOZnwB8PYZ4MWdzfgM4B0wwIs7m/EY4C0Y4MWdzfgo4B0xwIs7m3EW8I4b4MWdzTgNeCcN8OLOZtxN+Xszns04Fb3Y6Gdjn/bt6PPhLtNnucv0ebTL9Hm8y/R5osv0ebLL9Plql+nzjZTp43I9PcmaeTivy/1t9aH7DjyweLZWP3Tu7HL1dH2hXq0Jb8HBNXqPaJ6iK/eT2gVr/NnoWl5bq7CNNFmEr6nehYR698X0G/ba9c6RTfC7Fuu50Zwik7YeLfwHSFbL8jTWo/tIHrYPx1m/ImtJofnrY9dplgublhtM145E7hB/F+y/cT/miTFaBHy2Ba8f5RU5tTEqxOhU8PS8xHuM6HMia5iXZN2gNwCeQbNv2Pqi9yIv9xe+PvV/Ce7FXobcu9JX4Rf2e7VDv1zMdQVD+awQtH5WDNr754P2/o09oqBdRqENAs0nPkPRe7QXYokcPvX/VfRBY30YviPfLyn8+4l/i9zKZ+gnjJVXPpP+4fi8Esko8yXqbjtfrfAkfPyMZRPfGfTafRd1wzEX+WVc0eY85ug/BZArbGJfHHPEEjl86v86jTnqJt8vKfzRLsxL489jrsVCUekf2vW3YFesY7R1T8ESWlzuwxyOn2PumwtWrz71f5PWZLgWnI3el9fYtDWZIunQBzpo8+mNQasO0r8v6hRe3gIfYHsKb82ePUTrJzsgDeXmcWjEMujQ30EH6f9PqOvvhLo+bDiHiD4iQyFolXM2+ry8tjYeyvEi1fgi64r8Qave2jo49seYCf86PdeBNtPW533C8hUstPkeklVs2Kv0Rzxev+yJXoR97+5tlQ/9eoBkR9257ssrfIWGvlUEma+JePO9iGUfmOL7SmxaTZsjGsYJ18IDJDPS0A9M94PFFqZ7UTbyBNaJK/IF7XJtRNwKz7Bx3GKM5pX+HLcXivP5YPWq7bmxf2tzgUnMhG0P8UN/kbHBmIl75s5XdAi/cm1vEw/HEfM7fpfzu/R/L8xR10WvRzw9nyEN/ZJ9j+8Lkab5pTZ/sd/j2Hfyh5LyfennuJYY1+ajHPF29Fxi4mfjhP+Ap+e7WTvyVDrFpbYWsR7PkYZ/2rN6Wj0QPq+wxWsfM+3MvTYfarmE8wzmEp6bcew4z2i5RO7ztXnXA1kES8sTWtzhWGl5RfIc176zkFeOUV7R1oO1/MB5RVsPFpq2Hiz4Wk2HdRjPJZ2e50T9hTf6x3ACrL4OvDv9pofGG+XiZwD5Wcq45xRXeAVNmtjGcU0wodUEmC+4Jkj6zHUnW2rjqJ2V5udyMY45HpHvING0vQItjsV/MV60dUe8R5AaAH3fA+zZ6H3ZtI3WFifro1PT5anJyuhMje+RPa/1N5ts81+cmDy1OD5RLdcrK9KsN//zrKcWq1OVysx4pT5embgQ//8D1vEyQbvjAAA=","debug_symbols":"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","names":["emit_position_update"],"brillig_names":["emit_position_update"]},{"name":"constructor","hash":"10431881581836879204","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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Lm3GhXr3mAv17iGXTL17zIV695iL75yL2fqR3tiDfkDuvc4oxd97PVCKv/d1uxR/7+trKf7e18Hv47dL7+tVKf7e15VS/L33O0rx996XKMWve/21i+711y6611+76F5/7aJ7/bWL8vXXKF9/jfL11yhff43y9bfJ/v6S8Stff43y9dcoX3+N8vXXKF9/rfL11ypff63y9dcqX3+b7GssGb/y9dcqX3+t8vXXKl9/rfL11ylff53y9dcpX3+d8vW3yX6OkvErX3+d8vXXKV9/nfL11ylff73y9dcrX3+98vXXK19/vfL11ytff73y9dcrX3+98vXXK19/V+Xr76p8/V2Vr7+r8vW3yZ6DkvErX38730mwHL/y9bfznQTL8StffzvfSbAcv/L1t/e9AYvxK19/e9+/rxi/8vW39z32ivErX3973wevGL/y9bf3veqK8Stff3vfT64Yv/L1t/f95IrxK19/e99Prhi/8vW3+/3kSvErX3+735+tFL/y9bf7/c5K8Stff7vfP6wUv/L1t/v9uErxK19/u9/fqhS/8vW3+/2iSvErX3+z8vU3K19/le9/ZZXvf2WV739lle9/ZZXvf2WV73/llO9/5ZTvf+WU73/llO9/5Rbd66/rfv+r0/YVDdtYsyz20+A7mGk3ui6BmXan6xKYabe6LoGZdq/rApjuNy9rBkbvKSb3+PWeNnKP3yuPX29Vc49fb/Fxj19vjXCPX+9Sfo9f74r7O/7udxUrxa/3tIZ7/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexQvzd7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf9/rru99VrBS/7vXXd7+rWCl+3euvX3Svv17xrmL3+HWvv17xHl33+HWvv17xjle/41e8MdU9fuXrr/L9r7zy/a+88v2vfO/7XwWXt/jT4gov/aON5dI2w5w/j71z6Xxdb8al83qhGZfO65DzuHy/QaPvfYOxZmB637msHZjOS7J2YDqv9dqB6byIbAfG9w0m7S/tky+BicF9DI4x7GO9/Zhq54Ws5FQ7r00lp9p5ufnNVO/xd14WFuPvvHorxd/59nSr8es22IQDe9759nTl+PsuWcrx911ZlOP3yuPve1Uvx9/3Ul2Ov+/1txx/3+tvOf6+19/n+K2xX+PvfHu6cvx61t/j+PWsv8fx61l/j+PXs/4ex9/5+htN3AenfBB/5+tvMf7O199i/J2vv8X4O19/S/F3vj1dOf7O199i/J2vv8X4O19/i/F3vv4W41e+/na+PV05fuXrb+fb063JLdvgHFLhpX3eJ/v8VaZkD8bauGzHGdtoH5Vt+ODS+breikvn2+m149J5HSLE5T7XzmsW0bl2Xt+IztVPNNfO6ybRuXZeY4nOtfN67EdzvbXctsE+Hcx1pNqtNNeR6rHCXDvfMlF2riPVTaW5jlQ3leY6Ut1UmqufaK4j1U2luY5UN63rXjelg7qp820mZec6VN1UmOtQddP3c+18q0vZuQ5VNxXmOlTdVJjrUHVTYa5+orkOVTcV5jpR3dT59qDfzfUev95a6B6/3vrmd/ydbw9ajl9vHXKPX29tcY+/73ohLMsWSHDBHMTvlcff97pejr/vtbocf9/rbzn+vtffcvx9r7+l+NfOtwctx9/3+luOv+/1txy/7vV3XXSvv2vn24OW49e9/q6dbw9ajl/3+rt2vj1oMf7Otwctx698/e18e9By/MrX3863By3Hr3z97Xwbz3L8ytffzrfFLMevfP3tfJPJcvzK19/Ot2wsx698/e18A8Ry/MrX3863KizHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18/8Fy/MrX3873HyzHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18/8Fy/MrX3873HyzHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18P79y/MrX38730ivHr3z97XzPu3L8ytff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M0/40OuZ40OvZ44PvZ45PvR65h7mlzPHh17PHB96PXN86PXM8aHXM8eHXs4840OvZ44PvZ45PvR65vjQ65l7mF/OHB96PXN86PXM8aHXM8eHXs8cH3o187zgQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxodczx4dezxwfejlzgw+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzC0+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzN3+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17O3ONDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfMVH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZB3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZx7xodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZx5wodezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5hkfej1zfOj1zPGh1zPHh17P3MP8cub40OuZ40OvZ44PvZ45PvR65vjQi5m7ZcGHXs8cH3o9c3zo9czxodcz9zC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYGH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZW3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ+7wodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZy5x4dezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5is+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzMP+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17OPOJDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfOED72eOT70eub40OuZ40OvZ+5hfjlzfOj1zPGh1zPH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+E3SFW+SL3iTF4/Mhd/Enf7RzBL3sG9/u5byev5bhPPfIp7/Fun8t8hnv0VelvPfQmI9+faHWXmx57+FO/8t/NkLb17W898inP8W8fy3SOe/RT79Lcxy/luY89/Cnv8Wh0m7rlvXdE3PlZ79uCjWXJRqLjpOlSXus/r1d/5LRZJfPOZaYt5L2OX2oPjLZabuMlt3mau77PhmudweKD0ue9qEfbtsrbss1F0Wqy5zL3TLj+3olxzMl8tekMxp25bemGX5QtL5usvWusti3dxS3WUvPjg5u6cg179e5pe6y0zdZbbuMld3ma+7bK277PiDcxuaH5fZ5yz5+89z6ng/Lek3SVe8Sf7zN/n+WWQ+fkIo+xbm/LewP32L+2Wu7jJfd1ndLfLF87niZbHuslR3Wa66LCx1l5m6y2zdZXULaahbSF886ojrfmON8flnqkefFhuX/RtG0dovb5FPf4sXjzpE38Kc/xb2/Ldw57+FP/8t1vPfIpz/FvH8tzj/0x3P/3Sn8z/d6fxPdzr/053O/3Sn8z/d6fxPdzr/053O/3SnH3+675flqsvyUneZqbvM1l3m6i7zdZetdZeFusti3WV1WZJrsmRdlqXuMlN3ma27zNVd5usuW+suC3WXxbrLUt1ldVli6rLE1GWJqcsSU5clpi5LTF2WmLosMXVZYuqyxNRlia3LEluXJbYuS2xdlti6LLF1WWLrssTWZYmtyxJblyWuLktcXZa4uixxdVni6rLE1WWJq8sSV5clri5LXF2W+Los8XVZ4uuyxNdlia/LEl+XJb4uS3xdlvi6LPF1WbLWZclalyVrXZasdVmy1mXJWpcla12WrHVZstZlyVqXJaEuS0JdloS6LAl1WRLqsiTUZUmoy5JQlyWhLktCXZbEuiyJdVkS67Ik1mVJrMuSWJclsS5LYl2WxLosiXVZkuqyJNVlSarLklSXJakuS1JdlqS6LEl1WZLqsiTVZUmuy5JclyW5LktyXZbkuizJdVmS67Ik12VJrsuSut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZoXvde8f8PQZG8OLnuRJfuWfiZn++myo618hQ4KuYUT+won9RVO7iqcV73tVuGYvsKxfYXj+grH9xXO2lc4fd2VU1935dTXXTn1dVfOfd2Vc1935dzXXTn3dVfOV9+Vvz3j6hbP2lk8obN4YmfxpM7iyV3FY4+f4Npb6fpxmbVmLcRzc+jLHn6If9294PYm5oo3sVe8iRN5ExcebxLc05sc/CIvuW1jILc87/u0HG+nuux7ri3u8dv7bD/i953Hv+78w+rc1/hX5fEH5fFH5fEn5fFn3fGbRXn8Rnn8Vnn8va+/pfiVr79G+fprlK+/Rvn6a5Svv0b5+muVr79W+fprla+/Vvn6a5Wvv1b5+muVr79W+fprla+/Vvn665Svv075+uuUr79O+frrlK+/Tvn665Svv075+uuUr79O+frrla+/Xvn665Wvv175+uuVr79e+frrla+/Xvn665Wvv175+rsqX39X5evvqnz9XZWvv6vy9XdVvv6uytffVfn6uypff1fl629Qvv4G5etvUL7+BuXrb1C+/gbl629Qvv4G5etvUL7+BuXrb1S+/kbl629Uvv5G5etvVL7+RuXrb1S+/kbl629Uvv5G5etvUr7+JuXrb1K+/ibl629Svv4m5etvUr7+JuXrb1K+/ibl629Wvv5m5etvVr7+ZuXrb1a+/mbl629Wvv5m5etvVr7+Zt3rr1t0r79u0b3+ukX3+uu63/+qFL/u9dcp3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yivf/8or3//KK9//yivf/8ovutdfr3z/K9/9/lePlw4xm+f4jwZvUYcUHi+c1o+59r5WS86193Vdcq691wCCc+1+vy7JufZeW0jOtfM6ZM1reszVfj9XH/MWh08u7YNtTodhm7hH7fw+2rn8wabzGqcpGw+bl2w6r83i6u3H6BiW8D0b57axzj8FfTR0DesW8hqXp8G/6r+vMee8v/KypE+j7xg7LxG1YOy8+tSCsfPCVgvGzmtmJRh7375PC8bOK30tGDs3EVowdu43tGD0YJTAiIsRwYiLEcGIixHBiIsRwYiLkcDY+yaoWjDiYkQw4mJEMOJiRDB6MEpgxMWIYMTFiGDExYhgxMWIYMTFSGDsfStpLRhxMSIYcTEiGHExIhg9GCUw4mJEMOJiRDDiYkQw4mJEMOJiJDD2viG/Foy4GBGMuBgRjLgYEYwejBIYcTEiGHExIhhxMSIYcTEiGHExEhh7P9ZEC0ZcjAhGXIwIRlyMCEYPRgmMuBgRjLgYEYy4GBGMuBgRjLgYCYy9Hw6lBSMuRgQjLkYEIy5GBKMHowRGXIwIRlyMCEZcjAhGXIwIRlyMBMbej9jTghEXI4IRFyOCERcjgtGDUQIjLkYEIy5GBCMuRgQjLkYEIy5GAmPvB5VqwYiLEcGIixHBiIsRwejBKIERFyOCERcjghEXI4IRFyOCERcjgHHt/bhnLRhxMSIYcTEiGHExIhg9GCUw4mJEMOJiRDDiYkQw4mJEMOJiJDD2fgi9Foy4GBGMuBgRjLgYEYwejBIYcTEiGHExIhhxMSIYcTEiGHExEhgtLkYEIy5GBCMuRgQjLkYEowejBEZcjAhGXIwIRlyMCEZcjAhGXIwERoeLEcGIixHBiIsRwYiLEcHowSiBERcjghEXI4IRFyOCERcjghEXI4HR42JEMOJiRDDiYkQw4mJEMHowSmDExYhgxMWIYMTFiGDExYhgxMVIYFxxMSIYcTEi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","names":["constructor"],"brillig_names":["get_contract_instance_internal","decompose_hint","lte_hint","discover_new_messages","notify_created_nullifier_oracle_wrapper","directive_invert"]},{"name":"add_asset","hash":"7391825123906140728","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"oracle","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"loan_to_value","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"is_borrowable","type":{"kind":"boolean"},"visibility":"private"},{"name":"optimal_utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"under_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"over_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"deposit_cap","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["add_asset"],"brillig_names":["add_asset"]},{"name":"_compute_utilization_rate","hash":"10162810886186855195","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"precision","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"deposit_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]},"visibility":"private"},{"name":"borrow_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"12348881442450494403":{"error_kind":"string","string":"Function _compute_utilization_rate can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1dXYgkVxWu6p/p6Z7+y+4m+2MQAnlQCVjV3dMzK4F0yEzcZHdnsxvdv7zY0z+ysDEym4ggSD0IgqIivvjokwhBfFEQfAuC4IPog29CBF8EQRAEURCcO1On++uvT9V0dd+a6Zl4Yba665z6zs8959xb91b1us5hK+z/ueHnHJzjJjyd8Ogt1nyLWF6aerqnRM/MKdEze0r0zJ0SPfOnRM8Vi3q6oGdh6kOovEkIE2ymI42TVhTjCsq5v2QOj8XwewboFoPXL5Jcm/ib3nqv6Ew2y/o3iyHmajr4G4JfTAffk77/XDDGR1tEbjY83g3GvrwL1+SB5x7w3IvguQ8894EnBzwPgOdBBM5D4HlIOJXwMyaK2Cm0DNA+T7Qs0O4SLedM21gB/dg2oWH+PSAa5qHYYvrikjP+/ClnfI1pb4V8aGeRbLOcU7tFZ9I/tmvC+Qj9xTbTXglSkd0U/C3Ad+zhe4K/nY7+I/xXQ/w0dP9sOr4ZjQXX0vHNCP81675ptAT7dfvY64J93T52V7Bv2Mcejb037WMPBHvHOnZzFOe37GOP6ssb9rFHcXLbPvamYN+xj70r2G8ujt3gE2vO4bj5sxBPxtrVsaiJuSceTcsq52RcqitYW8GknKJFOYj1KskpWZAj4/oa0Drh0VusNeqkJ8ophzaa1v3K27e+3HunP3i5398bPHnikl1riv5aS4JZToB5iTF33nv8+NHw0WBv+6uPnrw7hV1RsOVzxtFtY72QD1ueZHwmPJp4/AXoXGOd3xx8qT/YWybXOmRKXtGpTDThfSk8GrN/GX5OMZTbgv0U6GZvmuI3JKXPOdNNaOdB9irRLgCtSLSngVYi2jNAWyPaRdBBpk9CuwTXaSVHWpa+ow+NDb8CmcznkD4YV+eJhil3gWhVoD1NtBrQniFaHWjii6Iz7W+LcbDOfeYofsA+KxPtItAqRMM+qxLtMtBqRLsCtDrRPgY0vHXjpsWB+NDEwQ/cMS7zOSQT6wP3GebnRaKdA9olomFuiS/KoOO4jL77zl73i4M7g25/1rrHfOcj+LLOdLwiZh54MN6rCgZeVyGMIp03rRMevcXaaOkKa47F/GhzDmDTcoDrJOYA10nMAa6TVxR/cg6YJreCQnsWrktaJ8WHSeskxg/nANY7zgGsd5eJhjF7hWhYC8UXHGMnXSe53mGMcL3DGOF6hzHCYxDGCI9Bi9RJ8WHSOonxxnUSl3s5RnDZmWMEp/Lz1sko+5mvFMGn1UDExDqJGBUFIxMhT+abeD4D57G+yrKwxHyVcDrhd2/B5pIdOdCnqujDc+bvAQ/GdhZ4SwqO8NcUuVgzeK5eI7km5nYyk5i5I3TIkg5aX2AfylK7Vn/S6Iuy4pOKog/HzQ8d3bdRflgh/qoiF2t7huRWSa7WF5kjdJC+0LY13Iij48y2/MC51wm/ewu2ujPtP5QV1YdaXeA+fD88GuwfEaYLdmqYWbK/kJL9LmCyjQVFnzzx/4Tswq3BPNmq5euqIhfHF47TVZI7a5yiDlJTtL6Xa825n8bwlRS+miJLrlkDu3KBM+GPTnjeW6BtbI73/rPB2Gc8X0D5eeL/efidx1XxWWdOPYcbXX/Y7A67691+v9XrniN80zLgJ9vydwf+oDkcDpuDbmvYHh67/O5ue/+ffentbq/f7DWPkq8tTZeBV65Ldw7ttWap1Si/RLpa1sfn+Y3ow/7JkO+qiq51opkmy+euQssq5zLHjMVrWYJvmja3tOj79VljQeSXnFRj04/za0Xxq3Z/K9fWiWYa919NkVNT5JwmLNla4zwRfO0ocvhcVPxibsbVsnnlaOtYcXkyrxzE2g4m5dQsykGsreDwKLmN91IW10p8XhvFpq2N8loJrv1wX+PaD/cPrgHyGguuzeB9JjdtPUT8ZMbR25kxLvNJKypyLPrX4/UzbNq6NPsXfc/+Rd+zf9H37F/0Pc5ruWn+FT/N6t+aM+1frMOoQ06RY9pWcHjME/+/w2O6OeJ5PGdDWR+l+JknRr49Z4xUibai2CG0umKHNhbxvR+OHytEw7lLnWhYp/HRNx7fsoRtmjzKptks1xaV6zrh0Vuo+bssi+/pWS5+zzvTuSlzEl7/+EbYwebaujtpV9m+XX3RtRJjV9TzAl8DXS+krmvDT6Jreno0W+yHPfDDZfKD/f3ARkNsrcb4oeKkrUezweugj8APH3fH8uJ0NU2eg2C8LwDecwnwXo/Auwd4z1M/Va37p7EhutYidNXsEN4d0PUT6eu6uYiu26DrCzP2k5bHwvsi4H2a8OapU80I/x3HfAdlob44fuG4sRXo9rVDUDM3+DXMDczpAslAGu5J8n09vwqDNG3Pip8VMU0evzU2fMe1Y+tLS2rrrRRsvbaktl5PwdbbS2rrjRRsfbiktt5Mwdbektq6k4Ktj5fQVhzrbNr63pLaWk7B1q8vaQzLKyg2bf3mktp6R7G1QtchXoX0RP0rpCfqXyF/oB4VsgFti9pn5NcNHGf6/lMwO+F3b7E28z6jyC8503mUxt6Sto6D/uG4qSi6avsHvIej7Wdqe1jHhXWCe84z7zOK/P/vOS8/Fu8zoi/diKPI4XNR8avVvTWLcrQxOy5P5pWDWNvBpJw09mdN2woOj5LbuNZ/kvsYvB+BaxLc17PuQfLeCO6DJd1nFD8txz6jN9T2ox2yV9sn0XzP/p11D4n9i74/iX1GXrOad5/xD6GgdHNEX3cTWR+l+JknRubdZ6wQbUWxQ2g1xQ5tLOJ9Rhw/eJ8R5y41omGd5n1GHN+S7jPKtSnuMw5Zlu19RsF9Oex3c+1f3Um8KNmmXY/Auwp4f0uAdyMCzwe8vyfAuxmB90nA+0cCvJ0IvOcA758J8G5F4F0GvH8lwHsjAu8pwPtPArzbEXhFwPtvArw7EXhuiJfyfbI6NqAs1DfpOkoutOEk11GMnq9l7NhTPmP2XDhj9jx7xux5/ozZ88IZs6d1xux58YzZs7Vk9qS5Vh+1Hm/7vaN2q+1vbnY3e+3e8Gqrt5vkvSPtXihLtALp6YBf8L0+9pFpW8Hhkd/ru09zqbR+4lSbSxXJhgLYoN1fvUI2CP8ezC/fykz6jN/TRRr6M0M0/ilZpKHe3A/4bmqWsDQbhH8X8vE3dF8t7wuiPWm+27jfWkaP31Ju4s+b5YNJu7V7Y+TH/DR/cXs96DPtnj1PWHkFC31+jXQVH64o/IjHa1JvQx/9OTOpH8Z1iXRH2wtEyypyhYaxVQSdv0U5yzWjE373FmsbPB5g08YDHiu094q18YDHCoyDpGvE4ouk61M26gTuTx/oF0zrdRJ5iz9ZyHmLOZpV+Dlvj8rz7eDwqK3DcXxrY0GSnDHtGsnDeJG+wZyJ2ofPKzaY675L8y1cL8sq13J9F/4fwxj1fRqjuJ4hTXtXXotLHqO0uNTGL4577Pu4eNDe0Re+lOcSLW08ckl2Ss8qzLxfLvJLjl7vOnb08ePyEudOGfJPms+WmD9t/16bD5g9jKoz3Wfae6baeKjVEq4zWEt4bMa+4zqj1RKjY9xc3SUsrU5oeYd9pdUVqXM8930f6soHVFe0+zitPnBd0e7jhBb3e0TanA7nYTyWxD3jgfaLbO2ZxTisQozsuPfYNdmoFz8XwM9XRD27cCArGNPENynPCda1OQHWC54TzPocVpwvtX7U3g/kZ3UwjzkfUe4a0bR7fC2P8XdkPiCfaPmJcwDb6wVeo99rDxobm95G229c7R/376T01tu7vdZ61xv4B9ocJV/2SleCMR3j2bRC+B3/CxHkF7w88f8O6tjvad6eV+QZvg9j+NyI4wGGci4XTJ4rBtP82WCaf/RcXDCto9DWgIa5Zlo5/I7+QizRI0/8f4Jab9oqXCPX1xX5qyR/Qm/lHOYcY2WVc8Jv+uePlDdou+050IFMwsdzrNuHcD9gO6/2U2qj193w/astf9Dy14/Kq/8BTEg8YABvAAA=","debug_symbols":"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","names":["_compute_utilization_rate"],"brillig_names":["_compute_utilization_rate"]},{"name":"_compute_total_collateral_value","hash":"998039105144149582","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"4270187767586857285":{"error_kind":"string","string":"Function _compute_total_collateral_value can only be called internally"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_compute_total_collateral_value"],"brillig_names":["_compute_total_collateral_value"]},{"name":"_compute_borrow_rate","hash":"1484209913714173427","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"asset","type":{"kind":"struct","path":"asset::Asset","fields":[{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"loan_to_value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"oracle","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_borrowable","type":{"kind":"boolean"}},{"name":"optimal_utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"under_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"over_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"deposit_cap","type":{"kind":"integer","sign":"unsigned","width":128}}]},"visibility":"private"},{"name":"utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"precision","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"17134621154673181869":{"error_kind":"string","string":"Function _compute_borrow_rate can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VYy27TQBT1M42TVq1gwwp2bNjYseO4G1RQQ5q+EAKxAQlN/BAV5aEWEMt8Oh2YKx9uZ1pVsSM8UjVj3+Nzz33M2I1t/R2Dqz9brT24xwdh9tQcrjaiBrnCNnXaHdHpdESn2xGdXkd0+h3R2euIzo2O6Ox3RGfQoE4bdA6uLZR4eRDKQ0ZuYLk5ZOPJosqEBZpAB5p7n9RMeAfsDR5gUcD8NsmfhUmF8bagPw4U57AdfkH8m+3whxuKZ39Z82Ms5NdV83RZ53IKz/iAmQFmBhjkOQDMgYFnDpi5AXMImEMD5ggwRwbMMWCODZgTwJwwzJZa4wbdVxiyOWCbMpsLthfM5oFtxmw+2A6YrQe2ObNtgO2Q2fpgO2I23E/HzIbnCOVHcj206vUjq35GjlOFw9xRz7dx5lydCWVg/Zvzps+0+wb9cgxVHt6qa7m/dtRa/Pz88lv+tSifFcVFeXmJvcT35U3jLpybd+B8wDlPf5yfn1Vn5cX019nl92vcWxpuWjuWPjauC3E4dOeuHHtqDlcbfz4qMYbHapa1ew852eY5eV1+KcqL/6l0FgvFt8zHPA/7iZpl2B/UesvSl0w3y+Fq7lFZda+3Jr/nd26I1dbETvEHTA/mhvBzNctjdsQ4bfa8iZOwDnD5GkzANBA+VbOsz8LA6cBzqIteAVQDj+nbU9fhioP8Uh94oMfT6PEZ/imLi3LhavKBPITva/wGDIN++8yvvC4ZXlffAbuHeIrFVN+BIfbnoGFh4DTlwTZoRj89wLgMr+vJnoaf+56B5o9qrduHNvC/MWjF3sWakQ7dq7yN3qXYsIdcjR6ei1csLupNrJmt4aH7nsYv9jc/FzzmV9e7zi0aqC91NcOeoJptazjomSFo9Ja1vanPrUlW/0/sLutc4Oe0xfz7DP9OXeP+pXmV38CqiYiqWFRiLIoiycU9xm9BPoct+F+UURlXVRWXIqnSau3+yyIX6WSUxeM4TBJRrNv/KMvS3dEiTCZFXhVJvG7/aZJGWSayPM2r3SRfrNt/MhaTXEyiaDeJyiQa3+b/N2+7b5UQGQAA","debug_symbols":"vZfdbqNADIXfhWsuxmN7xu6rrFYVSUiFhEhEkpVWUd99h4qflIWmtaLcRJ7ofPjgMQO+Zrtyc3l7rZr94ZS9/Lpm9WFbnKtDk1bX9zzbtFVdV2+vt39nrvtB/6E/HYumW57ORXvOXgA9cZ6Vza6LUVy6xr6qy7RyKf5f77wf5I78qNa4ICZ1sReTQhjFgRfEQiS9WCjQrfh3niE+xr3qIAfQ57mnx7hnGWsvd2oPHAf3EBC/dq+M1Is1cXP3/Gj34D+573KEJ+SIT8ghizlAFQfIO4A7OdiJ6+UplDutxzD4F0Y33zxdNJRMxMkQxjuGHvgskPtGhVA/GeowsGHehi0eN56UhjKkmKc6MH5QZKLYRAUTFVeoMJyLnh3IjOLFLfOMgUaKAOcUmChvotBE0RqFE0Uwp9hEBRMVTZSYKLVQwZkoMFErvUHjAZ5iiXMKTRSZKDZR3+kNmT+VYa03kL+ixESphYrORIGJWtllGN9zKQ7zjopkothEBRMVTZSYKLVQ4kwUrFFhopTnlDdR9POOek+rP0VbFZu67Ger/aXZ3oxa57/HcjZ1HdvDttxd2rKbv6bRC7oKScgVkhnoblwlT18aKUlK9A8=","names":["_compute_borrow_rate"],"brillig_names":["_compute_borrow_rate"]},{"name":"get_position","hash":"9561173294592718536","is_unconstrained":true,"custom_attributes":["utility","view"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"position::Position","fields":[{"name":"collateral","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"scaled_debt","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"debt","type":{"kind":"integer","sign":"unsigned","width":128}}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"H4sIAAAAAAAA/+29CZRc13El+BNVBaCyUKgEAQIgQBAFbuImMtdavEIWoY0ite/WklWZCVFcQBIABVCk+AEUFmIjQFKk9pXUvli2ZdOyJduSbE9rRmfcXo/b03b7eMbqnlEvc9zHY4+mexoflZF581b8rTJeIYuodw5QP/+LdyNevHjx4i3//4w3mwbO/cs0r/ubf/u8uUlotjf/5rtLBUOsvEs5M4tEzmWGcmL795FtDHCGVGaZUqivWXCAaIP0/22b/TvY/L0M8vsMFTNIfC3xJ/JTpUGvMxnLfx4/47UbwBX+gBv8/Iomztf8Nj7WRfgON39nQJdSRvLQxr5OeWiP32jmrTz3b43Xvj4DvIL0K35bjgzlfRPyllHer0Ke8HXZTufsLO+4nUprvfC2ERt/qe+1UptvoTQxVipOjBWLtXq+Whsbb0yWxvOlqUppcnqqkC9VihO18Wopn6+X6tPlfG1sslKrVycrpcZUdXJMsG9VsUv1qXNQlerYxFShUR1r5KfK4xOlamN8vFatTZbr45V8rTA9VpguFhoTE9VKpTpdmSwUGvXJSmOihb3Dd6KzouC/zAl+qSL4Lwf8fjv584L/Cjf4Ld/7Sjf4Lf2/yon+2/Lf1sT3PHvdv9qJ7IUW/u1udFMW/Dvc4LfG1dcAfsYB/mvd4Lds53Vu8Fu2/3o3+m8I/hua+B5gFyZKxeJ4aXI8PzlRyxfKtenixDnvP1XOT+er08X6ZLkw2SgXy6Xp2vTURHmiWmjkG9XpycbELLhgv9GJ7KWWbb7Jie5LrXHlzYpu8t2lls9/Szj2vNUv2G9VsIvV0nR+spGvViaq4/WJyrnhOn/uYmqi3hgrVqfODdzFWqFQqJfP/Ves18qTU7WxwtRYfbxYmTrHrtWmb/NdtGlhWvDfbow/Vs1P1sfGxgX/Hcb4U1Nj49Vz+hT8XzbGL02P1Rul8ZY/eKcxfrVSbjQqpargv8sYv1LI1yvF8ZZtvtsYf3IqXxmbmGjZz3uM8c/FnaXaZHVK8KvW+pmq56drhUmZe0w18YVHkIT3tDHvZprMED/Pa8978J7wz5Ks1nFZhvihPKgfnrfV/Lmy5pQ89DGc16fcEz4a1jsMsX7ZEOudhljvMsR6tyHWewyxpF+77Wvl1jhac4JfmhD8uhP8fF3wGy7wC+3YcSfge3byt/DfC/gZB/h3utF/C/99bvTTmtfc1cR3gX23PXYrPrrHHrs137jXd9Kmrdhxlxv81nzmPjf4rdj6fjf4LZ/2gBv8ScHf7Qa/FVvvcYPfik33usFvxdYPusGvCf77neAXWvrZB/h2Pr/Y8sn7neCXWvgPucFv+eUPOMEvt/AfdoPf8s+PuMFv+ecPusFv+edH3eC3YjbfCX6lNbc/4AR/rGU/B93gt9aKD7nBb9nnjBv8ln0edoPfss8jbvBb8cNRN/it+OGYG/xW/PCYG/zW+HXcDX5rfD/hBr81vp90g9/yb6fc4Lf822kn+OOt8f1xN/itudEZN/gt/3nWDX7Lfz7hBr/lP590g9/yn0+5wW/5tw+5wW/5t6fd4Lf82zNu8Fv+58NNfM8Ku1Bu+YaPmGNXWnHPR+2xW332Y/bYrf70cXvsVl/6hD12qx990h671Yc+ZY/d6j+ftsduxQafscdujdufNccea42pn7PHbo2nz9pjt8a65+yxW33n8/bYrRj+C/bYrX75RXvsVr/8kj12q+982R67Ne58pXvsIt8Q7K92j13iG0Pe7Fndv1s7i7fq3L/VTeyd9T2/dPeu6bvu2HvPVP0B3HmWk4Vyjff7vLkpQL2kjfrSXffueaA6vecltdoD9d27GWFAQfZCULOA+t7qnfe+ssZoy+eH9ub6A7vv3HUvo61IiCbnh1cCveEaT17OYQ+SfMg7C/cN129rSc4nIP8syWq8Xl3IED+Rh/WD5xOCvCFF1pySx204pPAZUvjklLwZ3w7rcUOsw4ZYpwyxLOt4whDrmCHWSUOsI4ZY+wyxLHU/Y4h1pkexDhhiWdrEjCGWpX0dMsSy7NuWNnHQEMvSRz9piDVjiGU5dshantvYKj81rPCWJHmrgDfGVJw4Eke5g5jmx2vbuEwnaRXw2L3/3uk7du2p7/YiCgRJHlzj+72mPH4YcjhBHTwvXrE/TaBYDuBRtmHCxLIZBatPucfGjDofDJEBMaStMBA2nESUktQD+S/UJEJzEtokQvSzyo1+ihnCR3lWKfphG+a2C/7JxH4AsJB+FdQR6fFayuO9f2z+zXlz+5E8zJdR8vqUe6LfYNr+H6lu2DZsp27aoVxIaqfCP+u57DdtO9XsQhvMBr257Wx5gDpJu2q+bbWSJ1gjzd9op0g/DHVEeryW8h35zQbLeXNtmu10tVIfvId2+tPm9WBIfbY3f+e7SuPj2jjF/QD1ZPlAWNJ+IPyznku7a/cDrZ00fyK6G1FkzSl5vOgzovAZUfjklDwORLvBOmWIddAQa8YQ60yPYh0zxDppiHXEEGufIdZxQyxLu+9FfUWNg2mxgmRpq2cNsY4aYlnaqmUdDxhi9WrfftoQa78hlhxa4jhT8IM06M3te9ZzN+Qn9cB7yD9LstrK046VNL1qMa3oJ+dGPy15coo8OUU/0pZrlDzBku1lnDMgfQ7qiPR4LeXx3m3NBssR5vk8v1OGNUp98B7OGXZkOuuGbcN26rIdkJ/IjfeQf9Zz2W/ykXah9f9Bb247G+onn6RdUV5py0uUPMFqLg122CnSr4E6Ij1eS3m89zayU7RpttNLlPrgPbTTN5CdYtuwnTpph0IjsZ0K/6znst+07VSzi5yix0Fvbjsb6iefpF1RXmnLtUqeYK1r/kY7RfpLoI5Ij9dSHu/tJDtFm+aHwNcq9cF7aKfVJu5gSH22N3/nu0qVstaWdvjjhWGlntzPUNd2dl1K3M+Ef9abaxcu+tk6kifMDkR3lyqy5pQ8tpFLFT6XKnxySh7Pa7rBmjHE2meIddAQ67gh1gFDrGOGWCcMsWYMsQ4ZYvmGWGeMsDT/3I1cjxvJFaSzhliWfftpQyxLX2jZH08aYlm24zOGWJY2Yal7q77tGdfR0iZOGWL1qp+wlOtiiJmWxrQLp3vL/njYEMuyjk/1qFyW8YRlHXl/AOeWmebfQW9u3zOcZ9czxE/qgfeQf5ZktZWnPc/W9LpO0avobr0ia07J43n2eoXPeoVPTsnjMaMbrBlDrH2GWJZ1PGaIddIQ66whlqXunzbEWmrHdFjPGGJZ2sQhQ6xThlgzhlhnDLEsdW9pq5a671X/ZWmrM4ZYJwyxLNvR0r4s+5ClfT1uiHXAEMuyjjOGWJb90bKOlvFEr7Zjr8ZyTxli9WqcYxljLsUTL4w+ZOknLOWysq/gmtdVu5HrCd8Oy1L3ljHATBOLz7sJfpDcrqEVE5+x5TU0J2ewYtbQtLN1g95cOzTUTyFJO6O80pYblDzB2tj8jWfCkH491BHp8VrK4713NJWSI8wg8ZmwDUp98J7oNzgT9qbmj8GQ+mxv/s53lyZ4PVR4IG/Uk6HdJfpYFPLPei7trt0PtHbS/IvobqMia86baztsDxsVPhsVPktYvYX1WiOsKB8m+UEaVMpZ+1vkJ/XAe8g/6zn1C4UovWr+UvRzmRv9tM4oX6bIc5miH2nLTUqeYG1u/sbxCOkvgzoiPV5Lebz3KI1Hm4CW+8AmpT54D8ej/cs664Ztw3bqph2SP/Mh/LOey37TtlPNLrT+P+jNbWdD/eSTtCvKK225WckTrMubv9FOkX4T1BHp8VrK471TZKdo02ynm5X64D2006PNHyNeeP9M0p8RV/PbrEMsx/3BSXsX6vmk/UH4Zz2X/bPdHzYl1KvoZ7MT/dQaSewH5ZW2vFzJE6wtzd/YH5B+M9QR6fFayuO9T1J/wL7D/eFypT54D/vDh8lvY9uwnTpph3y+kdROhX/Wc+kn23aq2YU2/g16c9vZUJ56knZFeaUttyh5gnVF8zfaKdJfDnVEeryW8njvq2SnaNP8rN4WpT54D+308zTf5fpsb/7Od5XqBa0t7fCr+UFF13b4xclBpb3s8KcmBH+rG/wxwR91gj/Rat9tTvArLf1c6Qa/JvhXubGflvxXO8EvlQT/Gif49Zb81zrBL7fwX+QEf6rVf69zgj/Zsv/r3ein1b43OMFvVAT/Rjf6acl/kxv5W/7/ZsC3XIsQ/LwT/HxJ9HGL1059Sp2Ev8QiLwb6TMhfweI84ZUlLFdxn1Y3lJ/nfbeAPKiDMKxbUmINKnku2vTmiHoj/+EIWbkeQeJ34MxXJ0E6ZIj1qCHW40ZYWmzbjVwPGcp1uZFcWvzbDdYVhlgrjbCCxB8J7kaurUZyBdejPYq1zRDrSkOsqwyxrjbEusYQ61ojrCDxxyG7ketFhnKdNpTrOiO5guvrDbGsxo7g+gZDrBsNsW4ywgoSr532CpbsIbtd7ypPul3vKlXdrneVa27Xuyolt+td5XG3613laYnVZTwUHmhbOL7ZzSvKiZ8FFf5ZktVWnvb87iqSh/XD53euVmTNKXncR69W+Fyt8MkpeXyWtxusJw2xDhhiHTfEOmaIdcgQa58h1glDrBlDrDM9imVpq0cMsWaMsLRxu1ds1bI/njXE6tX++IQhlmUf6lXdHzXEsvQTlmPtjCGWpe4t9dWr9mUZm8wYYlnq/mLwE08bYQXXPIftRq5HDOW6wkguS6wgfcC3k2uroVxWug+Sb4hlaRPbPDuslUZYQbKyiSA9aoj1sCGWpX1ZymVlq73sC9cYymVpq5btaOlXe1VflrY66tlgBcmyb1v6r2cMsSzjr8OGWJZrCjOGWJZzBcu1R4nvZR17G+Rlmn/d7gHk570HsM2NPJF7ANsUvWrnYQ3lqSVpZ5RX2vIaJU+wZC8fz/Yj/dVQR6THaymP977TbLgcYQaJz/Zfo9QH74l+g7P9v9nXWTdsG7ZTN+2Q/Buwwj/rOe03hSi7uErRo2YXUjan5HFMn7S9tLbns2/dYJ0yxDpoiDVjiHWmR7GOGWKdNMQ6Yoi1zxDrtCGWZR+ybMcnDbEOGGKdNcSaMcSytC/LPmTpVy8G3Z8wxLL00eILteeoDOOPvPackyF+65mDayN0gfz5LI7ka38Fi/OEV5awjOtWiKpb1NwN43A+26thXZsSS3s2zkWbXhNRb+Tv9lnAStHts4CVMbfPApYbYvPXgT4zpLsbnLTlROJ3qQj/LMnqqk/dQPKwfng+dKMia07J47N7Nyp8blT45JQ8Hre7wXrSEOuAIdZxQ6xjhliHDLH2GWKdNsR63BDLUve9aqtnDbFmDLEs7cvS55wyxLoYdH/CEGvGEOtMj2JZ9u0jhlgzRljBNZ/L7RVb7dUYwBJradxeGrcXy9ixNG4vjdtL4/YLU/e9aqtPGGJZ6svS51jq/qghlmUfshy3ZwyxejVe7VX7sox9ZwyxLHV/MfiJp42wgms+n9MN1jWGWFbr5MH1tUZYQeKzx93ItcZQrkeM5AqSb4j1qBFWcM37X0u6j64jPzvRDdYVhlhbjbCCZKmv643ksrTVIFn2oV61+16t4wvdF1rKFaSlsWPxjx1B+qARVnBteebBSl/B9aihXA8bymU11gbJcnwcNZSrF8eOID1jiGU55ztsiGW5pzNjiGW5PmF5Poefb8OzYZnmX+198QGf7c3f+e5SLUP8pB54D/lnSVZjeQpRer1B0av2vntDeaYzhI/y3KToR9ryZiVPsOQ9mQOAhfQ3QR2RHq+lPN7bNDD7N0eYQeLn27R3peM90W/wfNu6gc66Yduwnbpph2Li59uEf9Zz2m8KUXah9X/NLqSs1l487idtLw3rmCHWGUOsg4ZYpwyxnjTEmjHEetwQy1KuQ4ZY+wyxnjbE2m+I9YwhlqW+ThpiWfbHs4ZYM4ZYlr7Qsh0PG2JZ+hxLmzhhiGWp+wM9KtdpQyxLm7CMTSzHbct27FX/ZWlflv1xxhDL0kdbYlna1xFDrJkmlsxXcH6Taf51/A24cob4ST3wHvLPkqy28rTneppeb1L0mub7YsG15Teb2Dd3g3XKEOugIdaMIdaZHsU6Zoh10hDriCHWPkMsq28jBemAIZZlfzxriGVpX5b6Om6IZWlfln3I0q9a2sSMIVav9m3L/mjZh540xLLsjxeDfZ0wxLKMAWSsHWnmYbyN7yPBPOQTFfNjeaEbVsplmn/dfsN3MvH7OoR/VtGJi5j/loR6Fd3lFVlzSh6fXckrfPIKn5ySx2NTN1hPGmIdMMQ6boh1zBDrkCHWPkOs04ZYjxtiWeq+V231rCHWjCGWpX1Z+pxThlgXg+5PGGLNGGKd6VEsy759xBBrxggruOb3dfSKrfZqDGCJ1avjtqXuLWMASx9tGU/0qq0ujdsXbkxbisnTYS3F5BfOvpbiwgtnX70YFwbJUl+9aqtPGGJZ6svS51jq/qghlmUfshw7ZgyxenU+1Kv2ZRn7zhhiWer+YvATTxthBdd8xqkbuT5gKNc1RnIF12sMsSz3hyz1NWool28kV5AeNcIKrvmZ/l6wiSDxs829oHvLvm3dH636UHB9rRFWkCz748VgX/y+oW6wrjDE2mqEFSRLfV1vJJelLwySpY/uVbvv1Tq+0MdaS7mCtBSbLP6xI0gfNMKyjCeCZKWv4HrUUK6HDeWyGmuDZDk+jhrK1YtjR5CeMcSyXFM4bIhluW81Y4hluf5leb6Q3ze0BvIyzb9yzhd9XcBne/N3vqtUSPy+IeGf9eaOVXbytM/5bvbm6nWNolfR3eWKrDklj+fGlyt8Llf45JQ83vPtBuuUIdZBQ6wZQ6wzPYp1zBDrpCHWEUOsfYZYpw2xLPuQZTs+aYh1wBDrrCHWjCGWpX1ZymXZjpZyWfoJS5uwbMcThliW/l78qsRWHBNsb/7Od5UqFYlNMJaRmGrQmxubGMZ1ExniJ3rCe8g/S7LaytOO67R2Q/1wXLdFkTWn5HEbblH4bFH45JQ87pvdYD1miGUp1ykjrOB6lWeDZV3HfYZYJwyxzhhiHTHEstTXWUOsDxlinTbEmjHEstT9MUOsQ4ZYlnV82hBrvyGWrPNxbBGk7c2/54bD0sRYqTgxVizW6vlqbWy8MVkaz5emKqXJ6alCvlQpTtTGq6V8vl6qT5fztbHJSq1enayUGlPVyXG3sUNlctCb6+MNY5OC4F/hBr8o+Fvd4JcEf9QNflnwr3GDXxH8a93gjwn+i9zgj7t990FhQvDzbvBb/avgBr8q+EU3+DXBL7nBrwt+2Q1+Q/ArTvCLecEfc4Pf8p/jbvBb/nPCDX7Lf066wW/5z59xg9/ynz/rBr/lP3/ODX7Lf/68G/yW//wFN/gt//mLbvBb/nO7G/wpwX+JG/xpwf8lN/gt//9SN/gt/3+rG/yW/9/hBL/U8v8vc4Pf8v8vd4Pf8v+vcIPf8v+vdIPf8p+vcoPf8p+3ucFv+bdXu8Fv+bfb3eC3/NsdbvBb/u01bvBb/u21bvBb/u11bvBb/u31TvDLLf/zBjf4Lf/zRjf4Lf/zJjf4rfjzzW7wW/HnW9zgt/znW93gt/zn29zgt+LPt7vBb/nnd7jBb/nnX3aD3/LP73SD3/LP73KD3/LP73aD3/LP73GD3/LPVSf4lVb8OeUGv+X/p93gt/x/zQ1+y//X3eC3/H/DDX7L/+90g9/y/+91g9/y/3e6wW/5//d57dTGLtWnzm21VKpjE1OFRnWskZ8qj0+Uqo3x8Vq1Nlmuj1fytcL0WGG6WGhMTFQrlep0ZbJQaNQnK42Jlux3qdjdpPa+yN0u9FJotPzCPYCfMZN/ooV/rxP8fKtf7XKin1rLL9+ntG2xXBubqubHG+PV6kTj3CBarJ37M3bOahqVYnWyNF09Z0W1qXp1qjQ9WZyuFWul+sQ5X1MvTY7V6+0x635ruynkW3p/wIne2/shu831PnH+/+Cbpl9cMYsl79beA7yyVK+9zd/yvdYg3em3afZAPtL/eGj2b8Dvq01+cs4I92kzzb9S70Hzep/X62SG+HmefkZL+GdJVlt52me0Bkke1g+f0coqsuYoL0i8Z59V+GQVPhrWM4ZY+wyxThtizRhinTTEOmSIdcwQy7KORwyxetW+DhhiPW6IddYQy9K+LPV13BDL0r4s+9ApQyxLm5gxxJKznIPe3LHQbmwem5KxFucdkiQP5w0DlHcP0N/qt+k49dFvrFMQAwyta+MyHcuDcdPdgB8WM3heW49DkG8Z4wj+ajf4JbGpYdIp12l1iK4kX/srWJwnvLLeXL27iA+1uqH83F+GQR7UQRjWcEqsQSXPRZsORdQb+Q9HyKrVg+c3mj/S4m+hXx0hF9KPKLylrOhwBPIMdViM0iH2ReG/Cupcq0/t3fnqXTs9Sn2kB9HbRqJ7ld/WA9vgcAiWR7830r0+wMPkds54YccBqVPacQDnq3dT3nz9XpDYN6DOhWcw1882f4wo8mAZtKGwtYWVkI/0xcE2v9VNIsdjTUN0KH0Gk+TlgHc/5eEz/Gwnl0DeCspbC3nLKW8dyHCP35l3KeR9jPLWAyb6N06aXYp+A7Vvnqdd5igP7WIN5aG/voTy0LespTx8Tmod5aFPFj0NEq2t/RQqWruwjrBdVlLeBsgbpLyNkJelvMsgb4jyNkHeKsrDZxN5rOVnIeSak2Y/ot+gfn+dwn6wX6+nPBxHN1Ae9smNlId98jLKwz65ifKwT4qe3MZFhbLW51lHlwJvjnnRtkYoD22L+ybaFvdNtC3um2hb3Df5XVKel9x+RL+B/Xzs0jYu03nEE/3PpZSH/odtC/0P2xb6H7Yt9D+XQX3YRlZGyCo0nud8fCsmiQOQ/0Ktj2vxthafB/qW9ti9Z9cD1Z3119erHa/cYfXxXzZB+d1P9ziMWkW/2Rzv8ufiRKWMgqtVXULtEW+uGbM7jzIpNNULYVLCf6FMKk6vvOUyrMiqTS0HF0avNZYLkzZcoj45aS5W5A7K3bq+jct0zBPtj6e6+qOZXaXWVikO1YZDbomHe0+pM4aLHPLjcMwhPw7HHPLjcMwhPw7HHCJeBvJ9yu/Mw+E4bcgv+g34vTqFPaQNwRc61Bv05raFof2Mc3t6io6wPdlnY3jFITi2J4d6GF5xqIehO4d6+Agyh3r8+LBcc9LsR/Qb2M+qDW1cpvOIJ/otbk/s8xy6Y3jOoTv2182Uh/31cqgP23LakM3lUinyE3nxHvJfqPFVW2buImQbpmKc7ynQHLJdQr8vpd+rCOdufy5OVEpadQ7Z0Ky4i18AkyoudpPShhApm1PyVi2IXue/+pPUxeKs+NZ5DtHIH2UIdCsrsNoUQ5uZBvTbm7/zXSa2gX6QR2vLAaL/xMrOesmw1we0KxUcoR9R+GKoMUh8R4hv8OdbGzp1NWisq9LUZHW62tbVqpg68lTFUQid2u45hN5AesI8DJ04hMbQiUPoTSDDm/3OPHw72scpD0OnbkLo+a6acyiMvopDYewXHDphCM2hE9o1h04YQvOqJ4ajhvYzpbUL60h747AW0vL4iiEth9D4NhsOoUchj0PobZDHIfSVpCO55qTZj+g37ao59uvLKQ/D3S2Uh33yCsrDPrmV8rBPjlIe9knRk9iPmzdcF6pan2cd4XSJV7HRtniairbFfRNti/sm2hb3zVHI476JtpWBa06a/Yh+u1k15+kS+h+2LfQ/bFvof9i20P9shfpwndNOwRy9QT1xvCz8FypeXkPysH5STsHWKFXCfEzym6dgw/Q7R78ZZ76r5mmnYBlFxqUp2FyTSjsFyymy5pS8hdFr707BsE3Xky4crJq3HqjGYdxQzxMcCnhKnTEU4JAfQ0kO+XGo5pAfh2oO+bWXF/NQHaRP+515OFSnDflFv2lXzdH+uw3PXYSBbJvG9pN61Zx9NtoWh+doWxyeuw4D04b8ot+0q+Zopxxe9kMe29YA5LFtLYc8tq0VkMer5ljnZV64rEITJLf2lXzVXPhnvbl6dTG+riR5WD8pQ7aVVIzzPQWaQzb+vYJ+s9nOd9Uc6bWqc8jWp8iYxKT6Sfbtzd/57lLikE34L5RJxemVQ7YViqw5Ja9vQfSaPmRLO0SL3GlDNmxbXjUXGXDVHG2AdYd6dbFqLnXE1WutLQeI/ubBznqJXnBFeZmCw/4H+Q4TDfJdSXxx1TxDPMJk4HOxyxR+Wtgtq+WBWxUfs0bBlXK8Wo70QRJ/JfSyIb0c6oA0a0gXQj8Ouni+qQvt/L3IM0jlbfvjhX0eQuqU9nkIbEeUDTHl+QNu27B2eSm0y29vaMvM/HDXmeshv9+n8NP8Ho9ljg6tFJKOZcI/S7K6GsvWkzysHy08untXtfbS6n27995d57AAz4EgfI7ghAZpMeFmItIP0G8+Q/Zqf245TqLKAZJ5Gh5/ub15Pezp5hUkt4825KeTmozwz3ou3VTbZNaRPKyfZaQfRyY8lfHmmmufwpPPyK1X8gRLZsfoupD+Uqgj0uO1lMd772jaU86b2+1u8ztl0Lok3hP9Bnb6JrJTnO3s9DvzsgpPyRuKyBuOyMMNCX4cAR/pupPK5RTMoD5fovBIszVsb57CoO2H+aIwrB2EheU5HN0Qg3UHYWH5DYS1MQbrdsLC8hsJ67IYrHsJC8tfRlibYrB2ERaW30RYm2Ow7iMsLM+PtVweg3U/YWH5ywlrSwzWA4SF5bcQ1hUxWLsJC8vzZ823xmDtISwsv5WwRmOw9hIWlh8lrG0xWA8SFpbfRlhXxmDVCQvLS9lhBYvH56vg/oUYn4V/lmR1NT5f5c3VK+qHlyeuVmTNKXnst65W+Fyt8NGwNhpiXWaItckQa7Mh1uWGWFsMsa4wxNpqiDVqiLWNsOLG69f7s3+jxmsph7bLO4d9nhc6RiNGWDyABzzi4oJXk8waTy3GfJ/fmYePdXI8iI91Rj23wrs9GGOy30/73ArGmLxE9tXmfbfLPfk8LoWE6Uo7IZFkvAkS2zLu+PDS0VpDPoh1q9/JZ+GXXPL1JPVA/q6XXLQdfNbFZU54lxMvP11GutjoSBfil+LmBbzUrMX+GxV6XK7aWd/z6l07f2n/G6s7eaeNp4i4CYt06+n3hhCxthPdZfRbwguWA7EwsRy8HMb022Po8Tqr3A+SNm26lHhqzaZ9ATunlN8cwWdjl3w2Knyka7n50mje8ZdA22/u0qaqWCc+86l9sT2pGxBeC/VFda1uUe2sfVE9CivpV8AFa1DJc9GmUV+SR/7DEbJq9cA3QKGfe2UzIwiD/jRi6ZCHJTdvhCyNJbVH4b9QhzKTvr1OC22lbI7ygvRBv03HeX3KvWURWKcMsZ4wxDppiHXIEGufIZZlHS3b0bKOBw2xLOt4whDrtCHWcUOsGUOss4ZYxwyxLG3Csj9a9iFLm7DU1xFDrDOGWJa6P2yIZan7xw2xLPVl6QsPGGJZ6qtXfaGlvix9zsUQM1naxIwhlpXug2t+90Kv2L2l7o8aYlnavWUdLf2EZQxgqa+nDbGSfGEp7VvptXWpi+Wt9BWis3grfYXu9Xn6W+nxLei8HuYBvdv12FLip1KEf5ZkNW7/1pqVdvxIW/fUHsKUsjkl73q4xjzks1Xhk1PyeNzuBuuEIdZpQ6zjhlgzhlhnDbGOGWJZ2sRJQ6x9hliWNmGpryOGWJb6OmyIZamvJwyxLG31kCHWxdCOjxtiWerLchw6YIhlqa9eHYcs9WXp7y3ty9LnWPZHS5uYMcSy0n1wzWswvWL3lro/aohlafeWdbT0E70afz1tiCVrMNqjKnxEXpvDXhHBB8tfkQBLmw8L/TaFPmqtZxTKS1lZe7gS8lys9WjtsQ14Cv/5rPWI3gpEx2s96NtGQ7A8+l2ge2FrPXxu6XeaC1CiX0fn0dSj2XxeEc+M8rlI7XFFvMf2qz2m6raO6d82wC9mugfy+Kj+vYAlj3xmFD599BvrG9jrd1O8mAnb4+4QzAGFdoDyhPZ/zrbl+GFTjoVuezdrhQvX9jv8Nh0nre2lvoHOf9Rl22svHhO5tcdxcY0c80RWvsftqH1WReNzQ5d8blD4DCvlMiF/hQ/fYz6azFHr7fPlg1jiK9yu3ae3f9Yz2j+fzb0X8vi917sgD/eBOGl9Q3QR9I01G9u4TCfJ7RftFk6H/IgY6hD7NidNh/h11SQ6HPHi+/aIUg9tnOBnGtKOE1h+XQSf1V3yWa3w6bVYhF+8iLbEjymiLfGLF3cBH/5WwX1Qjh+Xux/yhijvAcjjl2fuhjz2DXsgL61vwJhpRwK7TjJuov+/h/KGFVy3j66VEr9Ykh9dG3YiT3u/VXukFvXD+62bFFlzlBekh/02Hef1KfeWRWAdM8Q6Y4h10BDrlCHWk4ZYM4ZYj/eoXIcMsfYZYj1tiLXfEOsZQyxLfZ00xLLsj2cNsWYMsSx9oWU7HjbEsmxHS/9lqa/ThlgHDLEs9WXZhyzjCUt9HTfEWvKrF86vWuk+uOb91l6xe0vdHzXEsrR7yzpa+okjhli9Gq8+ZIgl8aqUwzk+rjk73pcrXsh3bGh7zDynl3ztr2BxHr9jY5ObukW+YyPKDnAPivfpu3nHBr+XxfU7NjZH1Bv5D0fIqtXjMkOdZAlLe05FW1tK27baO3ekrOM+1jq7cFmEnpB/N8+pFIluh9/WA7fd5hAsj34X6V6fp59d4I8bBUn2t4JnWM4M6TLjK6fxnTbrIR/p/6ehNuaTzesRb649iQ5H6HdwLa9sc/uRuPTr/FnKu0epT0bB6qPfWKe0XzjAZ5n4CwdSPuwLB0OQj/SfHmrL8kdbdcwMYOIzXfz1C9lHCPv6Bcsg9M+CDM9v0DH7Q+o1HIL5bbDFLwzpmJ6CqdVrhOrFMqwmGYT+K1CvH8IBKaSR3/jMn3wQU3jlFF5eyD3ExrKcF8U3rmxwjV+/4Dy2FdYXlg/TKduK0P96hK0MKTJgfbldWQamGQmR4XlFBny93/Su+/Y3v0bhUeqHa3Qr8pubkptgSMEJS6KGoHrfHtJx5HeU+eE2rOamhkNkxLKrgK5Wv7u+px6ioGUElg1htszTE/tKKRekXv2g65AbeSI/6Ko9r6y9wlbK5pQ83t9PymeV114LCT5sF2YLOHZqtrAyhH9GKe9R2YxyL0j4TK8Wu3CdtbgY70WdaRA6jc+lXfK5NCGfjV3y2ajwYSwtjgzStN/OR/o/A//6o6065rIQTPnMhdBrsb125kTotbWJy5Q6as/Xb/LieaMueTzanFLWuLWBy0hWbY6ZVNYd/sLKmk0p62qFN47J5wadOx+sP3DHrj2ttzB7ihgeXQ/SPf7aEw8zwyGiriI6DsN42YZd3Qb6nVPk05LIgYll6fPiEx9J/t+hi/5xSBf1PL2LitnztBTL4rRUTOKDCp3wfJTqg/TIU+h94KOFfh+kegv9T5TQL6fIJPIMUnnbIX6i9QbvA97cJHkHgTcfHzsE9C/123SctGlsk/y8Ln66to3LdCwPtiPKhpg4ZGDbhrXLP0O78If6kN+jXng95PdKhR/rUvKDJG18CO7btXGlmiF+Uje8h/yz3lzduggrD5E8rB/NDUd8qO8AXCP82whOaJAW09tAJKRn1+3T78uVcpxElQMk89qmTw3cybLm9Yg3t+vz90V9wO5T7nG0NajIr/EZ6pLPkMKHT4cGaaffmbfXm1tXyXsQyvHH194PefxBt33e3HpJ3v4IzIciMD8QkfdwRN4jSl7Q5jPDbRnZHWtdgz8S1/wZ2Q/CsHYQFpY/RFgzMVj8kTgsP0NYh2Ow+CNxWP4wYR2JweKPxGH5I4R1NAZrF2Fh+aOEdSwGiz8Sh+WPEdZjMVj8kTgs/xhhHY/B4o/EYfnjhHUiBos/EoflTxDWyRisPYSF5U8S1qkYLP5IHJY/RVinY7D4I3FY/jRhPR6DVScsLP84YZ2JweIPN2H5M4R1NgaLP6iE5c8S1hMRWME1P12C5Z8grCdjsK4gLCwvZYcVrEzzr4RfT8F9u3CnkPi0v/DPkqy28rTDr6e8uXpF/fCq3ocUWXNKng/XmId8PqTw0bAOGGIdMsSaMcQ6bIh1xBDrqCHWMUOsxwyxjhtinTDEOmmIdcoQ67Qh1uOGWGcMsc4aYvFYdkDBwrFMNnmj4noph/4M6fqABv2nNg/Q8DOQH1YOZR4lmTWegjUTg3UNYc13/hBcX0tY850/BNcvIqz5zh+C61sIa77zh+A6T1jznT8E1wXC6mb+8H6/E6ub+cPbCGu+84fgukh1nO/8IbguEdZ85w/BdZmw5jt/CK4rhDXf+UNwPUZY850/BNfjhNXN/GGCsKLmD0/FYE0SFpZ/irA+FIP1M4SF5T9EWE/HYP0sYWH5pwnrmRisnyMsLP8MYX04BuvnCQvLf5iwPhKD9QuEheU/QlgfjcH6RcLC8h8lrI/FYG0nLCz/McL6eAzWSwgLy3+csD4Rg/VLhIXlP0FYn4zBeilhYflPEtanYrBuJSws/ynC+nQM1g7CwvKfJqzPxGC9jLCw/GcI67MxWC8nLCz/WcL6XAzWKwgLy3+OsJ6NwArSG/1OLCz/LGE9F4P1MsLC8s8R1ue96Dq+0uvEwvKfJ6wvxGC9irCw/BcI64sRWEGq+Z1YWP6LhPWlGLluI7mw/JcI68sxWK8mLCz/ZcL6SgzW7YSF5b9CWF+NwbqDsLD8VwnrazFYryEsLP81wvp6DNZrCQvLf52wvhGD9TrCwvLfIKxficAKkpxKGlHK/wphfTNGrteTXFj+m4T1qzFYbyAsLP+rhPVrMVhvJCws/2uE9esxWG8iLCz/64T1rRisNxMWlv8WYf1GDNZbCAvL/wZh/WYM1lsJC8v/JmE9H4P1NsLC8s8T1m/FYL2dsLD8bxHWt2Ow3kFYWP7bhPXbMVi/TFhY/rcJ63disN5JWFj+dwjrOzFY7yIsLP8dwvpuDNa7CQvLf5ewfjcG6z2EheV/l7B+LwarSlhY/vcI6/djsKYIC8v/PmF9LwZrmrCw/PcI6/sxWDXCwvLfJ6wfxGDVCQvLS9lhBSvT/Cv7T38A9+32e8qFDPGTeuA95J8lWW3lae8//YE3V6+on2Wkuz9UZM0peYfgGvOQzx8qfDSsGUOsw4ZYRwyxjhpiHTPEeswQ67gh1glDrJOGWKcMsU4bYj1uiHXGEOusIdYThlhPGWJ9yBDraUOsZwyxPmyI9RFDrI8aYn3MEOvjhlifMMT6pCHWpwyxPm2I9RlDrM8aYn3OEOtZQ6znDLE+b4j1BUOsLxpifckQ68uGWF8xxPqqIdbXDLG+boj1DUOsXzHE+qYh1q8aYv2aIdavG2J9yxDrNwyxftMQ63lDrN8yxPq2IdZvG2L9jiHWdwyxvmuI9buGWL9niPX7hljfM8T6PmHFnZNrNK+jzslJOVx3Qro+oNHOxiGGhp+B/LByKPNOkrmb83jvJaxuzuPdSVhYPu15vMsJSzuPpz0H9z6/M28vlONnGB6EPJ/y3g95BygPn4Pjden9kHeI8h6CvBnK+wDkHaa8hyHvCOU9Anmio+Ve+zk4eT5SdHS0eX+Q6iY2uL35O99l0r6WxnrEdsuE/PW8uWvsQWIfgF/K4EerDxjyQSx5TFtsFO13GK4xT/jwPeaD5Q+GYMmj2UGSZy7RrgeI/skmaPBY9Z/SqwIOeXPl2wv3XhVRVykrNsV+bXvzd767VBD8I27wS1H+F+vEfRB1l8a+kFfW89RxZbuR7qLqhvKzHeJ4kOTc+OGUWINKnos2nYmot+ZzNVm1eoT1TeQT9XbOIxFyIX3U+Cw6xDHSUIfFKB1qY/x83s4pettMdPxlUS3WYSyPfm+me32e/nZOzbetDpFT+Mb5cSwvdFGvsEjiNzQ+mszCx4dy+LbRb9Kz8mJ3+MoPH3C3QD7S/69r25i/3sTUnrsJ6ysZ4IfvJuBXxQi/5V5bJ0jzYIh8vwXjHr+p8EGlzlsiZBbMfm8u3yDt9HUZvktxl6MxUo27hNcIycvtw3XR2oTtzlf0EKbbIGGcgnEM0v8gZZziwz2OU1AmKavN9Xwvnk/UOOkn5DPSJZ8RhU+3cYjGR5OZ51RBQn/yr8mfiN1h38Ky8hz8ANF/B/zJn0X4E5SRf2u+mf2J8AvzJ2yfQv9XEf5Ei81f7YfLLJjoT1Bm9idC/zfkTxzFT6o/EV7aeJnzdH14XrLxMqfowfV4mSM+M4Z8EEv6ihbL+XCNecKH70X5H45lw/rrT4Z1nlp/RdsdIPrD0F//M/VXtHfRuWY3PEbNKHy5z3je3PlZkKJ82UwIVtIxSuj/n4gxKmquEaSouXTUmiPSIU3U+l9fBA+0W7wvsTGOnQ8S7WGinYmgDZs3Btd3Na/dzu0nxqUv4BqmJMk7psgsefjM7xv8Nh2nPvqNdQps5S+2tnGZjuVBPR0LwdT8xV1+J63UeZmCe4Rw0QewvuQ9W9z/NzQnHEH/X7Vax2M7CZJ8Xdft/HVigtsXE7cv64eT1r4id9C+A6NtXKZjntiGj1Ee+myJAXg+hxiB7rc1dd+rfWk+/SWNPrX+oumT9wh8KCcYqM8BwrgV7P0qsneh4fEiSNJ/pM+K/vqV8kHi2E/oX9TkGejndaM6/6j+5nm6X/AhD0g79MmyaHUW2peQPWIfs7PHcuvVq8dJZuR9whHvDPHzPH2dV/gPK/KI3Fklr78LWSuF8fHiWLlWaUyNTVQq9Qzhi6x8j9cotXdBaG+YFl2f8lzoulQTH9Dnt/FPgl6D1A95JyhvAPJExqAPvXG0U/6TjuRPon/kn1Pod/htujRtmVP4+J4d1sw8sS7xOvuANhZibMNjIcYv+B7Q94T45SS+Tnwb+32sJ/vBd5Kvw/HP0IbKWjzKvu64I95JfZ3wH/bC2zar5HXj62qVcqHcmKxM1Rqlem28kfHmjgl9yj32dZrdrlXoHfuKvObr2J/1Q95xykNfJzJqvs7NuFjKJ9E/8s8p9OzrkrZlTuHje3ZYM/PEEl+HcRDHqejrOE49otQHfR3Py6bJJ/lQ3vUaoQ/1YHmDhHPoI6An1i/j4D2Mm7EMr9kI/V0Qt793tS6f1OE2RT7tTJEP9bpndTjdEYUu2CeVtfWd9T1veG/1gXrtDfXpB+p7cFqkqYGXQnHZKCxJ1frp3gfoNy/f7CUcGYL7vfiEJoFYWtMhNg+998OU592js9eDJK/w2t78m+8yaVNHHmrdbOMVE08rhH/Wm2tyLo6PaEubqB8eHt1sSxTzwQfgeOk7SA1/rm5YDrEXPgYo+dpfqS/f42ECbZHtxm9eay4wzGWdBpf16Oo2PfsArS2iXm0fthWP95D+HsrDrbNMBD4vgxyGfvxDWgrFUEfqIZ8u6Ic8y34WyDE12paD7QnDqDD7R3oOJ6OOkgVJthqijhZpttUsdl7/YiNaO0sZbTucPwSZduv/EoWP6z51CdUH7dj3OuuTdusRy/PWY9gW2kdD+mTYFloF8pH+QdhC+wS1J5ZHPZ+vl9/OW6A+U0zbZ7R2QHruM3FH9kWH2hbrm/zOPK3PaHr1SYa9igzaOKfZjtAliR9QPrs2KiSOH4T/QsUPDybUq+jnoBv95JP4CM2vaduc7Oux72vTEm0bDscJnsb9ZtMfRB0piOo72tb4+eN/NF1xHQdF9Yf58kEs+WzLQPO3zCV+H2Ko310dXl4+1bIcymjHEbg+aEM4NvyAxgbcJonalue5z8/D2PBH8xzrkW4+Y73GJ6l/50/gYPmwOHRIkSu4fqB5LW0sSyR/Am38xyHT8CBh+/w5tQ/6Qq19hLc2vZeyiMsy/hXI+JcRfQ9l/OsQuuB6tzeXjn2R5+lxCLchLk9o9HwsQOj/NmE837x0HJsU1Hge259jk6TjEesJ6RFDfFCO6FmHQRK7+Cewi39P/Vvzo/Ptw2FxZJjvd7xsOJk0RhH+Wc9lzNSOUXxvrl6jbIL7WpCm/HD6OBsS+mCNg/08Ho8UvviVzCN0j8eoqJgmSOh7/mW1joH10+IieT09YiTx/WntWatTL/SbJHat8YmKmXxDPj7Q8GNYjh6tK4vuj4KcWozMx9qOQR36CEOj5/VGxufX6kn5fk8/Ziv9gce9n2uu258/8jbSiRlVxyDJ5xgzikx9Cg0f6ZTto+UhMt9OMgv9mqac2rF1be6Cx7v4qL7QrwNM/kC89pmUKD+qbaPhVpnIox2fPk7lcLuO21zD5i1zDYdfo8j1XAb3LlWwtS3j4N/25u98l0nwZEu1H3icVOQZIPoryY5Pe506jdJZ8O+Uwhdff3gp8T1FfAMb+hbZpciG8wFsd24TjlNZznspX+ivg/58bfNaO2KC4+PNIzpvnD+ciJD1uCIr9pl9fme+0N8E+to3qsuK8qCsF27dUI/NO9Y9/E79aP5DewQirf/QtvSPUB6Oxex/tbXBqDEG20Gj5+OTQv8z0M4yt4pabwzwZVzS1i18ksuHOkSNU3Hb3ttHdFxtDTxIdb+zvkJ/M6xzvHRE5x0k7IM7UvLeEcL7Hy5pY76CdCg0aBeW8Z/WVhu8znolXdfLKeX5UYYZA5lzETJr4zPH+mkfb8LyYY/qS36QHMezieeuwj+r6MTF3FWbW/reXL0Kfdwnuplee22P1m44d0Xf6hFfnLseo3tRvjjOL7w7pV/AtWOk/zb4hSnyCyiX9APNZ2z0dFk8L7qNckp5oXM9L9xI9Tnohdcn7T4rlud91oOG9dFkjrOb+8lucE1es5uwR5g/BnazJ8JumsUjz2hobZBkDT6qDR5MyOdQl3wOJeTzQrapGSObegxs6mhEnPdC1/NhQz7aWg+PW6xfzBM+fC8qTgo7TooyBG389IjOM6ndCP39YDcfSWA3WhvMUN5hhe9CnclZKH8YhaXF3kKvxbZ+BH3S/QDtsUuxbbePnSQ/TyL8sySrrTzteFdbIziq6G6V1177qNZ3F4oTt9anH9h/3x5uDAHMeZ1KPkaAQu/Rby4XCNVPNAcVHkHC94SgIfE7NTigZvwkMsXRxuVrnfBoSD09L1knxPJhnVCcX5Dw8As/nyr034RFlCTvaUDjSfOehpkQ2fuUOmRDyuGiMeZhnV8VUWehfz6izodj6rzD76yzdohaW4jlg/Bch5Wefqgi6l0yl3mdsqe1Jyy/UMHKZcQnbHD/QcjicdjB0V2Qj/TvgsH9j2hw14Jv1/XnCcMhpV67gIYDK6lXv4IZJDnUxXr442bdHS/8qM86RT0fhAfl/2QkXjdRbS70r4U2//MEbR7Vf1C3L/hAplDPJ7Fx5L/oA5m/zXQqOWkgw+WiAhmmDevU3QYymkxhtGkDGZwBcCCT9sQIlhc6t6epinNONOOuDnYmn+p2COqgDdB+iC4yIfg8AEj5/hDd8QkLof8PEMR8YHT2WmurTSHyeV6ytsLyC3W6ZxPx8Q35+JDHKxoLHayH2WCleR0XJP1zygETJwlI78GA+VMaMLVVhPmu1LLNe16yFf6o/ia/4/oP66hfwQwSB1BCv6HpEN0+2VrJX7hdu0riwZ8DOu1URVbJ6+9C1sp4o5AfGxsvNYrViXpljMdIkZXv8Tiu7ehdqdC7XTEqqy/rOQp6DVI/5B2hvAHIw51BfoGFm8CsXEuif+SfU+j5hbNpV40tsOSlE9pk/UL5srBFHH6Bt9BvafqmpC+ExnEr6inoQ1TukCJ7kNgnBml782+cJTVikvCT9lmhyMJPBgnt1aCXD4521iXs5E9/SH2xbp6CEaY75rFMKXuf1ynb4QSyaQtPiOGHyBlgLNQJFI3Pti75bFP4uNz5Qp5x8dhYrl0G/U3YjtSDfjsf6f/TmjbmZBNTeyqXT95pC6tRHwzgk3dMw/5G6H8B+lXcBwOwnlF2hvFY1AcDhP6lFI9diAUtrnO/1z7d60MdXk51EPo10M4vy6XDfEUI5u5cG/OVKTFfGYJZA8xXR9jjZq+TX9qnxLE8nrpFWYzbt/XRpH1u8Fsf2Hm/ogusk/Dv9ilg5LVQT61rdYtqZ/x4HO9Ma1jvT4k1qOS5aNOopyOR/3CErFo9OK7Q+GxWdCL0+yPkQnrpw2j7UlZ0iB/lM9RhMaq98SOBwn8+H00SvW0gOv5oEup+XwiWR7830L0+T/9o0vk30DT9vLZusiZEZpGB77H9Y3m2fzc+c6KsnZSWxLEYy8ipj36j3EF7/3htG5fpEIPt+BDVPcrnhmFoa7lx/T5IuBkhLwLevWfXA/XXPnDng9U99R0P1u/do9jvSq+zfgP0m99Eh7KiXMNEx5uZ76ffD9PvRxR5OLFOMA0rdGEprn/cBNfz6R9YPmr98uou+Vyt8InCuknBivLfVyv0F4v/voroZM7Vjf++iu6F+e+FemKasXD+tMNv0/AavtB/mOZDbmKfyZL4d/SdojPhvd8R7wzxE33jPeQ/rMgjcmeVvG7Wp4sTpUJh4twWej1fzldr+ai+jPe47z+k0N+s0IuuH3aja/UFyw+BXoPUD3n7KW8A8kRGbX3ajX+aTKR/5J9T6Hm9JGlbalg75okl69Po46VvL5RvcutT0seT/PYHXI/hg1y434Nr6Zy0OFTqG9jtdze0cZmOZdWeyBrx5uqQ2yrt3Feba7pdz1i4tsK+x0lrK6lv2rbC9hC53fqmhdMh+hxOmg6lvuffVpFCh2hrvCaPvlbk7jX9DlAe7hPe6rfpOMXpcGhdG5fpWB5tXb/Pm6unvQoWz9/ep8gjPuYRr1N+bL8g8X4gln+EsPwYrB2EheV9wjoYg3UHYWF53lOYicG6nbC0g+uCdTgG617C0vblBOtIDNYuwsLyvOdwNAbrPsLS9uQF61gM1v2EheX5bQ6PxWDx2w6xfNgbQMKwdhNW1NtXTsRg7SEs7SMc2hoRxmzDyj3p624/KFJI/aEtbf7jYm9A07sW54ruTiqy5pQ8HLcxD/mcVPhoWA8aYh0yxHrIEOsRQyzfEOugIdaMIdZhQ6wjhlhHDbGOGWI9Zoh13BBrnyHWBwhLm1trvm1V81+Qzu8DvLR63+69d9c9ShhPBli8/v9wCP+cUt6jshm6lwvBEpzgnva1DKEX/xv2Rlw+O9Kib67141ubosoHKclbWB3t9RaTjqu85+76LaxR5wmCxOOqtn6UU/J4TWJvQj4WNh6kW32df0Yp7xFWRrkXJG2PCfvSVYTxMMnL99hHYHmh0/hc3SWfqxU+UVhXKVhCr82RovaYfCgvZd1+xai9x6TNWbV51nz2mERvm4mO95i0uStjefR7M92L22PCNt0XIqfwjbMVLB9lk3u75LNX4cNYYQ9o816W0E82+6rYF+recJ2oFPV8kdvnPCYS72UJ/2FFHr95nVXyutnLakwU89OlRj1fKU1NTedrUT4j7Zs+rlPoHX+QXd3LwnXKIPVD3gzlDUAevkGc97Lc+MGJfBL9I3/tSygcvyVtS0ss2cvyQWbp2wvlmxz7lJ7dy8IzPWn2R7A9eC/rEaUeUWM23otqq0ci+NzQJZ8bFD7DSrlMyF/hw/eYjyazNo/B5wdeu6ZdBvsJPj+AZff67Xyk/9/gXPkbIs5W8ZoQ9wm0wSBxvxd+Yc8P8Pgu9G+FOSA/P+BTnbGemszCox/uC0aQdvqdMgj9OynGcDPO688PRD1fxmuRPtSlT7nHdqc9k+s4lqloz99I0vwan3XHNS0+u4NrVA9RHu41vNnvzMM1JN7fwzX4hylPW8uVvFOQx8/C45vc0UY5ab4ZXwK0Y2Mbl+k84ulDHj+Ti+uq/GUAnBvcCNeYJ7LyPbY3LL8vpBz7EcdnEwuO+3Tr/P8hRVdYJ47dtX2hJOML8lqofRutblFnnXDfg/ctNKxDKbEGlTwXbfpQRL01n6DJqtWD5/NaP7tR0YnQz0TIhfTai44Wer1G06HVeo3o7Uai42c60AYPhWB59PtGuhe2XhP3HOjxNbrMSd/LIfTfhzjuFFzzWiZi7fE68/ZA3oHmtePzfHltXYV1dwB4h30xkuXnpI2leGbvpwmeHdHO7KFsiInt9yjQhO11fAzi3D/aqmNmPD2251hbbCLps7pC/6mIWFto+kPq9f4QzG+BLX42xNY9BVOr136qF8uwj2QQ+s8r+0ie56nj7B74fZffKdtDCi8v5B6PBQ+F5EXxjSsbXH8QrrWxnu31UaKXfcownbKtCP03ImxFexYq6qw0y8A0+0Nk+DVFhmCcGGrmT++6b3/I1lI/XLN71pqSm+BBBScsiRqC6kl3YBz5HWV+2racF3KPm0HK4jvvavW763vC9t6WEdjeEGbLPD0t7cO20rz3YfcrsuaUPI4Xk/KZ7z4s28KeEP4ZpbxHZTPKvSAFneWLK2avtbkor32knYtqnYOxwt7FMe2385H+X4E/4i/47QM5NEw5syr0WlzsK/UR+rj5pfAXXWrzlCje2rlfoZ9JKau214Mx/0MkK8p3OKWsO/zZvwslq3a+PUrWsH4pY9g5J33ng/UH7ti1p45dhcXw6HqQ7oUdD5Lf+0NEXUV0vOx9iH7zuMlj0gcU+bQkcmBiWfq8+MTv8/4r6KJ/HNJFPS/6WJN2DB9D7uM05fKBjpekNXNM8hoedE2Iwa8JEvq/i3BNR2LqzV1CO06ufeBDO5rOr61b+A+b52vaxxNRBwN+8vpq+tGOyGuvsc0RPepK2xriZVvto1m4NaQd52eXpNUt6igfvie/T8Go++18pP/HCPvTHgPAJWDWb9qP26J+paxmf/jIUZD6Ic/Q/uqa/aEO2P6i6qvpRztGj1sc0r45okddaa82E56a/xOd46vNtO3tTMhfkZXvRR0tuM3v5OPilW5Bkm1B9pdaKBdcV7xOevygsuYvmV70jEstWvsNEP1Qc/8QP/7LS89BwuXH4Ut03ti/DymyMu/r4bXAueZ1VPjGr8xdC7IfGA0vz2MLxkD8yo6wVyOi/rGe2Obsx4T+MpBzZnT2WvMluIwepH7IM/QljbRjmeZro8ayOF/L4xXaKU8rtCkK6jxsWrFcoUc8jvGuhjbij/3imMkfKvZTyp40NjwE9fhnemW2Nm5FtZXm97XXiD+WAOtIRH2Pg8waPfoJpM8rumfMAU+3pWMhmCXA/NOUmLtCMMcAk+MRbfzUvh8h9NpjItrHyrXHBU9SHsrO4+YJ4M+09xN/7fFGT+HrRcjLY26cvOzbJe92GBte0rweJDxjv1iKassXK/VJ2paHIurPWFKu35trr1ofOqHo6xWX6JgDKTFvU8ZXLdZ5n9/mfXtIbBAkjg2CxD7wkCIXxhxRrxbm+OANSn+NOqrrdNwt1PPauIu64HFXm2NrxxqEPm6OzTE80r/X78zDLVJX49qf0LimtWmULhB3C9FL3dDHoy7uhnykn47w8docPao9NNvHeaXIoz32jvOm8+X9dt6FtNeoOFHTz5Eu9MP2qsU9mr3y47DacmxSe8VXWP+A7FU7Sq21Ja+fxK318FFn9IMaPcdAQv/+BHEVyhD1qEXS9QFtjDvh6byxb6JO+EO6Qv9IQn++MGsyhYLWP1Cv3D+idBiktDEir7toj0tr/eM45WlrrUn8bpCi+o6UxY8pR334OG1/ZRm1ebnm64X+dISv18bSKF8f16f50Qb0HVL2wq0J6LaMOkji66PmO934ep5za0eP43z3TIT9+SRr0u8oRtmKFnel3du4kG2/kHsb3Pba3kaGdIJYmm/Q1mc43ppvvBkk/lZ0XLzJa6BC/7WU8WaUHS7qeHMedthr8abmg3A98v4En76Lsr+o/S0LH9SnyIVjsfYYbZC2N//mu0xRezJuPzeWr2SIn+gD7yH/rKJHQ3kKUe2K+uFHnN18Ti5fDrZi2faD1PDn6ibM72SovOyFBel2wOHj2j7ww32oH9JakxYHYlnhwXHgH8Pa2Y8IE8unjX+lbID77oi5I79WSmvzgwou+8HlIfQ4NiH9n0fMDzVfqdmd0Mft+fheZ/21/XXmrZ0X0MZSof/rnpofFgsXes+ex6youSPaIO8DaWORD/e4D/hQHueAPwzpW2HHG/k1mtq+rWDxnDFIdb9NszekTmG+Ql5Jyb7iJynnjOvhXtq42G9eR80Zo3j7cC/sTM5yhT7KZ/xjhM+IO+fDOhX6f4rQqeaHonRqcc4nqU53+LqsSXUq9P8tgR9OqtOWvta2MX+UYO0vSqdJ/UyStb84nfKRZm1P2Vd481rhCqg/69SHMkl0KvTZC6hTH/L4dbHoM/gVN+zvsiHlLo3APBaCGTX/YoywttR8Grfluoi21Op1LGG9HjOq12Mp6yX0mxzVyw+pl9xPWq9jMfXyqV5CP5qgXmFnqHjtX+ivUvrexbxmxmeo0DZ8ytPOL0XZxHzmNztofuMDHcdq0kZhj8qwDQh9MaENCO8LYQO4Psk2EPVYSJDYBrS4G9cbeL0K6WWerNkAzzd9hc98bGD7SCedq7O1+GoqrDfOI3CN4naiPwZ8tb7I9NLv8Gwt9jc+fyL0O8Be+Wxt2KP9L1+r8w7rK7ymIfRvX9vGfFXzWnucn8+/Rp37154jQT1zvxX61yTst/hJ3iD1Q57rfov2lcR3R62FxPlu0Znmu9k/a6/H1V6ZpfVzkVF77YHgnj/XsDpefm0tudv4510RcYI270E9jYVgToPdV9d21l877xTQ3bXWhncj5fzAh3tp5wciT9Sci+vNbXUX+YWofTcplzQexTxes4/qV9rZXtbhci96bs/zhwcUO0ty9iHpc05xz7a8nPQcte+jxQg+3JtvjKCtoeG+1fnyfjtPZHS8RlpM64uj6qvpZ75nIllX7HeT7D1H+WLt9TyBrXy06Yu1PVo/Qd20MxjaXjj3FZHvOPQVPjevjf9RcbvQn4rwi3HrQfM9S6Dtcx6LKKftcyKv7c2/+XyjqyT8xG+tUGQJGy8/BHr84Kgua2aOvN0lbezMkJ54HcWGdzGfIX6eN3euwGOTNt5sN5GnvSerrUlr/U70c9yJPIUG7smi/eKerPZMB9qLtnaB85FPUWyk+QD0p2XIR/rnIC77bAim56UfZ/GM10+GO3Gtz6hFnR/i53W0+WHU8zoc44Q9m8RnGYX+a+Abop4xFLncnh1vXPCzsXz+NerTS5r9oS0k2TuLeqZJ6J+PiEOjzufOpJT9iCI793PuO5+iGBV5HkrAs5vzuVsgH+m/t4Bxw9L53Ln08z2fi/aS9Hzuv24qV3t+m89mxr2OJ837T4LrKyAf6f8swv7izocu1PtPRE+O7a94ofc7/OZ1kvefRJ3N9CEPz2Z+s6lcl3ocn8i3YlppQ7FJTv2Qj/T/0LTJLNRD/vZ3IWdjvFpolKqNaqVaq5Wnq/xa+SBJmwWvmQrs4e/WtnUmerLWWZAEf8ANfuu5336oa59SJ+EvtrQM6DMhfz1Pn7MIryxhGdetEFU3lJ/XCvpJHrkOw+pPiTUYkrfdpt6tNu2LqDfzD6PX+oDcXx6Bj/Ti19GGl5MuVrjRRTGq3ZYDT+E/n9dmy+/LiY4/c4b6HgjB8uj35XSvz9Nfm81+adibW28p49inJH6dqPDPek77Q8sPDJA8YX0XXyd4965qrfmWT3Z53HSoToTjanPTtYZFusfmsIzKSainDaEsZ0bB0FTAX6jPKPw1V9IXwtfz2ubK7iMOS677ImQJw8gQxnAExlLXWeo6SlrqOum7jnSPSwhje/N3vqtUaH1Ucq03N0neOrj3Fb8tBydN7yJ3UKejo21cpmOeqyFvHeWNQN6llIcfil5PeWsgbwPlXaLIk8R1BIkjVGyr1SH1suCDOhohPiOGfFDfOeKTM+SDbSdtNejNbbsLZf/YtpJ3KeRxW6+HPG6fDZDHOt0IeezHMWn9TfQU9LfnRtu4TCfJ7fDb+/rFWRInTb+ip7T6dTMb6y39JtWh6CLQ4d+OtnGZjuuBNrouBFNWXXEm/WG/k3Y10WIoJm90HSDcHzYZBrhvXJec90dC8H4P8N6SAu9jIXi/AXhvT4H38RC8rwLeO1PgfSIE77OA954UeJ8Mwfsw4E2nwPtUCN5pwGukwPt0CN4M4N2ZAu+5ELyHAO/uFHhfCMG7r4kh/gnHeMvVVu2DosgL5cUpF8ZJO329frubdQj8yD+Pzl6Lr1hJPDBvEPKWUV6W9IB5Q5DXT3mrII9XdtG3fdGf/RvU4c/Wdco4Xz08sgj18Hl/9q+lHo4uQj18xp/9a6mHs4tQD5/1Z/9a6uFji1APn/Nn/1rq4blFqIdn/dm/lnr4xiLUg8QDlnr4rUWoB4ljLPXw/UWohy/5s38t9fCjRaiHL/uzf1EPw8QP5dDWXFdSHu5eDlMe6nSI8nBeuorycB1Y9LW0xttpm8h/aY23k8/SGu/SGi8m1NPSGm87b2mNt817aY13fmu8x5uKCnDXXZqcd9garw94G1Lgha3xPgh4m1Lgha3x3g14W1Lgha3xTgHeaAq8sDXetwLeVSnwwtZ47wC8a1Pgha3x3gp416fAey4E72cA76YUeGFrvPkmxmJe4y0167BY13ifurRTxvnq4ecXoR5wjddKDy9fhHrANV4rPbxuEeoB13it9PCORagHXOO10kN9EerhWX/2r6Uedi1CPUg8YKmH/YtQD7jGa6WHQ4tQD7jGa6WHU4tQD7jGK3pY7Gu8jta4itoap0dy4vpB2jVeXHNKs8Y7DHlrKc/l+i/Kw389L9laJbbVcEi9LPigjl6oa8mD3ty2u1D2j22rrZ9xW1usn6Vd4xU99cgab8/rd5Gv8faUfpPq0GKNd20IprbO9VG/k3aYaJOs8VaaFT6/b5xije0zIXg3Ad5fpsD7bAjeVYD3b1LgfS4EbxPg/dsUeM+G4K0BvH+XAu/zIXgrAe/vU+B9MQTv/4c11H9IgfelELx/Arz/kALvyyF4/5HWZHFMdr0mi7xQXox7sf+GzSX+S4/PJQI5f2G9TV3/5SKq67L1F09dhy6iuq67iOq65SKq67UXUV1vuYjqOrGI6trtepzLNbcMyeZ5c5/fDxK/Z0B7/r/Pm1tPpBvw9HcDaLyxXIYwNJ0tvRugk+fSudF4PkvnRpfOjWJCPS2dG23nLZ0bbfNeOjc6v3OjP4U1rMPrk/MOOzf6fwPesRR4YedGfwx4J1LghZ0b/beAdzoFXti50T8FvLMp8MLOjf4rwHsqBV7YudHfBbxnUuCFnRv9FuB9NAXecyF4XwG8T6TACzs3+pkmxmI+N/psj8+hJA99G54bHdjQKeN89fD1RagHPDdqpYfnF6Ee8NyolR6+twj1gOdGrfTwvyxCPeC5USs9/MUi1MOz/uxfSz38u0WoB4kHLPXwfy5CPeC5USs9/NdFqIcv+bN/LfXw3xehHvDc6AB9KXfp3GjHGsHSuVGSE+Xhv563dG506dxoZ97SudHFrd+lc6PtvG71m1SHi/Hc6OebRhPg7tiQnHfYudFPAN4rUuCFnRt9CvBuS4EXdm70BODdkQLv2RC8g4D3uhR4YedG9wPeG1PghZ0bvQ/w3pIC70sheDsB7+0p8MLOjb6ribGYz41Wm3Xo5XMt30gwb0pS1/ddRHXdfRHV9eGLqK6HL6K6nr6I6vrMRVTXT19Edf3SIqprt+tx1mtu1l9AHSuPFSYmqhPTY9ONyfL0VNwXUK35FycmxiaLU/nyeG26USuXFpr/9NTYVLk+NT1WKI+Vyvlami/AZrzONsaztdr52wGi/x70gz+lLy0vi8AM0oN+J6bQ/wFg8teb8Ztl2vliPu87oNDz5+aCpJ1H5nVvbC+X7TlenZianJ4sV8tj+en8+Fia9tS+VppJoJMBBTunlB9IgIVtvMfvpBf/udzT7Uzw2N/+OdjED7fqmAOA9aAfLzPaAc4L2ecL/V+BDD8dnb1mPyh4QRokbKnr9ubvfHdpOkP8PG/u2i/yzyr6MJSnwO0h8oTZl+Ov505lCB/lWaHoRxu/se1wHEOfhvQroI5Ij9dSHu/9uGlbOcIMkqyTZZS8PuWe6DeQ/e8oBsC2yYT8FVy+x34BdcO+Ev30nX5bnp9Q/IX9vU8pK/6D++JPYc3nPzevtW9Xcvux72ef3+fp8oX5Kx4Xhf6/gq94nurM4yLWk2VEfv0K3yCxvxL6f6F1LEf9Xl3HYntAHUs9grEr6uvaUf1XG8O5fywPoec1wVbfaR5I18aYlVCmT5GLYxmh7wNMjmUGlXpp/U3uZxX6QaVeI95cv4Tx/vnyfjtPdC9Y/ZBnOV4F8kyNtuVgHQ748fpZ0YV+xAZyRI+60nzbCuITFVMGSZ5x0+ZP6E9+Aj6C4zeOGZC/Nr7iPfbTWF7oND6szxURfDQ/pfU7TY/cRzZF9Dstttvrz8VkGZLGdkJ/Bcjw30dnr7XYDsey0Y3RsrJfwzkW0r9oYxvzqua1tA+3fZC0uLyP8rAtRUfob5cruJrfYJvQ+iTSc6wtfWx5CD3GU0j/YsUmRry5/bYvhB/Kh/ei+kY2BEtrzyBxbCL0pQifP6TI16fIJ/SrFHpcCxJ5NN2s8nTeWB9sz71UH6GfVOqjjSNiU47HkZo2jqBeeRyJ0mGQWOfDCj3qUuqnnQ3KUh720SHKQ768Zhg3h+IxRouf0EfhGKPpTOQcVOpr13bThQzxk/rhPeSf9ebavIs5a1IbEf0Mu9FPPsoGhxX9ON6jLmnn+divyDkX9CtIPww6RHq8lvJ47+1N29XOGwo+n2cLEs+XMa9PubfsAmHlFCzUm7Rp0I9fQ7pAe82E/BVcvscyYnvy+v6QIR/EkjhK60/Bv+3N3/muUqkYdUbT7TN3lfGkvk74Zz2nfbkQZcOoH96Xyimy8rsCgvQBv00XZ9/IR8M626NYM4ZYJwyxThtiWerrmCHWSUOsI4ZY+wyxLOt4yhDLUq6DhlgzhliW7XjIEMuyD50xxLJsR0tbfdIQa8YQ63FDrA8ZYlnafa/6HMs6Pm2Itd8Q6xlDLEt9WcYmlvbVq3Ghpd33aix3wBDruCHWxRDL9ardW8YmS2NaOqxejeV61RdaxnKWvtCyHS311avx10OGWL0afx02xLLs25Z9yFJfluOQZR/qVd1b+i/LdbkZQ6xetS/L2LdXY8xeHDuCa96zshg7RkKw8Tpqb1jjk1Fk1vaUlwGG23eB5Etu36eeL0m91yi6wjrxe3jn+44V5JUlLOO6FaLqFrUXjfvuqIMwrDUpsdy+P6ndprmIeiP/4QhZtXoMG+pkwBCLz+pp/V/bvxX6SxR6zU5GFN5SVtoW329i2LbFqLZFHyH8gzMLcmaqVp/au/PVu3Z6lPpID6K3NxPdHX5bD9w31oRgefT7zXSvD/AwLZR/59/8josgyXkU7QxR8G9783e+qzRWjPKtbseZsVKG+IlOPdKb8F8o3x3lw4LEZzCS+LAgPeK36brxO0F6yhDrtCHWjCHWQUOss4ZYM4ZYhwyx9hliWdrEAUMsS5t4zBBrxhCrV23ipCHWKUOsXu3blrq31NdhQyzLOh43xJoxxLK0+yOGWJZ2f9QQy9ImnjbEmjHEWoq/Xhg+2nKs9Q2xLgZf+IwhlpXPCa55rt2NXE/4dliWfcjSR1uOab0aF/bqmNarcytL3Vv2IUt9WfropbFj8Y8dQTpsiGXpCx83xFpaU7hwfchS95Z1/JAhVq/Ohyx1f8wQq1fXCy3jnCU/ceHiiSU/ceF036t+Ikn8he89lHeiyB67to8vWJfEYO0gLCx/CWGtjcG6g7C08wzDClam+Vf2yPH7MQGf7c3f+e5SMUP8pB54D/lnSVZjeVp75OsUvaJ+eI/8UkXWnJLHZ1q4Pbeb1GO8qrWbHX6xxvUWHli39U7aqJz43bPCP6u0gwubWU/ysH7YZjYosuYoL0iP+m06zutT7i2LwDpliHXWEGvGEGufIdZRQ6wDhlhnDLEs9WVZRyu5ND/bK7b6uCGWZd+2tImThlhL/mvJf7mso6XuDxpiWdr9E4ZYln27V/ujpY/u1bHWsh0PGWJdDOPQxVBHS7ks/eqMIZZlvMrz9l6xrxlDrKcMsY4ZYlnGJr06pi31xwtXx14dty+GeZqlj+ZzdC9Euz9tiNWrax1PGmLNGGJJf+RnJIO0vfk331UqlWUtGvekMl4nX0d7P/UM8RMd4T3knyVZjeWJ3PtB/Swj/bjZ58jXMoSP8qxX9KPtK3Ac2XyVe8f78pF+PdQR6fFayuO9b22a/WvpJ89/R7aJm6IPFKcbhVKlPl7Jj1XLldpYqVgrjudr5UqjUJgoFCfLE6VSY7o8UZsolhrF8eL0sDe33bkPOGrjctI+wHtZjvpk5F7WOqWN0u5l3eW36Xpp/N3pd9Yn6p39bmyhNDVfW3D9zn7NFqLe2Z/UFj7ot+m6bT/LmNpyLnncEGvGEKtX1+gsY/1eXaPr1X2BE4ZYlvMGy/2Ki2HPrxf34IO0tA984XS/tA984XR/2BDL0u57dV9zyU9cON1b1vFDhliW8cSMIZal7p82xFrqQ+mwfEOspT504XRvOXe3nCPL8yS8hhSk7c2/+e5S6722G7rHrvENwd5oL3dDsC9TsAulUuGcOOOFRq1RqoxPFqcKY6WxsUa5MT42Ua41KuVqbbxeKFdLxcn6eL5RmKifW/ktTY+PNSZr02Mt7E3mcpcqst6F3/jGb7S/ZPPstdgPfoO9j8oG18sgH+m/sLmNeWvzehhwPcAI0iDhZTzLdcFiPkP8PE9fpxT+WZLVVp72OuUykof1w+uUfYqsOcoL0sN+m47z+pR7UVjHDLHOGGIdNMQ6ZYj1pCHWjCHW4z0q1yFDrH2GWAd6VK6zhliWdm8pl6XujxtiWbajpe4PG2JZ1vFpQ6z9hljPGGJZ6uukIVav9u0ZQyyJJ+RZcYwfV3mdeRg7DVFeP+QhBuahfP0R8mH5/pByXA+Jf5dT/vbm73x3qSD4K93gt741sULRFdZJ+Es8OwD0mZC/gsV5witLWNa6i6obys92sALk4W9SaFgrUmINKnku2nR5RL2R/3CErFo9+kknWj/LKDqR+ysj5EL6EYW3lBUdDkKeoQ6LUTrEvij85/OdDtHbVqKT93ss8+ba4IoQLI9+b6V7fYCHaYQwND/K/TmsfXMh5YM0HMFnWCkn9RsCGbdA/krisUWRcUuEjFhe6DQ+mS75ZBQ+jKWt0QRp2m/nI/2vNNdlgjr8aGsn5hWKfFF9catCfwXQiDyabqTssMI7E/JX+HhetA2hDOynthry2Qo0A8Rn1JDPKNCsIj7bDPlsA5ohKBf8vhLy0M7El74I8u18aXFC6nmdNzdJ3vVw76t+Ww5OffQb5Q76w9HRNi7TMc+rIO96yrsa8m6gvGsg70bKuxbybqK8FynyzLedsa2uCqmXBR/U0dXE52pDPqjva4jPNYZ8sO2krQa9uW13oewf21byboA8busbIY/b5ybIY52+GGS422/TcdL6m+gp6G/PjbZxmU7Sxaxfqatcc1rSbztvvvrFcY3Tkn7beUn0Ox8d/u1oG5fpuB7YVlIniW+lfP/ls3/Pz3su7yyPc82dfmfeZsi7jfIuV/IC/H9oBpoS36IeeI6B41Cfci9qjnFNCFY/YA0ClrxLcYDotzUr4tYmx8ajYhbhfZ0j3knGduQ/rMgjcmeVvP4uZG1MT+RL+bGxWn2sPFUpNzLe3L7bp9zjedf1Cr32XUTR9Q1udF1sfSfZb+NjLBykfsi7jvIGIE9kDOz+jaOd8l/vSP4k+kf+OYX+DqhDmrZ0iYX+wAJrxTyxLvE6+xP6HM1nriU+aX0mlhc6x+Ov6uskab4FZeQUN1beur6Ny3TME/V6HemiF+bqwXWO8tBPraE8jEU4nsNYBNc7OcXN/zPb2rhMx/VAe7o+BFPG3yshX+KHAaL9WYhbJihuwTn5a/zOPJz7Cp8A4/WXt+8jHy0GCtL7QuR6DcUMbsbtck1by+GY4QZHvJPGDLyWg/KI3Fklr5uYYarQKNXzU1Pl4lStMjY2liF8kZXvccxwo0KvvfNXdH2TG11PaTEDroMFqR/ybqA8jBlERi1muNGR/En0j/xzCv2dUIc0bSnjKfpQjmPRV7zX78zDNTecx7ye+ribeKtY5X6DSfPzPD6gTfL4gHN6Hh9uhry044PoIu34gH4S64Ty9cM9zcfz/K0KY8S7aYzAMV14B3R/T23rpl+337OOa4Osk5vhXtp1euzradbpMQ66mfLQzm+hPOzLecrD9ixQ3k2KPEnGlyBxPBu1huVqXZv3Mq435IP6DhtLLfhoftjtuJDO/rFtJe8WyOO2zkMet08B8linRZDhHr9Nx0nrb6KntOucF6N+g2s8G8NpSb/tvPnqF8dTTkv6becl0e98dJhmnR7bCuvUTezzuQWJUfP5S6heyGsphlqKocL4LMVQL/wxCN+nxmlpDGrnzVe/uJbJaUm/7bylGGpuuhhiqKRrPRnKC4u1XufP/h0g+n8P60z/QOtMOM69CHi/r3m492KNkaLaazHFSGHnIiz4aHvqSzHShfOB3NZL60y9rd/gemmdqZ3nQr84tnJa0m87rxdiJGwrXmeab+xzA8UxF3KdyZGNTGsxBOsW7SdtDIXtOd9nal5MeS7jK5RnvrEAttVCPVPzQo3V3J73SWf/2Laa/+S2tvCfadeZ8OxsmjHoYtVv2nWm+eoX+VxM+k0bQ4me0urX0TnWntJvUh3iOdY0MRTaKI+5uNYjdLjWwxjIw20bJf8mEz/L4aZPtt8X8iKSh/Uj41/wHLc8p76zvue1e6fuvnP6tvr+3S+5t/ba6gN77qze/ZJa7YH67t1YG+QwrNSWrYVp5Dqn3EeM62JqIW+ZGPHmtvJ1hHV9DNYOwtIiD8G6IQbrDsLSogspd2MIH6TRVnhQnhtj5LndD5eHTwXeFIN1L2Fh+ZsI68UxWLsIC8u/mMrdHMIHadAb3qzw1vDZbm+Jkfk+v1NmlOsWwsrHYN1PWFg+T1iFGKwHCAvLF6hcMYQP0uBIiitrGeWeJs9uP1yeImGVYrD2EBaWLxFWOQZrL2Fh+TKVq4TwQZoy3K8An4xyT5PnQT9cHimbZIRDWQ1HlMRPJQj/hRrh4vTKb+YZU2TNKXk4hmAe8hlT+GhY1xli3WCIdb0h1o2GWC82xLrZEOsWQ6yCIVbeEKtoiCU+UXwatuslxEeLEV4cwQfL80wBy2VC/gofvsd8NJm1lbQ7/dm/wYzk+S3tMmiD+HYsLCtj0QDRf2trG/O3m5iiS22mJGMA2padz21/9RbHVo90guPPBrjmpM0aRe60K7XYRjxWYv8fozzsz+OUh31qgvIKijzztS9sq4WyY16xvtmQjxYHs74t+GgxshZjYj/BPOHD96Le5sQr9mH9/y+36DzD+r/EfgNE/xz0/39DO0EYbxr28Qr3Y0xaDMUnQcYhj+15AvLYBichD9uWk+Y3RBdpV5twrJM69ZJ+g5R2twt1MV8fyn4S+zT7SWyrMD+J7auNId36AmyrJR+anA+2nbSV4xgitX8pU56lf5G8n4E8/HI7p7iYJc1uwcWqX/S5nJb0286br355fQqTpX6xHV+o+k2qQ9FF2vgDbXQM8HkMQDqMIcPWuT0Fg3F4XJQ6L1PKyhfGtLXudcRDW2/HezwGrVPkjRpT3fbv2TfOIz+pB95D/llFJy7WOQsJ9arFtgXSOebxWpu2nl9U+GhY7Je02GvQm9vHDPVVTtp+wj+r6MFF+2n7SesUvS6EfYe1880R8pTcyNN66522X6Ot/63xZufDbEPaPhXLjfs6ci+sbZA37y9H7fUVYrB2EFZYHcLaCLF4f1nTwQDlvau5zX/+q4hXdNLIvuibgeZlzeuoeZvjvafEfZr3ntzM4aP3nlA/aLMrvGjbwbYL25e/Sakr2/KNMTKxLac9A4BYbMtRZwBujsFiW8byHBegr+aTX0WlPpJXUuQLbPztV4Tj3xyBf0sEfiEC/yqg4xgV1xuLlIfrmiXAn4rAj/oawI0R+Dcp+IwpfgPP71xFeUJbb2IEMfLXt81eD3oux95SgeNsTNyeQUq71iZyd3OynNsY+2OJ8rB/8bxH8w2u18CuCqmXBZ8oG3Z14pv7g6sT+dJWbp9OTWf/mi9Cf8ZtjWMrtw/GAazTsDMWnLT+hk/DXviTub2v37RP2OOp3SX9xus37ZNl89Wvm7fc9pZ+k+pQdNHN03lSp+DUs5xR2Fnfc1t9/5urd99Zq+65c9e9r6/fv7e+e08/wV4VIo785qFJTARxvAhxg7SM8vhl3vKy1GWensRs3CxJuQ+rRO60YZXWxFroxGEVDr8cVmG4E3a0BOWZb3iAbfWikHpZ8EEdLXS4w/q24KMd5e6laQW2reY2ua3RbXL7oNtkneKwtAmuOcVNY9IMSxerftN+YGi++kU+F5N+04ZVoqfeeOC0t/SbVIf4UGmasAptlMdcjHnkgw6StxnKXUvlLoc8wdc+cIVLBLJCNUK/g2v5MOoAyfXfmkSDRGdsDzVeehMeyNtRX0/82EbYyyhR7qyS183HJIr1qemxarVRmm7kp6uN8w9RIr7Iyvf4YxLXKvSrFXrH09Wq9Bf8mATadpD6Ie8ayhuAPJwq8sck3Hw8qFRNon/kn1PoXwV1SNOWOYUP9u80WPJhClzqlr7ttr8Vx4a9uTYpSYvn086NcKxLMzfCD93zmIJ+L+wDHsF11FZC2IeFUZ4kvihIUTbRH1IvCz6oI/4guKsPdS/UErq0leOXQaSyf23c4Y8bYh4u1XP7JPlwaJDSvhBuvi+DuBj1y3EXJ0v9Ip+LSb8YN3PS9Ct6WrLfdh76RU5xNppmboQ2KnVaij+W4o8wPkvxxwvff6+Ha05L8Uc7b776vRKuOS3pt53X6/HdUvzRprGMP1j2AYV2C+UJ7cPwOPJnm9cj3tyxa9TrzNsCedso7wpFJsnbqsiUIR74OAyOkdN+Zx2E/lCTKNDlzKiOuSwEU46oaut8Uo/B5t9+yLOz3+lCIPfUaFsO1On5+vqddcLxvE+h57XUqxV6tNfR5rX2ePyVhHWFgjUK92StUNOnyHgh9Ikysj6vjKkT61PTP+pJdKTFTJsJa7OChTqO0udo896F0CfKyPrcFlMn1qem/21AIzrKeXN1fTlhafrE/s5r2VJ+uUKPeANE/ynwOT/c2ikf+k22hS0KNvreDGFgPbJKPYYpD8sGuC/Z3Ikb92o3bhvtER7c5xTb1l7TIWUdP16a+hU2/HoL7TVVkoePnvKeLj56yo8N4KOnqBNOWmyAj54mia8yxEdw2VexzVylyIivOtEejXox8bwlIU+hj3vVIdufZq/4WE2U/fFrr6QcxhcoP7+yRei/A339R81rzR+Lntz643xd88eoV/bHUToMUto+LzrTXtWRpzy0F+53VymY+Kot9Gnyt6u96VqtXigXxicn6uVybbJyCeGjLoYc8C9XquPT1fFCYbJcqJcLC85/ujI2NX1OiHy9cF4dC82/UpuayI8Xq5O16bFaqTK90PzrU+XJ8anJ6Uq+lp8sTJbi+Af97O/Wzv52uTYYpLv82b8yVi6H8oa+oyj4K0g+I/zWOakBb66ehPdKJ3VrNJK0A/LPkqzGum49UrqS5GH98FmWQTf6qQePrIrtoc9fruiG5VhBMmYdyaiNqyKTdt5G5AhovrmtU8ZljmR020cbrbNlGBve6c/+DXj+XzRXkLbBuAbtfhnkI/1/gbWf/0RrP+xzgzQE+SuUfPkt7bVMocVr/i2ys16RXmxyeUhdl1Ndhf6fIIZ7foOOifpDuZaFYP6LEhcKJs7Vovq80A8p9NjHRJ4Rb27fHKJyKPug15nwntY+GaLlMVjGKSwX9ntQwQmTYaWCo82nB0lW5Mn2ECSe8/QpfLBP4Zg/qPA3HB8q2lgpSfKWU30xD+v+Fr9Nx0mbY0qdgvr+Bc1pkI7l0fqaZWwk9wfgPvPtI9rlRIvjOetswEDGnMJnOeGuiJA/Qzj9SrlhT++P2t+k8mYUebWxpls+iPVWv5MPtjOOaVtH27jsx/uUsu/32/lIf/VoG/PK5nXcmMa+BOvwNr99j302x7HcJ3ntg8cupsFxHOmvH539i2MX+wfECu7dONrJW4sRtLiPY4TbRtuYNzevo2KAEW+ubtiGB4kXxscyvrAOxkbbcpRGw3mJXocj6hjcmxjV6VAGpGMMbewUDK1fS7kRRS7ue+w7lkfw0MYzjccA5XXbPtq4jbGGFsNo+TieIx++t0yhj4s/siHYGu5yBUfz8yspL6PksQ/D+qIP49hEm5Ohb9T6XVjbRcXemuxJ4qrlEbJr+kM/ZL2Wk5/IF/LT45VGo1Abq06V49Zy5P4Kv7Ne5//CvQGoV5BWIj3lDUJev9/JP9v83Q98EEvkGCD6d43O/h1p3l8OZaR8TuG/nPh3yK3cQ1tjrD7lntAHbfqW0dlrF2t0xcrkRHVyKl8oNorF0sRYXLtqesK1gyCJrrEtlit1GyD6xmi7zu9tXkvbDyj8Arr3R9BlQv6ex1Du9fud97Q2QtsVeuGd9efKKHlDkDdAfFY1f6O+EEvkGCD6PaOzf6VN0N6kfE7hv5L4d8it3GPbHVLohxT6oH3uGW3iNe9h3a3X/s7zJHy8x7KJ7ThZ+58ca0yWSlOF0mStPlkYW/C193JpqlFonFt/LzXypYnCgu89VPPFc3suU1OVQr06OdlY8PoXCoXGWHlqYmy6eG6Jb8H3PsqN8epYYzxfKdbK9WKtOp+9D56jB0nWSHh+vn2ecrLYSXwl8s96c2MpF2v6fSQP60eueW0Ey2r7QPIemIyS16fcW7bAWFHrBa7Xy5LagvDPek5tsxCl1z5Fr7wGhWV5rhEkbr8BhY+2prxYsKR8kLQ1xJ1+Zx62MeuU+zvmafso7OOi5uVR6x0il8z9tLU8rAvPqb86OvvX7d5fPs/+nnmhvBL3oT6CdAfVQej/cHT2b0D7jdFOnWnr15o+l1Getqaj7X1wO7TiOqjDyog6CP1vjM7+jTvjI/VxfManrJ3xwT0UjFuDf1H7R0HitctVCv0Q0PA6xyrI4/6r9X/UOa+D4toG0yMer+3+/ujsX+3MJdp1lmTHuvMaSJ/CN2rfKZDlb0Znrx2f1RjX9nkkDSt6Y1+K/YT9Je/fYx7aAeqAUx/9Rl0Ecv1gWxuX6SRZ+gl8duO8fP5cuS5Ev8V1T+632j4x0qfZJw6SjG85b25bsn1rY0GaPhOkVxE/bc0b+0zYuKvFROwv+pW6BInHVqH/P0Zn/2pnnlyPrXxextEZozFt/0LSsFJv9hHYf9hHcCyCedp586Q+QnSR1kdocaPmP9hHaPt6Wh/g/qGtx0ftu2jzJnlHVoYwPS96XV3bs3S5PpAv1qbH6sXxifz4WKE4WVvo9YnqeH2yPFYqTpcak9WJ/MRC85+qjU3nJ0uFWrU6fk4FE/NZH+EzAEFy7HsSr48I/6znNGZpzYnj9o/Y10Sd/9FinAzlIZ+VCh8Na5khFj83iu3BtuBobSrx+ojwz3pzderCFjSfp/Urba0syZnpjJKXdn2r17Gi1mCTtLvGh+0f+WB81XFOZ1tnGSmH820sy/Ntof/4tjbmlc1r7bljPhuN9d/e/JtPl8p8w/HaS1Wbv3uk7yGlzhmFXounRO6072/BeGqI8nB8WEV5OJYNUx76xNWU58p2B0LqZcFHO+MXNd7Pl492fkKb/3fLB9uOzyRp49l8x0ZtHqiNjehbfnGbzhN9C5a93W/nI/1J8C2/1Lx2vDcxwfaPKe16DNsz+ga2QVyX42d6MMWdAU7zDgq0vUHA536JPB3Hwan0H6S078gSudP6WOyTg5SHtpilvG59M8pj4Sui9lS65YM0C/UuroUeMxyvFaf2PzzGpF0P1vwP6xT7B8bEnOLWkdO8Y+hi1C/7ZE6W+s1QPbY3f+e7Sz2v37QxudCl1a+jtYGe0m9SHYouLOITfM5DO4euzceFPmqPBvlpcbSU7dU5Ztp+wPHnashjmxmBPNQJp7g5bZp3oGjzFKTjc+sZRUaci0Stw8t9bX1nQOEZJaO2Nhplr9p+ubbfwXaqzalQ/rA51bNNfcSdjxA9Od5nrWj7rKjXAZIpSodBStvn+dyW9qyutlbBc2Ft3xPX2az3OcaL05VqqTKZn65Xxqtj43H7HK1zD36bzrAdi8JX2qvPa/uDfr8tk/AXm8Oz5UInsg66kTUvsspZdOlDyBPrsozo+Zqf/fj+trbcWEepB95DfKHXzsHj8wEio/bMxJCfDmslYa3oAkvk0p4NWDFPuTSs5YSV5pmXbzXbJmzvL2y9/I+gTdHPJ10vF/q/2dbG/CGNTZb74lFrgdr5Oz63E/WMn+dFr3vy+giWw3GF/e2F2EMT/lnPaVxXiBqPtJhB9DPkRp6yyKOdH9TaOXjnzGpvbpuhfIKlxSFpz2nwOaYk5zTQ3vEdJ1HvIdGep9bWfbjfe150jMhna/9+2+zfoPz/S/1eO9ej9V/u99q5HskLO9cT1uZRMdSwQq/NM4Q32sRwAqwVEbxXK/TDEbxRLizLvMNsV4uFRTcXIhbGc4IDwDesHZE+iS61dswRPepO68dRcfIQ5Wnr6Fo/FvvF/qLF2ngGWcbo/wFxyvDV2UQFAA==","debug_symbols":"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lLKSMk0pKynTlLJGZJ1RVlKmKWUlZZpSVlKmKWUlZZpSVlKmGWWNpExTykrKNKWspExTykrKNKWsEVlnlJWUaUpZSZmmlJWUaUpZSZmmlJWUaUZZEynTlLKSMk0pKynTlLKSMk0pa0TWGWUlZZpSVlKmKWUlZZpSVlKmKWUlZZpR1kzKNKWspExTykrKpERWH9OGsJ7JGtsma1qW9l1WUqYpZY3IOqOspExTykrKNKWspExTykrKNKWspEwzylpImaaUlZRpSllJmaaUlZRpSlkjss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLJWUqYpZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrKNKOsjZRpSllJmaaUlZRpSllJmaaUNSLrjLKSMk0pKynTlLKSMk0pKynTlLKSMk0o6+1/Q9YZZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrKNKOsjpRpSllJmaaUlZRpSllJmaaUNSLrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oqydlmlJWUqYpZSVlmlJWUqYpZY3IOqOspExTykrKNKWspExTykrKNKWspEwzyhpImaaUlZRpSllJmaaUlZRpSlkjss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLJGUqYpZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrKNKOsiZRpSllJmaaUlZRpSllJmaaUNSLrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oayZlmlJWUqYpZSVlmlJWUqYpZY3IOqOspExTykrKNKWspExTykrKNKWspEwzylpImaaUlZRpSllJmaaUlZRpSlkjss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLJWUqYpZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrK9HNZ8+I2WcvzxHdlvX2k26A8y/qiCOqyFkFx7exov7T1aO/Lb0f/krWRMk0pKynTlLKSMk0pKynTlLJGZJ1RVlKmKWUlZZpSVlKmKWUlZZpSVlKmCWXNCynTlLKSMk0pKynTlLKSMg0pawxhPTrWs1uEOfqvg3N+lEDIe6tsj5uPy9M09g/Objs6+7ScHO2Ky1tVlb/uTx5/ett45+aearfu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","names":["get_position"],"brillig_names":["get_position"]},{"name":"_borrow","hash":"12003578371243816436","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"1602191554767750373":{"error_kind":"string","string":"Function _borrow can only be called internally"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14687457983715723088":{"error_kind":"string","string":"Asset is not borrowable"},"15333773746166717806":{"error_kind":"string","string":"Insufficient collateral"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_borrow"],"brillig_names":["_borrow"]},{"name":"public_dispatch","hash":"15504464052971452156","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"951653053333916160":{"error_kind":"string","string":"Deposit cap exceeded"},"1602191554767750373":{"error_kind":"string","string":"Function _borrow can only be called internally"},"1840251649407153602":{"error_kind":"string","string":"Insufficient borrowed amount"},"2830029349304997821":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"4270187767586857285":{"error_kind":"string","string":"Function _compute_total_collateral_value can only be called internally"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5235018679007078561":{"error_kind":"string","string":"Invalid asset or market id"},"6787403583199288031":{"error_kind":"string","string":"Insufficient balance"},"6828137438660822608":{"error_kind":"string","string":"Function emit_position_update can only be called internally"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8945853978429536226":{"error_kind":"string","string":"Function _compute_collateral_debt_value can only be called internally"},"10435052277855889085":{"error_kind":"string","string":"Function _withdraw can only be called internally"},"12348881442450494403":{"error_kind":"string","string":"Function _compute_utilization_rate can only be called internally"},"13135008234568508716":{"error_kind":"string","string":"Function _repay can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14434150440419769526":{"error_kind":"string","string":"collateral >= debt"},"14687457983715723088":{"error_kind":"string","string":"Asset is not borrowable"},"15333773746166717806":{"error_kind":"string","string":"Insufficient collateral"},"16022896159229267359":{"error_kind":"string","string":"Function _deposit can only be called internally"},"16523063005220065570":{"error_kind":"string","string":"Function _liquidate can only be called internally"},"17134621154673181869":{"error_kind":"string","string":"Function _compute_borrow_rate can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["public_dispatch"],"brillig_names":["public_dispatch"]},{"name":"liquidate_public","hash":"3135072406066435789","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"market_id","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debt_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"user","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"debt_to_cover","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"1VzbbttIDP0XP/theBkOp7+yWBRO4hQGDCdwkgUWQf99R17LcmM1aqcmrXkJrID04ZHm6NASpffFw/ru7dvXze7x6WXx5a/3xfbpfvW6edqVrffvy8XdfrPdbr59Pf/3InR/kA7xL8+rXbf58rravy6+ACHH5WK9e+g+k4byHY+b7bpshfL5Mj4g9uGB8RSd00gw55COwZxBTsESR4KVWY/BysLnwX8vF8jXqT7nPhwg+1Ufr1N91NO+14l9DzH11YMQfV59jsTH4FzyPlYv164e8IfqO4zkgKFjGBhT6DHKZ4ynrEjGqyKP1yOZhnoof16PUI8gcTjKWToACtYAYA2A1gBkDcDWANEaQKwBkjWAWgNYK5mtlczWSmZrJbO1ktlayWytZL6GklGg76FQznqF0g4eMJIDhjpgZHuMGBwwwAEDHTDIAYMdMKIDhoPOo4POo4POo4POxdq9xdq9xdq9xdq9xdq9xdq9xboPF+s+XKz7cLHuw5O1kpO1kpO1kpO1kpODSycHl04OLp0cXDo5uHRycGl16MbVoRtXh25cHbpxddC5OuhcHXSuDjpXa/dWa/fO1u6drd07W7t3tnbvbN2HZ+s+PFv34dm6D8/WSs7WSi63/8wRwBzBwaghkAcIe4BEDxDxAEkeIOoB4tCXAwQPEPAA8VA8eCgePBQPHooHazsHSOYIao5g7uho7uho7uiI5ghkjsDmCNEcwVzTaK5pNNe0+fwZXGUADTT0w4mgoBcY5qo2H0ID8yk0MB9DA/M5NDAfRAPzSTT4lVE0DTKhCGHpFSEyDMXyESPbY/zKQNofY8A1MIrtnwahi7mdjfeOjU1TYDhGU4g/jPceSsL5lUTzK4nnV1KcX0kyv5LS/ErS+ZWUb1FS7qMJ08RjB+XaZQr9dwekjw8eQAzNM4DmGWDzDKh5BrcwKpK+PyQ6e4rrJwwS0YlBipcMbuFrTP1eJeY0xaDAnxgohQsGt7BBBhgY6BSDDKeH0EKOesEgNc9Am2eQW2cgoXkG0DwDbJ4BNc+Am2cQm2fQvCdL854szXuyNO/JqXlPTs17cpqXHxxKmtcJ/lDSvM7Yh5JucQqO2N8rpDj507TcKRleF8JIFwy0eQa5dQYammcAzTO4zo8KUh5QAp4zOKCwC0p0QREPlPE57nL77ZTFcTj2KP/fVh0fzp7IwvGB68ksqMrCqiyqyhpddTAMDZaLAsNVVz4mxZokqUnKFUnjY6af323H8bHRqaRUU57WJNXsiPGZwqkkqEnCmiSqSapZsFizYLFmwWLNikCtWHuYK5Io1CRBTVKNCKlGhMQ1SbEmSWqS0u8mfS9b/6z2m9Xddn18r+Xj2+7+7DWXr/8+rz+88fJ5/3S/fnjbr7t3Xw6vvez2DXJYYo6lmI40ZllSDJ0VdosBVJeQqdvsDjNkLptSaih1/Ac=","names":["liquidate_public"],"brillig_names":["liquidate_public"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Lending::_compute_utilization_rate_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_compute_utilization_rate_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"precision","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"deposit_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]}},{"name":"borrow_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]}}]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":128}}]},{"kind":"struct","path":"Lending::_deposit_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_deposit_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::emit_position_update_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::emit_position_update_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"user","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::repay_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::repay_private_parameters","fields":[{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"nonce","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"on_behalf_of","type":{"kind":"field"}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fromPublicBalance","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"Lending::deposit_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::deposit_private_parameters","fields":[{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"nonce","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"on_behalf_of","type":{"kind":"field"}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fromPublicBalance","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"Lending::_borrow_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_borrow_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::_liquidate_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_liquidate_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debt_token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"user","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debt_to_liquidate_amount","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"Lending::_compute_collateral_debt_value_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_compute_collateral_debt_value_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":128}}]},{"kind":"struct","path":"Lending::liquidate_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::liquidate_public_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debt_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"user","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"debt_to_cover","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"Lending::borrow_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::borrow_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::_withdraw_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_withdraw_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::repay_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::repay_public_parameters","fields":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"nonce","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::_compute_total_collateral_value_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_compute_total_collateral_value_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":128}}]},{"kind":"struct","path":"Lending::update_accumulators_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::update_accumulators_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::compute_total_deposited_assets_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::compute_total_deposited_assets_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"deposit_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]}}]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":128}}]},{"kind":"struct","path":"Lending::add_asset_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::add_asset_parameters","fields":[{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"oracle","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"loan_to_value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"is_borrowable","type":{"kind":"boolean"}},{"name":"optimal_utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"under_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"over_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"deposit_cap","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"Lending::_compute_borrow_rate_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_compute_borrow_rate_parameters","fields":[{"name":"asset","type":{"kind":"struct","path":"asset::Asset","fields":[{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"loan_to_value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"oracle","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_borrowable","type":{"kind":"boolean"}},{"name":"optimal_utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"under_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"over_optimal_slope","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"deposit_cap","type":{"kind":"integer","sign":"unsigned","width":128}}]}},{"name":"utilization_rate","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"precision","type":{"kind":"integer","sign":"unsigned","width":128}}]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":128}}]},{"kind":"struct","path":"Lending::borrow_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::borrow_private_parameters","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::constructor_parameters","fields":[]}}]},{"kind":"struct","path":"Lending::withdraw_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::withdraw_private_parameters","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::withdraw_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::withdraw_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::_repay_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_repay_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::deposit_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::deposit_public_parameters","fields":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"nonce","type":{"kind":"field"}},{"name":"on_behalf_of","type":{"kind":"field"}},{"name":"market_id","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}],"events":[{"kind":"struct","path":"Lending::PositionUpdate","fields":[{"name":"user","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"market_id","type":{"kind":"field"}},{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"scaled_deposited","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"scaled_borrowed","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"deposit_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]}},{"name":"borrow_accumulator","type":{"kind":"struct","path":"accumulator::Accumulator","fields":[{"name":"value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}}]}}]}]},"globals":{"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"UintNote"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"UintNote"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]}],"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"PriceFeed"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000a"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Lending"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"market_assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"market_assets_list","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"market_assets_list_len","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"scaled_deposited_assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"scaled_borrowed_assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"scaled_total_deposited_assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"scaled_total_borrowed_assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"deposit_accumulators","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"borrow_accumulators","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}}]}}]}]}},"file_map":{"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"25":{"source":"//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n","path":"std/meta/expr.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"46":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n","path":"std/slice.nr"},"52":{"source":"use dep::aztec::hash::pedersen_hash;\nuse std::ops::{Add, Sub};\n\n// Utility used to easily get a \"id\" for a private user that sits in the same\n// \"space\" as the public users.\n// It help us to have a single mapping for collateral that have both public and private users.\npub fn compute_identifier(secret: Field, on_behalf_of: Field, self: Field) -> Field {\n    // EITHER secret OR on_behalf_of MUST be set. But not both\n    assert(!((secret == 0) as bool & (on_behalf_of == 0) as bool));\n    if (secret != 0) {\n        pedersen_hash([self, secret], 0)\n    } else {\n        on_behalf_of\n    }\n}\n\npub fn covered_by_collateral(\n    collateral_price: u128,\n    borrow_price: u128,\n    loan_to_value: u128,\n    collateral: u128,\n    increase: u128,\n    decrease: u128,\n) -> u128 {\n    let price_precision = 1000000000 as u128;\n    let ltv_precision = 10000 as u128;\n\n    let collateral = (collateral + increase) - decrease;\n\n    let collateral_value = (collateral * collateral_price) / price_precision;\n    let debt_covered = (collateral_value * loan_to_value * price_precision) / (borrow_price * ltv_precision);\n\n    debt_covered\n}\n\npub struct DebtReturn {\n    debt_value: u128,\n    static_debt: u128,\n}\n\nfn div_up(a: u128, b: u128) -> u128 {\n    let div = a / b;\n    if div * b < a {\n        div + (1 as u128)\n    } else {\n        div\n    }\n}\n\npub fn debt_updates(\n    interest_accumulator: u128,\n    static_debt: u128,\n    increase: u128,\n    decrease: u128,\n) -> DebtReturn {\n    assert(interest_accumulator > (0 as u128));\n    let accumulator_precision = 1000000000 as u128;\n\n    let current_debt_value = (static_debt * interest_accumulator) / accumulator_precision;\n    let new_debt_value = current_debt_value.add(increase).sub(decrease);\n\n    // static_debt_increase = amount / accumulator\n    // rounding up new debt.\n    let static_debt_increase = div_up(increase * accumulator_precision, interest_accumulator);\n    // rounding down repayment.\n    let static_debt_decrease = (decrease * accumulator_precision) / interest_accumulator;\n\n    // We need to allow repaying of the entire debt as well etc. This is very prone to failing\n    // if you try to repay exact due to time diff between sim and execution.\n    let new_static_debt = static_debt.add(static_debt_increase).sub(static_debt_decrease);\n\n    DebtReturn { debt_value: new_debt_value, static_debt: new_static_debt }\n}\n\npub fn debt_value(static_debt: u128, interest_accumulator: u128) -> u128 {\n    let accumulator_precision = 1000000000 as u128;\n    div_up(static_debt * interest_accumulator, accumulator_precision)\n}\n","path":"/home/jean/work/noir/comet/contracts/src/helpers.nr"},"53":{"source":"mod asset;\nmod position;\nmod helpers;\nmod accumulator;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Lending {\n    use crate::asset::Asset;\n    use crate::helpers::{compute_identifier};\n    use crate::position::Position;\n    use crate::accumulator::Accumulator;\n\n    use dep::aztec::prelude::{AztecAddress, Map, PublicMutable};\n    use dep::price_feed::PriceFeed;\n    use dep::token::Token;\n    use dep::aztec::macros::{\n        functions::{initializer, internal, private, public, view, utility},\n        storage::storage,\n    };\n    use dep::aztec::protocol_types::traits::{FromField, ToField};\n    use dep::aztec::{\n        event::event_interface::EventInterface,\n        macros::events::event,\n        messages::logs::{\n            event::encode_and_encrypt_event_unconstrained,\n            note::{encode_and_encrypt_note, encode_and_encrypt_note_unconstrained},\n        },\n        unencrypted_logs::unencrypted_event_emission::encode_event,\n        protocol_types::traits::Serialize,\n    };\n\n    #[derive(Serialize)]\n    #[event]\n    struct PositionUpdate {\n        user: AztecAddress,\n        market_id: Field,\n        asset_address: AztecAddress,\n        scaled_deposited: u128,\n        scaled_borrowed: u128,\n        deposit_accumulator: Accumulator,\n        borrow_accumulator: Accumulator,\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        market_assets: Map<Field, Map<AztecAddress, PublicMutable<Asset, Context>, Context>, Context>,\n        market_assets_list: Map<Field, Map<u64, PublicMutable<AztecAddress, Context>, Context>, Context>,\n        market_assets_list_len: Map<Field, PublicMutable<u64, Context>, Context>,\n        scaled_deposited_assets: Map<Field, Map<AztecAddress, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, Context>,\n        scaled_borrowed_assets: Map<Field, Map<AztecAddress, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, Context>, // static debt\n        scaled_total_deposited_assets: Map<Field, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>,\n        scaled_total_borrowed_assets: Map<Field, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, // static debt\n        deposit_accumulators: Map<Field, Map<AztecAddress, PublicMutable<Accumulator, Context>, Context>, Context>,\n        borrow_accumulators: Map<Field, Map<AztecAddress, PublicMutable<Accumulator, Context>, Context>, Context>,\n    }\n\n    #[public]\n    #[internal]\n    fn emit_position_update(market_id: Field, asset_address: AztecAddress, user: AztecAddress) {\n        let scaled_deposited = storage.scaled_deposited_assets.at(market_id).at(asset_address).at(user).read();\n        let scaled_borrowed = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(user).read();\n        let deposit_accumulator = storage.deposit_accumulators.at(market_id).at(asset_address).read();\n        let borrow_accumulator = storage.borrow_accumulators.at(market_id).at(asset_address).read();\n        let event = PositionUpdate { user, market_id, asset_address, scaled_deposited, scaled_borrowed, deposit_accumulator, borrow_accumulator };\n        event.emit(encode_event(&mut context));\n    }\n\n    #[private]\n    #[initializer]\n    fn constructor() {}\n\n    #[private]\n    fn repay_private(\n        from: AztecAddress,\n        amount: u128,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        asset_address: AztecAddress,\n        fromPublicBalance: bool,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        if(!fromPublicBalance) {\n            let _ = Token::at(asset_address).transfer_to_public(from, context.this_address(), amount, nonce).call(&mut context);\n        }\n        else {\n            let _ = Token::at(asset_address).transfer_in_public(from, context.this_address(), amount, nonce).enqueue(&mut context);\n        }\n        let _ = Lending::at(context.this_address())\n            ._repay(AztecAddress::from_field(on_behalf_of), amount, market_id, asset_address)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn repay_public(amount: u128, nonce: Field, owner: AztecAddress, market_id: Field, asset_address: AztecAddress) {\n        let _ = Token::at(asset_address).transfer_in_public(context.msg_sender(), context.this_address(), amount, nonce).call(&mut context);\n        let _ = Lending::at(context.this_address())._repay(owner, amount, market_id, asset_address).call(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _repay(owner: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == asset_address, \"Invalid asset or market id\");\n\n        Lending::at(context.this_address()).update_accumulators(market_id, asset_address).call(&mut context);\n\n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / borrow_accumulator.value;\n\n        assert(scaled_user_borrowed_amount >= scaled_amount, \"Insufficient balance\");\n        scaled_user_borrowed_amount_loc.write(scaled_user_borrowed_amount - scaled_amount);\n\n        let scaled_total_borrowed_asset_loc = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address);\n        let scaled_total_borrowed_asset: u128 = scaled_total_borrowed_asset_loc.read();\n        scaled_total_borrowed_asset_loc.write(scaled_total_borrowed_asset - scaled_amount);\n\n        Lending::at(context.this_address()).emit_position_update(market_id, asset_address, owner).call(&mut context);\n    }\n\n     #[private]\n    fn borrow_private(secret: Field, to: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let on_behalf_of = compute_identifier(secret, context.msg_sender().to_field(), context.msg_sender().to_field());\n        let _ = Lending::at(context.this_address())\n            ._borrow(AztecAddress::from_field(on_behalf_of), amount, market_id, asset_address)\n            .enqueue(&mut context);\n        // let _ = Token::at(asset_address)\n        // .transfer_in_public(context.this_address(), to, amount, 0)\n        // .enqueue(&mut context);\n        let _ = Token::at(asset_address)\n        .transfer_to_private(to, amount)\n        .call(&mut context);\n    }\n\n    #[public]\n    fn borrow_public(to: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let _ = Lending::at(context.this_address())._borrow(context.msg_sender(), amount, market_id, asset_address).call(\n            &mut context,\n        );\n        let _ = Token::at(asset_address)\n        .transfer_in_public(context.this_address(), to, amount, 0)\n        .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _borrow(owner: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n\n        assert(asset.is_borrowable, \"Asset is not borrowable\");\n\n        let total_collateral_value: u128 = Lending::at(context.this_address())._compute_total_collateral_value(market_id, owner).call(&mut context);\n        let collateral_debt_value = Lending::at(context.this_address())._compute_collateral_debt_value(market_id, owner).call(&mut context);\n\n        let borrow_price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n        let min_collateral_for_borrow = (amount * borrow_price * 10000 as u128) / (asset.loan_to_value * 1000000000 as u128);\n\n        assert(collateral_debt_value + min_collateral_for_borrow <= total_collateral_value, \"Insufficient collateral\");\n        \n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / borrow_accumulator.value;\n        scaled_user_borrowed_amount_loc.write(scaled_user_borrowed_amount + scaled_amount);\n\n        let scaled_total_borrowed_asset_loc = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address);\n        let scaled_total_borrowed_asset: u128 = scaled_total_borrowed_asset_loc.read();\n        scaled_total_borrowed_asset_loc.write(scaled_total_borrowed_asset + scaled_amount);\n\n        Lending::at(context.this_address()).emit_position_update(market_id, asset_address, owner).call(&mut context);\n    }\n\n    #[private]\n    fn withdraw_private(secret: Field, to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let on_behalf_of = compute_identifier(secret, context.msg_sender().to_field(), context.msg_sender().to_field());\n        Lending::at(context.this_address())\n            ._withdraw(AztecAddress::from_field(on_behalf_of), to, amount, market_id, collateral_asset)\n            .enqueue(&mut context);\n        // let _ = Token::at(collateral_asset)\n        // .transfer_in_public(context.this_address(), to, amount, 0)\n        // .enqueue(&mut context);\n        let _ = Token::at(collateral_asset)\n        .transfer_to_private(to, amount)\n        .call(&mut context);\n    }\n\n    #[public]\n    fn withdraw_public(to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let _ = Lending::at(context.this_address())\n            ._withdraw(context.msg_sender(), to, amount, market_id, collateral_asset)\n            .call(&mut context);\n        let _ = Token::at(collateral_asset)\n        .transfer_in_public(context.this_address(), to, amount, 0)\n        .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _withdraw(owner: AztecAddress, to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(collateral_asset);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == collateral_asset, \"Invalid asset or market id\");\n        \n        Lending::at(context.this_address()).update_accumulators(market_id, collateral_asset).call(&mut context);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(collateral_asset);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        let scaled_user_deposited_amount_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_asset).at(owner);\n        let scaled_user_deposited_amount: u128 = scaled_user_deposited_amount_loc.read();\n        let user_deposited_amount = (scaled_user_deposited_amount * deposit_accumulator.value) / 1000000000 as u128 ;\n        assert(user_deposited_amount >= amount, \"Insufficient balance\");\n\n        let total_collateral_value: u128 = Lending::at(context.this_address())._compute_total_collateral_value(market_id, owner).call(&mut context);\n\n        let collateral_debt_value = Lending::at(context.this_address())._compute_collateral_debt_value(market_id, owner).call(&mut context);\n\n        let collateral_price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n        let withdraw_amount_value = (amount * collateral_price) / 1000000000 as u128;\n\n        let total_collateral_value_after_withdraw = total_collateral_value - withdraw_amount_value;\n\n        assert(collateral_debt_value <= total_collateral_value_after_withdraw, \"Insufficient collateral\");\n\n        let scaled_withdraw_amount = (amount * 1000000000 as u128) / deposit_accumulator.value;\n        scaled_user_deposited_amount_loc.write(scaled_user_deposited_amount - scaled_withdraw_amount);\n\n        let scaled_total_deposited_asset_loc = storage.scaled_total_deposited_assets.at(market_id).at(collateral_asset);\n        let scaled_total_deposited_asset: u128 = scaled_total_deposited_asset_loc.read();\n        scaled_total_deposited_asset_loc.write(scaled_total_deposited_asset - scaled_withdraw_amount);\n\n        Lending::at(context.this_address()).emit_position_update(market_id, collateral_asset, owner).call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_total_collateral_value(market_id: Field, owner: AztecAddress) -> u128 {\n        let mut total_collateral_value: u128 = 0 as u128;\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id);\n\n        for i in 0..market_assets_list_len {\n            let market_asset_loc = market_assets_list_loc.at(i);\n            let market_asset: AztecAddress = market_asset_loc.read();\n            Lending::at(context.this_address()).update_accumulators(market_id, market_asset).call(&mut context);\n            let collateral_asset_loc = storage.market_assets.at(market_id).at(market_asset);\n            let collateral_asset: Asset = collateral_asset_loc.read();\n            let collateral_price = PriceFeed::at(collateral_asset.oracle).get_price(0).view(&mut context).price;\n            let scaled_collateral_amount_loc = storage.scaled_deposited_assets.at(market_id).at(market_asset).at(owner);\n            let scaled_collateral_amount: u128 = scaled_collateral_amount_loc.read();\n            let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(market_asset);\n            let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n            let collateral_amount = (scaled_collateral_amount * deposit_accumulator.value) / 1000000000 as u128;\n            total_collateral_value += (collateral_amount * collateral_price);\n        }\n        total_collateral_value / 1000000000 as u128\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_collateral_debt_value(market_id: Field, owner: AztecAddress) -> u128 {\n        let mut min_collateral_value: u128 = 0 as u128;\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id);\n\n        for i in 0..market_assets_list_len {\n            let market_asset_loc = market_assets_list_loc.at(i);\n            let market_asset: AztecAddress = market_asset_loc.read();\n            Lending::at(context.this_address()).update_accumulators(market_id, market_asset).call(&mut context);\n            let debt_asset_loc = storage.market_assets.at(market_id).at(market_asset);\n            let debt_asset: Asset = debt_asset_loc.read();\n            if(debt_asset.is_borrowable) {\n                let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(market_asset).at(owner);\n                let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n                let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(market_asset);\n                let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n                let user_borrowed_amount = (scaled_user_borrowed_amount * borrow_accumulator.value) / 1000000000 as u128;\n                \n                let borrow_price= PriceFeed::at(debt_asset.oracle).get_price(0).view(&mut context).price;\n\n                min_collateral_value += (user_borrowed_amount * borrow_price * 10000 as u128) / debt_asset.loan_to_value;\n            }\n        }\n        min_collateral_value / 1000000000 as u128\n    }\n\n    #[private]\n    fn deposit_private(\n        from: AztecAddress,\n        amount: u128,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        collateral_asset: AztecAddress,\n        fromPublicBalance: bool,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        if(!fromPublicBalance) {\n            let _ = Token::at(collateral_asset).transfer_to_public(from, context.this_address(), amount, nonce).call(&mut context);\n        }\n        else {\n            let _ = Token::at(collateral_asset).transfer_in_public(from, context.this_address(), amount, nonce).enqueue(&mut context);\n        }\n        Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, market_id,collateral_asset)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn deposit_public(\n        amount: u128,\n        nonce: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        // docs:start:public_to_public_call\n        let _ = Token::at(collateral_asset)\n            .transfer_in_public(context.msg_sender(), context.this_address(), amount, nonce)\n            .call(&mut context);\n        // docs:end:public_to_public_call\n        let _ = Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, market_id, collateral_asset)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _deposit(owner: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(collateral_asset);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == collateral_asset, \"Invalid asset or market id\");\n        \n        Lending::at(context.this_address()).update_accumulators(market_id, collateral_asset).call(&mut context);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(collateral_asset);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        let total_deposited_assets = Lending::at(context.this_address()).compute_total_deposited_assets(market_id, collateral_asset, deposit_accumulator).call(&mut context);\n        assert((total_deposited_assets + amount) < asset.deposit_cap, \"Deposit cap exceeded\");\n\n        let scaled_user_deposited_asset_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_asset).at(owner);\n        let scaled_user_deposited_asset: u128 = scaled_user_deposited_asset_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / deposit_accumulator.value;\n        scaled_user_deposited_asset_loc.write(scaled_user_deposited_asset + scaled_amount);\n\n        let scaled_total_deposited_asset_loc = storage.scaled_total_deposited_assets.at(market_id).at(collateral_asset);\n        let scaled_total_deposited_asset: u128 = scaled_total_deposited_asset_loc.read();\n        scaled_total_deposited_asset_loc.write(scaled_total_deposited_asset + scaled_amount);\n\n        Lending::at(context.this_address()).emit_position_update(market_id, collateral_asset, owner).call(&mut context);\n    }\n\n    #[public]\n    fn compute_total_deposited_assets(market_id: Field, asset_address: AztecAddress, deposit_accumulator: Accumulator) -> u128 {\n        let scaled_total_deposited_asset_static = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let total_deposited_asset = scaled_total_deposited_asset_static * deposit_accumulator.value / 1000000000 as u128;\n        total_deposited_asset\n    }\n\n    #[public]\n    fn add_asset(market_id: Field, asset_address: AztecAddress, oracle: AztecAddress, loan_to_value: u128, is_borrowable: bool, optimal_utilization_rate: u128, under_optimal_slope: u128, over_optimal_slope: u128, deposit_cap: u128) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n\n        assert(loan_to_value <= (10000 as u128));\n\n        asset_loc.write(Asset {\n            asset_address,\n            oracle,\n            loan_to_value,\n            is_borrowable,\n            optimal_utilization_rate,\n            under_optimal_slope,\n            over_optimal_slope,\n            deposit_cap,\n        });\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id).at(market_assets_list_len);\n        market_assets_list_loc.write(asset_address);\n        market_assets_list_len_loc.write(market_assets_list_len + 1);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        assert(deposit_accumulator.last_updated_ts == 0);\n        assert(deposit_accumulator.value == 0 as u128);\n\n        deposit_accumulator_loc.write(Accumulator {\n            // 10**9\n            value: 1000000000 as u128,\n            last_updated_ts: context.timestamp(),\n        });\n\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n\n        assert(borrow_accumulator.last_updated_ts == 0);\n        assert(borrow_accumulator.value == 0 as u128);\n\n        borrow_accumulator_loc.write(Accumulator {\n            // 10**9\n            value: 1000000000 as u128,\n            last_updated_ts: context.timestamp(),\n        });\n    }\n\n\n    // Create a position.\n    #[public]\n    fn update_accumulators(market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let mut deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let mut borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n\n        let timestamp = context.timestamp();\n        let time_delta = timestamp - deposit_accumulator.last_updated_ts;\n\n        // Only update if time has passed.\n        if !(time_delta == 0) {\n            let precision = 1000000000 as u128; // 10**9\n            let utilization_rate = _compute_utilization_rate(market_id, asset_address, precision, deposit_accumulator, borrow_accumulator);\n            let borrow_rate_per_year = _compute_borrow_rate(asset, utilization_rate, precision);\n            // TODO: let supply_rate_per_year = borrow_rate_per_year * utilization_rate * (1 - reserve_factor);\n            let supply_rate_per_year = (borrow_rate_per_year * utilization_rate) / precision;\n\n            let new_borrow_accumulator = ((borrow_accumulator.value * borrow_rate_per_year * time_delta as u128) / 31536000 as u128) / precision;\n            let new_deposit_accumulator = ((deposit_accumulator.value * supply_rate_per_year * time_delta as u128) / 31536000 as u128) / precision;\n\n            borrow_accumulator.value += new_borrow_accumulator;\n            borrow_accumulator.last_updated_ts = timestamp;\n            borrow_accumulator_loc.write(borrow_accumulator);\n            deposit_accumulator.value += new_deposit_accumulator;\n            deposit_accumulator.last_updated_ts = timestamp;\n            deposit_accumulator_loc.write(deposit_accumulator);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_utilization_rate(market_id: Field, asset_address: AztecAddress, precision: u128, deposit_accumulator: Accumulator, borrow_accumulator: Accumulator) -> u128 {\n        \n        let scaled_total_deposited_asset = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let scaled_total_borrowed_asset = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address).read();\n\n        let total_deposited_assets = (scaled_total_deposited_asset * deposit_accumulator.value) / precision;\n        let total_borrowed_assets = (scaled_total_borrowed_asset * borrow_accumulator.value) / precision;\n        let mut utilization_rate = 0 as u128;\n        if (total_borrowed_assets != 0) {\n            utilization_rate = (total_borrowed_assets * precision) / total_deposited_assets;\n        } else {\n            utilization_rate = 0;\n        }\n\n        utilization_rate\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_borrow_rate(asset: Asset, utilization_rate: u128, precision: u128) -> u128 {\n        let mut rate = 0 as u128;\n        if utilization_rate < asset.optimal_utilization_rate {\n            // rate = base + utilization * slope1 / optimal No base for now\n            rate = (utilization_rate * asset.under_optimal_slope) / asset.optimal_utilization_rate;\n        } else {\n            // rate = base +slope1 + (utilization - optimal) * slope2 / (1 - optimal) No base for now\n            rate = asset.under_optimal_slope + (utilization_rate - asset.optimal_utilization_rate) * asset.over_optimal_slope / (precision - asset.optimal_utilization_rate);\n        }\n        rate\n    }\n\n    #[public]\n    fn liquidate_public(market_id: Field, collateral_asset: AztecAddress, debt_asset: AztecAddress, user: AztecAddress, debt_to_cover: u128) {\n        let _ = Lending::at(context.this_address())._liquidate(market_id, collateral_asset, debt_asset, user, debt_to_cover).call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _liquidate(market_id: Field, collateral_token: AztecAddress, debt_token: AztecAddress, user: AztecAddress, debt_to_liquidate_amount: u128) {\n        Lending::at(context.this_address()).update_accumulators(market_id, collateral_token).call(&mut context);\n        Lending::at(context.this_address()).update_accumulators(market_id, debt_token).call(&mut context);\n\n        let scaled_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(debt_token).at(user);\n        let scaled_borrowed_amount: u128 = scaled_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(debt_token);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let borrowed_amount = (scaled_borrowed_amount * borrow_accumulator.value) / 1000000000 as u128;\n\n        assert(borrowed_amount >= debt_to_liquidate_amount, \"Insufficient borrowed amount\");\n\n        let total_collateral_value: u128 = Lending::at(context.this_address())._compute_total_collateral_value(market_id, user).call(&mut context);\n        let collateral_debt_value = Lending::at(context.this_address())._compute_collateral_debt_value(market_id, user).call(&mut context);\n\n        assert(collateral_debt_value > total_collateral_value, \"collateral >= debt\");\n\n        let debt_asset_loc = storage.market_assets.at(market_id).at(debt_token);\n        let debt_asset: Asset = debt_asset_loc.read();\n        let debt_asset_price = PriceFeed::at(debt_asset.oracle).get_price(0).view(&mut context).price;\n        let debt_to_liquidate_price = (debt_to_liquidate_amount * debt_asset_price) / 1000000000 as u128;\n\n        let collateral_asset_loc = storage.market_assets.at(market_id).at(collateral_token);\n        let collateral_asset: Asset = collateral_asset_loc.read();\n        let collateral_asset_price = PriceFeed::at(collateral_asset.oracle).get_price(0).view(&mut context).price;\n        let collateral_amount_to_liquidate = (debt_to_liquidate_price * 1000000000 as u128) / collateral_asset_price;\n\n        let collateral_deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(collateral_token);\n        let collateral_deposit_accumulator: Accumulator = collateral_deposit_accumulator_loc.read();\n        let scaled_collateral_deposit_amount_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_token).at(user);\n        let scaled_collateral_deposit_amount: u128 = scaled_collateral_deposit_amount_loc.read();\n        let collateral_deposit_amount = (scaled_collateral_deposit_amount * collateral_deposit_accumulator.value) / 1000000000 as u128;\n\n        assert(collateral_deposit_amount >= collateral_amount_to_liquidate, \"Insufficient collateral\");\n\n        let scaled_collateral_amount_to_liquidate = (collateral_amount_to_liquidate * 1000000000 as u128) / collateral_deposit_accumulator.value;\n\n        let debt_borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(debt_token);\n        let debt_borrow_accumulator: Accumulator = debt_borrow_accumulator_loc.read();\n        let scaled_debt_amount_to_liquidate = (debt_to_liquidate_amount * 1000000000 as u128) / debt_borrow_accumulator.value;\n\n        let scaled_user_deposited_amount_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_token).at(user);\n        let scaled_user_deposited_amount: u128 = scaled_user_deposited_amount_loc.read();\n        scaled_user_deposited_amount_loc.write(scaled_user_deposited_amount - scaled_collateral_amount_to_liquidate);\n\n        let scaled_total_deposited_asset_loc = storage.scaled_total_deposited_assets.at(market_id).at(collateral_token);\n        let scaled_total_deposited_asset: u128 = scaled_total_deposited_asset_loc.read();\n        scaled_total_deposited_asset_loc.write(scaled_total_deposited_asset - scaled_collateral_amount_to_liquidate);\n\n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(debt_token).at(user);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        scaled_user_borrowed_amount_loc.write(scaled_user_borrowed_amount - scaled_debt_amount_to_liquidate);\n\n        let scaled_total_borrowed_asset_loc = storage.scaled_total_borrowed_assets.at(market_id).at(debt_token);\n        let scaled_total_borrowed_asset: u128 = scaled_total_borrowed_asset_loc.read();\n        scaled_total_borrowed_asset_loc.write(scaled_total_borrowed_asset - scaled_debt_amount_to_liquidate);\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_position(owner: AztecAddress, market_id: Field, asset_address: AztecAddress) -> pub Position {\n        let scaled_user_deposited_asset_loc = storage.scaled_deposited_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_deposited_asset: u128 = scaled_user_deposited_asset_loc.read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let collateral = (scaled_user_deposited_asset * deposit_accumulator.value) / 1000000000 as u128;\n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let debt = (scaled_user_borrowed_amount * borrow_accumulator.value) / 1000000000 as u128;\n        Position { collateral, scaled_debt:scaled_user_borrowed_amount, debt }\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_total_deposited_assets(market_id: Field, asset_address: AztecAddress) -> u128 {\n        let scaled_total_deposited_asset = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let total_deposited_assets = (scaled_total_deposited_asset * deposit_accumulator.value) / 1000000000 as u128;\n        total_deposited_assets\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_total_borrowed_assets(market_id: Field, asset_address: AztecAddress) -> u128 {\n        let scaled_total_borrowed_asset = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address).read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let total_borrowed_assets = (scaled_total_borrowed_asset * borrow_accumulator.value) / 1000000000 as u128;\n        total_borrowed_assets\n    }\n\n\n    #[utility]\n    #[view]\n    unconstrained fn get_accumulators(market_id: Field, asset_address: AztecAddress) -> (Accumulator, Accumulator) {\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        (deposit_accumulator, borrow_accumulator)\n    }\n}\n","path":"/home/jean/work/noir/comet/contracts/src/main.nr"},"56":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr"},"57":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"64":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"65":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"66":{"source":"use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr"},"67":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"71":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"88":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"92":{"source":"use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr"},"93":{"source":"use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr"},"94":{"source":"use super::utils::{compute_event_selector, get_trait_impl_method};\nuse protocol_types::meta::generate_serialize_to_fields;\n\ncomptime fn generate_event_interface(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let (serialization_fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let content_len = serialization_fields.len();\n\n    let event_type_id = compute_event_selector(s);\n\n    let from_field = get_trait_impl_method(\n        quote { crate::protocol_types::abis::event_selector::EventSelector }.as_type(),\n        quote { crate::protocol_types::traits::FromField },\n        quote { from_field },\n    );\n\n    quote {\n        impl aztec::event::event_interface::EventInterface<$content_len> for $name {\n            fn get_event_type_id() -> aztec::protocol_types::abis::event_selector::EventSelector {\n                $from_field($event_type_id)\n            }\n\n            fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n                _emit(self);\n            }\n        }\n    }\n}\n\npub comptime fn event(s: TypeDefinition) -> Quoted {\n    let event_interface = generate_event_interface(s);\n    s.add_attribute(\"abi(events)\");\n    quote {\n        $event_interface\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/events.nr"},"96":{"source":"use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr"},"97":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"100":{"source":"use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr"},"102":{"source":"use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr"},"103":{"source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr"},"104":{"source":"use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr"},"105":{"source":"use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr"},"106":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr"},"107":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr"},"109":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr"},"110":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr"},"111":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr"},"112":{"source":"use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr"},"133":{"source":"use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr"},"136":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"139":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"140":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr"},"141":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"142":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"143":{"source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr"},"144":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"149":{"source":"use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"150":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"151":{"source":"use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"152":{"source":"use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr"},"154":{"source":"use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"156":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr"},"157":{"source":"use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"159":{"source":"use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"168":{"source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"181":{"source":"use crate::{context::PublicContext, event::event_interface::EventInterface};\nuse protocol_types::traits::ToField;\n\nfn emit<Event, let N: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface<N>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; N + 1];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_public_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface<N>,\n{\n    |e: Event| { emit(context, e); }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr"},"182":{"source":"/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr"},"185":{"source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"186":{"source":"use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr"},"188":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr"},"189":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr"},"191":{"source":"use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/field.nr"},"193":{"source":"use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"204":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/jean/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr"},"221":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr"},"223":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"266":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"269":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr"},"271":{"source":"use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr"},"276":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, FromField, Hash, Serialize, ToField},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"283":{"source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"284":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"298":{"source":"use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"300":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"301":{"source":"use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"310":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"321":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"335":{"source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"339":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"340":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"356":{"source":"pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr"},"359":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"369":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/home/jean/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr"},"400":{"source":"use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr"}}}