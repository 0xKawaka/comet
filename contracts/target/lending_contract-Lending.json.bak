{"noir_version":"1.0.0-beta.4+0000000000000000000000000000000000000000","name":"Lending","functions":[{"name":"sync_notes","hash":"14799559270070945457","is_unconstrained":true,"custom_attributes":["aztec::macros::functions::utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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hbz/K+L7vyK9/yvm939Ffv9XlLd/xc7yT9WveP9fd3n/X3d5/193ef9fd3n/X3d5/193ef9fd3n/X3d5+1+3m6b3f8WP/7rvp/lzp4Vzp8m50+K509K50+Zzp+Vzp5VTp7np3GnnqsSdqxJ3rkrcuSpx56rEnasSd65K3LkqceeqxJ+rEn+uSvy5KvHnqsSfqxJ/rkr8uSrx56rEn6sSf65KwrkqCeeqJJyrknCuSsK5KgnnqiScq5JwrkrCuSoJ56pEzlWJnKsSOVclcq5K5FyVyLkqkXNVIueqRM5ViZyrkniuSuK5KonnqiSeq5J4rkriuSqJ56oknquSeK5K4rkqSeeqJJ2rknSuStK5KknnqiSdq5J0rkrSuSpJ56oknauS+VyVzOeqZD5XJfO5KpnPVcl8rkrmc1Uyn6uS+VyVzOeqJJ+rknyuSvK5KsnnqiSfq5J8rkryuSrJ56okn6uSfK5KyrkqKeeqpJyrknKuSsq5KinnqqScq5JyrkrKuSopp6rET9O509y50/y508K50+TcafHcaencafO50/K5085Vybns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NXvZK9lfXjvFte5jdN2qmSe19OK/3Ta1o6zld5ncRvObGs42dZwiqnh7GXbWsNxtobjbQ0n2BqO2BpOtDUcW1flYuuqXGxdlYupq3KYTF2Vw2TqqhwmU1flMJm6Kofp6qvyy1cx3cYTjY0nGRvPbGw82dh4iq3xuB9fm++nuXOn+XOnbV6TbquYyxYet7XCeADNpTmsb/dNc3psrLO108HNKi+byNzuF+Hgs9M0rRtgTeHxY/LiPsYvxscfp0WAFEP4Ov7Y+PhT4+OfGx9/bnz8pe3xbz+A0dD4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","names":["sync_notes"],"brillig_names":["sync_notes"]},{"name":"_withdraw","hash":"15373317336553195228","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"10435052277855889085":{"error_kind":"string","string":"Function _withdraw can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_withdraw"],"brillig_names":["_withdraw"]},{"name":"borrow_private","hash":"1369793046078957607","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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tvgSavElrsWX+BZfEhp8iVYXX8luX8FRp7x6l+72Feb6r7DXfwVd/xXu+q/w139FuP4rOOqUVy+K3b4iXf4VRl3/FfriOuX2Feb6r7DXfwVd/xXu+q/w139FuP4r4vVfkS7/ipO7tyrsp/36O/1xyj+5JatC2ktqFbV/Os3VnebrTgt1p+WFVdHa47SHVde301LVaSc3s4qn6brTTnRLx/rzKnn9dNoJyVuLajtNK/VEkmLdaanqNKerxpa/W1c+7eSHk5J9CNI9nUZ1p7m603zdaXm5b4em4zTzKMCfK+SKLb4kNfiS/CqKn33Jy/t6t6/Q13+Fuf4r7KdfcT+N6k5zdaf5qquPr7tE+rpLpK+7RJ7cLyyeputOM3Wn2brTqO40V3fayfP/br+whvD4ymeuNDNB7U/rBGP++BUnt39Yv0Jf/xXm+q+w138FXf8V7vqv8Nd/Rbj+K+L1X3H9rztd/+tO1/+60/W/7nT9rztd/+tO1/+60/W/7nT9rztd/+tOH/+6f52mlao7TdedZupOs3WnUd1pru40X3daqDst1p1WlyW6Lkt0XZbouizRdVmi67JE12WJrssSXZclui5LdF2WmLosMXVZYuqyxNRlianLElOXJaYuS0xdlpi6LDF1WWLrssTWZYmtyxJblyW2LktsXZbYuiyxdVli67LE1mUJ1WUJ1WUJ1WUJ1WUJ1WUJ1WUJ1WUJ1WUJ1WUJ1WWJq8sSV5clri5LXF2WuLoscXVZ4uqyxNVliavLEleXJb4uS3xdlvi6LPF1WeLrssTXZYmvyxJflyW+Lkt8XZaEuiwJdVkS6rIk1GVJqMuSUJcloS5LQl2WhLosCXVZEuuyJNZlSazLkliXJbEuS2JdlsS6LIl1WRLrsiTWZUmqy5JUlyWpLktSXZakuixJdVmS6rIk1WVJqsuSut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nr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","names":["borrow_private"],"brillig_names":["discover_new_messages","decompose_hint","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","directive_invert"]},{"name":"_repay","hash":"5591769251819908652","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"stable_coin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13135008234568508716":{"error_kind":"string","string":"Function _repay can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_repay"],"brillig_names":["_repay"]},{"name":"repay_public","hash":"1344114842652524081","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"stable_coin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"1ZzdbuM4DIXfJde5EEmJovoqi0HRvykCBG3RnwUWRd997UztZBq3njo+HvEmqBuR54ujIyq25NfV9c3ly+355u7n/dPq7J/X1fb+6uJ5c3/XHL2+rVeXj5vtdnN7fvjvVWhfmHftnx4u7trDp+eLx+fVGQmnsF7d3F23f4ulJsfPzfZmdVbK2/q4eWDuWofI+8Y60Diq0nvjqDn0jTUONLYU0ntjS0yHjX+sVyyzwJfStSYqy8HHWeCT9WfeRs48pZy7xiryNXxJpfukRSV+hE8zwxP/Bt9KKF4iD0mUWKT75In2X1uSoQ5hErsOYQdd/5MOkbnvEJY/nlMbpuk/QQPGX9OMCBSwgAS0AKEFGC0gaIGIFkhoAUULZLQA2smCdnI83cms1NVV1rwXoCA7BYIrMFxB4AoRrpDgCgpXyHAFgysUtEKCezrBPZ3gnk5wT6fTPa3StdW0n8eXtEufsOkVmz5j0xs2fYGm14BNT9j0jE0v2PRY1yrWtYp1rWJdq6e7lix0v9PJyD4KYH2bsb7NWN9mrG8z1rcZ69uM9W3G+jZjfZux1TZjXWtY1xrWtYZ1rWFda1jXGta1NsMVLIrdtXoTK4cC32rc0uSqaKwqmtEhJB3c+xieWRBTf1uFOO7vSKShmzASYndfRULb4rfrbiVUxkOV8XBlPFIZT6yMJ1XGo5Xx5Mp4rDKeysZnCssP0BS6GzXStD4EGqh2kqSvdtmO6Mk1PbumF9f00TV9ck2vrumza3pzTf8XymfJPX0aWWPW1KPc4TefOnxcZUYUnPOTc352zi/O+aNz/uXrbtOi4+dUxviVtOdXyUf8y1deCf35l7HRv2G2fu1yyCRH/MvXXjbb86cx/lwOli9HOuI35/zFNz8H5/zknJ+d84tz/uicPznnV+f8zusvO6+/7Lz+ivP6K87rrzivv1JT/d0B1VRQd0A1Vcgd0PJDbgz9Ha84+pOzqQnU55ZwdINMim/+GJzzk3N+ds4PHuF2GmkBDV1AY47psVi/sLsxLx9p2AIaBa+RwgIaw2OHhv2TAHhsP/x8D0igTzZ7pf6aZ1EZwRlTELhChCukkxVGNqzRJ3u+ZpXIeAnDSxS4xCd7wGaVILwE4yUELxHxEnh3K97dine34t2tp7v7q10DlAM4P4HzMzi/gPNHcP4Ezq/g/Bmc38D5wf41sH8N7F8D+9fA/jWwfw3sXwP718D+NbB/DezfAvZvAfu3gP1b8DPqgp9RF/yMuuBn1AU/oy74GXWB/17mEPAShJdgvITgJSJeIuElFC+BrdQcDJwfW6mZAjg/gfMzOL+A80dw/gTOr+D8YP/S6f6d8SEKTKUqHA514YwPJrrkHmZmrg1IagOKtQGl2oC0NqBcG5DVBlQqA5JQG1BtI7UsP1LPt/uYRVzTR9f0f6FgzLhzlEWd82fn/Oacv/jmj8E5//KldM6d3xyXr7xz7vzmuHztnXPnCsfonD8551fn/Nk5vznnL775U3DOT8752Tm/8/r7B/sW6uZ3Xn+T8/qbnNff5Lz+pprqbwukNRXUHVBNFXIHtPyQO+fOV9bknF+d82fn/OabP88xwn29Q5czLaDBC2gIXmN4uT7F2EfFtL/u1wxfv6J0UlSeFGWTosqUqOHF7aNRNCmKJ0XJpKjh72u/wJL0wNnxV9cYXndMGvtrwqrhQ5AMryQeC4rfx5PhRaxjQTolKE8JsilBZUIQhSlBNCWIJ3y5w8ssx4LilKA0JUinBOUpQTYlaIoJeYoJmaYETekRPKVH8Ld7xFtz9O/F4+bicnvz1MS0b77cXT1v7u/eD5//e+jeuXzcbLeb2/OHx/urm+uXx5vz7f1V+94qtC+tuHBei3ED0/YzMVlHyT/aB8g3h5zTmi20h+15bGdBbNIwNBz/Aw==","names":["repay_public"],"brillig_names":["repay_public"]},{"name":"withdraw_public","hash":"2053383335125897517","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"1ZzdbuM4DIXfxde5EClRpPoqi8UgbdNBgCAt0naBRdF3XzmNf7bxjFE1J2PdFHFB8nx2fEQ5sv3W3G9uX3/+2O4fHp+bm7/emt3j3fpl+7jPW2/vq+b2sN3ttj9/jP/duPYPu2P889N6324+v6wPL80NeRa3ajb7+/azN8k1Hra7TXOT0vvqPNwxd9Eu8BAcJ4JDjHQKDlFdHxzDRLCJk1OwCdM4+O9Vw3QR+JS6aKJ0PXi+CLxYf+Rt5siTqHbB0fvfwydJ3Z6m6MNneH9heOL/wbcSAS8hUxIi6k85Imk4TOLBJ0ScpInc7a9EbzM05kNHYyMj/oJGuacx/Uyj08em3938Kf2eZmZ3DS2QwALeoQUILcBoAY8WCGgBQQtEtADayR7tZP99J3OOOAVz1GGwI+dbheDgCgRXYLiChysEuILAFSJcQeEKBleAe1rgnha4pwXuafm+p/O09BQbZZguJzmWD9jygi0fseUVW96w5RO0fHTY8oQtz9jyWNdGrGsj1rUR69oI774R3n0jvPsqvPsqvPsqvPsqfEat8Bm1wmfUCp9RK9zTCve0wj1tcE8btisbtisbtisbtisbtisbtisbdi5t2Lm0YefSCTuXTljXJqxrE9a1Ceva9H3Xkrlu1YiM7LMA1rcJ69uE9W3C+pacA9cncH0G17/A+hKFblXcvKWxwpeCjzhhWTiyLJz5kURpZqgipv4eBuIwLP/L1B0P3oWutndtxCn4Y1mJnC4NyJYGlBYGRG5pQLQ0IF4akF8aUFgakCwNaGkjNV1/pM5zlw4oR4+BJhqfF983PrUzequaPtVMz65qeqqanqum91XTh6rppWr6P9A+k/b0o8vkSfp81d/f4Zz32oUzfq2c3yrnT3Xze1c5P1XOf/2+myM6fpY0xx8p9vzR6xn/9Tuvd/3x93Ojf2a2/pEhp+TP+K/fe9ls4Jc5fk2jp4YCnfFL5fyxcn6tnN8q50918wdXOT9Vzs+V8/vK+Svvv6Hy/hsq77+h8v4bKu+/ofL+K0vqv0egJTXUI9CSOuQR6PpDbnD9ileYveTMv2lRX9u7swUyiZXza+X8Vjl/qps/XmKE89bfB5mvoXjMf9TgK2j4K2gEvMb0Ixt5Zt5nBRl+9+P4cYfY9GMYs1lWlJVKsqYfgZjNoqIsLsryRVmhKGv6+xqe8cieGZwdPk6N6ZvR81nZ/yYcoztLopIkKcGLJUlFB8JKktLXk9i5kiQqSeKSJP/1Lzcve5QkSUlSLEnSkiQrSUoFSeRKkqgkiUuSSs4IKjkj6MtnxHve+md92K5vd5vT+/UeXvd3o9ftvfz7tPn05r2nw+Pd5v71sGnfwTe8fq8lZrIVq88wLQprWOVrldbq7VeU1Vek1G62B5+U82bIDJnjPw==","names":["withdraw_public"],"brillig_names":["withdraw_public"]},{"name":"get_asset","hash":"17136482851554061393","is_unconstrained":true,"custom_attributes":["utility","view"],"abi":{"parameters":[{"name":"asset_id","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"asset::Asset","fields":[{"name":"interest_accumulator","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"loan_to_value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"oracle","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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5VyVlHNVUs5VSTlXJeVclZRzVVLOVUk9VyX1XJXUc1VSz1VJPVcl9VyV1HNVUs9VST1XJfVUlcRlOXeaO3eaP3daOHeanDstnjstnTstnzutnDvtXJW4c1XizlWJO1cl7lyVuHNV4s5ViTtXJe5clbhzVeLOVYk/VyX+XJX4c1Xiz1WJP1cl/lyV+HNV4s9ViT9XJf5clYRzVRLOVUk4VyXhXJWEc1USzlVJOFcl4VyVhHNVci57jeey13gue43nstd4LnuN57LXeC57jeey13gue43nstd4LnuN57LXeC57jeey13gue43nstd4LnuN57LXeC57jeey13gue43nstd4LnuN57LXeC57jeey13gue43nstd4LnuN57LXeC57jeey13gue43nstd4LnuN57LXeC57jeey13gue43nstd4LnuN57LXeC57jeey13gue43nstd4LnuN57LXeC57jeey13gue43nstd4LnuN57LXeC57jeey13gue43nstd4LnuN57LXeC57Teey13Que03nstd0LntN57LXdC57Teey13Que03nstd0LntN57LXdC57Teey13Que03nstd0LntN57LXdC57Teey13Que03nstd0LntN57LX9CB7rdvDe66K2zntQZXkbf/HWv2n0/ZeadbqhcnpUaarNZxkazjZ1nCKreFUU8N5lMVrDcfZGo63NZxgazi2rsrB1lU52LoqB1tX5WDrqhxsXZXF1lVZbF2V5d1X5bRtvrHcv0RhG08wNh4xNp5obDzJ2HiysfH8+Np8Pa2eOi0u507bvSZ5t72Z03sXD6C5lMP2rr6U021jnb2dDnwJ6yYyYbnfhGfZ3wp02TbAWsLtx+TVfYzfGx9/XFYBUrx7geQ2/tD5+KXz8cfOx586H3/ufPyl8/HXvse//0hKR+O3fv89Gn/n99/U+f03dX7/TZ3ff1Pn99/U+f03dX7/TZ3ff3Pn99/c+f03d37/zZ3ff3Pn99/c+f03d37/zZ3ff3Pn99/c+f23dH7/LZ3ff0vn99/S+f23dH7/LZ3ff0vn99/S+f23dH7/LZ3ff2vn99/a+f23dn7/rZ3ff2vn99/a+f23dn7/rZ3ff2vn99/a9/03L33ff/PS9/03L33ff/PS9/03L33ff/PS9/03L33ff/PS9/03L33ff/PS+f3XdX7/dZ3ff13n91/X+f3XdX7/dZ3ff13n91/X+f3XdX7/dZ3ff33n91/f+f3Xd37/9Z3ff33n91/f+f3Xd37/9Z3ff33n91/f+f03dH7/DZ3ff0Pn99/Q+f03dH7/DZ3ff0Pn99/Q+f03dH7/DZ3ff6Xz+690fv+Vzu+/0vn9Vzq//0rn91/p/P4rnd9/pfP7r3R+/42d33/N7391NP7O77+d73+VO9//Kne+/1XufP+r3Pn+V7nz/a9y5/tf5c73v8qd73+VO9//Kne+/1XufP+r3Pn+V7nz/a9y5/tf5c73v8qd73+VO9//Kne+/1XufP+r3Pn+V7nz/a9y5/tf5c73v8qd73+VO9//Kne+/1XufP+r3Pn+V7nz/a9y5/tf5c73v8qd73+VO9//Kne+/1XufP+r3Pn+V7nz/a9y5/tf5c73v8qd73+VO9//Kne+/1XufP+r3Pn+V7nz/a9y5/tflc73vyqd739VOt//qnS+/1VZ+r7/ls73vyqd739VOt//qnS+/1XpfP+r0vn+V6Xz/a9K5/tflc73vyqd739VOt//qnS+/1XpfP+r0vn+V6Xz/a9K5/tflc73vyqd739VOt//qnS+/1XpfP+r0vn+V6Xz/a9K5/tflc73vyqd739VOt//qnS+/1XpfP+r0vn+V6Xz/a9K5/tflc73vyqd739VOt//qnS+/1XpfP+r0vn+V6Xz/a9K5/tflc73vyqd739VOt//qnS+/1XpfP+r0vn+V6Xz/a9K5/tflc73vyrm97+6fXTKl0HfjX/v4HXUqaTbBxf5mKv1e3XLuVq/r7ecq/UeoOVcrfcLLedqvbdoOFfr+4DFGsttrv75XP1Sq1/Hffl32Q73NX/M13jf0ny+xvuc5vM13hc1n69MNl/jvVTz+Rrvp5rP13hPlaOsM8hpSc/nG8J6bJC7Qfs9jimuQ/71cvPbwWHvaH/jGJalfDr6itF4u9YLRuOdYCcYrW921wtG471rLxiNt8S9YDTeafeCUcDYAqNxX9ALRuN2oxeMuJgmGHExTTDiYlpgtL5laC8YcTFNMOJimmDExTTBKGBsgREX0wQjLqYJRlxME4y4mCYYcTEtMFrfeLkXjLiYJhhxMU0w4mKaYBQwtsCIi2mCERfTBCMupglGXEwTjLiYBhir9e3re8GIi2mCERfTBCMupglGAWMLjLiYJhhxMU0w4mKaYMTFNMGIi2mB0fpLQHrBiItpghEX0wQjLqYJRgFjC4y4mCYYcTFNMOJimmDExTTBiItpgdH6q5R6wYiLaYIRF9MEIy6mCUYBYwuMuJgmGHExTTDiYppgxMU0wYiLaYHR+gvpesGIi2mCERfTBCMupglGAWMLjLiYJhhxMU0w4mKaYMTFNMGIi2mB0fprPXvBiItpghEX0wQjLqYJRgFjC4y4mCYYcTFNMOJimmDExTTBiItpgdH6y5F7wYiLaYIRF9MEIy6mCUYBYwuMuJgmGHExTTDiYppgxMU0wYiLaYHR+qvVe8GIi2mCERfTBCMupglGAWMLjLiYJhhxMU0w4mKaYMTFNMGIi2mBMeNimmDExTTBiItpghEX0wSjgLEFRlxME4y4mCYYcTFNMOJimmDExbTAWHAxTTDiYppgxMU0wYiLaYJRwNgCIy6mCUZcTBOMuJgmGHExTTDiYlpgrLiYJhhxMU0w4mKaYMTFNMEoYGyBERfTBCMupglGXEwTjLiYJhhxMX8cY1oWXEwTjLiYJhhxMU0w4mKaYBQwtsCIi2mCERfTBCMupglGXEwTjLiYFhgdLqYJRlxME4y4mCYYcTFNMAoYW2DExTTBiItpghEX0wQjLqYJRlxMC4weF9MEIy6mCUZcTBOMuJgmGMU2xl/7na4Yi6sHGHNZDw7lbtih7g5b/DoQJ/mmUMl7H+3Ksn60q7eDfdr76LAEtx0d820gS905uri0DqT45TbHC6mdoyUv4eNoyb9KZP3sGD8kNe6okPTnkhp3d0j6c0mNO00k/bmkxl0vkv5cUuMOHEl/LGkwngYg6c8lNZ5MIOnPJTWekiDpzyU1ntgg6c8lFSQdTVLSo+EkJT0aTlLSo+EkJT0aTlLSo+9JKq6uHy3FH0gaF7etgC5yk9SlK3Uh4NGgTgajQZ2YRIM6SYYGdYG6AnXyAA3qWHYN6rhqDeoYXw3qeFMF6hFvqkHdlDe9DsmUcbsOyZSruQ5J7A3JVD98HZKpZvE6JFOd1HVIptqM65BM3YN/DymZukFdh2Tv6p3sXb2Tvat3snf1Tvau3sne1dvWO+6vQ7J39bb17vXfQ7L1HvPrkOxdvW29X/s6JHtXb1vvfb4Oyd7V29b7iK9Dsnf1tvWe3OuQ7F29bb2/9Toke1dvW+8VvQ7J3tXb1vsur0Oyd/W29R7G65DsXb1tvR/wOiR7V29b7627Dsne1dvW+9SuQ7J39bb1nq/rkOxdvW29f+o6JHtXb1vvRboOydzV29l6X891SOau3s7We2SuQzJ39XaLuau3s/WukOuQzF29na13WFyHZO7q7Wy9W+H3kGy9p+A6JHtXb1v751+HZO/qbWtf9+uQ7F29be03fh2Svau3rX2wr0Oyd/W2tT/zdUj2rt629g2+Dsne1dvWfrbXIdm7etvaT/Q6JHtXb1v7OV6HZO/qbWs/veuQ7F29be1ndh2Svau3rf2krkOyd/W2tZ/PdUj2rt629lO5Dsne1dvWZhnXIdm7etvaZuE6JHtXb1s/0L8Oyd7V29ZPu69Dsnf1tvWj4OuQ7F29bf2c9Doke1dve7+1dPZ+a+ns/dbS2futpbP3W0tn77eWzt5vLZ2931o6e7+1dPZ+a+ns/dbS2futpbP3W0tn77eWzt5vLZ2931o6e7+1dPZ+a+ns/dbS2futpWv0y68l34bk8t2Qfn/Jz3+ldD3NnzstnDtNzp0Wz52Wzp2Wz51Wzp1WT532819aXE87VyX1XJXUc1VSz1VJPVcl9VyV1HNVUs9VST1VJX5Zzp3mzp3mz50Wzp0m506L505L507L504r5047VyXuXJW4c1XizlWJO1cl7lyVuHNV4s5ViTtXJe5clbhzVeLPVYk/VyX+XJX4c1Xiz1WJP1cl/lyV+HNV4s9ViT9XJeFclYRzVRLOVUk4VyXhXJWEc1USzlVJOFcl4VyVhHNVIueqRM5ViZyrEjlXJXKuSuRclci5KpFzVSLnqkTOVcn+yp6k7bRPb5y5neb2T3O30/zyt+d2uyzycXAJ96/A8TvH1rJmBbV+PvY6HG9rOMHWcMTWcKKt4SRbw8m2hlNsDaeaGk5abA3H1lU52boqJ1tX5WTrqpzefVVO67FuWfzOeJKx8WRj4ynGxlNtjScvxsbzY8vy8wUq32jjyoMvSe/4kjbL1eJuXxLr3Zf8bEHyOqRib0jV3JAabS75gyHJZcFn/Zv2Xyup0daSDQfkrQ3o7Y8ZHV0s37+r5OGIorkRJXMjyuZGVMyNqFob0fv3kzwckTM3Im9uROau2dXcNbuau2ZXc9fsau6aXc1ds6u1a3ZYrF2zw2Ltmh0Wa9fssFi7ZofF2jU7LNau2WGxds0Oi7VrdlisXbPDYu6arbB3ZFyW9bOj1KPPrnH76Frc3QTCxwSc8QmUGtajl/B5AjvZrkvrLwqKX+rB0VK2uFLKXW4cYvyA44HzGE4AzmM4ApzHcCJwHsNJwHkMJwPnMZwCnMdwKnAewvHWu1hVOHTIT+BM0yFfpztNz3udrsw13bH60stgt+lGf3B0rrIenWsNB0eHvA5bgtyOXfameBuG9yHcH3yFPla/2wn0sfroTqCP1Z93An2svr8P6GEsP9EJ9LF8SifQx/I/nUAfy4V1Al2A/n7oOFIF6DhSBeg4UgXoOFIF6DjS90MXHKkCdBypAnQcqQJ0HKkCdAH6+6HjSBWg40gVoONIFaDjSBWg40jfDz3iSBWg40gVoONIFaDTp78CerxBT+krdLqXF0DPsk0xR/kKne7l/dAT3YsCdLoXBeh0LwrQydMVoAvQ3w+dPl0BOnm6AnTy9PdDz++/pj95qe/Xo1PcfmCc4l2MUd3H+E29BvzE+E29M/zE+E29YPzE+E29jfzE+E29uvzn4y+m3nN+YvymXop+Yvy+8/GHzsff+f23dH7/LZ3ff0vn99/S+f23dH7/rZ3ff2vn99/a+f23dn7/ff/7CxqPv/P7b+38/ls7v//Wzu+/te/7ryzG77+xxvUlYilXfz/+nY9eavVbRFpr2Q73NX/M1/j9uvl8jd/fm8/XeD/wo/lKrus4pIS92cpUszXeazSerfHOpPFsjfcxjWdrvOtpPFvjPVLb2bqOOqqSv3aErqMOaXf8HXU8u+PvqIPZHb90Pv6Ouozd8XfUN+yOv6NOYHf8Hd3bd8ff0d16b/ze+P03R1k9bE5Let5thLAeG+Ru0H6PS9repBbzcndw2Dva35x0WJby6egrRuOXERsYwyWFWD/5E4/do/M24rwdKeGDt/HL3nC8jV+mh+Nt/LYyGu/AbfC9vI3b5uF4G7f5w/E2HksMx1vg/VbexmOf4XjjL9/LG3/5Xt74y/fyxl++lbfgL9/LG3/5Xt74y/fyxl++l7fA+6288Zfv5W29H/QlbaO/e9n3Lm93IbeOI6e7jULC3kfHZd0nJMry6djfZKL1zk2PjPUeS4+M9W5Ij4z1vkWPjEDmARnrvYAeGeupsB4Z6/mtHhnrSasemYl74CQrmVoOjhUfV4zii3wyHb85Kmw8aoVj2Q6+f9Z2/1gf/Lb7/CWv3I5+sEGhS7cNCu8GvX+0lO13zFL8rdZD/Kj1NO89tR+N5r2796PRvH1GPxrN2/H0o9G8vVc3GuV5k9B+NJo3k+1Ho3nT4X40mjen7kcjQSPzGpEzvFejK3WSAw3qZAEa1HH3L6Bu5HU4/ulbccX66zTQ/nXaW38VCdq/UHtSjnm1Jz2ZV3tSmXm1F7SfVntSpHm1J8uaV3sStXm1J9ebV3tyvWm1t/6KQ7R/ofbkevNqT643r/bkevNqL2g/rfbkevNqT643r/bkevNqT643r/bkerNqH62/Oh3tX6g9ud682pPrzas9ud682gvaT6s9ud682uPvB9Y+3rRP6Yv2jj5/XO2zrMf6HOWr9vT582pPnz+v9oL202pPnz+v9qzfz6s96/fzao+/n1d71u+n1d6zfj+v9vPmetWvc6wxHhwbl7y9RsUt95XiPzjOm5G15Thv3tSWo8CxCceJc5CyvgzKLXfvwX1wc7xt5nlZO8xHN8emWxFHP3Fg0Y9IEycL/Yg0cQTQj0gTe/VuRAoTm+p+RJr4qZZ+RJr48ZN+RJr4OZF+RBJEsi8SiUMHIpE4vFmkK3YyBBXspAIq2PH5r8Dex49thPxgYvHJJSYWn7xjYvHJUSYWXxB/XvHJfSYWnzxpYvFJtSYWn2xtYvFJ+OYVP5LwTSw+Cd/E4pPwTSw+Cd/E4gvizys+Cd/E4pPwTSw+Cd/E4pPwTSw+Cd+84icSvonFJ+GbWHwSvonFJ+GbWHxB/HnFJ+GbWHwSvonFx+ePLP7zlyNluv2BxT/YQTfT7U8sviD+vOLT7U8sPt3+xOKznj+x+KznTyw+Pn9e8Qvr+ROLz3r+xOLLSOInL5v4+VDPuqxH+xrDwdGyLGutyCL3hfXxQpUy1A30RyTDsrhtIOWQ+89eN9Z2f9M61J1uWJWGuiUNq9JQq0PDqjTUMs6wKgkqdaDSUAsjw6o01ArGsCoNtdQwrEpDrQkMqxLZg32V0kL28G6VrtxJE3S4kw/ocMfxv4R7Fw/sp0VQf2L1SShmVp/kY2b1SVRmVp+kZmb1SYAmVt+RLM2sPvnWzOqTss2sPlnfzOoL6k+sPlnfzOqT9c2sPlnfzOqT9c2sPlnfxOp7sr6Z1Sfrm1l9sr6Z1Sfrm1l9Qf2J1Sfrm1l9sr6Z1Sfrm1l9sr6Z1Sfrm1j9QNY3s/r4/aHVf/rulRTo+UdW//m+nCnQ88+sPj3/zOrT80+svtDzz6w+6/szq8/6/szq4/dnVl9Qf2L1Wd+fWf2Jsz63lHUgLuaDoyXXdSBSZLk72n+QnDg3a0xy4gyqMcmJ85y2JOPE2YjLG0nvj0j+8F1lbfc5jhNnGB2pNHHW0JFKE2cCHakkqNSBShN77I5UmtkL96PSzD67H5Vm9vD9qDRzPtCNSonsoQeVyB7erdKVO2mCDnfyAR3uAvdXcO/jlzmJJGFm9UkoZlaf5GNm9UlUZlafpGZi9TMJ0MzqkyzNrD751szqk7LNrL6g/sTqk/XNrD5Z38zqk/XNrD5Z38zqk/VNrH4h65tZfbK+mdUn65tZfbK+mdUX1J9YfbK+mdUn65tZfbK+mdUn65tZfbK+idWvZH0zq0/WN7P6gvojq//8HUuVnn9k9Q923a30/DOrT88/r/p5oeefWX16/pnVZ31/ZvVZ359ZfUH9idVnfX9m9Vnfn1l9434/1rhKlIs7UD/ksulZ7oYd6u6wQ1h3zXSXw7ejS945+AJ6RV7ueEi9YnTGjXMvGI070F4wGrdyvWA07ol6wShgbIHReJduBWOM6wxj2sNovN3tBaPxNWIzGLdWPea6g9H4YmsvGHEx38NY11tMWsJXjB4X0wQjLuanGJ3bwYiLaYIRF/MtjJe7yIqxLDsYBYwtMOJivoexrINOVXYw4mKaYMTFfAvjZZlgHYYrOxhxMU0w4mJ+itGnrxgDLqYJRlxME4y4mO9hrNty+bJzpw64mCYYBYzfwVi2P+qyd6cOuJgmGHEx38MYwopR/A5GXEwTjLiYn2KMOwlPwMW0wCi4mG9hrG49tu6134KLaYIRF/M9jGEFUmVnLUZwMU0wChi/hXF7hqemvT9qXEwTjLiYn2LMO9GE4GKaYMTFfAvjZXTrI2VuSXsNOD6mDcg4sZMRvw7Eyd3P0XZBBldWkMHVu22Z0t5HhyXLNsdyC9fCr5/I7QzbrW4z5Du7+evoq0gT+6R+RJrYhfUj0sQerx+RBJHsizSxP+1HpIndbz8iTeyt+xFpYufej0gTpwLdiJRIHDoQicShA5FIHDoQicShA5EEkeyLROLQgUgkDh2IROLQgUgkDh2IROJgX6RM4tCBSCQOHYhE4tCBSCQOHYgkiGRfJBKHDkQicehAJBKHDkQicehAJBKHl4i0/agxuJgPRCq3l80Uf/fWm/0XwkheVkklu9veBiHGq6SFfGI4SUkzhpOU7GM4SUlKhpNUkHQ0SfGO3Um6bXR4+Wf6Kmml4+1N0rKsvzqX4pcdSel4TUt6FYketgOR6Eo7EEkQSV0kI29xvg3D+xDuD76WCquIlMo3S4W1TErlm6WCK6ZUvlkqrOtSKt8sFVaXKZVvlUpZyPAolW+WCtkgpfLNUiGhpFS+WSrkpJTKN0tFKBVK5XulQlpLqXyzVEhrKZVvlgppLaXyzVIhraVUvlkqpLWUyvdKxZHWUirfLBXSWkrlm6VCWkupfLNUSGsplW+WilAqlMr3SoW0llL5ZqmQ1lIq3ywV0lpK5ZulQlpLqXyzVEhrKZXvlYonraVUvlkqpLWUyjdLRSgVSuWjVOKtVFL6Wio4IErlQ5gs67E+R/laKjggSuWbpYIDolS+VyoBB0SpfLNUcECUyjdLhedVKJVvlgrPq1Aq3ywVoVQole+VCs+rUCrfLBWeV6FUvlkqpLXfKxXv102sQ7h7FdN+qbTdILsEctIORCKhtC+SkA12IBKpXAcikYd1IBJJVAciCSLZF4n0pQORyD06EInEoQORSBzeLNIVOxmCBvZIKqCCHZ//Cux9/KIgkh9MLD65xMTiC+LPKz45ysTik89MLD65z8TikydNLD6p1rziJ7K1icUn4ZtYfBK+icUn4ZtYfEH8ecUn4ZtYfBK+icUn4ZtYfBK+icUn4ZtX/EzCN7H4JHwTi0/CN7H4JHwTiy+IP6/4JHwTi0/CN7H4JHwTi0/CN6/4BZ8/svjPX+lSBPHHFf9gh8hCtz+x+HT7E4tPtz+x+HT7E4vPev684lfW8ycWH58/sfis508sPuv5E4sviP8t8SVs4ktxB+IHt22zGZzc8dsD4rKssF1OdwfvjSOJfBybYrg/9Komkd1IapLB9aXmJky6uz1sahKqdabmeuPMy87fJinZN9V09aamP1AzLm4FEhfJ92peqRNPvZ96XciFNKgTyGhQJwnRoE4EoUFdoK5AHY+uQR0vrUEdz6tBHW+qQR1vqkDd4U1fQF1qLRv1WP/2NFWTWNcUW5IsXyXCyJqXCNdrXiIssnmJBImsS4T5Ni8RTt28RNh68xKRAZiXiMDAukSedMGWROGrRKQL5iUiXTAvEemCeYkEiaxLRLpgXaJAR3dConQgkZPtKWwnoTyXKC2yfnRa6vL8YHc5Yj368u+YvipKAziaovSLoylKezmaooKigylK8zqaoqykda1o/aooC2+jKco63WiKsqw3mKJCZjSaomRGgykaZ76PLuWBolc0M9+QnqNJM1/ZD9AMdYksUTY0eTlC424XG+dve6aFpe4cLduucCJ3u9XUvWODu21t4z8de2U+VPDdCfOhoulOmAvM3858qHi3E+ZDBbCdMB8qIu2E+VDmqxPmQ7m6PpjnoexiJ8zxoe9njg/9JnPnN+ZywFzrDZ4143BHUlNQcyA1ceUjqYnfH0lNkoSR1CSjGElN0o+B1CzkKiOpSWIzkppkQSOpSRY0kpqCmgOpSRY0kppkQSOpSRY0kppkQSOpSRY0kJqVLGgkNcmCRlKTLGgkNcmCRlJTUHMgNcmCRlKTLGgkNcmCRlKTLGgkNcmChlEzLwt+sys1403NlL6qSU/bk5pZ1mN9jvJVTXrakdSkpx1JTXrakdSkpx1ITcf65khqsr45kpr4zZHUZH1zJDUFNQdSc6wsqG4fXe/12VUzbJ8sd8PY335791An5QPiUBFMDduLG5d0BLG4tA6k+KUeFK6UbWNyKf7uzy3GD5JDxR+qJIeKHlRJDmX7NUn6oSy3Ksmh7K4qyaGspirJoWyeKkmBZCOSQ9kbVZJ4nFYk8Th7JK9scC2P2eBDHrIJEzuL27N7xUd/cHVSe4QwTOxYOlFoYifUiUITO6xOFBIUMq7QxI6wE4UmdpqdKDSxg+1EoYl9dCcKTezm+1BIyBSsK0SmYF0hMgXrCpEpWFdIUMi4QmQK1hUiU7CuEJmCdYXIFKwrRKZgXKFIpmBdITIF6wqRKVhXiEzBukKCQsYVIlOwrhCZgnWFyBSMK5TwQ+oKPd8sNNHLaSt0sIVHEhQyrhC9nHWF6OWsK0QvZ10h1oesK8T6kHGFMn7IukKsD1lXiPUh6wqZ6uWuQzLVvFyHpHu3Dkd17MpWmq5I2Y4Wfx1/WTofv+t8/L7z8YfOxy+djz92Pv7U+fhz5+MvnY+/8/tv7fz+Wzu//9bO77+18/uv8ovY//j4O7//1s7vv7Xz+2/t/P5b+77/uuXt99/gwpq7BFeXg8/2wW9Pfoi4g/in7SaobnHAeQzHA+cxnACcx3AEOI/hROA8hpOA8xhOBs5jOAU4j+FU4DyE4+iQn8CZpkO+Tneanvc63Wm62Ot0ZajpdvHjGufG6nc7gT5WH90J9LH6806gj9X3dwJ9LD/RB3Q/lk/pBPpY/qcT6GO5sE6gj+UFO4EuQH8/dBypAnQcqQJ0HKkCdBypAnQc6fuhBxypAnQcqQJ0HKkCdBypAnQB+vuh40gVoONIFaDjSBWg40gVoONI3w9dcKQK0HGkCtAF6C+A/nQbaid0Ly+A/nyfLid0LwrQ6V7eDz3SvShAp3tRgE6ergCdPF0BugD9/dDJ0xWgk6crQH+/I73EESt0X/wR9NtvMi/n5SPobX+8HAtwHsOpwHkI5/1vhOsJjgPOYzgeOI/hBOA8hiPAeQwnAucxnAScx3DokJ/AmaZDvk53mp7393TzNF3sdbpj9aV9PIeQx+p3O4E+Vh/dCXQB+vuhj9X3dwJ9LD/RCfSxfEon0MfyP51AH8uF9QG9jOUFO4GOI1WAjiNVgI4jVYAuQH8/dBypAnQcqQJ0HKkCdBypAnQc6fuhVxypAnQcqQJ0HKkCdBypAnQB+vuh40gVoONIFaDjSBWg40jfDt0v9OmvgP50ex+/CNDbQ3/+C1a/0L0oQKd7UYBO96IAne5FATp5+vuhO/J0Bej06QrQydMVoJOnK0CX90Ov68Eh3O2S9Ouzr0PK9oZU7A3p7R2QLGH9bFni0V/Ls6N/T+D9b5tuPQFnewKpRPk4OpXs7j75Onzf9/BD38MX48Ovy3pDStXnL8OPfQ8/9T383PfwS9/DN37nPRh+MH7fPRq+9bvuwfCt33UPhm/9rnsw/L7vuqHvu27o+64b+r7rhr7vuqHvu670fdeVvu+60vddV/q+677/TWJth9/3XVf6vutK33ddMX/XlS2mqvHr8M3fdZ8OP5q/6z4fvvm77vPhm7/rPh+++bvu8+G/+LZ1/RIefvp1dOM12+DXTZUvgUu8P/gKnYef3g99sBd2dAKdh59eAd2FDbr/+iOFwV4w0gl0Hn5SgC5Afz90fo6jAJ2f4yhA5+c4CtBxpArQcaTvhz7Yy3c6gY4jVYAuvPj57dlL5hXnCtB5xbkC9Az091/TC9DfD70C/e3QFV6MAnSFF6MAXeHFKEBXeDEK0BVejAL0giNVgI4jVYCOI30/9Pe/LuIypXWqYXHh4LNjjWUFU9zt9fTV7XGpYX04VJZ0IxNq7Deoef+7JVDohwp5FDKuUEAh4/chQSHjCkUUMq5QQiHjCmUUMq5QQSHjClUUMq1QWMgUrCtEpmBdITIF6wqRKVhXaCg/dNtaN5S8HCjk3FLXUTt/p+dSd44W51fmcse8VkMZXliG8k7TqzmUz5pezaE82fhqPr9vuqH82/RqDuX1pldzKF84vZpDecjp1RTUHEjNoda7p1eTLGgkNcmCRlKTLGgkNcmCBlLTD+U3cymbmnfDfqCmbL/3cJJvaEre+2i/JaQhlHLjmPp9bDr4oewp4v9MfEH8ecUfyvwi/s/u+UN5ZcT/mfhDWWvE/5n4QzlxxP+Z+EMZd8T/kfhhqGc+EP9n4g/1iAji/0x8Er6JxSfhm1h8Qfx5xSfhm1h8fP73xHflboO4dCB+uL3JNri7d9PuL/92shIQSAUole+VipAhUCrfLBUSB0rle72KkE9QKt8sFdIMSuWbpSKUCqXyvVIhKaFUvlkqPDlFqXyzVHjOilL5ZqmQ1lIq3ywV0lpK5XulEklrKZVvlgppLaXyzVIRSkW9VFy6lcpSD8SXXNejL/+8jSTE+CEp+Udvkha37eZ7T+QmKTlFd5L6sEka/I6k5AnDSYrvH05S/PlokiZ89HCS4neHk5SniLqTdMmbpH7ZkZSnff5lNEkFSUeTlPRoOElJj4aTlPRoOElJj4aTlPRoNEmzcV+afVk/OuflQFKX/Lru5PKdSC7scnd5KwDv88HR/sbd+5APuHfyM7hs3MKi/kvVF9SfWH3jxhj1/5j6z5+TysY9NOq/VH3jdhv1X6q+cWeO+i9V37iJR/1Xql+MPy2C+i9V3/iDJaj/UvXJ+mZWn6xvZvUF9SdWn6xvZvUn9vvLsq2tLuXo6Au9TX0R14v6z3P+MrHfR/06sd9H/Tqx359B/ef3/Tqx30f9OrHfR/0qqD+x+hP7fdSvEz/bg/p14md7UL+S9c2sPlnfvOrLQtY3s/pkfTOrLyOpn5ftx5Y51QM9S1nJuGU5FH/An/LIMpTdR/yfiT+U20f8n4k/lNlH/J/d84fy+oj/M/GHsvqI/yPx3VBOH/F/Jv5QRh/xfyb+UM/0IP7PxB/qkR7E/5n4gvjzik/CN7H4JHwTi0/CN6/4fmKfvx1ccjjSfsDf7oif2OZPr/3ELn967Sc2+eNrf3C/F7SfVvuJLf702k/s8KfXfmKDP732Ez/BM732Ez/AM7v2gVxvXu3J9ebVnlxvXu3J9ebV/v3+Pi7r6H2UevTZpW7jX8IgQXrIQH8/9AL090OvQH/7NV0WoL8fugP6+6F7oL8fegD6+6EL0N8PPQL9/dBxpArQcaQK0HGkCtBxpO+HHnev6bKs2YH429BdqHtYQl1fluTE3bCEy9HXr8iv/4ry+q+oL/+KtLz+K9zrv8K//ivC679CfvYV15PimZPSmZP2/6bCdl3IZeekcuKk/de+S16vsnK/d2L9uKrsvy386KR64qT9dxNHt94zog+fTtpb8br9CKyUWym48vEN7uXf4F/+DeHl3yAv/4b48m9IL/+G/PJvKC//hvrqb6gv/5uuL/+bri//m97fsz/KugdulPzlchn3t3uOeT0pybJzkj/zTfuXnLjedmOSnZP2ryLFryfVsHNSPHNSOnNSPnNSOXNSPXHS/g5fRyft/ymUZTtpR6f9HYWOTgpnTpLnJ6Vlb077FZHrdlLZOWm3IpJb6aVQd07KB9+09/fkyok/QldPnOTP/Lnv/6DM+bhOyvm0g2L/t0jHp6Vzp+Vzp5Vzp9VTp+0/snt8mjt3mj93Wjh32oMqKXk7rfqd0+LxaWnntHTutHzutHLutP0qCct6Cbn8c+fCs/9QwPFp7txp/txp4dxpcu60eO60dO60B7qlTe6Qd+4ycZ/krcdzF9g7pz1AUre/N1nizmnx+LSdP9OYzp2Wz51WTp2W3LnT9knK9jCok7uY9nZaPHfaPslLaredlnYuCqk+OO02t7xzE84P5ha3UpayU5M5njstnTttv0qkbu/huBiOndPKudPqqdP2E6Lj09yDv+5Nt0vHs3OaP3daODdIOXdaPHdaOndaPnWd3E8yjk+rp07bzxyOTwunrlz13JWrnrty1XTmtLTfPOXtepfTp7Wn3+fs9zI1rWtQNaev57gT5/gT54QT5+wLtch20V9K/XpWPHVWOnVWPnVWOXVWPXNWXE6d5U6d5U+dFU6ddao24qnaiKdqI56qjXiqNvYXL59fLfb7vrpdl6rsnHPiL3+/4zv4nnTinHzinHLinPpzBvnElTmfuDLnfX22wO7T0w3rOeHEOXLinHgwn71z0gkG+cQ55cQ5J+qgnKiDcqIOyom/03LiDr3fAh+cE0+cc6IOHrxWubiyLeykW8Mc6u7vIG+/bSzhzmDuH31ZD9+eGyj+7rNj/BhSsTekam1I+cFbUVWH5OwNydsbUrA3JLE3pGhvSMnekMxdvfPS4urttwXhIi4fHX3bIvsyoru2f/fB1EuUud4PJTu/M4Ha+QTc0vsEXO8T8L1PIPQ+Ael9ArH3CaTeJ5B7n0Dvd2LX+53Y934n9r3fiX3vd2Lf+53Ym78P1LhN4O6RqdsErF+FjhxZMHUVug7J1HXlOiRTV4rrkN7/t2/kF6G3YXgfvix45CCA2QcTAbMPJgFmH0wGzD6YAph9MBUwu2BkAcw+GAeYfTAeMPtg6HwfgBHA7IOh830Ahs73ARg63wdg6HwfgKHz3QcT6XwfgKHzfQCGzvcBGDrfB2AEMPtg6HwfgKHzfQCGzvcBGDrfB2DofPfBJDrfB2DofB+AkWnBxBuYlL6CmfaulLefLftLm/sVzLR3pSMw096VDsDkae9KR2CmvSsdgZk2jzkCM20ecwRGALMPZto85gjMtHnMEZjdzjcsy7pDV1ikHEzVubS9ReXyb3+Exl/+72ZT4u3oy2SugyotBhVv2/O5dLdD+FsefN/fe6SrKexvhdLXFFz/U/D9TyH0PwXpfwqx/ymk/qeQ+59C/3fnYuzu/HtQ1dj99jooY3fQ66A07ol9RPw1gOYRGgHNIzQRNI/QJNA8QpNB8whNAc0jNBU0+2jKsoDmERoHmkdo6IYfoqEbfohGQPMIDd3wQzR0ww/R0A0/REM3/BAN3fAjNI5u+CEauuGHaOiGH6KhG36IRkDzCA3d8EM0dMMP0dANP0RDN/wQDd3wIzR+5r7m6a+3LkObF83zx3uLn/gOdYRm4jvUEZqJ71BHaCa+Qx2gCRPnNUdoJs5rjtBM3NccoZk4rzlCI6B5hGbili/49bnvi4WKX9FM3PIdoZm45TtCM3HLF7Yfdl4ofXXeMnHLd4Rm4pbvCM3ELd8RmolbviM0AppHaCYOQI/QzNwNH6CZuRs+QDNzN3yAhm74EZp5NxY/cFDzbix+BEYAsw9m2o2sjq4x025kdQRm2i1cj8BMu4XrEZhpt3A9ADPvxuJHYKbdwvUIzLyd7wGYeTvfAzACmH0wdL4PwLy/j/nZpmO5rkdf/nkb/7rpWFHYMv6Hu6Y5WSdQXP06AYWt3X84AR+2CQS/MwHX+wR87xMIvU9Aep9A7H0CyfoEnm8+WXLufQLW78SHEzB/Jz6YQDF/Jz6agPk78dEEzN+JjyZg/k78ZAJ/u/zH//cf/+Mv//hPf/3X/7yc9Ot//b//9s//9Zd//7eP//hf/9//Wf+Xf/qPv/z1r3/53//wf/7j3//5X//l//7Hv/7DX//9n3/9b39aPv7f/4w+uT/Hy2wuaH5V5gVP/XOuS77851+cclr8n3Nyv//33ycsF2Nz+X/x13/x+4wU3OWIEC5ju4zv/wc=","names":["get_asset"],"brillig_names":["get_asset"]},{"name":"_borrow","hash":"2672895720000059944","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"1602191554767750373":{"error_kind":"string","string":"Function _borrow can only be called internally"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_borrow"],"brillig_names":["_borrow"]},{"name":"deposit_private","hash":"14136445116895499311","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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POG53xOe93rC8z5PeB7whOf9nvB8wBOeD3rC8yFPeD7sCc9HPOH5qCc8H/OE5+s84fl6T3i+wROeb/SE55s84flmT3i+xROeb/WE59s84fl2T3i+wxOe7/SE57s84fluT3i+xxOe7/WE5/s84fl+T3h+wBOeH/SE54c84flhT3h+xBOeH/WE58c84flxT3h+whOen/SE56c84flpT3h+xhOen/WE5+c84fl5T3h+wROev+UJzy96wvO3PeH5JU94ftkTnr/jCc+veMLz/3nC83c94fl7nvD8qic8v+YJz697wvMbnvD8pic8f98Tnt/yhOcfeMLzDz3h+W1PeP6RJzy/4wnP73rC84894fk9T3h+3xOef+IJzx94wvNPPeH5Q094/pknPP/cE55/4QnPv/SE54884fljT3j+lSc8/9oTnn/jCc+/9YTn33nC8yee8Px7T3j+gyc8/9ETnv/kCc+fesLznz3h+S+e8PxXT3j+myc8f+YJz3/3hOd/eMLz557w/E9PeP7CE56/9ITnf3nC87894fkrT3j+jyc8/9cTnr/2hOdvPOH5f57wDPr84JnwhGefJzz7PeE54AnPQU94DnnCc5YnPGd7wnPYE54jnvCc4wnPuZ7wHPWE51Ge8BzzhOe4JzznecJzvic8F3jCc6EnPBd5wvNoT3ge4wnPxZ7wPNYTnks84bnUE57LPOF5nCc8j/eE53JPeK7whOcJnvA80ROeJ3nC82RPeJ7iCc9TPeF5mic8T/eE5xme8DzTE54rPeF5lic8z/aE5zme8DzXE55JT3imPOGZ9oRnxhOeWU945jzhmfeEZ8ETnkVPeE54wvMpnvB8qic8n+YJz6d7wvMZnvB8pic8V3nC81me8Hy2JzzP84Tn+Z7wvMATnhd6wvMiT3he7AnPSzzh+RxPeD7XE57P84TnpZ7wvMwTnpd7wvMKT3he6QnP53vC8wWe8HyhJzxf5AnPF3vC8yWe8HypJzxf5gnPl3vC8xWe8HylJzyv8oTnqzzh+WpPeL7GE54lT3hOesKz7AnPiic8q57wrHnC82pPeL7WE57XeMLzWk94XucJz9We8FzjCc/rPeG51hOeN3jC80ZPeN7kCc91nvBc7wnPmz3heYsnPG/1hOdtnvDc4AnPjZ7w3OQJz82e8NziCc/bPeG51ROedU94bvOE53ZPeO7whOdO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","debug_symbols":"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","names":["deposit_private"],"brillig_names":["discover_new_messages","decompose_hint","store_in_execution_cache_oracle_wrapper","call_private_function_internal","notify_enqueued_public_function_call_wrapper","directive_invert"]},{"name":"get_assets","hash":"2150477930133724140","is_unconstrained":true,"custom_attributes":["utility","view"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},"visibility":"public"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"H4sIAAAAAAAA/+29C5Ac13UlmNU/oAtodBHgDwT4ASH+SbG+/fEXskjbIiVa1s+SZUuq7qoiKZEECYCkQBBANtAACIEAAZAUKdmyZdmSZcmWLNmWLMmSY3YmHDMbseMYb0ysYzY8M94Je70eO6z1zI5ntPZqkWTeqlOnbr7M6rqvUSTwIoDOynffuffdd999930yMxe8mnLxvyiNBd0pB39HlPs9KYlIrmevefXvJNFH+aPn/u2IfxcHS6VJpQJW+HPF+cXJoFdRhvJXJoPuhjHGLwq+J/0X18Q4nww7+JoxrT33byNcHwi66dGeRgkngPxJqIOH9q4L/pgH/HOpPCV1DHt1JHljYTdvzBuHvDHQ5/ymbv34aG/Ujw/9R/rZlCC/1C1Kbw6DdurwLVXmZirluZlyudEs1hszs635ymyxslCrzC8ulIqVWnmuMVuvFIvNSnOxWmzMzNcazfp8rdJaqM/PCPZdKnaluXAOqlafmVsoteozreJCdXauUm/Nzjbqjflqc7ZWbJQWZ0qL5VJrbq5eq9UXa/OlUqs5X2vNtbHvDv3oTPB/3At+pSb4PwH4Y4Gtj4rST/rBb48Rb/GD39b/PV7035H/3hg/COx1/1Yvspfa+G/zo5uq4N/nB78i+D8F+DkP+G/3g9+2nZ/2g9+2/Xf40X9L8N8Z4weAXZqrlMuzlfnZ4vxco1iqNhbLc+e8/0K1uFisL5ab89XSfKtarlYWG4sLc9W5eqlVbNUX51tzr4IL9rsU7GJ/qcQ3BPvdXvRSadv9e0If7Vppj1k/079uSmnogv3e/rHTUnusel8y9orNRrB/VsEu1yuLxflWsV6bq88252rnwoziuYuFuWZrplxfOBdwlBulUqlZPfdfudmozi80ZkoLM83Zcm3hHLu2Tt4f+rCXUnse83PG+DP14nxzZmZW8H/eGH9hYWa2fk6fgv8BY/zK4kyzVZlt+7EPGuPXa9VWq1apC/6HjPFrpWKzVp5t22bdGH9+oVibmZtr28+CMf65eLnSmK8vCP6itX4WmsXFRmle5k+NGF94REl4N415x2k+R/yCoHv+FBD/PMlqHU/miB/K04B7PC9thb2yFpQ89DGcN6rcEz4a1s8bYn3AEOuDhlgfMsSqG2ItGGJJv/bb16rtcbTlBb8yJ/j3e8EvNgX/AR/4pU7s9SDgB3byt/E/DPg5D/gf8aP/Nv5DfvTTno89HOP7wH7EHrsdH+30o/d2fPeoH/z2fOYxP/jt+HeXH/y239ntB39e8Pf4wW/Hv4/7wW/Hj0/4wW/Hv0/6wW8I/ke94Jfa+tkL+HZ+udz2m095wa+08ff5wW/7zqe94Ffb+Pv94LfXgw74wW/754N+8Nv+OfSD346rlrzg19rz70Ne8Gfa9nPYD357HXrZD37bPo/4wW/b51E/+G37POYHvx0/POMHvx0/HPeD344fPuYHvz1+nfCD3x7fn/WD3x7fT/rBb/u3U37w2/7tOS/4s+3x/bQf/Pb85Ywf/Lb/POsHv+0/n/eD3/afL/jBb/vPF/3gt/3bx/3gt/3bS37w2/7tZT/4bf/ziRg/WDl2hW+sC149g3RXfAZp/bl/G2Ls+5t7fuyhnYsfue/xhxeau3C1W2oYBN2r4DLz4RShbuygvnnnI3t21Rf3vKnR2NXcvZsRRhTkIAE1D6gP1B985C2NJHn6RHtPc9fuB3c+wmhjGdHkrNU40BvGrMWpGG+C5EPea0gLNrxLDa3lWcvIP0+yGs+/SzniJ/KwfnBPJMpbq8haUPK4DdcqfNYqfApKHsfQg2CdNsQ6aoh1yhDLso7PGmIdN8Q6aYh1zBBrryGWpe4t+9CZIcU6ZIhlaROWure0r2VDLMu+bWkThw2xLH30C4ZYwzo+ytzEb2xVnJtSeEuSPHxuBmMqThyJo9wR/j2bOrhMJ2k98Nu995HF+3buae4OHAWiJIf8+f6wKY8DwnyGOgRBumI/kEGxHMCjbFOEiWVzCpY2xWFjRp1PJMiAGNJWGAgbTiIqWeqB/FdrEqE5CW0SIfqZ9KOfco7wUZ5JRT9sw9x20b918e9xwEJ6fOAP6fFayuO9P4//FoLefiQPPuSUvFHlnug30vn/TnXDtmE79dMO1VJWOxX++cBnv+nYqWYX2mA2GfS2s+WhrSztqvm2dUqeYK2Pf6OdIn0e6oj0eC3l8d7fxX8LQa9Ns52uU+qD99BO/6/4ejKhPjvi38WB0uysNk5xP0A9WR5Cz9oPhH8+8Gl3nX6gtZPmT0R36xVZC0oeL/qsV/isV/gUlDwORAfBOmWIddgQ64gh1pkhxTpuiHXSEOuYIdZeQ6wThliWdj+M+nKNg/1iRcnSVs8aYj1jiGVpq5Z1PGSINax9+yVDrKcMsWQTluNMwY/SZNDb96znbshP6oH3kH+eZLWVpxMraXrVYlrRz5Qf/bTlmVLkmVL0I225QckTrOn4N84ZkH4K6oj0eC3l8Z48AVYgzCjxnGGDUh+8h3MGWQDhuFTworQa7YD8RG68h/zzgc9+U3Tahdb/J4PedjbUTzFLu6K80pbTSp5gyQNWaKdIvwHqiPR4LeXx3k+QnaJNs51OK/XBe2inbyI7xbZhO/XSDqVWZjsV/vnAZ7/p2KlmF1OKHieD3nY21E8xS7uivNKWBSVPsC6Jf6OdIv001BHp8VrK4713k52iTfODZwWlPngP7fSnYtzJhPrsiH8XB0q1qtaWdvizpSmlntzPUNd2dl3J3M+Efz7otQsf/ewSkifJDkR3GxVZC0oe28hGhc9GhU9ByeN5zSBYRwyx9hpiHTbEOmGIdcgQ67gh1rOGWJY2sWyItWSIdcYIS/PPg8h12kiuKJ01xLLs2y8ZYln6Qsv+eNIQy7IdXzbEsrQJS91b9e3AuI6WNnHKEGtY/YSlXBdCzHRxTDt/urfsj0cNsSzr+OKQymUZT1jWkfcHcG6Zi/9OBr19z3Ce3cwRP6kH3kP+eZLVVp7OPFvT6yWKXkV3mxRZC0oez7M3KXw2KXwKSh6PGYNgHTHE2muIZVnH44ZYJw2xzhpiWer+JUOsi+3YH9bLhliWNrFsiHXKEMvSf50xxLLUvaWtWup+WP3XsiGWpX09a4hl2Y6W9mXZhyzt67Qh1iFDLMs6WtqqZX+0rKNlPDGs7TissdyLhljDGudYxpgX44nXRx+y9BOWclnZV3TN66qDyPW8kVxRstS9ZQwgYy2fdxP8KPldQytnPmPLa2hezmClrKFpZ+smg147NNRPKUs7o7zSlpcqeYJ1Wfwbz4Qh/SaoI9LjtZTHe2+JlVIgzCjxmbBLlfrgPdFvdCbszfGPyYT67Ih/FwdLc7weKjyQN+rJ0O4yfaAC+ecDn3bX6QdaO2n+RXR3mSJrIei1HbaHyxQ+lyl8LmINF9bbjbBcPkzyozSplLP2t8hP6oH3kH8+8OoXSi69av5S9HO5H/20zyhfrshzuaIfacsrlDzBujL+jeMR0l8OdUR6vJbyeO9hGo+uAFruA1co9cF7OB7dP9JdN2wbtlM/7ZD9mQ/hnw989puOnWp2ofX/yaC3nQ31U8zSriivtOWVSp5gbY5/o50i/RVQR6THaymP9/aRnaJNs51eqdQH76GdPh7/mA6S+2eW/oy4mt9mHWI57g9e2rvULGbtD8I/H/jsn53+cEVGvYp+rvSin0Yri/2gvNKWm5U8wboq/o39AemvhDoiPV5Lebz3LPUH7DvcHzYr9cF72B+Okt/GtmE79dIOxWIrq50K/3zg00927FSzC238mwx629lQnmaWdkV5pS2vUvIEa0v8G+0U6TdDHZEer6U83vsk2SnaND+rd5VSH7yHdvoCzXe5Pjvi38WBUrOktaUdfr04qejaDr88P6m0lx3+wpzgb/WDPyP4V3vBn2u37zVe8Gtt/VzrB78h+Nf5sZ+2/Nu84Fcqgn+9F/xmW/7tXvCrbfw3eMFfaPffG7zgz7ft/0Y/+mm3701e8Fs1wb/Zj37a8t/iR/62/78N8C3XIgT/Di/4xYro4/agk0aVOgl/iUVuBfpcwl/B4jzhlScsX3GfVjeUn+d9t4M8qIMkrNv7xJpU8ny06W2OeiP/KYesXI8o8TtwVqqTKC0bYoWGWKeNsLTYdhC59hnKtdlILi3+HQRriyHWuBFWlPijh4PItdVIruj66iHFusYQ61pDrOsMsbYZYl1viLXdCCtKHw/t5HqDoVzPGcp1g5Fc0fWNhlhWY0d0fZMh1s2GWLcYYUWJ106HBUv2kP2ud1Xn/a53Vep+17uqDb/rXbWK3/Wu6qzf9a7qosTqMh4KD7St6+C+3byimvlZUOGfJ1lt5enM764jeVg/fH5nmyJrQcnjPrpN4bNN4VNQ8vgs7yBYLxhiHTLEOmGIddwQa9kQa68h1rOGWEcMsc4MKZalrR4zxLLSfXTN4/aw2KplfzxriDWs/fF5QyzLPjSsun/GEMvST1iOtVZ+IkqWurfU17Dal2VsYtmOlrq/EPzES0ZY0TXPYQeR64ChXFuM5LLEitLToZ1cWw3lstJ9lJYMsSxtgtfSB8EaN8KKkpVNRCk0xNpviGVpX5ZyWdnqMPvCDYZyWdqqZTta+tVh1ZelrfLa6jDYapQs/dfLhliW8ddRQyzLNYUjhliWc4VlQyyJ72Ud+xrIy8V//e4BFFe8B3CNH3mcewDXKHrVzsMaytPI0s4or7Tl9UqeYG2Pf+PZfqTfBnVEeryW8njvi3HDFQgzSny2/3qlPnhP9Bud7f/saHfdrgM6tlM/7ZD9G7DCPx947Tcll11cp+hRswspW1DyOKbP2l5a2/PZt0GwThliHTbEOmKIdWZIsY4bYp00xDpmiLXXEOs5QyzLPmTZji8YYh0yxDpriGXZty3ty7IPWfrVC0H3zxpiWfpo8YXac1SG8UdRe87JEL/9zMF2hy6QP5/FkXztr2BxnvDKE5Zx3UquuqH83M4Yh6MOkrC294mlPRvno02vd9Qb+ft9FrBW9vssYG3G77OA1ZbY/A2gzxzp7iYvbTmX+V0qwj9PsvrqUzeRPKwfng/drMhaUPL47N7NCp+bFT4FJY/H7UGwXjDEOmSIdcIQ67gh1rIh1l5DrOcMsU4bYlnqflht9awh1hFDLEv7svQ5pwyxLgTdP2uIZVnHM0OKZdm3jxliWek+uuZzucNiq8MaA1hiXRy3L47bPv3qxXH74rh9cdx+/Y3bUbLU17Da6vOGWJb6svQ5lrp/xhDLsg9ZjtvD6qOHNZ6wrKNl7GvZjpa6vxD8xEtGWNE1n88ZBOt6QyyrdfLoersRVpT47PEgcm0wlOuAkVxRWjLECo2womve/7qoe3cd+dmJQbC2GGJtNcKKkqW+bjSSy9JWo2TZh4bV7oe1jq93X2gpV5Qujh2v/bEjSgeNsKJryzMPVvqKrq82lGu/oVxWY22ULMdHS30N49gRpZcNsSznfEcNsSz3dI4YYlmuTywbYvHzbXg2LBf/1d4XH/HZEf8uDpYaOeIn9cB7yD9PshrLU3Lp9SZFr9r77g3lWcwRPspzi6IfacvblDzBkvdk4vNtSH8L1BHp8VrK47218aJLgTCjxM+3ae9Kx3ui3+j5tpHx7rph27Cd+mmHcubn24R/PvDab0ouu9D6v2YXUlZrLx73s7aXhnXcEOuMIdZhQ6xThlgvGGIdMcQ6PaRyLRti7TXEeskQ6ylDrJcNsSz1ddIQy7I/njXEsrR7S19o2Y5HDbEsfY6lTTxriGWp+0NDKtdzhliWNmEZm1iO25btOKz+y9K+LPvjsPpoSyxL+zpmiCW6l/kKzm9y8V/P34Cr5oif1APvIf88yWorT2eup+n1FkWv/XxfLLq2/GaT1Xe8onTKEOuwIdYRQ6wzQ4p13BDrpCHWMUOsvYZYzxliHTLEsuyPZw2xLO3LUl8nDLEs7cuyD1n6VUubsPSrw9q3LfujZR96wRDLsj9eCPb1rCGWZQwgY+10nIfx9ragm0+/MT+WF7oppVwu/uv3G77zmd/XIfzzik58xPy3Z9Sr6O4ORdaCksdnV+5Q+Nyh8CkoeTw2DYL1giHWIUOsE4ZYxw2xlg2x9hpiPWeIddoQy1L3w2qrZw2xjhhiWdqXpc85ZYh1Iej+WUMsyzqeGVIsy759zBDLSvfRNb+vY1hsdVhjAEusYR23LXVvGQNY+mjLeGJYbfXiuH3+xrSLMXl/WBdj8vNnXxfjwvNnX8MYF0bJUl/DaqvPG2JZ6svS51jq/hlDLMs+ZDl2DKuPHtYxzbKOlrGvZTta6v5C8BMvGWFF13zGaRC5njaU63ojuaLrDYZYlvtDlvq62lCuJSO5ohQaYUXX/Ez/MNhElPjZ5mHQvWXftu6PVn0out5uhBUly/54IdgXv29oEKwthlhbjbCiZKmvG43ksvSFUbL00cNq98Nax9f7WGspV5Quxiav/bEjSgeNsCzjiShZ6Su6tozJ9xvKZTXWRslyfLTU1zCOHVF62RDLck3hqCHWcUOsI4ZYlutfy4ZY/L6hDZCXi//KOV/0dRGfHfHv4kCplPl9Q8I/H/SOVXbydM75Xhn06nWDolfR3WZF1oKSx3PjzQqfzQqfgpLHe76DYJ0yxDpsiHXEEOvMkGIdN8Q6aYh1zBBrryHWc4ZYln3Ish1fMMQ6ZIh11hDLsm9b2pelXJbtaCmXpZ+wtAnLdnzWEMvS34tfldiKY4Id8e/iQKlWk9gEY5lc0M0bYxPDuG4uR/xET3gP+edJVlt5OnGd1m6oH47rrlJkLSh53IZXKXyuUvgUlDzum4NgfcwQy1KuU0ZY0fVkYINlXce9hljPGmKdMcQ6Zohlqa+zhlgfN8R6zhDriCGWpe6PG2ItG2JZ1vElQ6ynDLFknY9jiyjtiP+eGw4rczOV8txMudxoFuuNmdnWfGW2WFmoVeYXF0rFSq0815itV4rFZqW5WC02ZuZrjWZ9vlZpLdTnZ/3GDrX5yaDXxxvGJiXB3+IHvyz4W/3gVwT/aj/4VcG/3g9+TfC3+8GfEfw3+MGf9fvug9Kc4N/hB7/dv97oB78u+Hf6wW8IftEPflPwS37wW4Jf9oJfLgp+xQ9+239W/eC3/WfND37bf874wW/7z1k/+G3/OecHv+0/5/3gt/3nD/jBb/vPH/SD3/afP+QHv+0/f9gP/oLg/4gf/EXB/1E/+G3/v8MPftv/v8kPftv//5gX/Erb/7/ZD37b/9/lB7/t/+/2g9/2/z/uB7/tP3/CD37bf/6kH/y2f3uLH/y2f7vHD37bv93rB7/t397qB7/t397mB7/t3+7zg9/2bz/lBb/a9j9v94Pf9j8/7Qe/7X/e4Qe/HX++0w9+O/58lx/8tv98tx/8tv98jx/8dvz5M37w2/75vX7w2/75fX7w2/75Z/3gt/3z+/3gt/3zz/nBb/vnn/eD3/bPH/CCX2vHnx/0g9/2/x/yg9/2/3U/+G3/v+AHv+3/F/3gt/1/ww9+2/83/eC3/X/LD37b/98fdFIHu9JcOLfVUqvPzC2UWvWZVnGhOjtXqbdmZxv1xny1OVsrNkqLM6XFcqk1N1ev1eqLtflSqdWcr7Xm2rI/oGIPkjr7Ig/60Eup1fYLHwb8nJn8c238j3jBL7b71UNe7KYj/8Ne9N9o+/1HAmPbKRWL0XdBX1jzKtY0yC71WENtMhb/Hge6j4Td9ZZ8pP9u/tW/Eb+XY9ApKiMYUZqk8rZtVprPEb+A6h0Q/3zQqxsf55zGSB7WD59zGldkLVBelHjfe1zhM67w0bBeNsTaa4j1nCHWEUOsk4ZYy4ZYxw2xLOt4zBBrWO3rkCHWaUOss4ZYlvZlqa8ThliW9mXZh04ZYlnahKVflfOQ2nlsu7F5Zk7GWozdJUkext48Rn8Y6O8KO3ScRuk31mntuX+PbOrgMh3Lg3HTg4CfFDNESfQ4AfmWMY7gr/WDXxGbWhN065TrtDZBV5Kv/RUszhNe+aBX7z7iQ61uKD/3F4zfUQdJWGv6xJpU8ny06YSj3sh/yiGrVg8+/6/5Iy3+Fvq1DrmQflrhLWVFh3nIM9Rh2aVD7IvCfz3cbzQXHr//rTtxSaRdHvUgeruS6O4JO3pgG1yTgBXQb34OZhTwMPmdM57fcUDq1O84gLp9kPJW6veixL6BdR6lqK3/m2NtAcugDWVdWxD6y9Z2+H1vTUdm5qfph+0tSn7t6NX+GATpYwuvPeT8yONce9DaPPIP6+Lr3Xt27qrf33xHs971SgBWH/9ls5ffbJIjRPdw2J0/mpA/FmRLLrePMoobEzPGuknZLCblJ0TNblLCf7VMKk2vfZrUuFKlIBjMpB4Ju/OtTApxspjUiCJDFpPytCJZyWpScm+1TCpNr64VUilbUPKSRiPkk2Vmim0ZmbS073oHrymSEemjJLYi9PJGk4mgUyekkbLjRH9VPFJGfw5s6pYfZRJ5Jqm8bZue34hK6tRvRIXtiLIhpkQw3LZJ7XIjtMvSpo7MzG/KUQ/5fb/CT2QvEG2UpI0vgfuGOy2Zvwgq/PMkqy8/cgnJw/rRhqaHdtYbb64/uvvxh5ojpMppuEb4AsEJDdJiKoBISM/lN1C5t4a95TiJKqeD3m5dIJkQf1S5x+6voMgmZi66eSsE6pX4OstLrKZJ/h3x7+JgaTGraQr/1XqJ1TTJk6R70Y+nrrKQC3q7xajCU+SVtrxEyROsjfFvdJFIj/0F6fFayuO9N8X2VAh6u/e9YbcMWtfHe6LfyE5/MMadVurDL97U2m1awS0o5VmH2I8fDLvzxpW6Sd6EI2+NI2+tUi/Jy0O5j1C5dQrmK5v8azt4SbpBu+JwWNNNVtd9N2Fh+UsIa2MK1n2EheU3EtamFKy3ERaW30RYl6Zg7SQsLH8pYV2WgvUoYWH5ywjr8hSsxwgLy19OWFekYO0iLCx/BWFdmYK1m7CwPL8QdnMK1h7CwvL8Ac+rUrAeJywszy9M35KC9QRhYXl+ievWFKwnCQvL8wvTr07Bup+wsLyUnVKwOA64Bu6fjzhA+OdJVl9xwDVBr15RPzwdulaRtaDksd+6VuFzrcJHw9pkiHWpIdZlhliXG2JdYYh1pSHWZkOsqwyxthhisd9KG6/fEb761zVeSzm0XaQbBRptjEaMpHgA52x4/+oM9cF7rJurE/glyYe6kfmmK/6YpnKazIUUPi6ZhU6LmR8Ku/NweY7jW9yU5DgcN2wvoby1Sr04ZsZ25ZgZ9YYx8zjV5xfi+36X44pFtL8kXfG6hPY3CHrHzyhxWyLNyCrwidJ7Q/98tPpsMOSDWHeF3XxWf4mv2MxSD+Tve4lPdLHJoYtLvfCuZl7uvJR0scmTLsTPps3b+GCLNjfTxhJcHr2/ueetO+//sb3vqt+PSw3oVlmcKaK7hH5vTBBrB9FdSr8l/GM5EAsTy8Fugel3pNDj9bhyP0ratJaXYbVmw3uuZdjLHXw2Dchnk8JHuhaGuJam7Pf9dZ2zZtpSAtZJ+E8peurHtSOvfNDbRj7cgFY3VzvjFCPLksuVfWL5/U5Fp02vcNQb+U85ZNXqgWeW0M/9yOSrf6Ow7l/SVofmK/weEKnMZLVHPiDi6XSB84AI6ofDqAlF1gLlRYm/F6WdfZxQ+GhYpwyxnjfEOmmItWyItdcQy7KOlu1oWcfDhliWdXzWEOs5Q6wThlhHDLHOGmIdN8SytAnL/mjZhyxtwlJfxwyxzhhiWer+qCGWpe5PG2JZ6svSFx4yxLLU17D6Qkt9WfqcCyFmsrQJy3HbSvfR9WRggxUlS7u31P0zhliWdm9ZR0s/YRkDWOrrJUOsLO8E0eb1Qq89R6mtS10oz1HWiM7iOcoa3RsN9OcoI+z/Ru/oWf1vkVUyP9T0evkW2Y1wjXnIZ7W/0xUly29YWX5H6YQh1hFDLMtvWFl+k8nSJob1e2uWNmGpr2OGWJb6OmqIZamv5w2xLG112RDrQmjH04ZYlvqyHIcOGWJZ6mtYxyFLfVn6e0v7svQ5lv3R0iYsYyYr3UfXvAYzLHZvqftnDLGG9futln5iWOMvy++RyhqM9igRP8LQ73fQsfzmDFjafFjotUePXGs92qNHfr+l2Vnr0dpDe3xpJWs9orcS0fFaD/q2LQlYAf0u0b2ktR4+t/SV2HmKfj2dR1OPmvN5RTwzyuci+33UFstPO/hsGpDPJoWPX132/xYNfmwC3+vOjzh8BLDwXVycRuk31jfqF8t9vGED2+PBBMxxhXaE8oT2n0925Dgdy+H33OHqtcndYYeOk9YmUt9IF88P2CZ8/hXl1h6XzvIYt/YYfkEpf4mDz00D8rlJ4TOllMsl/BU+fI/5aDK71ttXygexpA/7Xbvv3/5Zz2j/fDYXvxPB73LFbzzgPhAnrW+ILiLM/y1D3/C737R6OuRH3lCH2Lc5aToUXWTV4XTQq0Pu29NKPbR+jxgr6feaDMM2TmyiPGzjSykP2/gyynsI+PAjcQ9DOd7LegTyJihvJ+Tx+3gfhbw85T0GedjWnNLGs/FLO7hMFxBPtJss45n2ChXB9ftIWSXzm/j4kTJP72Ru74Nqjwhr748W3V2myFqgvCjtDzt0nDeq3BtxYB03xDpjiHXYEOuUIdYLhlhHDLFOD6lcy4ZYew2xXjLEesoQ62VDLEt9nTTEsuyPZw2xLO3e0hdatuNRQyzLdrT0X5b6es4Q65AhlqW+LPuQZTxhqa8ThlgX/er586tWuo+ueR90WOzeUvfPGGJZ2r1lHS39xDFDrGGNV/cZYkm8KuVwjo97lp7fY9D+tvVVfvDb70lw7eUif57TS772V7A4j89tX+anbs5z2y47wLXxLK8I3dwn1vl8nwnqmt9nosmq1eNSQ51k+Q6XtrbUb9u6XtnquY+1zxRc6tAT8h/k+ZEy0d0ddvTAbXdlAlZAv8t0L+lMwXTQ26ZrE+QUvnyPbQXLjzv45Afkk8/IpzAgn0JGPpsG5LMpI5+L7dPN53y2j/hhfGeR7NtGey6fzOs88ZX6+K4mPjMh9P8Gvsn+qXxyHUep/ugn5FWEfr8D2f8+Gevyw0p9cgqWtsckder3SzH4jB5/KUYwk74UMwH5SP+FfEeWv96iY+YAE59V5K8ISZ+dCDr1RhqWQei/BDLIV4QYcyyhXmsSMP8F2OJX8jpmoGBq9cpTvViGtSSD0P8e1Otv4V3rSCO/0U7kC2HCa53CK0i4xz5tXUKei29a2egavyLEeWwrrC8sn6RTthWh/47DViYUGbC+3K4sA9PkE2T4nxQZ8LWVizsf3Rt/1SegxB+PG6ff3JTcBBMKTlISNURl/kVex0E6SWx+OBSvUXjkE2TEspF6pHkbzYeae5oJChohsPEEZiOBnvx+c9rPuKGdr0Dfy0kbU6S+kcK/u6WDy3SS8Jnsi3HVyuIqxtLipSg1w04+0v8Z+JHvb9ExRxIw5TMyrjFNO5sk9Nqc0RVzoz3yPF3jjbpkv3tZn7KmrTesJVm1uWhWWe8OV1fW8T5lzSu8cew551wffKK5676de9pv0Q4UMQK6nqR77IZ5vFiTIOp6opum3/xaZXbvG+n3OkU+LYkcmFiW0SA9SRcVXf0tdNGRrd28NBeCXVTMnqdfWBanX2ISTwId6/mjVB+kR55Cvxf4aCHOk1Rvof9/lBCnoMgk8kxSedthd7YuOnwq6E2Stw9481Gxp4H+zWGHjpM2tEqdIl18oI/pGrYjyoaYOGRg2ya1S25dRxb+sCfy+2iQXA/5Pa7wY11KfpSkjZ+G+3ZtXKvniJ/UDe8h/3zQq1sfy/xPkzysH80NOz7s+RRcI/z7CE5okBbT+0AkpOfy3OyblXKcRJXjJPP1cf0id7Iuvp4Oerv+BMmNMowq9zjamlDk1/isHZDP2ox8Xsv1yfIByDGlrnwKO0r8scZHIY8/APmYUi/J2+XA3O3A3OPIe9yR94SSF9Xzl9d3ZOThRevq/FFJbLukfp2EdTdhYfmnCWt/ChZ/VBLL7yesAylY/FFJLH+AsA6mYPFHJbH8QcIKU7D4o5JYPiSspRSsxwgLyy8R1qEULP6oJJY/RFiHU7D4o5JY/jBhLadg7SEsLL9MWEdSsPijklj+CGEdTcHij0pi+aOEdSwFiz8qieWPEdYzKVj3ExaWf4awjqdg8YfesPxxwvpYChZ/GA3Lf4ywTjiwomvZCZ5Wyp8grGdTsLYQFpaXslMKVi7+K+HkSbhvF76VMj/lIvzzJKutPJ1w8mTQq1fUD09dTimyFpQ8HIswD/mcUvhoWE8ZYj1tiLXfEOuAIdZBQ6zQEGvJEOuQIdZhQ6xlQ6wjhlhHDbGOGWI9Y4h13BDrY4ZYPJa54vroWt7A4orrpRz6M17uGqUySI8YSfOG0UCfDzyboT54j3XzbAK/JPlQN/JGmkHnKdH19YS10nlKdL2dsFY6T4mu30BYK52nRNe3E9ZK5ynR9R2EheXZtx9KwXojYWH5fucpHw27sQaZp7yfsFY6T4mu7wy6sVY6T4mui4S10nlKdF0irJXOU6LrMmGtdJ4SXVcIa6XzlOi6SliDzFNqhOWap5xMwZohLCx/krBOpWDNEhaWP0VYz6VgzREWln+OsE6nYM0TFpY/TVhnUrB+gLCw/BnCOpuC9YOEheXPEtbzKVg/RFhY/nnCeiEF64cJC8u/QFgvpmD9CGFh+RcJ6+MpWD9KWFj+44T1UgrWDsLC8i8R1sspWG8iLCz/MmF9IgXrxwgLy3+CsD6ZgvVmwsLynySsX0jBuouwsPwvENYvpmDdTVhY/hcJ61MOrCi9O+zGwvKfIqxfSsH6ccLC8r9EWL8cuOv440E3Fpb/ZcL6dArWTxAWlv80Yf2KAytKrbAbC8v/CmF9JkWunyS5sPxnCOtXU7DeQlhY/lcJ69dSsO4hLCz/a4T12RSsewkLy3+WsD6XgvVWwsLynyOsX0/BehthYflfJ6zPp2DdR1hY/vOE9RsOrCg1w24sLP8bhPWFFLl+iuTC8l8grC+mYL2dsLD8FwnrN1OwfpqwsPxvEtZvpWC9g7Cw/G8R1pdSsN5JWFj+S4T15RSsdxEWlv8yYf12Cta7CQvL/zZhfSUF6z2EheW/QlhfTcH6GcLC8l8lrN9JwXovYWH53yGs303Beh9hYfnfJazfS8H6WcLC8r9HWF9LwXo/YWH5rxHW11Owfo6wsPzXCev3U7B+nrCw/O8T1jdSsD5AWFj+G4T1zRSsDxIWlv8mYX0rBetDhIXlv0VYf5CCVScsLP8HhPXtFKwFwsLyUnZKwcrFf2Wf6ztwP+KzI/5dHChVSzniJ/XAe8g/T7LaytPZ5/pO0KtX1A/vc/2hImtByeM1xz9U+PyhwkfD2m+IdcAQ66AhVmiItWSIdcgQ67Ah1rIh1hFDrKOGWMcMsZ4xxDpuiPUxQ6wThlgnDbFOGWI9Z4h12hDrjCHWWUOs5w2xXjDEetEQ6+OGWC8ZYr1siPUJQ6xPGmL9giHWLxpifcoQ65cMsX7ZEOvThli/Yoj1GUOsXzXE+jVDrM8aYn3OEOvXDbE+b4j1G4ZYXzDE+qIh1m8aYv2WIdaXDLG+bIj124ZYXzHE+qoh1u8YYv2uIdbvGWJ9zRDr64ZYv2+I9Q1DrG8aYn3LEIvXHNPOyS3G165zclIO15340cxRKoP0iJF0Dm800M/XfTtDffAe6+bbCfyS5EPdNOJri3N/TcIa5Nxfi7CwfEhYSylYmwkLyy9RHpbjc6L7HHyi5Donus/B59sD8vm2wkd7TvGhsDtvTKmr9rUYfvbxUch7ivIeU+rFzyliH+HnFNEG+TlFtCl+ThFthJ9TxDbH5xTleVzR0Wfi+5NUN6HZEf8uDpi0ryuyHrHdcgl/g6B3byJKbB9IM7IKfKLEXy1arfo8ZcgHseQ1B1r/5bf79Nt/sfy+BCx5tUGU5Blf7KfjRP+7sS2/8uUletWGdkYdX4F1j6OuUlb6CI9vO+LfxcFSSfAP+sGvuMZHrBP7FNRdP/aFvPKEZa07V91QfrZDHK+zxBEH+sSaVPJ8tOl+R721MUSTVatHUt9EPtobhYT+oEMupHfFT6LDEPIMdVh26VCLwVbyFmTR2xai4y8ra7EoYwX0ewvdGwU8TJpvW5cgp/BN8+NYnuOwfSSX9lf48D3mo8ksfPB9FjJORDHPn9C7GcTu8JU5+BzVVZCP9Ddt6mD+2xhTe84rqa/kgJ+MXVHiVy0Jv6RXLe1MkO/fwbjHb7TcqdT5KofMgolxMsos7/1gGf4DxZGexkg1jhRe0yQvtw/XRWsTtru9ih6SdBsljFMwjkH6v+gzTkH75jgFZZKy2pyf37aq8XGNk+sVPoPGBxofTWaeu0UJ+/nfUT8Xe0Cbx7LyPoRxor8M+vnfO/o5nx/imIZ9H/dz4ZfUz9luhP4fHP1ci5nfGibLLJjYz1Fm7udC/4/Uzz3FNWo/F17aOMb9vN9xTPPjGp+pAflMKXx8j5dTxGe/IR/Ekj6Z1l/zUx1cbFetv/K4jfT/cWMHcyrG1Hyfqz157Niv8OU+EwTZ1ihdzyazj4qSa+xo+6i4ntrY4ZoDRMk1x3WtCSMd0rjWTUcdPNCe8L7ErDim7STaA0S730GbNJ+LruXty37n3HNF6Qth0Jskb0mRWfIOAf07ww4dp1H6jXWKbGXt1g4u07E8qKelBEzWaZT47e/yc0TBPUi46ANYX/eG3XlCW4srE/X/W6d0PLaTKMk6nd955VyJ2xcTty/rh5PWvmF8HbXvbB/ti214iPLQZ/M7/nCMFIxI9z8aMx3WvrSS/jI7YH/R9Ml7EahPwUB9jhPGAtj7m8jehYbHiyhJ/5E+G//sGmO1due+eDeMPYe36vxd/S0IdL+AeuB3jS4FuixanYX2g2SP2Mfs7LHa7t+HSWbkveyJd474BYG+/ir8pxR5RO68kjc2gKy10uxseabaqLUWZuZqtWaO8EVWvsdrh9q7OrQ3p4uuj3rRdaUhXW007OAfAb1GaQzylilvHPJExqgPzW/qlv+IJ/mz6B/5FxT6u8MOXT9tWVD48FxtEKz9K8TaGHT3AW0sxNiGx0KMX8S/Rn75QIJfzuLrYpgev4/1ZD+4j3zdEpQxtKGqFo+yrzvsiXdWXyf8p4Lkts0reYP4ukatWqq25msLjVal2Zht5YLeMWFUuce+TrPbgkLv2VcUNV/H/mwM8g5THvo6kVHzdX7GxUoxi/6Rf0GhZ1+XtS0LCh/2dYNg7V8hlvg6jIOW4mvN13GcelCpD/o6npctkU/y80kHfY2QfSrKGyWcQx8EPbF+GQfvaX45uuY1G6E/DnH70SldPqnDvYp82tklrNeJqWS6gwpdtIQ7Hd+/v7nnnQ/UdzUb72wu7mruGQ108biKXH2eTgVEFwS9Xy7bQ795+WaMcGQI5vsunjnC0poOsXnofQ6mPEfjKc8kySu8dsR/iwMmberIQ62f7bVy5mmF8M8HvSbn41iHtrSJ+uHh0c+2RLkYTT94yyBKD4S9umE5xF60rTvUH/eFLNuU2nbtVKD3K+2v8OF7zEeTWX67XG2Sa/wyuMZP07aAtrXiOrKVZSse7yH9hykPt+hyDnxebvkc+Av5YKcWUkk95KtUY5Bn2Z8jOY7DUhbbLYZrSf1M+1yI0LuOkkVJtjRcR4s020Jb+jJt7Whb8qu19a/xmR6Qz7TCx3ffnSY+SVt130rok0lbdWXIR/p/A1t136H2TPJdr9Qr7OStUp8p99tnND/l6jNpj26IDrUt1veE3XmavbNeo9QIu2UYU2TQxtOCUl7ossQpKJ9dG5UyxynCf7XilJ0Z9Sr62edHP0WXbe5T9MNHA7jt0Hdj39emP9p2H44TPF3807izu44UuPqOtgX/yvE/mhb5joO4b42CjBXAks8j+T72gf6S28PQ9qtS74OOejP/6F8IddCO2zI9z3kYPyR6KY8fftdsi+3xbyAm/cuEoypB4I5JWScTgT5e8ra30P+1EkdqbYzbhn9D4yrqko8aHVD08MpRugzjvbaNz+P9izDe/z3JpfkfLa7iGL7fuErjw1hZjwgK/f+AduEPLqd9Fi3L0XjUrcij6SbpGIb0jSiJn+G+k2SX2DfeRvVvy7ohaNf/AH09NAQeSceBkh5pHA3c9pWjf7x0F/3bqPDXtkWifzvi38UBE/uyMeCxpMjD2zfrNnTLdTjo1mmaTzyk8MUl443E9xDxjdrxl+kYWSg0QW8/09pkJ/FgOT9C+UJ/SSxDZIPT8XXakf4rNui884Fuh0n9BGXFfrg37M4X+stAX59JmBugPJqsWh/Fj7D320fvI1mFfoujj7psSYvp+CiP1kdZ7hzdz2oXQr8d7GIb2QX6e7SLEumajxSm+YeQ6rAj/l0cMHFbYj8NFXm4LW+jekn/HVXqqrXpksIXt4HYPywRX80/4CN9IsdDgJlkx+OKzFHiPif0dzr63E6lzpodaGOs65GOELA0eq6L0NdAVte6n8QDftcwSuq6H/ad8bC73tpngrXYivUUJOhJYpdCkO6T8RiXNl9qhZ18pL8H/MSPkp9wrUl42o6czxE/0Q3eQ/6rtSbRb9vuU+RvhMn0Wh/T1jyivRNewy0AlvDFT1AfpHvaOgWvRyXNbe4j36CtgaHdyVyOeUapEeo8ERd5amud7Cf7WZNL04Fm/1nsU+Pj2lvaa8hHOw7rmjMm2Svfc63doD9m3+RjjSQEObPMd5agDlniW+2RU+14MvfdsQTd8RqJ0J8B31unfhU66hglnJeyTNrcldcBJH6ZSJCZ565C31LiYtYbjkEhYPJ6gNA/CJi8HoBH5bL43cMKPcZqYXyt9QmeN+IckNtcw0b60QScQ4TD9UyKtQVDO7oW/dsR/y4OmARvOcbDmPeIIs840T9JdnyMdOrSWfTvqMIXX5PNsfZR4qvF2iIbzsWx3blNeF+a5eQ5l9Dvh/68j2IpHN9xPD28QeeN84Jlh6yHFVmxz/C8QOiXHPMCbc0TZdVicumT5yMmR781HnbrR/MfrvXErP5DO1p4kPJwzM/yCpAsY8xEAj3brNA/p8ypXI/rRvhnKN5CPnweYC/UwTVOcVth2Yjnixt0XBxLUGf3h931FfqjsGb+csb1sE8m9EHtFRdRupt4C/2PAO9PkQ61PSXX3n1OycsSz+7MyGdfAp8gIx+tPpZxs7ZefynJ3O9eBpZfrTMilxKfAwofz3Fz5jm18M8Hvf3ex5za9VpI1KvQhwr9fgf9kkKvvXoK59TowwPii3PqJbqn9XNeR+x3juU656Xtf6b5uW/26ed2hZ18pN8Ifu7b5OeG7VzZZQPyuUzh49tnXEb12eeoT782heVX69UZlxGfpHNyf5yw/9DvK2j+yyUdzD9ZoX26XnexWq9J8bFGcyHU5/XcR/7KqI/8OfSR/0x9RDuPpumZ11771XNWPq+H9jxgyEdbm0+zm+8l7OlltRuh/1dgN/+UwW403SS9KhP5rpa9ubBcsaV2Tsm1LunaQ0V67fUcYgt+H0/Ofh5Y+OdJVlt5OvMEbQ0nVHS3PuisTdWbu0vlubuai7v2PrqHG0MAC6TkJQIU+oB+c7lIKD7Auk/hESV8nxwaUoHK80SE8bPIlEablq91wjDQ6xkE2Tohlk/qhEnv81qCfKTfOP3q36zv8wrhXj/v80pyIKNKHfIJ5XBRH/Owzvc46iz0mx11PpBS57vD7jonvS8XfzOddnhmbaAvsLs2Ii8PumXv156w/GoN7pcTn6RB94bpThnUQ9KDPw9DPtJ/DQbdm2NM0WXWd/Txe/j61bPGx7ee+V2sBxz16fc949p7vV3t9DDQJB3O0hZlosQPRgv9bNyWnt/NrT7jL7y0593xwc15Ixv+PNjwD5ENawtdq7Wg1k9fyQUr7yurVR8XltYfciQz0r+mA9pSs5jFByH/13xA+x9y3UpeIkChD+g3l3MFtEzLzlAMadCAVpMpibbfgBZXkkKi7XeFGMvjLjh2CFtDKvc8mYi7r0vAk1f2noY6aIFa0qp8LgGfHSW+3EXTHZ+EEvr3QTD72TiY1drqigT5giBbW2H51VrNv4L4+DjtFyWcKGWxjTLJlRTENikA0D4Aoe0s88cN3gsBwAMUAGirxK5dI201nwdA7cSuNkBpgWfSKYc0u2YdjSmYUeKAUOiXKSD084aaWvH87UbXMg/K/OIm7ambvJI3NoCstdlWqTgzM1tpletzzdoMj10iK9/LslN9rULvd0Wvqr50MwS9RmkM8g5S3jjkiYzai+hCT/Jn0T/yLyj0SU8Ta1hRGvGAJS+Pcz3xxSeeooR+ZSfkI/0xx0KQFtTvU+qj+dOnqRyO9ejL2FdFaUf8N62FWykpIL2tUWThJ+SE9hTo5fNbu+uivaROfMeog0eg3MsFybpjHqMK3rvC7rwDGWTTFuwQY2+CnBGGNum+hurS72LKNYo8Pne+kGda/PIpil/Sdr6eDDv5SP/jEL98muIXbeFH+GmLBxg7sE/BJ/G0BWH2A0L/WbD3tA9YYT1ZRsTUTiZGieMXof8CxS+eTrSpC1rCS4sbea7Z77zBdUJzJ+hKTq2jf/yJsFtXQr87npRG7fzb0/1h/mQC5p9NdzB/p0/MtyRg/mvA/JrD7q8Muvn1e6IUy/NbV3geuiP+XRwstT8W+pgf/PaHJR9VdIF1Ev6DnqBFXqv1ZKRWN1c740eguS9pWI/2iTWp5Plo052OeiP/KYesWj04rtD4XKnoROh3OeRCeunDaPtSVnSIH9c21GHZ1d74sW/hv5KPhYreriA6/lgo6v6xBKyAfl9B90YD/WOhkc/8P2M/r41LGxJkFhnSxiUsz/bvx2fONrQneSVpT/KijJxG6TfKHbX3PZs6uEyHGGzH/DFBl89NwtDWPtP6fZRw8V5O/+/es3NX8+27Hnyivqd59xPNR/Yo9rs26K7fCP3mNz2jrCjXFNHx5uyj9Ptx+v2EIg8n1gmmKYUuKaX1j1vgeiX9A8u71hW3Dchnm8LHhXWLguXy39sU+gvFf28nOpnbDeK/t9O9JP/NsuD86e6wQ8Nr3kL/fZoP+YlJ5itTQa9Pk7oI712eeOeIXxDocanwn1LkEbnzSt4g67nluUqpNHduK7hZrBbrjaKrj+E97pO7FfrbFHrR9eOBF12rHxbZDXqN0hjk7aK8ccgTGbX1XD9+Yz6T/pF/QaHn9ZKsbalh3b1CLFnPRd8rfdtvX+8//uKnM11vtAwBC9eeOWlxm9Q3sqflDHGb6y1Ufuflq6dDtFVOmg6lvv3qEG2NdeinL6+eDrGPctJ0KPWNdPh8HzpEW+M1bPRNIvew6ZcPXOE+1F1hh45Tmg4f6UOH2jr4aNCrpzEFi+ch9yvyiJ9+IuiWH9svSryvheWfIKy9KVh3ExaWz/LkHGLdR1iu8wv7U7DeRliuJ2UOpGDtJCzX2xAPpmA9SliuNzOFKViPEVbSm2+jf0spWLsIC8svEdahFKzdhIXlDxHW4RSsPYTlejvOcgrW44SF5ZcTyqF/i9KUck/6ut8Pz5X6/iCrNl/wscat6V2LC0V3RxRZC0oejtuYh3yOKHw0rJ2GWE8bYu02xHrCEGuvIdY+Q6z9hlgHDLEOGmKFhlhLhliHDLEOG2I9Zogl68jaOugu4tPvOiiWz7IOqvnQ9fG/KL2ybv7m+qO7H3+oGVDCuDUX9K6XP57Av6CUD6hsju4VErAEJ7qHMS2vUYifT/qCBZ/pEPoPx4zx7V2TSnnDeceC9lCXJMnD8YHHPoxb7wq787Qv+eUUPtqcROob6eK7Wzq4TCdJ21tAm7gOrjFP+PM9tnUsL3Qan20D8tmm8HFhXadgCb02p9im0GvzEynr+Us47b0FbY6nzUtWsrcgettCdLy3oM31GCug31voXtregsiS9AAw7y0I/YuxbU8qstq1x1zF9dyC33Pqc5n3FoT/lCIPvymcz0PuWKGsrblycbHSahZrlYWFxWLD1cf6fZPEDQq93zN1c+reAq6DRWkM8vZT3jjk4RvHeW/Bj9+YK2bRP/IvKPQ8bmdtS0ss2VtA3yt9229fH969BTyT0M+6OI6X/BIC1OFNcI15Ig/f43a/SZF1SimXS/grfPge89Fk1p5fw/PPnyt0yqBd4flnLPtE2MlH+iqcf/4Nx5kNnqOzraJtRIn7Cb4VNst4KPRfgliZzz9rz1Y8ESbLLDyyPr8l9L9DY7KfcVE//yy8tNiN52L9PhunPYPnt46zTe35AUmav+EztCHk8dmDJcjbTXm49vvesDsP5/Q878E10ccpT1tbk7yjkLeT8vDN52ijnDSfiS9lGb+0g8t0AfHUvtTDc0LUr3YO6Wa4xjyRle+xvWH5xxLKsR/xfOap5LlPt88Va89sYZ041tXW6bOML8hrtdbRtbq5zmrgOgOvI2tYT/eJNank+WjT3Y56az5Bk1WrB68Lav3sZkUnQr/fIRfSTyu8V3s9QNOh1XqA6O02ouOz4miDTydgBfT7NrqXtB6g+dGdCXIK3zQ/mvUZE4wX/1NB55n1eX+h3wLx4l/Cs068JsfrmJiHun0qvvZ8vmpeW+8ISHdPAW+eA/HzfnLNKe0M1QdWeIYKZUNMbL+PAk3S2vN/hXj6r7fomLlAn0NwTC82kfWZRqH/746YXmjGEur1aALmBrDL/zfB1gMFU6vXLqoXy/AYySD031fW9YOg1/+iDUXp4bBbtt0KryDhHo85uxPyXHzTykbXT8I157GtsL6if7I/laRTthWhXxu3q+v5V5TBdaaUZWCaXQkyrFdkiMajdXH+4s5H9yZsZ/Ejf/ybm5KbYKeCk5REDVH1pDswDtJJYvPTjr9i2V0JMmJZfMdVo/lQc0/Sfh/v740lMBsJ9OT5uaiSdgZfknaOkMcNnrdg3h7IQ9/LSRtT8HmqrPtmL6x59Xq1YpIssUaUmmEnH+m3Qb/jL8g9BnJomPj1aO5YrrURoU+brwl/0aUW97t4a+cahX5/n7Jqew0YQ+8mWV0vyUyT9e5wdWV9rE9ZtXMM6KvPOaMHn2juum/nniZ2DxYjoOtJupd0LEF+70oQdT3R8TIyv2KExwd+zG+PIp+WRA5MLMtokJ74fcUl6KIj9JoazYVoxym0Y8YYWv4nmlpoWyguc3SFsNp7TxGDXxsi9PMO15T1o79CHyr0uATKS8DYDaSsts2HS7pRGoM8w6l8Q/t4H+pgPMxeX00/Swp9CDT82P0S5PG2INoLL4PiEIbvyv0c2Z/2yjJX3VxHiETWpI+r3h928pH+Xof9acectffNCv1hhR6PzIXxtXYsWspq9oePVERpDPIM7a+p2R/qgO3PVV9NP9oxYdwykPYtED3qSnvVkfDU/F8YX+OrjrRt3FzCX5GV77m2tu8Nu/n4+riJbLOxv9RCuei6HF9LqI+6t9x+4/6DSxCHFXl6PqJ8SXe9joB+NL9eDrrplxW+uMU0RnyXiS9+JJeXnKOEy4EPkKyHAJuX3V11XoZll4/E164wk1+N+QjI/sWtyeV5DMRYjV8B4PqwqfaaMLRN9rdCvwfk/BLoOEro83D5PEpjkGdoq61+x1xtTHCNuWljAo+r2D94+qNNpVDnSdOfpI/i4qtqkf4gtBF/FBfHdv6g794+Zc8awz4N9eDX7braQ5PjMGBp9Nh/kf4ZRSeMiX0B23gpAfMEYPKrKdMwH07APOWIZ7TxN4R7bLvaMXock0Ue7XGqI5SHsvO4uwz8mfYR4q89/hUofAOHvDxmp8nLPlfyPgs++xPxtfYBeh9bplpb3qrUJ2tbPu2oP2Ph+Mr2qvWhZUVfn75ExxzvE/NXlXFPi5UeCju8P5swZkeJx+wosW96WpELYwFtfsPbgCLbF5X+et7mAKVmURsPUY88HoaQp41J/c5BeQ6A9B8Ou/Nc3wrRlseyjjf4itF5eqWj65sirvWK6Poqog/j3+jj0WYehHyk/5bDx2v61Y59uGx/CWj4taEh5OG865XyYScPX7MQpTHI822vrvhN08/BAfTD9qrN9zV75ccFrez1BrJXzQdpbcn9J2s/ZT1NJNALHo+hf5whrkIZXI8KZF1f0Ma45UDnjX0TdcIfABX6fztM/rxYKmn9A/XK/cOlwyj1GyOKzlyPk2r94zDlaWu1WfxulFx9R8riR2C1uXHSK6DTeLKM2nxZ8/VC/5cOXx8qMrh8fVqf5kcA0HdI2fM3V9dtOexUKZOvDx36GcTX81xYOwqc5rv/ymF/vK2c9ftiLlvhz4Ig76x7I+ez7VdzbyQpLmVdoU4QS/MNrjWVQePNKPG3dOOfifEmr0226ePnKbLGmy47fE3HmyuwQ00/5zPe1HwQrhP+scMHccyn2Z8rPgsVerQ//nyV5oNGFblwLNYeA43SjvhvccDk2tPx/J3SWo74iT7wHvLPK3o0lKfkaldtDcDv55yKrzyBp+3HPRB2+IXAW/M77MNlLy1KbwMcsVXtdRC4P3T9xm5cLQ7EssKD48CbN3YwbyBM7bVq6IM5/tVeqxbhfpP6PuqE449Q4emKl5eAj0YveLw/fweMPX+bYX/etfakzScPKTK79ueZt3beQBtLhb6ijKXnb35YLp3vPf8wvs6y5482eIj4aGOR9hit9hgCzgGvT+hbuKeOfYtfM6g9/p0kY5Rkn5T7JfcJrU7yyj6O1+7qM17bBPf6jUdca0rcRhpv16PO2poStpvgcR+7N4PPSFrXYZ0K/X0OnWp9wqXTtD4h8mRZp0rT6d2hLmtWnQr9ux06TVsrY50K/XsdOtV05NJp1nUo115lVp3ykWjhk1WnQv9Bh05xvyiLToV+4TzqFOt8hMqhzwjhejTo9Xf5hHIbHZiHEjA1/xUqdXC1Zajw4bZ8yNGWoVKvQxnrddioXof7rJfQ7/JUr30J9drXZ73S9h1431XoP5qhXto6SZR47V/o92WM7c7nWkXYqUYwHnbXewnyRhX6la7laGsV+ygPY6WQ+FjNbz5J8xv+fCjy1M6zoxxsA0L/sYw2sDpnynUbcO3na3G0a04VKvTanmNBoZd5smYDvKaqvZIla3yPr8x5cUM3XQgYuYS/wpPvjWSoG/ctnEegXmUeMQxnc1Ee9pufpvmRdjZ3ScHh8TXpbC6ftVomvtrZ3KS1l8+QrFrsvy9DnX8P1l4+G19rMQ+fn0VfGAbdsoSKLGgPSWPMFzL6F5Fr2MYYV9wSJcvzs0uEpY0j2vlZbb0hzurxoTzG/N1UuvxLSlnuHxOBOx7k/vENRzyDZ+u0+WYlAfM7YPd/sLG7/tiOci4rovujjTa8/5ljHqPNS1x7TkcVeu1V1NMkA5blenNb/RH5BW2Ni3WCcTPSc9yMef3Mc5aVOrIOJxLoeT4g9P+LYmcFpZ689qPJl3X8xhj/Mxn8r/B0ffo9SmwnrtgnuuY9cly/xv21V8qHnbzV8cXl8vmO9XhvMoQ8fm2/5ovH4J7LF/PnhzBuRF/8rbgxOEb/P8CG+dy9Fvdre+qM+RcOfxUGvXV12eGSQh8CjeusxpKjnLZPirx2xH+LxdZASfhJv12jyCJ8Odb6W9Dj57fqsuZ65B0sueYCk4Hud214l4s54hcEvXMN5J9XdGk4Pyi5/HUI93hP1898pdTCPV20X9zT1Z4JQXvRzmngPOEfKGbRfAD6uRLkI/0/Qbz0vQTMIHD7u7QzYnmKL12+IkqDnr/RnrPV5je8D4Rtwr5f2y9Aej4L2aaPF6vTnh0UufyePW+d97O1fH5Wm0e77A9tIel5+onAPe/i/foCtBHHh67zvfv7lP2gIjv3c+47/0CxI/J8OgPPQc73XgX5SH8V6Mt33HDxfG8vPfqwfs73or2EQbfMSb777+IXxWjPZWf5vKG25u0as9C+t0A+0t/usL9hef+K6Mmz/ZXP9xljad8s719xne3UPksT2d+frO/cj9KasFueV/7CPamvtMlapKe8ScgbC7v55OPfsubLWCLHONG/ObbNaakDlJHyBYX/BPHvklu5h+3EWKPKPaGPdPpDsYzRa7F82ufsXLE9VxDdj4N8mMYgH+nfEsuap/pKv96xQjlbs/VSq1Jv1Wv1RqO6WOfX76POIj1F/ewu+uwJznks9zsEf9wPfvt5bPSLo0qdhL/00RGgzyX8DQJ9Lii88oRlXLeSq24oP++DjZE8cp2ENdYnlt9PvHXadNRRb+afRK/1Abk/4cBHehkv0YYnSBdr/Oii7Gq3CeAp/FfyenH5vZXo+HNjqO/xBKyAfm+le6OB/npx9kvaa8Db40Pg1aeUs/qB9ngZeO0PbT8wTvIk9V18TeRDO+uN+I217PK46VCdCMfV5qZrD4t0j81hhMpJCK0NoSxnTsFwTQung24ZsKzmSkYT+AZBx1zZfaRhyfWoQ5YkjBxhTDkwLnadi11HSRe7TrauYx2Nl+fmZubLC8XqbGOx1ahW0qJxa/6LCzML1ebC4kypOlOpFhv9zAY42sDVjFFFf+NE/wysZvDO3ogDM0r8hlqhP+FYIdGiIq2eWdwAyjMd9NoVzyBWy55m63ML84vz1Xp1prhYnJ1ZSXtq9UbdPx5200tkORG4Z1PjRP+ysvrMmDhrfjLsxWSZsX0wYueP3An9L4IMX6HVJNQDD4kYTRsOQYs54hcE+pAo/POB1yG6xO0h8rB+eIfR0wxnIUf4KM8aRT/SlmuVPMGSlSD0NUi/BuqI9Hgt5fHeF2LbKhBmlOStszklb1S5h6tYv0ahG7ZNLuGv4PI9nsGjbtiHof/EHdkvJ/iPpFMZ4j+4L/6zTR3Mr8JqouAGgd5+7JNdcQLyS/JXPF4J/dfBV/BHWXi8wnqyjMhvTOEbJfZXQv8HtBLnqd+rH+UUXtp4lwt0fQRBtlUobXycUviIvtYF7pUWl59wrXhJn5tIoBe8caL/I8dYthbKjCpycSwj9P/KEctMKvXS+rXczyv0k0q9poNe/ydltd0e0b3nN/8uars9qMPxMF0/awbQD+82Yty2lvK0lTb2Pcgn68kS9FtfBtu4i3wl8ud6av1hQqmnqz9o9WPb/bM+Yzv8gPGaBBmyxnZC/+cgw+86YruuDwZucsvK/gbnPkj/1zCW/SW1j7YKqvnBUcrDthQdoR+cUHC1/sw2ofUVpOdYW2x/IoEe4ymk/67DJvJQRosvOWYQ+v/i8JHrgt564TyG9bBeoV8X9OphOuj1AesDnTfWB/XMHyYX+v+h1Efzu7ijEKUxyDP0u+pXTlCv7HddOowS63xKoUddSv0KRI/61/rOOspDvmtJhrS5DftkLd5A36Etr6IORM5Jpb52bbdYyhE/qR/eQ/75oNfmfcwls9qI6GfKj36KLhucUvQj8mzwIk+xIrZSUHiLrPKBQ/QrSD8FOkR6vJbyeO8q+Kh6dH8aygl+gfKixPNYzBtV7o2cJ6yCgoV6kzaN+vE06YK/GKb9FVy+xzJie4rNu3zESvkglsQ3Wn+K/u2IfxcHSpWy1GODUg/hjXZl13dqs1l9nfDPB177csllw6gfnusWFFkLQa8NPx126NLsG/loWGeHFOuIIdazhljPGWJZ6uu4IdZJQ6xjhlh7DbEs63jKEMtSrsOGWJb90bIdlw2xLPvQGUMsy3a0tNUXDLEs7eu0IdbHDbEs7X5YfY5lHV8yxHrKEOtlQyxLfVnGJpb2NaxxoaXdD2ssd8gQ64Qh1oUQyw2r3VvGJhfHtP6whjWWG1ZfaBnLWfpCy3a01Newxl/7DLGGNf46aohl2bct+5ClvizHIcs+NKy6t/RflutylrHJsNqXZew7rDHmMI4d0TXvWVmMHdpeL55RnFTksNzvFfyNnvBFV5c4dIX8ee9X8rW/gsV5witPWMZ1K7nq5tojxv1w1EES1iV9Yk0qeT7atOCoN/Kfcsiq1WPKUCfjhlh8tk07s6Htqwr9RoVes5NphbeUlbbdBHmGbVt2tS36COG/kqe3RW/vITr5SsZI0Ns3LknACuj3e+jeKOBhmg56bW1tgpzCl++xrWD5KZJDfsuZFzwDK+dEtLM90b8d8e/iQGmm7PKtfseZmUpW3y38V8t3u3xYlPhsRBYfFqUDYYduEL8TpRcNsZ4zxDpiiHXYEOusIZZlHZcNsfYaYlnaxCFDLEub+Jgh1oVgEycNsU4ZYg1r37bUvaW+jhpiWdbxhCGWZTta2v0xQyxLu3/GEMvSJl4yxLK0iYvx1+vDRy8bYi0ZYl0IvvBlQywrnxNd81x7ELmeD+2wLPuQpY+2HNOGNS4c1jFtWOdWlrq37EOW+rL00RfHjtf+2BEly7mVpS88bYh1cU3h/PUhS91b1vHjhljDOh+y1P1xQ6xlQ6xhjXMu+onzF09c9BPnT/fD6ieyxF/4nkB+L6+2jy9YG1Ow7iYsLL+RsDalYN1HWNp5Bil3aQIffOcFnsG4VOGt4QuGdo4j+rcj/l0cKM3WJ5V62OGXG7IffhnUOxf/Fd6Xw327vftq5veTCv88yWorT+csweUkD+uHzxJcochaoLwohWGHjvNGlXsjDqxThlhnDbGOGGLtNcR6xhDrkCHWGUMsS31Z1tFKLs3PDoutnjbEsuzbljZx0hDrov+66L981tFS94cNsSzt/nlDLMu+Paz90dJHD+tYa9mOy4ZYF8I4dCHU0VIuS786jON2dM3z9mGxL0t9vWiIddwQyzI2GdYx7WJ/PH91HNZx+0KYp1n6aD479nq0++cMsYZ1reMFQywfPpqfC4zSjvhvcaBUqcpaNO6d5IJuvhiLGK6bN3PET3SE95B/nmQ1lqe9jq/t5aB+Rkg/fvY5io0c4aM8lyv60fYVOI68Mv6N+1hIfznUEenxWsrjvUfigpZ+Mnre+oEYt48+UF5slSq15mytOFOv1hozlXKjPFtsVGutUmmuVJ6vzlUqrcXqXGOuXGmVZ8uLU0Fvu3Mf8NTG1ax9gPeyPPVJ517WpUob9buX9XDYoRum8Ve+35Pl/fF+bKGysFJb8P3+eM0WXO+Pz2oLB8MO3aDtZxlTW84lTxhiWcYWy4ZYlvGmZaw/rGt0w7ov8KwhluW84XlDrAthz28Y9+CjdHEf+Pzp/uI+8PnT/VFDLEu7H9Z9zYt+4vzp3rKOHzfEsownhlX3LxliXexD/WEtGWJd7EPnT/eWc/dlQyx5hoLXkKK0I/5bHCxVJxW+Rtjt98ReOTh2g28I9mZ7uVuCfZU5dqUm61343Xb8jvf34kYW+4k/pdy19o7fbx6BfKT/2Ss6mP8UY04BbgAYUZokvFxguS5YLuaIXxDo65TCP0+y2srTWaccIXlYP7xOOarIWqC8KO0PO3ScN6rcc2EdN8Q6Y4h12BDrlCHWC4ZYRwyxTg+pXMuGWHsNsQ4NqVxnDbEs7d5SLkvdnzDEsmxHS90fNcSyrONLhlhPGWK9bIhlqa+ThljD2rctxw6JJ+T5aIwf5Zvx00Fv7LSO+I1BHuJLXDpB+Tvi38XBUknw1/rBb3/3YI2iY6yT8Jc4cxzocwl/BYvzhFeesKx156obys/2swbk4e8jaFhr+sSaVPJ8tOmEo97If8ohq1aPMdLJmMInp+hE7q91yIX00wpvKSs6nIQ8Qx2WXTrEvij8V/LNCNHbtUQn75oYCXptcE0CVkC/r6V7o4CHiefc6COngl6fKXwj/yjtsxXy+XsTW4HXqHKP+wuW35qApa01RKkZdvKR/kPxWkOE/f0t3ZhXK/K5bPcahf5qoBF5NN1I2SmFdz8+FOUqKDKMrhKfsVXis3aV+EyuEp+JVeLD/v0aQz7XAM048bnWkM+1QLOe+FxnyOc6oOHYbxvkob8ROa5X5JDxaTvcNxyfMp+xFf55ktVYnnastZ3kYf3w2PIGRdYC5UXpkbBDx3mjyr2RBCyptxWW2MZ00Gsr1xOfbQqfbQ4+1yt8xK5upPrsiH8XB0rlWWmXm4LeJHk3w71PhB05OI3Sb5Q78ulf39rBZTrmiXq9mfKwj91CedhWt1LeDZB3W3w9HfTqF3ljntSR73E7YvkbHXy2D8hnu8JnSik3qK/UdMPtZMEH9bad+Gw35IN6ewPxeYMhH7TFG4jPFiiH+21fvKJTBsthDIxl5X1w40T/77Z0ML8UY4ovuRnkMvQl81K3W4LeJHm3Am+22dsgj+3sdshj27gD8lDnnDT/JLqI/NOf9uGfboI8qZO0gZT/Dux5fvOK7vLYhvzcBo6f91LeDUpehL/7qo48qIcoZhe7mYSybDdC/6dkK37GnZlZbWwRPQvvWzzxztKftbEF5RG580re2ACythbnipXizEyjOVNdqFVbuaC3T40q93jeeqtCr30TUHR9mx9dl6UvjIYdfByXozQGebdQ3jjkiYxRX53f1C3/rZ7kz6J/5F9Q6O+DOvTTlj6x0B9YYK1ZIdbGoHdMEp/jOfad03yQJK3PFygPbe4SysP+xN+FxrEM1/o4pcXT/3cf4xWOi7ckYMpYgHMBGWPGifavYGz7CxrbtkH5nwq78zD2Ej4Rxvcp7hE+uNYs42SUHkqQ6x9XJdapNrRYh8evWz3xzjp+8fwH5RG580reIOPXQqlVaRYXFqrlhUZtZmbGNR7hPR6/blPotffQiq5v96PrBW38ug30GqUxyOOxDccvkVEbv/yMv9WFLPpH/gWF/iNQh37aUny7FjdpvuLDYXcezvkw1v0+9XE/cWK5zv0Gk+bneXxAm+TxAecsPD68EfL6HR9EF/2OD+gnsU6IOQb3NB8/TvQb4oO2UR3WX9nND8d04R3RHSW6WxW5/faZ7Gutwl/zoT7WWjWfqPU7zf64f2MevgsA85DP7QofDWvcEEvsYjrotdFbic/NCp+bHXxuVfiIXWH/M/QnLWmXO4PeJHlFuNfvWqvI3e9aK+q1SHnYx0qUh21Vpjz0b5X4ejro1S/yxjypI9/jdsTyb3TwuW1APrcpfKaUcrmEv8KH7zEfTTeutZKV8tH8Pbe5BR/U2+3E53ZDPmiLdxAfjNFxrfUHruyUwXK41qrNvceJ/n+GtdYfjjEng95+cL58iWazJchjOytDHttGBfJQ55w0/yS66HetFX011gllzxqbCP291E6eYoniRqqXplPXGuiwxTh+5tPuGEcbx/uNca6Aa/Y9/cYl2w2xxLangyAxLslRHvK51cFHi5cu1BhH8yGrFeNwrNpv7IHlX28xTtIalQUfbX3jQotxnjSKcb4JMc5TNHZ6Wn8xjXHYznzFOLj+8qdGc7C0tZIc8U6KhX46fPUvr9OcgHWa41cmy3Uj8B7d3E13cZ3mwl2ncZ1x4rGv3zNO2nmRCzWGQb2udgyDvDFP6pgWW2D511sMs1pn7y7UGObrRjHMFyCG+eZrcJ2G7ey1tE6D+/lZYhOh/5dDtE6zTam/3zMq2WMc4Z8nWX3FONo4jvrhGOc2RVbN9/A6jRZL3abw0bC2G2LxOg1ibyM+2xU+2x18tiky+z3X0Pn28R1Bb9LGy35jHDzr0E+Mg3plX4h97E7K63d9Zzro1e+g63pY/nYHnxsH5HOjwsf3WL1a5/FXK5Y6X+tOSTHOf6UYR8pljXGE/pMQ4/zD6qzT9OVLNJu9E/LYzjCOYNvQ1ney+qeVrtNsgzz2T7hWInTaWonWdzzHEZm/U8NxxHY/8jjjCG2sXB90nkG9v7nn7Y8vPPTg4r3Nvbvf9Ejj7fVdex6sP/SmRmNXc/durA1bDdeWrYVp5Lqg3EeMW1JqIU/4aysktxDWrSlYdxOWdgqdvUgS1n2EpXkuHpG03sbRFNKjPLenyPO2MFme2wnrjhSsnYSlzTwF640pWI8SFpZ/I5W7M4EP0qA3vFPhreGz3RZTZH4s7JYZ5eLZWSkFaxdhYfkSYZVTsHYTFpYvU7lKAh+kwVlwBfjklHuaPHvCZHkqhFVNwXqcsLB8lbBqKVhPEBaWr1G5mQQ+SFOD+zPAJ6fc0+R5MkyWR8pmGeFQVsMRJfOpeOG/WiNcml55pjyryFpQ8ngWMavwmVX4aFi3GGLdZoh1qyHW7YZYbzTEutMQq2iIVTbEKhliVQyxxCdqOxGbiE+/OxFYfrV2IjYRn21QDmebP725UwZtEGebWFbGonGifwZmm++KMbUVMteOD6+69KtnjY+MNWjDdr6989ZsHMMlSR6Oc/gFSk7a7FTk7nf1DPXKYzL6mVnKQ78xR3nYd+fj6+mgV7/sE7U4EO+57Ljs4HPngHzuVPhMKeUG7Zeabnz3f14VvdOQjzZ/0HbDB+WjzS3S/NkT5M+kXJI/k1h2nOg/Cv5sb4w5GfT2g/PpS9hmtbhE8uYgj21jHvJQ55w0/yS66Hf1DH01+yetT0wGvbZ3PnbXhH8+6O1zPuYM2pqANgZq/lvKav1pM1xzvx1V7rn65nZDLJlLumKHHOUhH9fumhZreI4PKrwLj2mK6hylfnfXVhofoF6rlId9rEZ52Fbcb9Evii/Sxm22l37HbSz/eosPVmt37UKND77cZ3zAu2tC/wDEB1+l+ADXw4Y1PmA78xUfiC76jQ9wbj8D+GxfSIdtqNl6oNzLKTjc54oJ/KP0M+Grf7W19UuJhzaW4z2270sVeV391e9Y9urbxZGf1APvIf+8ohMfMVI5o1412yqTzjU7YBtBPhWFj4bFftC1Ll70o6/MMa7wX611cS1evFTR62rYd1I73+mQx4+/77yJPm1/SOSJ3iwyEfTakLYvxnLjPpLcS2ob5M372a69xbT9wLsJK6kOSW2EWLyfrelgnPL+ezyORzr895u7ae6Iab4LNP+RTnNgO3Gf9rTXlblP815XzY88zr0u1A/a7JrAbTvYdknnAO5Q6sq2fHuKTGzL/Z45QCy2ZdeZgztTsNiWsTzHBeir+WSbdhKc56CI/8pptM3J+Hc68IsO/LIDfxvQcYyK8/cK5eHcswr4/+jAv9WBf7sD/w4FnzHFb+B5oW2UJ7TfjzGiGPnLV+vyCkaU/L5VLrtPEf6rddJcOw+F+nE9Tcdv5bQ8hYtYtxhiyf653xPglbK2piFJW79arRPg2C7c31HPvH6F/YLXr/BMgowTq3UyW+MzqL3covCZUsrlEv4KH76X5SlPbicLPtp5SG5zCz7aWUm2Hws+rhPgGK/iGtXN9AZv7QS4FuvyCfD3whrVbTGm36enbE+As51hTMi2McgJcHyb9J8O+IRKdDpZnly6v7nn3ube99QferBR3/Pgzkfe0Xzs8ebuPWMEy92HzfzWBHERJ3CIG6URyttO+fJSzZFAT1mWLfwMT9nDEeG/WssWaUeYORy5Q5G1oORdBdfclUaVeyMOrJsNsfhDKYjNS2X9voRxuyLzxZcwXnwJYxKfiy9hXBmfYXi4fxuUw7BngcIefBl9lq05of9JCHuaFPb4GRNemy9hFF0M8uAb+yf8mI28mF/yrody/LEl/CCX4OPHbLTjIPLBw2n6HV3LA2LjJNfHyB7wY4aGU+p2GKx9RMrvA36VzI8/JE3jUO68kjfIRwHKzYXFmXq9VVlsFRfrrSb3dZGV740Af/a9Qr9Boff7wGulLv0FPwqA/TdKY5DHjyCOQx4+iMofBfDzss1KPYv+kX9Bob8H6tBPW2pTfo4js2JtDLrtFvu25pu4L/rxA9nnLsI/T7Iay9Oeu2gfM96i6FWb6kpZLXbnF5NtV/hocyQN62pDLBl7tLFiC/HRPgx9tYPPFkXmYfpgUZRW62OdqFdeosE+xktu2FYc42Cf5qVU1C/bS79+CMu7XmR3zYB8rlH4+F5KvZr4+PrwNPtcXx+e5q3B7YZ80BY5Tt0G5XDu8rWEjy5mnbsI/RzMXb5BsSp/yHhH/Ls4UOr/42dss7jcynaG8022jaQX7nDS/JPoYpC5C/snrU8Ma3xwtR95nPGBNgb2Gx/wS70GGdNvMsQSu5gOetubxxVNN9c4+Gj+8UKND1Cv3P+wb/qID3yM26v10XDf8cFqjdvbiM82Qz6ot/MVHyR9zPvvMsQHro95C/3NEB/8PcUHfsYE2/iA7azfD31n9U+ii37jA5zL3ZKAOa7QbqU8of1+3EZRe90QF5hWyl8bdOdthbzrKE+bu2rjFmIgD7Q57OfNsLsOQj8RM4l0+aWtOuZIAqbYsbZOhnPlKI1Bnp39LpYiuY+DDaBOX6lv2F2nbZA3qtDzWqQWd6AvEh1liWG0tYdr4Z6stWn6vC6+dz70iTJm0SfS96tP0ZFrnScX9LabFse69Ckyng99ooxZ9KnF5jnSCdKjPq+LrwtBrw5vIKxrFSzs77wWfF18f0KhZ5+E9NeDz/nbLd3yaettkrdVwUbfmyMMrEdeqccU5WHZCPd7l3fjavsSrrbRXhd4s8JL/Lv28W6/ewTleW2+IEkb43n8z7oGsI3y7oA8judwXx51wkmLDURPkW19FY5bMx1eIx/BZTtim9miyKjFgjen4PZrM6LH14vN8JoS2gzb02vBZrbBPbaZbYqM2vpi2mtG2Wa0o/MYs7PNaC9Ifi195GnQMxSSh4+toE44aTaD+7n92EzaC/VdNoMfZuLzNHek4LLNaGeytP4lNqOdyfL8UY3mlCKrJLYnrX2zvlSa16q0R9I0e0KdcNJsRvTUr82kvd6XbUZbT9OOnmuPWWrn8oReey0q6kPsTXvFqpSdVMoZnnmoTimySpI8fDySz1Lio5w8xmivc5Q8fMUCn5vCVyzw620xaTYjeurXZrRX/W6Dey4/I2W1V2qkPZrLNqM93pzVZqSsZ5sZqldzSd4PQN5rzWaeoFdEoo/m1zwVM/IU+rTHzNn+NHtF/+6yP34FqZTDNTaUn183J/SnYb77/fhaW5MQPfldkyg2tTUJ1Ot42F1vlw6j1G+fF50Vgl5/XKI87XWRrrOq2mtPrWMjiRdeL7ERj3NZP0Y2rLERzp/YZ92iyKh9mEV7bF/7uKfLj6H+2WbQLqSs39cgVopTiqyStLbnsQzbnu1Ca3ttnsV2iH0fdcJJsxnRU782o/mDrDYjZbUPFmo2oz0XdaHaTBZ/8Xq3mScv+pm+bIbXei5Em/kBspmbFFzcB8ryPAXuTfI+BO4L8fOaWG5YzyFsozztY5HaejOf90A7QZ1w0mxG9NSvzdxAuNg+UXLtQ0jZyGa+GB/GyxOv6O9Az/g0Gs1StTQ7P9esVhvztY2EHyWxv3Ue+Fdr9dnF+mypNF8tNaulVP6R/u/a1K3PMSiDbTel3BNcsf9xKrtjhfVgteaIXxDoZ0WFf55kNZanfVZ0nORh/fBZ0QlF1oKSJ20wHSS3SY7yUIYxRYaCUn4sA5ZWn/Xxvyjt3rNzV/PN9Ud3P/5QM6DEtsJ9eiSBf04pHziwsIyPfrVYm1lYPNe5is3SK/a42v261liYK86W6/ONxZlGpba42vybC9X52YX5xVqxUZwvzVf68StTQa9t5RL+RmnUgV1QsB4OX/0rPgj7kaUPEvw1JJ8Rfkn0NK7oSXiv9VK3ViurfxX++cCrv2/717UkD+uHn3Wd9KOfZvSqRrE99FkTim5YjjUkY96TjNqaqcgkeWOQJ3JENH9zdbeMI55k9NtHWw0tRsGzyFfTGU5pG1yzRrsfgXykv35rB/O6+Ho66B6X0E+tg/w1Sr78lvYaUWjxmn+L7KxXpBebnEio6wTVVehvjusXyXZgk46J+kO5RhIwbwPM79P5NDyL5urzQr9Oocc+JvJMB719cx2VQ9kng+6E97T2yREtj8EyTmG5pN+TCk6SDGsVHB4nGZN5arEez6VGFT7Yp3DMn1T4G44PNW2slKTF2jnKw7q/L+zQcdLmrlKnqL5r+zhfr/U1y9hI7o/DfebL8fgE0eJ4zjobN5CxoPCZINw1DvlzhDOmlJsK9P6o/c0qb06R1zUfXikfxPrZsJsPtnPXZwxpTEM/PqqU/WjYyUf698CY9q6MYxr7EqzD+8POPfbZHMdyn+R9bR67mAbHcaR/vzJ2sX9ArOjez2eIEbS4j2OE/aDPD5E+tRhgOujVDdvwJPHC+FjGF9bBAyBHc2syL9HrlKOO0b0Pb9XpUAakYwxt7BQMrV9LuWlFLu577DsmHDy08UzjMU55g7aPNm5jrKHFMFo+jufIh++NKPRp8Uc+AVvDnVBwND+/lvJySh77MKwv+jCOTbQ5GfpGrd8ltZ0r9tZkzxJXTThk1/SHfsh6Lac4VywVF2drrVapMVNfqK72WlK5Nj9Xn18olsqtcrkyN5PGf1p0EnbycY4bpTXx70iuUYUe5yFIfxJ843MUy40r/CK6X3LQ5RL+voKh3BsLu+9Nhr30o2EvvfDOh70ySt46yBsnPuvj36gvxBI5xon+F6A/RWktlJHyBYX/WuLfJbdyD/szY40q94Q+ap8XqN9g3a3XqF7hSfh4j2UT2/HRr2aqM6W5ufrc4sxia766uLDa/XpxfqY1X6kslCrzjeZ8aWbV16irlYVWqXVunbrSKlbmSqu+Rl8vls/tuS0s1ErN+vx8a9XrXyqVWjPVhbmZxfK5pbBV3yOotmbrM63ZYq3cqDbLjfpq86/PNuerM5XyYqU1X58rzq02/4XGzGJxvlJq1OuzxdmZuZXskfBcPkqyluJpLzPze3jafjrojbl8rP2PkjysH95b1fZItf0ied97TsnLsn/qG2s66G1vnj9ruhl18OG2ilKW/Xxf63dZbU74r9Z+ftb9b14Tw7I894kS24l2bkBb436tYEn5KGlrmg+G3XnYxqzTrLYqa2DsS6eD5LYR3jLnwvvjiry8Rvbv4/hN2ws2tMcijx3Iy/NZmxltXUfSlFJvbnecy3Pb8v4s5uF4zOdAMGlr8qKLV/aTMpwn02wkR3kTSj20dQQea3KKXK69Y9d6lDZOyLvFc4QZBO71Bm0tNy0e4bX5KHm2/czxiPDPB73t5WNsSFvXYVt37ctpa4g5ykM+axU+GtaIIdYY1Qfbg23BUyyYOU4Q/vmgV6c+bEHrczlFr1psmuUskyseyRpPDjuWa86Tpd01Pmz/yAfHd9w/m766u4yUw/0eLMvvpxP6T13dwdwYX2vnN3ksQZk5TtHsbMRRf43PpFJuR/y32F+q8g2/566KdY4NMEneOqXOOYVeixtE7n7f5YlxwzrKw3FoPeXhmDlFeeh75XsOmo1wzNKvjWB5ly1ODMhHi5989/lx4uP7zIIrTlopH20/SDu3MigftMW1xAfLoa+ska/EvW9tHHxb2MlH+pPgK+fo7KGfM67FeZ6DYNLmIGyz6GfYztZDHtvGFOTx2WFMmn8SXfT7Lk8cB/KAz/1lVCnrWg/yNOfMHPO/Hp7viBLHU9p+tza3cD0rYoHlGg/4HFa/44G2nul5LjnHYysmzR/0+y5wkbvf+AH1Okl5Wt9dadyhrVdwjKzNa/Gea7xd4+AzNiAf19k+X+PgasUpPLf28WyMNk6tVjyUFD/spPhBO6uIZXmuJfT7IX7YRfGDpzGhL1+i2WzW2IJtA2ML1DknzT/JvX7jB7QJqROe99TWlbRxMRf0+lheh0J+2tqrlB22+JDbV5uHam3I7YvxIffXDZCHOuGUFjv284y1Fj8gHZ9fyykyan1dswFtzUjotedA+KxdlLRzmVJ2WNcnXH1bswv2r2gXbIfTkIc64ZS2HtKPzWj+IKvN4NniGq2bIR3bh7YGOa7wdMmoxcVZfRafC9aeHWLeOM6h/Enz5M/G+kh7N5royfO70Wrau9FQr+Mkk0uHUeq3z/Meu+aPtXiL1ze0vWFcC7Y+GzRbXqzVK7X54mKzNlufme3nbJDr3HuWuFvqrsXTUeK9bqH/BsVVnnyouteddKZazqty3+U4Uej/V4gT/4B8C69vYp42J3A9M6E9W8jt0D6PGuh9gesg9P88ow+Q+nj2AVXNB2C/ZR/gej4zSuwD1iv0OIbycwRJ8TGPB5rOeYzA+MXl83k+8q+hjfibDWjXeZJdm0tr6yW8lqQ91xnJ8p+pz3raE5/V5uGStP2MHOVhP+GYiJ+PxzxtnpRTZNBiG9FFv2dELPwExvyvyBf2ynU++i2Oz9xvXWNxEPT227R+LusAhaC3Ldm+tbGgnz4TpXuIn/ZMGfaZdcBrIuzQGrZB+z1GoutRkHks7Mgu/MVe8DkLoWvPi/3IWhRZ5bkMGbeQJ9ZlhOj5epzu/X8wP8Q6YjtivXlvV3smBJ+VERm154fWhf1hrSWsNQNgiVzaczJrViiXhjVBWNqzRXhP9Bv1ie9Cn9DOhSWdpRi5psMTfVvWsxRCv/maDuZ4fO3jzF6ar2af19ZloI9VO+LfxcFS5nNPwj8f9I6rPvbDtDFBm0OLftb5kafqihW1MSp6f8+GoLfNUD7B0ublrnVJtvU03RSU8nwWFNvYdYaUx8YsZ0jR3tcF7vlljrC0fqzFSJoutLUZnq9dA/2+Rv1eO3Os9V/u99qZY8lLOnOcZFuutYsphV6bmwhvtL2pDFhrHLw3KPRTDt4oF5Zl3kl9RItjRTfnYw0KY0+OY13zyShl0aXWjgWiR91p/di1PrWO8rD/cR/X9oexv2hrXDivlTH6/wcdvfdFB84EAA==","debug_symbols":"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b/k7S7LTXNaW+nZM+nKaP3daOHeanDttW9jbKMLjtKe3aiynpXOnzedOy6dO29kOeiqP94tMJbkvp+2QvC3+L6e5afpCcmeDz8PT0rnT8rm5lTOnuZ2dx24fF54GGb+c5s6d5s+dFs6dti337dDyOM0/C/APP5bL7eySVPlL0hVfMv/5L3m9rud2dnup+hXl7V+xs4vHi6+4n+bOnebPnRbOXH2ck3OnxXOnpXOnzedOy+dOK6dO89O509y50/y503ae/4/rhXWen3/yudWa+Xlan9aZvf/yFfP7vyK//yvK279iZ/mn6le493+Ff/9XhPd/hbz/K+L7v+L9f93h/X/d4f1/3eH9f93y/r9uef9ft7z/r1ve/9ct7//rlvf/dcuP/7rvp83nTsvnTiunTovTudPcudP8udPCudPk3Gnx3GnnqiSeq5J4rkriuSpJ56oknauSdK5K0rkqSeeqJJ2rknSuStK5KknnqiSdq5L5XJXM56pkPlcl87kqmc9VyXyuSuZzVTKfq5L5XJXM56okn6uSfK5K8rkqyeeqJJ+rknyuSvK5KsnnqiSfq5J8rkrKuSop56qknKuScq5KyrkqKeeqpJyrknKuSsq5KimnqsRP07nT3LnT/LnTwrnT5Nxp8dxp6dxp87nT8rnTzlWJO1cl7lyVuHNV4s5ViTtXJe5clbhzVeLOVYk7VyXuXJX4c1Xiz1WJP1cl/lyV+HNV4s9ViT9XJf5clfhzVeLPVUk4VyXhXJWEc1USzlVJOFcl4VyVhHNVEs5VSThXJeFclci5KpFzVSLnqkTOVYmcqxI5VyXnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38ue/Xnsld/Lnv157JXfy579eeyV38uew3nstdwLnsN57LXcC57Deey13Auew3nstdwLnsN57LXcC57Deey13Auew3nstdwLnsN57LXcC57Deey13Auew3nstdwLnsN57LXcC57Deey13Auew3nstdwLnsN57LXcC57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","names":["get_assets"],"brillig_names":["get_assets"]},{"name":"get_position","hash":"6794881232180930961","is_unconstrained":true,"custom_attributes":["utility","view"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"position::Position","fields":[{"name":"collateral","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"static_debt","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"debt","type":{"kind":"integer","sign":"unsigned","width":128}}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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646f/+tOn//rTp//606f/+tOn//rTp//606f/+tOP/7rvp+Wzp2Wz51WTp2Wl3OnmXOn2XOnuXOn+XOnhXOnnauSfK5K8rkqyeeqpJyrknKuSsq5KinnqqScq5JyrkrKuSop56qknKuScqpK0rKcO82cO82eO82dO82fOy2cOy2eOy2dOy2fO+1clZhzVWLOVYk5VyXmXJWYc1VizlWJOVcl5lyVmHNVYs5ViT1XJfZcldhzVWLPVYk9VyX2XJXYc1Viz1WJPVcl9lyVuHNV4s5ViTtXJe5clbhzVeLOVYk7VyXuXJW4c1XizlWJP1cl/lyV+HNV4s9ViT9XJf5clfhzVeLPVYk/VyX+XJWEc1USzlVJOFcl4VyVhHNVEs5VSThXJeFclYRzVRLOVUk8VyXxXJXEc1USz1VJPFcl8VyVxHNVEs9VSTxXJfFclaRzVZLOVUk6VyXpXJWkc1WSzlXJuew1ncte07nsNZ3LXtO57DWdy17Tuew1ncte07nsNZ3LXtO57DWdy17Tuew1ncte07nsNZ3LXtO57DWdy17Tuew1ncte07nsNZ3LXtO57DWdy17zuew1n8te87nsNZ/LXvO57DWfy17zuew1n8te87nsNZ/LXvO57DWfy17zuew1n8te87nsNZ/LXvO57DWfy17zuew1n8te87nsNZ/LXvO57DWfy17zuew1n8te87nsNZ/LXvO57DWfy17zuew1n8te87nsNZ/LXvO57DWfy17zuew1n8te87nsNZ/LXvO57DWfy17zuew1n8te87nsNZ/LXvO57DWfy17zuew1n8te87nsNZ/LXvO57DWfy17zuew1n8te87nsNZ/LXvO57DWfy17zTvZatof3TPGmctpOlaRt3/NS7G+n1V5p1uqFyXkv05UajtM1HK9rOEHXcKKu4SRdw8m6hlNUDWdvTUJqOLquyknXVTnpuionXVflpOuqnHRdlZOuq3LSdVVOV1+V47b5xvL88rB1PHlRNh6jbDxW2XicsvF4ZeP58bX5flo8d1o6d1r1mmTN9mZOa004gGZictvrm2KKj411ajsd2Fs4+HWwW5434VnqW4Eu2wZYi3v8mLyYr/EX5eMPyypADE8vkFzHX1/T7mj8pvPx287H7zofv+98/KHz8cfOx586H7/2++/R+Pu+/5al7/tvWfq+/5al7/tvWfq+/5al7/tvWfq+/5al7/tvWfq+/5al7/tvWTq//5rO77+m8/uv6fz+azq//5rO77+m8/uv6fz+azq//5rO77+m8/uv7fz+azu//9rO77+28/uv7fz+azu//9rO77+28/uv7fz+azu//7rO77+u8/uv6/z+6zq//7rO77+u8/uv6/z+6zq//7rO77+u8/uv7/z+6zu///rO77++8/uv7/z+6zu///rO77++8/uv7/z+6zu//4bO77+h8/tv6Pz+Gzq//4bO77+h8/tv6Pz+Gzq//4bO77+h8/tv7Pz+Gzu//8bO77+x8/tv7Pz+Gzu//8bO77+x8/tv7Pz+Gzu//6bO77+p8/tv6vz+mzq//6bO77+p8/tv6vz+mzq//6bO77+p8/tv7vz+mzu//+bO77+58/tv7vz+mzu//+bO77+58/uv+v2vjsbf+f238/2vSuf7X5XO978qne9/VTrf/6p0vv9V6Xz/q9L5/lel8/2vSt/7X8Wl7/2vfu0O2vn4u77/3sbf9f33Nv6u77+38Xd9/72Nv+v77238Xd9/b+Pv+v57G3/n99++97+6jb/z+2/f+1/dxt/5/bfv/a9u4+/8/tv3/le38Xd+/+17/6vb+Du///a9/9Vt/J3ff/ve/+o2/s7vv33vf3Ubf+f33773v7qNv/P7b9/7X93G3/n9t+/9r27j7/z+2/f+V7fxd37/7Xv/q9v4O7//9r3/1W38nd9/+97/6jb+zu+/fe9/dRt/5/ffvve/uo2/8/tv3/tf3cbf+f237/2vbuPv/P7b9/5Xt/F3fv/te/+r2/g7v//2vf/Vbfyd33/73v/qNv7O77997391G3/n99++97+6jb/z+2/f+1/dxt/5/bfv/a9u4+/8/tv3/le38Xd+/+17/6vb+Du///a9/9Vt/J3ff/ve/+o2/s7vv33vf3Ubf+f33773v7qNv/P7b9/7X93G3/n9t+/9r27j7/z+2/f+V7fxd37/7Xv/q9v4O7//9r3/1W38nd9/+97/6jb+zu+/fe9/dRt/5/ffvve/uo1f+/338dEx3Qb9NP7aweuoY46PD87+a67a79Ut56r9vt5yrn6iuWrvF1rOVXtv0XKuyvuQX296eszVvp+rXUqx67hv/87b4bakr/kq71uaz1d5n9N4vkb7vmTN56u8j2o+X+W9VPP5Ku+nms/X655vCn6dQbqtor6f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","names":["get_position"],"brillig_names":["get_position"]},{"name":"constructor","hash":"6987466487073815960","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"H4sIAAAAAAAA/+19B3wcx3X+Hg4ACZAgjk2iREqkqE6qXEWRbZlW791qtmwDuIOKKVKiqEKKpI5NFMUikSqU5d577z12/HfcYsdxL4ntxLGT2LHjxLETJ7b/M9K9u4cPb/f2cG/AG5Hz+z1gb2fme9+86bOzs4ngaXdTMgjSyaevE0aSlf9tRhbBPfrPrzuEcNOEez3CvV7h3kzh3iFGlsG9hUK4RcK9o4R7i4V7x1fucddW+b+s8j/dnMscz7By6b58vtSfLWVymaF0dnB4oJDOF4b7BjIDmcJAoZgdyOVKA/mB/sHhwf70YCafK2VGC4O50QrY/7Xp8eJ2sLjWDu1BrUygSyjbJaGHlU4xnn+sZOCfKv//TBlK5b3yv63yP1n5317531H531n5P6Xyf2rlf1flf3fl/7TK/+lYYSwwVpxO4V6XcG96cnwmYAY0W5h6kloZkBl2yXPGxHnm8YblNisYW9CtHf5UubaFh64Ddn9G5Zri9ZrfKSMzjcxK1u6TS4IN0s25zJ8UK35vUi9vZif1KrGUN7NZHqTY9Ux2PQvyZo75PdfIIUYOFfJGu3zOm7gNcnFswMvnn1n5nMPuzwMbHGZ+H25kvpEFk2CDI9TKQS7vkueRE+dZTMfIqyNYniTYdRu7PhLyaqH5vcjIUUYWT0JbktSrs5mFim3J0YptiUv7tSvab5Gi/Y7xxH4divY7StF+xzruy45mbcAx7PpYdr0Y2objzO/jjZxg5MRJaBs6FfPmOMW8WeJJ2Z6iaL/jFe231BP7TVW03wmK9jvJcduwhLUBS9n1Sez6RGgbTja/TzFyamUxx3Xb0KWYNycr5k3Gk7LdrWi/UxTtl/XEftMU7Xeqov1yjtuGDGsDsuw6x67T0Dbkze+CkT4j/ZPQNkxXzJu8Yt4MOM6bAZYHBXbdx677IW8Gze/TjDzLyLMnYW7+HD0bjEo2eA5L6yC7PixifeJ08/u5lpeR51Vs0B7U1kGDOjZJN+cypyuWizbG84xKxTqTFnLpv/Uow70zK/e4066YpytWpjPiY43UwcqcqZgBtuC0BbUnN5KLq6se78BhoTxDubEidxYWRnsjUafgaRaWOlwzdfzTZykW4rOTaoUhzW16dozK3Cz3MxXtoGnTcxqwaT1d3KbnsEZzKrMnt2m6OZf5UzRedmQ0kyuU+gvpvqF8odiXyxaz/elivjCaMYSzg3ljmtGR/EBxIJsbzfZnR/6kyy9Nj+WDoNaRUK96ZuX6XPP/PCPncwM5KH+aK5/nKpa/C5Q7k45gckYhFzhq8C9MOiR8YVIf9yLFwuAq3RexyqWEGzldbtYOmsvs5ynmz8WeVtaLHVXWS5IOCV/ioLJe2uKV1ab70kmurOnm3JjeMN2cU21ML1Mu9F2V/L6MjWLOY9cXJWtrAO3sfge7pj1Ul5v/Vxi5svKbsM8NwT6fYdcLc5X5/3wjVyfd1M2LKmVUe63nGuW1XG1+rtJ9rWL9CZhrU+Z5vmLdvE45zZjWdHMuY+unZr7YOnmNg7JzfdJNH6FddjoVy84LWrzstFdms1p4tq5c76DsvFC57Gjb0ZYZzbGFLTcvdGBHzc3gAXPaPG/Qs2XRJc8XOX7udQMbM9kyS9cvinjm82Lz+yVGhowMC8+9tMt+oNhevtjTSavivvExk9aRpEPCIw4mrcUWn7TadBc9W2FyVVCb5VXytLKWkm4q62jSIeFRB5X1xhavrDbdNzqqrNojgWKFq3bvWky2Zn7bCmuzpi0Y77TLgatRq3K5GqgC8m02vhtHvUT/n2IXdFNS15D0RNziLqpjh1bq1k8I3BQC7TQrFtbMiZ6kuU0xzUs8SXNSMc1LHaVZuyE+yROeJ3vC8xRPeJ7qCc+0JzwznvDMesIz5wnPvCc8C57w7POEZ78nPAc84TnoCc/TPOH5LE94PtsTns/xhOfpnvB8ric8l3nC83me8DzDE55nesLzLE94nu0Jz3M84XmuJzzP84Tn+Z7wvMATnhd6wvMiT3he7AnPSzzheaknPC/zhOflnvC8whOeV3rC8ypPeD7fE55Xe8LzGk94XusJz+s84Xm9Jzxf4AnPF3rC8wZPeL7IE54v9oTnSzzhOeQJz2FPeI54wrPoCc+SJzxHPeF5oyc8b/KE582e8LzFE54v9YTnck943uoJzxWe8FzpCc/bPOF5uyc8V3nC8w5PeK72hOednvC8yxOed3vC8x5PeK7xhOdaT3je6wnPdZ7wXO8Jzw2e8LzPE55lT3hu9ITnJk94bvaE5xZPeG71hOf9nvDc5gnPBzzhud0Tng96wnOHJzx3esJzlyc8d3vC8yFPeD7sCc89nvDc6wnPRzzh+agnPB/zhOfjnvDc5wnPJzzh+TJPeD7pCc+Xe8LzFZ7wfKUnPF/lCc9Xe8LzNZ7wfK0nPF/nCc/Xe8LzDZ7wfKMnPN/kCc83e8LzLZ7wfKsnPN/mCc+3e8LzHZ7wfKcnPN/lCc93e8LzPZ7wfK8nPN/nCc/3e8LzA57w/KAnPD/kCc8Pe8LzI57w/KgnPD/mCc+Pe8LzE57w/KQnPD/lCc9Pe8LzLzzh+RlPeH7WE55/6QnPz3nC8/95wvPznvD8K094fsETnl/0hOeXPOH5ZU94fsUTnn/tCc+vesLza57w/BtPeH7dE55/6wnPb3jC85ue8PyWJzy/7QnP73jC87ue8PyeJzy/7wnPH3jC84ee8Pw7T3j+vSc8f+QJzx97wvMnjni2Ac9W+pb0P0xSmtPNucw/KtqPf4c93aRzWR5/GvjB85884fkzT3j+3BOe/+wJz3/xhOe/esLzF57w/KUnPP/NE56/8oTnrz3h+e+e8PyNJzz/wxOe/+kJz996wvO/POH5O094/t4Tnv/tCc//8YTnHzzh+b+e8Pw/T3j+0ROef/KE55894WkBfeCZ8IRnmyc8k57wbPeEZ4cnPDs94TnFE55TPeHZ5QnPbk94TvOE53RPePZ4wnOGJzx7PeGZ8oTnTE94zvKE52xPeM7xhOdcT3ge4gnPQz3hOc8Tnod5wvNwT3jO94TnAk94HuEJzyM94bnQE56LPOF5lCc8F3vC82hPeB7jCc9jPeF5nCc8j/eE5wme8DzRE55LPOG51BOeJ3nC82RPeJ7iCc9TPeGZ9oRnxhOeWU945jzhmfeEZ8ETnn2e8Oz3hOeAJzwHPeF5mic8n+UJz2d7wvM5nvA83ROez/WE5zJPeD7PE55neMLzTE94nuUJz7M94XmOJzzP9YTneZ7wPN8Tnhd4wvNCT3he5AnPiz3heYknPC/1hOdlnvC83BOeV3jC80pPeF7lCc/ne8Lzak94XuMJz2s94XmdJzyv94TnCzzh+UJPeN7gCc8XecLzxZ7wfIknPIc84TnsCc8RT3gWPeFZ8oTnqCc8b/SE502e8LzZE563eMLzpZ7wXO4Jz1s94bnCE54rPeF5myc8b/eE5ypPeN7hCc/VnvC80xOed3nC825PeN7jCc81nvBc6wnPez3huc4Tnus94bnBE573ecKz7AnPjZ7w3OQJz82e8NziCc+tnvC83xOe2zzh+YAnPLd7wvNBT3ju8ITnTk947vKE525PeD7kCc+HPeG5xxOeez3h+YgnPB/1hOdjnvB83BOe+zzh+YQnPF/mCc8nPeH5ck94vsITnq/0hOerPOH5ak94vsYTnq/1hOfrPOH5ek94vsETnm/0hOebPOH5Zk94vsUTnm/1hOfbPOH5dk94vsMTnu/0hOe7POH5bk94vscTnu/1hOf7POH5fk94fsATnh/0hOeHPOH5YU94fsQTnh/1hOfHPOH5cU94fsITnp/0hOenPOH5aU94/oUnPD/jCc/PesLzLz3h+TlPeP4/T3h+3hOef+UJzy94wvOLnvD8kic8v+wJz694wvOvPeH5VU94fs0Tnn/jCc+ve8Lzbz3h+Q1PeH7TE57f8oTntz3h+R1PeH7XE57f84Tn9z3h+QNPeP7QE55/5wnPv/eE54884fljT3j+xBOe/+AJz3/0hOdPPeH5T57w/JknPH/uCc9/9oTnv3jC81894fkLT3j+0hOe/+YJz195wvPXnvD8d094/sYTnv/hCc//9ITnbz3h+V+e8PydJzx/7wnP//aE5/94wvMPnvD8X094/p8nPP/oCc8/ecLzz57wDNr84JnwhGebJzyTnvBs94Rnhyc8Oz3hOcUTnlM94dnlCc9uT3hO84TndE949njCc4YnPHs94ZnyhOdMT3jO8oTnbE94zvGE51xPeB7iCc9DPeE5zxOeh3nC83BPeM73hOcCT3ge4QnPIz3hudATnos84XmUJzwXe8LzaE94HuMJz2M94XmcJzyP94TnCZ7wPNETnks84bnUE54necLzZE94nuIJz1M94Zn2hGfGE55ZT3jmPOGZ94RnwROefZ7w7PeE54AnPAc94XmaJzyf5QnPZ3vC8zme8DzdE57P9YTnMk94Ps8Tnmd4wvNMT3ie5QnPsz3heY4nPM/1hOd5nvA83xOeF3jC80JPeF7kCc+LPeF5iSc8L/WE52We8LzcE55XeMLzSk94XuUJz+d7wvNqT3he4wnPaz3heZ0nPK/3hOcLPOH5Qk943uAJzxd5wvPFnvB8iSc8hzzhOewJzxFPeBY94VnyhOeoJzxv9ITnTZ7wvNkTnrd4wvOlnvBc7gnPWz3hucITnis94XmbJzxv94TnKk943uEJz9We8LzTE553ecLzbk943uMJzzWe8FzrCc97PeG5zhOe6z3hucETnvd5wrPsCc+NnvDc5AnPzZ7w3OIJz62e8LzfE57bPOH5gCc8t3vC80FPeO7whOdOT3ju8oTnbk94PuQJz4c94bnHE557PeH5iCc8H/WE52Oe8HzcE577POH5hCc8X+YJzyc94flyT3i+whOer/SE56s84flqT3i+xhOer/WE5+s84fl6T3i+wROeb/SE55s84flmT3i+xROeb/WE59s84fl2T3i+wxOe7/SE57s84fluT3i+xxOe7/WE5/s84fl+T3h+wBOeH/SE54c84flhT3h+xBOeH/WE58c84flxT3h+whOen/SE56c84flpT3j+hSc8P+MJz896wvMvPeH5OU94/j9PeH7eE55/5QnPL3jC84ue8PySJzy/7AnPr3jC86894flVT3h+zROef+MJz697wvNvPeH5DU94ftMTnt/yhOe3HfFsA565dF8+X+rPljK5zFA6Ozg8UEjnC8N9A5mBTGGgUMwO5HKlgfxA/+DwYH96MJPPlTKjhcHcaAX7eMU0f2eS0pxuzmW+26Znv5uSfuRzu6L9vudJ2e5QTPP3PUlzp2Kaf+BJmqcopvmHnqR5qmKa/86TNHcppvnvPUlzt2Kaf+RJmqcppvnHnqR5umKaf+JJmnsU0/wPnqR5hmKa/9GTNPcqpvmnnqQ5pZjmf/IkzTMV0/wzT9I8SzHNP/ckzbMV0/zPnqR5jmKa/8WTNM9VTPO/epLmQxTT/AtP0nyoYpp/6Uma5ymm+d88SfNhimn+lSdpPlwxzb/2JM3zFdP8756keYFimn/jSZqPUEzzf3iS5iMV0/yfnqR5oWKaf+tJmhcppvm/PEnzUYpp/p0naV6smObfe5LmoxXT/N+epPkYxTT/jydpPlYxzX/wJM3HKab5fxXTnAye3uPzzUqCTzByopElRpYaOcnIyUZOMXKq1WckYyRrbWIkb6RgpM9Iv5EBI4NGTjPyLCPPNvIcI6cbeW7FBs8zcoaRM42cZeRsI+cYOdfIeUbON3KBkQuNXGTkYiOXGLnUyGVGLjdyhZErjVxl5PlGrjZyjZFrjVxn5HojLzDyQiM3GHmRkRcbeYmRISPDRkaMFI2UjIwaudHITUZuNnKLkZcaWW7kViMrjKw0cpuR242sMnKHkdVG7jRyl5G7jdxjZI2RtUbuNbLOyHojG4zcZ6RsZKORTUY2G9liZKuR+41sM/KAke1GHjSyw8hOI7uM7DbykJGHjewxstfII0YeNfKYkceN7DPyhJGXGXnSyMuNvMLIK428ysirjbzGyGuNvM7I6428wcgbjbzJyJuNvMXIW428zcjbjbzDyDuNvMvIu428x8h7jbzPyPuNfMDIB418yMiHjXzEyEeNfMzIx418wsgnjXzKyKeN/IWRzxj5rJG/NPI5I//PyOeN/JWRLxj5opEvGfmyka8Y+WsjXzXyNSN/Y+TrRv7WyDeMfNPIt4x828h3jHzXyPeMfN/ID4z80MjfGfl7Iz8y8mMjPzHyD0b+0chPjfyTkZ8Z+bmRfzbyL0b+1cgvjPzSyL8Z+ZWRXxv5dyO/MfIfRv7TyG+N/JeR3xn5vZH/NvI/Rv5g5H+N/J+RPxr5k5E/G7GVLWGkzUjSSLuRDiOdRqYYmWqky0i3kWlGphvpMTLDSK+RlJGZRmYZmW1kjpG5Rg4xcqiReUYOM3K4kflGFhg5wsiRRhYaWWTkKCOLjRxt5Bgjxxo5zsjxRk4wcqKRJUaWGjnJyMlGTjFyqpG0kYyRrJGckbyRgpE+I/1GBowMGjnNyLOMPNvIc4ycbuS5RpYZeZ6RM4ycaeQsI2cbOcfIuUbOM3K+kQuMXGjkIiMXG7nEyKVGLjNyuZErjFxp5CojzzdytZFrjFxr5Doj1xt5gZEXGrnByIuMvNjIS4wMGRk2MmKkaKRkZNTIjUZuMnKzkVuMvNTIciO3GllhZKWR24zcbmSVkTuMrDZyp5G7jNxt5B4ja4ysNXKvkXVG1hvZYOQ+I2UjG41sMrLZyBYjW43cb2SbkQeMbDfyoJEdRnYa2WVkt5GHjDxsZI+RvUYeMfKokceMPG5kn5EnjLzMyJNGXm7kFUZeaeRVRl5t5DVGXmvkdUZeb+QNRt5o5E1G3mzkLUbeauRtRt5u5B1G3mnkXUbebeQ9Rt5r5H1G3m/kA0Y+aORDRj5s5CNGPmrkY0Y+buQTRj5p5FNGPm3kL4x8xshnjfylkc8Z+X9GPm/kr4x8wcgXjXzJyJeNfMXIXxv5qpGvGfkbI1838rdGvmHkm0a+ZeTbRr5j5LtGvmfk+0Z+YOSHRv7OyN8b+ZGRHxv5iZF/MPKPRn5q5J+M/MzIz438s5F/MfKvRn5h5JdG/s3Ir4z82si/G/mNkf8w8p9Gfmvkv4z8zsjvjfy3kf8x8gcj/2vk/4z80cifjPzZiB1YJIy0GUkaaTfSYaTTyBQjU410Gek2Ms3IdCM9RmYY6TWSMjLTyCwjs43MMTLXyCFGDjUyz8hhRg43Mt/IAiNHGDnSyEIji4wcZWSxkaONHGPkWCPHGTneyAlGTjSyxMhSIycZOdnIKUZONZI2kjGSNZIzkjdSMNJnpN/IgJFBI6cZeZaRZxt5jpHTjTzXjluMPM/IGUbONHKWkbONnGPkXCPnGTnfyAVGLjRykZGLjVxi5FIjlxm53MgVRq40cpWR5xu52sg1Rq41Yr81b7/jbr+Rbr8/br/tbb+bbb9J/RIj9lvK9jvF9hvA9vu69tu19ruw9pur9num9luh9juc9huX9vuR9tuM9ruH9puC9nt99lt49jtz9htu9vto9ttj9rte9ptZ9ntU9ltP9jtK9htF9vs/9ts69rs19pswZSP2Wyb2OyH2Gxz2+xb22xH2uwz2mwf2ewL2rH57Dr49Y96e327PRrfnjtszve152fYsanvOsz1D2Z5PbM/+tefq2jNr7Xmw9qxVe46pPSPUnr9pz7a050baMxlfY8SeJWjP6bNn4Nnz5ezZbfZcNHvmmD3Py56VZc+hsmc82fOT7NlE9twfe6aOPa/GngVjz1mxZ5jY80Hs2Rv2XAt7ZoQ9j8GedWDPEbDv6Nv33+275fa9bftO9F8Yse/y2vdk7Tuo9v1O++6kfS/RvvNn36ez76rZ98DsO1b2/SX7bpB978a+02LfF7HvYtj3HOw7BHbcave+233ldp+13cNs9+Hafal2n6bdt2j38dl9bXaf14+N2H1Adl+M3Sdi903YfQT2ubp9zmyfu9rnkPa5nH1OZZ/b2OcYdl3frnPbdV+7DmrXBe06mV03susodl3BzrPtvNPOw+y8xI7T257u8gO7z9i6E4KaqzQHQbLib/fl2n2qdt+m3cdo9/XZfW5235fdB2X3Bdl9MnbfiN1HYfcV2Ofs9rmzfQ5rn0va53T2uZV9jmOfa9h1frvubdeB7bqoXSe062aLjBxlZLERO++281A7L7PzlOOD8W4qu55R+T/3p8877PYvvflsHu7Uyv9Xv/XID87/adv13C8d4VeI8OuP8Luk8v+M479x3ZsS5d9yv6sr/3+1+Jhlsy57KtlVd31IGjor//sq/7sq/9sq/22e2fxaRmlqci7XxXC18QfShUJXMNYp8891BbVy7Mo+hOkA/6k90tadVa7hY1qs66n8TjBbUhxbNxYEtesjWBzrzmbYCfA7R9BLfueWZR7Wncf82sHvfObXAX4XML9O8LuQ+U0Bv4uY31Twu5j5dYHfJcyvG/wuZX7TwO8y5jcd/C5nfj3gdwXzmwF+VzK/XvC7ivmlKveo7M0Man56dTNfIPxZDvBN1XlqPxLyJ13W3jYfqU22Np5dub6xtPrMlStWrxoaWX3+ijtWD60YKZFJCKYNfifhdzv87oDfnfB7CvyeCr+74Hc3/J4Gv6fD7x74PQN+98JvTC+ZkN9v1CUc+iXgXiIkbo/g3wZ+Uc0fb4bbwa+d+XWAXwfz6wS/TuY3BfymML+p4DeV+XWBH+9Wu8Gvm/lNA79pzG86+E1nfj3g18P8ZoDfDObXC369zC8FfinmR+VvGktbe7nmr9Vs9A+k01Q2khX8jmBs/Q5AfweEp6EctzP9b+Z1u9H+ocxobmh0qDBULOZHhmYBvnVtzE403vN7CJfvPziEi3ZaQziqp/aa10XrGh3CuUwzHzq0O8A3Ljs7CG/vqTyeWQ6qLqbeTD3FNCw5rIKXFHjwetbBwkh5Hgj3EkF4H4g6kgIepbsngttE+1kf2vcjK7/3d/t+VOX6YPse6XKO29+s47ZIbN+jxqFS+451zjpq07Htx6khb98J22WfacpEn+M8y8wOotsga4f5Qc1xO3cE4W1bB4Q9pPLfjvFnh+B1BvXbymRIPOonugSMQNFeUW095yG1+z617Ysqv/d32z6n0sn43bYPjhxs26Mdte1PlsfiB0H9tp3iSG37yyt+U4NaO26v11SupfZCO99d9Q/WzQ7C20wcn+vqzlbL9FlO8NNFwqf+ORiDnckN9OWyA33ZbLGUHir29Y8O5vrTueFCbnBkOJPOFbIDxf6hXDpdypVG8uli32ChWBoaLORGh4cG+wj7HBE7Vxo2UIWhvoHhzOhQ32h6ON8/YFqt/v7iUHEwX+ovpIuZkb7MSDYzOjAwVCgMjRQGM5nR0mBhdKCKfa4bu2QJ/zwn+Lnqo6LzRds05MbN8wibP35QPHqpin+hG/xqP3GRG/xq3l7spuxU+dPjmCbydpwj7EvdcM8R/mVu8EcJ/3In+Jmqfa5wwz9P+PzxVsKB/a9yg18tm893g1+tW1c7sX+uav9rnOBnhgn/2gp+wLAzA7lstj9nt5wPFNOZfHEkO2B6xuF8eiQ9NJItDeYzg6P5bD43UhwZHsgPmFF4enRoZHB04Gl0wr5OwK5HrB5zwr6+7CJfc9X+9gWNc6/nqn3hC8OxJ2x6wr5BwM4O5UbSg6PpocLAUH9poGCGMWlzMTxQGu3LDg2bAU22mMlkSnnzJ1sq5geHi32Z4b5Sf7YwbNRVbf4iZnPFslgd+71YGb9vKD1Y6uurroW9RBl/eLivf8jYk/CHlPFzI32l0Vx/ta0ZVsYfKuRHRwu5IcIfUcYvZNKlQra/WjaLyviDw+lC38BAtfyUlPHNeDxXHByqtpWj2vYZLqVHiplBmkveWMEnHdaR7puUdVfcIK5tBcHYuXIA+ruBq/aYMgH6OB9uH9zWdHN5PNeU4MfbGPRLCvdIj4T1EkWsIUWsYUWsEUWsoiJWSRGL6rXbupav9qM3O8HPDRD+LU7w0yXCf6kL/ExtbLec4Qd6/Kv4tzL8hAP8FW7sX8Vf6cY+1TnTbRV8F9i3u7FNdQy2yg1+dV5whxv86hh1tRv8attwpxv8QcK/yw1+dYx6txv86hjvHjf41THqGoav1/Zkq23DWif4uSr+vW7wq+3DOif4+Sr+ejf41fWaDW7wq+3bfW7wq+1b2Q1+deyw0Ql+oTrH3OQEv69afja7wa+uh25xg18tn1vd4FfL5/1u8Kvlc5sb/Gr/+4Ab/Gr/u90NfrX/fdANfrV/3OEGv9o/7nSDX33+u8sNfrV92+0Gv9q+PeQEv7/avz/sBr+6hrnHDX61/dzrBr/afj7iBr/afj7qBr/afj7mBr/avj3uBr/avu1zg19t355wg19tf15WwQ8mjp3DG7S3cm5lM6S0f0txrJXGd7NIB9fN381SfFZUjLNezfV3A1cX69VcH/FB++De006Ba0rwwzzsFPR0CnpSgh+O/ZrBelgR635FrN2KWJpp3KmItV0Ra5ci1jZFrDWKWJq216xDe1oUa5MilmaZ0LS9ZvnaooilWbc1y8RmRSzNNvpRRaxW7R9pTO12bJXu6xF0k5PenedjKnRJ+M15P/Ue0OwaLoYjNz2oPZO9Y82KkUtWri7dEUREsO7ssny/1YyXAL+pMdIQBPUNe2oMw0qHK+AhCR1C3ISAJW0WwcLMbR52wAPHoLzCgfCyyu90Uy6Ti5MOrn+yJhFSIyFNIsg+U9zYJ5sAfM5nimAf6fAMnneJoFaR+cvVPPwUlkYenl9TfH7vu5X/qWB8PeLnBKFfUrhH9rXc/xbShofLBIHrfMhn4pZT0t8duKw3tXIqlQupM+sKxuez5oaaOPkqtW1dgh9h0QY3Xk55+KksjTw8v6b4/N7PKv9TwfgyjeW0S0gPv8fL6Y8r110h6VlW+Z1uyvX3S/0U1gNuJ80NwnHrAenvDlyWu1o9kPJJak+kQ4Iobkrww0WfbkFPt6AnJfjhQLQZrN2KWJsVsbYqYu1pUaztili7FLG2KWKtUcTaoYilWe5b0V5R/WCjWNZpltW9ilgPKGJpllXNNG5SxGrVur1PEWutIhY9PMRxJuEHQW2shP39ssrvdFPu6bkb10fp4Pe4/m7gqsunNlaS7CqNack+09zYp8pnmsBnmmAf6aBGnneJoLbWwucMPPw0lkYenl9TfH6PTl5JAaZ1OGeYLqSH3+NzhiWJsWnDg0+tm4x84PqIN7/H9XcHLutNOrJcSPW/Kxifz4r2ScfJV85XOjSU550VOpCKl1MefjpLIw/Pryk+v3c6lFNeprGc9gjp4fd4OR2AcooH8lrnNB8yo7HLKenvDlzWm1o5lcrFNMGOXcH4fFa0TzpOvnK+0gG2PO+s0GFpvJzy8D0sjTw8v6b4/N5FUE55mcaXgmYI6eH3eDk9p4LbFZKeZZXf6aZcIS/lpR5+f6ZHSCfWM25rvXKdi13PSH93ML5cuKhnvcAnrBxIByxT3JTgh2UkJehJCXpSgh/Oa5rB2qqItUYRa7Mi1g5FrE2KWNsVsXYqYmmWiS2KWBsVsfYoYUntczO8HlbiZd1eRSzNur1PEUuzLdSsj7sUsTTz8QlFLM0yoWl7rbodKKdRs0zsVsRq1XZCk9eBMGY62KftP9tr1sf7FbE00/hYi/LSHE9ophGfD+AHoqzrCsbXPcV5dikB+igd/B7X3w1cdfnU5tmSXXsFu5LtZgpcU4IfzrNnCnpmCnpSgh/2Gc1gbVXEWqOIpZnG7YpYuxSx9ipiadp+nyLWwXxsDOsJRSzNMrFFEWu3IpZm+7VHEUvT9pplVdP2rdp+bVHE0ixfOxWxNPNRs3xp1iHN8vWwItYmRSzNNGqWVc36qJlGzfFEq+Zjq47lHlPEatVxjuYY8+B44plRhzTbCU1eWuXLXuO6ajO8HlHiZZ2m7TXHANTX4n43wrfO7RpaNvYeW1xDc7IHq84amrS3risYXw4V7ZOJk8+cL+XlLMGPsOhDj3xPGA8/k6WRh+fXFJ/fW1YxSgowrcM9YbOE9PB7ZF+7J+y0yo+ukPQsq/xON+cGcD2UdHDd3E6K5S7WxwO4/u7AZbmr1QMpn6T2hWw3W+CaCsaXHSwPswU9swU9B7FaC+sqJayoNoz8resS4mm3t1wfpYPf4/q7A6ftQibKrlJ7SfaZ48Y+1T3KcwQ+cwT7UF7OFfwIiz5CzPsjHn4OSyMPz68pPr9XhP5oLguLdWCukB5+j/dHL2obmzb8cLJ1bvMh/jsfpL87cFlvauVUKhdS/e8Kxuezon3ScfKV86W8PETwI6xDK795OeXh57I08vD8muLze6ugnPIyjeX0ECE9/B4vp8srP3qD8PoZpz5zXKndRhvyeFgfnOR3ppSOWx9If3fgsn7W6sPcmHYl+xzixD7F0Tjlh/OlvDxU8COseZXfvD7w8IewNPLw/Jri83uboT7wuoP14VAhPfwerw/rod3meYPl1Ek+pNOjccsp6e8OXLaTtXIqlQup/+sKxuezIp9SnHzlfCkv5wl+hHVY5Tcvpzz8oSyNPDy/pvj83h4op7xM47t684T08Hu8nO6A+S6mZ1nld7opV8pIeamHP5TuEmyth58d7BLySw9/eIDwD3eD30f4853gD1Tzd4ET/ELVPke4wS8S/pFuyk+V/0In+Lkc4S9ygl+q8j/KCX6+ir/YCf5wtf4e7QR/sFr+j3Fjn2r+HusEf7RA+Me5sU+V//Fu+Ffb/xMZvuZaBOEvdYKfzpE9lgQ1lxTSRPppLHICC58I+U9Y6Ee6ugHL1bhPShvnj/O+JYwPt0EY1pIGsboEPxd5emJEurn+ngiumA7r8AycidrEui2KWGVFrIeVsKSxbTO87lXkdagSL2n82wzWYYpYSSUs6/Bjfc3wOlyJl72e36JYCxSxjlDEOlIRa6Ei1iJFrKOUsKzDjzQ1w2uxIq+HFHkdrcTLXh+jiKXVd9jrYxWxjlPEOl4JyzpcO20VLHqG7Ha9Kz/odr0rN+R2vStfdLveVci5Xe/K97td78qP0Fid+kPSwcsW79/05hX52O+Ckv5u4KrLpza/OxL4oH1w/85CgWtK8MM6ulDQs1DQkxL8cC9vM1iPKmJtUsTaoYi1XRFriyLWGkWsnYpYWxWx9rQolmZZ3aaIpWV7qd9ulbKqWR/3KmK1an18RBFLsw61qu0fUMTSbCc0+1rNNlrT9pr2atXypTk20cxHTdsfCO3EPiUse41z2GZ4bVDkdZgSL00s69aV9XgdrshLy/bWbVTE0iwTuJbeDFZSCcs6rTJhXVkRa70ilmb50uSlVVZbuS2crshLs6xq5qNmu9qq9tIsq7i22ip1W7P9ekIRS3P8db8iluaawlZFLM25whZFLBrf0zr2AuaXqPx3+wwgPeFnAAvc8Il8BrBAsKu0H1aRTzFOPnO+lJeLBD/COqrym+/t5+EXsjTy8Pya4vN7r6tkXAowrcO9/YuE9PB7ZF+7t/8VybFp43mD5dRNPsT/Bizp7w6c1ptMVLk4UrCjVC4obkrwwzH9IkHPIkGPlPe4960ZrN2KWJsVsbYqYu1pUaztili7FLG2KWKtUcR6SBFLsw5p5uOjilibFLH2KmJp1m3N8qVZhzTb1QPB9jsVsTTbaGoLpfeoFMcfaek9J0X86jsHR0XYguvHvTjkL/0nLPQjXd2ApZy2TFTaouZuRzE+i9h1GNZRDWJJ78a5yNNFQXi6uX637wIWsm7fBSz0uX0XMD9KZf5oZs8E2O5YJ3k5EPssFdLfDVxd1aljgQ/aB+dDxwlcU4If7t07TtBznKAnJfhhv90M1qOKWJsUsXYoYm1XxNqiiLVGEeshRayHFbE0bd+qZXWvItZWRSzN8qXZ5uxWxDoQbL9TEUszjXtaFEuzbm9TxNKyvb3GfbmtUlZbdQygiXWw3z7Yb7tsVw/22wf77YP99jOv37ZO016tWlYfUcTStJdmm6Np+wcUsTTrkGa/3aptdKuOJzTTqDn21cxHTdsfCO3EPiWsRDB+f04zWIsUsbTWye31UUpY1uHe42Z4TVfktUGJl3UbFbHKSlj2enGgh/VMt729xncnmsE6TBHrcCUs6zTtdYwSL82yap1mHWrVct+qaXymt4WavKw72Hf433dYd58Slr3W3POgZS97PV+R13pFXlp9rXWa/aOmvVqx77DuCUUszTnf/YpYms90tipiaa5PbFHEwvfb+N6wROW/dF681bOs8jvdnCsmQB+lg9/j+ruBqzKfTJRdjxXsKp13r8hnJAH4nM/xgn0oL08U/AiLzsnk77fx8MezNPLw/Jri83t/bn/6fwowrcP326Sz0vk9sm+nkf9pH5s2njdYTt3kQzb2+22kvztwWm8yUeVCqv9SuaC4Un5hvx83vySs7YpYexSxNiti7VbEelQRa6si1sMtymuLItYaRax9ilhrFbGeUMTStNcuRSzN+rhXEUuz3Gu2hZr5eL8ilmabo1kmdipiadp+kyKWJq+HFLE0y4Tm2ESz39bMx1ZtvzTLl2Z9bNU2WhNLs3xtU8Qi29N8hc9vEpX/XRAvEajO9fIJ0Efp4Pe4/m7gqsunNteT7Hq8YNdGvi9GXOma+3E9k/0dL+t2K2JtVsTaqoi1p0Wxtiti7VLE2qaItUYRS+vbSNZtUsTSrI97FbE0y5emvXYoYmmWL806pNmuapYJzXa1Veu2Zn3UrEOPKmJp1scDoXztVMTSHANQX9tb8ePjbX4eCffjeqLG/Dw+hesR4iUq/7uAXyLQHGMPxj6vg/R3CzZxMeZfEtOuZLulAteU4Id7V5YKepYKelKCH/ZNzWA9qoi1SRFrhyLWdkWsLYpYaxSxHlLEelgRS9P2rVpW9ypibVXE0ixfmm3ObkWsA8H2OxWxNNO4p0WxNOv2NkUsLdvbazyvo1XKaquOATSxWrXf1rS95hhAs43WHE+0alk92G/vvz7t4Ji8MayDY/L9V74Ojgv3X/lqxXGhdZr2atWy+ogilqa9NNscTds/oIilWYc0+45WbaNbtU/TTKPm2FczHzVtfyC0E/uUsBLB+D1OzfBap8hrkRIvez1dEUvz+ZCmveYr8tqoxMu6shKWvV4c6GFplQnr8N3mVrC9Zt3Wro9adcheH6WEZZ1mfTwQyheeN9QM1mGKWIcrYVmnaa9jlHhptoXWabbRrVruWzWNz/S+VpOXdQfHJv73Hdbdp4SlOZ6wTste9lpzTL5ekZdWX2udZv+oaa9W7Duse0IRS3NN4X5FLM3nVlsVsTTXv7YoYuF5Q9OZX6Lyn/b58rbO6llW+Z1uymVinzdE+ruD8X2VHp/aPt9DgvF2nS7YlWx3qMA1Jfjh3PhQQc+hgp6U4IfPfJvB2q2ItVkRa6si1p4WxdquiLVLEWubItYaRayHFLE065BmPj6qiLVJEWuvIpZm3dYsX5q8NPNRk5dmO6FZJjTzcacilmZ7T+0qja1wTLCs8jvdlCsUaGzCxzKJYKxuHJvo6M4MJEBfEMjjOtLfDVx1+dTGdVK+cfvguG6ewDUl+GEezhP0zBP0pAQ/rJvNYD2oiKXJa7cSlr2eEuhgaadxjSLWTkWsPYpY2xSxNO21VxHrcUWshxSxtipiadp+uyLWFkUszTTuU8Raq4hF63w4trBuWeW/6Q5zA3257EBfNlsspYeKff2jg7n+dG64kBscGc6kc4XsQLF/KJdOl3KlkXy62DdYKJaGBgu50eGhwX63Y4fCYFcg9686+JkM4R/mBj9L+Ie7wc8R/nw3+HnCX+QGv0D4R7nB7yP8xW7w+92efZAZIPylbvCr9eskN/hDhH+yG/wi4Z/iBr9E+Ke6wR8l/LQT/Gya8DNu8KvtZ9YNfrX9zLnBr7afeTf41faz4Aa/2n72ucGvtp/9bvCr7eeAG/xq+znoBr/afp7mBr/afj7LDf4w4T/bDX61fX6OG/xq+3y6G/xq+/xcJ/i5avu8zA1+tX1+nhv8avt8hhv8avt8phv8avt2lhv8avt2thv8avtzjhv8avtzrhv8avtznhv8EcI/3w1+tX27wA1+tX270A1+tX27yAl+vtr+XOwGv9r+XOIGv9r+XOoGvzo+vMwNfnV8eLkb/Gr7eYUb/Gr7eaUb/Or48Co3+NX2+flu8Kvt89Vu8Kvt8zVu8Kvt87Vu8Kvt83Vu8Kvt8/Vu8Kvt8wuc4Beq488XusGvtv83uMGvtv8vcoNfbf9f7Aa/2v6/xA1+tf0fcoNfbf+H3eBX2/8RN/jV9r8Y1FwNO1caNo9CCkN9A8OZ0aG+0fRwvn8gNzTa318cKg7mS/2FdDEz0pcZyWZGBwaGCoWhkcJgJjNaGiyMDlS5l0TsZlztucWoC7tkRqvtwo0MP6HGf6CKf5MT/HS1Xt3spNzU+N/ixP7Farv/0kC57GTSafvdzgcrGyXo/OjlLB0dkCe3Vn7TN0mtW1GuhVnO/Hn4r3Q//d/q213R18NsFTA91lGa213Y1DzrSIC+IJD3IZH+buCqy6e2D6kd+KB9cB9Sh8A1BX7W4XPpDkFPh6BHwnpCEWuNItZDilhbFbF2KWJtUcTaroilmcZtilitWr42KWI9rIi1VxFLs3xp2muHIpZm+dKsQ7sVsTTLhGa7SvsVu4LxfaFe39xX3S9dCsY78uNj7wT43cjCn1OuhUOXhN88TVONPHd2DRfDIR8+bhpl+GFjBuvIjp3MX3OMQ/hdbvBzZPupwVibYpq6QmxF/tJ/wkI/0tUdjLe7i/GhlDbOH+vLVMaH2yAMa2qDWF2Cn4s87YxIN9ffE8FVSgfOb6T2SBp/U/iuCF48fK+gm+KSDbuZn6INs1E25HWR9E9nPIul4TtvvGglb8Kq8bkdyG7zINzF5ZodsAxODcEK4Pc8uJdkeNy5nTPu336A0tRoP8BtOwp+E233rMO2AW1unc3rX8LaQlJIE5ahsLWFJPPn4X8zpabv3yvX05jO6RE6e4A3D2/dxeWx4WewtCWFMNOBI4X/XYWXzb9LK/kn2Y74dEH8Z1JZpjQ1WpZ5PiI3wqSyg3kbli9tU2tcrphd44z6eiLSQb+Lgj7inoKw1lEez2T3Fde4Yn8rjfR3A1flfqg6hpkJfNA+1LZYG06rXC9fOVQ8c+i2O+5cXmoDU/ayaw6fAjgKw8Nyl2KUgpBwmO3WXV4eHw8dmbI3GF+tU6CL4yeFe9j0pgRuVMzJNidUirlttnor1z2BXIyt6wrG21axKIzELZqkvztw2RzWimYv8AmzPdnHUVUZTgTjq0VS0El8KS9nCn6ENavymzeRPDyvLzw8v6b4/N4RlfKUCsZX70vKYzlIVZ/fI/vacnpoBbdXSM8MSJuUb70CbkqIjzbk9Xh5eaxfh5A28uuM8Jsa4dclpIv8ulm8FRBvmoBpOayeWsMLsw0vVzR8kdqmsLY1DOtcwOLxZwLWrDpYlwIWjz8LsGbXwboCsHj82YA1pw7W7YDF488BrLl1sFYBFo8/F7AOqYN1B2Dx+Hgk3aF1sFYDFo+PnxCbVwfrTsDi8fHI1sPqYN0FWDw+HiN3eB2suwGLx8cjW+fXwboHsHh8PEZuQR2sswCLx18AWEfUwboFsHh8itsjYOE44Eh2f3+MA0h/N3B1NQ44MhhvV24ffAy7UOCaEvyw3Voo6Fko6JGwZitizVHEmquIdYgi1qGKWPMUsQ5TxDpcEWu+Iha2W/X668vKT/+P6q8pHi+7PFyShZH6aI4RNh7gczZ+/4gY6eH30DZHhOgL48dtQ/PNqPFHL8STOKfq6IniTOGkMfPK8lg/vsSO41u+HIzjcL5UPhP8uoR04ZiZ5yuOmbnd+Ji5A9Jzd+W+2+W4dJqXvzBb4bqE9D8I4i3XSkvurvW0TZIeTM8MRT0ci5Y9998SX7oUJx1cv+slPrLF7AhbzHGiOx97uXMO2GK2I1tQWaw3b8NHitLcTOpL+PLojaXV5iHdGWuuGrpxCgvKm1Wk0wPhZsLvWSG0lkG4OfCbhn/Ig2Nxhzyill8l/VIzQtcdwn3rpGktLsNK2SadCCctwx4SoWd2k3pmC3rcnryTdnwyTu0pv7SUwNNE+qNOMIzbDJCuyTphUEpbVD5LJwxGYcU9FY+w3J6mVMvTqJMVuf5GT1bkT4t5O3d4ZWxoh3VvgEcdUlvhdvdYri9ueST9k7XTPO5OF2moTnFT4GcdfklD2nXSKeiRsHYrYj2iiLVLEWuLItYaRSzNNGrmo2YaNytiaaZxpyLWQ4pYOxSxtipi7VXE2q6IpVkmNOujZh3SLBOa9tqmiLVHEUvT9vcrYmna/mFFLE17abaFmxSxNO3Vqm2hpr0025wDYcykWSY0+20t29trPO29Vcq9pu0fUMTSLPeaadRsJzTHAJr22qeIFedtbGleT+GlN1ikdakD5Q2WAoTTeIOlAPeSgfwGi8X+JZyOgG+/WOd2PTaXTYA+TGMA+ruBq3L+V9espO1h0ron2e5wgWtK8MMvYUtbxw4X9KQEP+y3m8HaqYj1kCLWDkWsrYpYexWxtitiaZaJXYpYaxSxNMuEpr22KWJp2ut+RSxNez2iiKVZVrcoYh0I+fiwIpamvTT7oU2KWJr2atV+SNNemu29ZvnSbHM066NmmdAcM2nZ3l7jGkyrlHtN2z+giKVZ7jXTqNlOtOr4a58iFq3BSK8S4SsM0hz2sAg9PP5hMbCk+TCFl149ilrrkV49orUHR6/gZKPyQ3p9aSJrPWS3DITDtR7ets0PwQrgdwbuha314L6lXZWFLLKvo/1o4lZz3K/I94zivshGX7Xl8Xsj9MxuUs9sQY9bWzZ+iga+NsFP1MVXHG5iWPwUFHRJ+M3Ta+vF8xs4YYPnx2gIZocQNgF+FPbVXTUeQxUebvcdTl6enFuuhUMn5Qml19qi2GSe4P5Xzlt6XTrOa9zSa/gpIf7MCD3HNqnnWEFPjxAvEfKf9OA91CNxjlpvn6gejkV12O3afePlH+3Myz/uzeUndOMpejczP/4cCJ1UN8gWtm68JUbdcPu8afJsiK+8cRvyuo1OsiHZIq4Ne4PxNsS63SukQ6r3HGMi9V7i0Gr9xGzw43k8B/x4Hs8FP57H+LyKnyCfAL+XMr9O8OMntuNJiLcyv27wW/H0z3F5ja5ef/btBvozXm7i9GfSESqE6/aVslwuTrvP9XcDV10+teeg0ivC0smdZLu5AtcU+Fm3vlwLh35J4V5bBNZ2Raw9ilibFbF2K2I9qoi1VRHr4RbltUURa40i1j5FrLWKWE8oYmnaa5cilmZ93KuIpVnuNdtCzXy8XxFLMx812y9Nez2kiLVJEUvTXpp1SHM8oWmvHYpYB9vV/deuatneXuNz0FYp95q2f0ARS7Pca6ZRs53YpojVquPVexWxaLxK8fgcnz+zdHyOQfWrooe7wa+ekxD1LJfrxzk9+Uv/CQv9cN/2XDdpi9y3HVUO+Np4nCNCD2sQa3+eZ8JtjeeZSFyldMxRtEmcL6BIa0uN5m3Uka2O61h1T8GcCDtx/c28P5KFcPScsC0Yn3fzQrAC+J2Fe2F7CnqD8XnaFcKT9OI9LCs8fkeEnu4m9XTH1JNqUk8qpp7ZTeqZHVPPwfwZq2d/5g+1w/zMInpua5+53NUt6+RH6vOzmnDPBIV/J/sa7pru8DQmIf28naCjCN1+gavx52RoyxuF9CQELOkZE6Wp0S/F8Hf0ODeOGfalmE7mz8Pf313j8on5MmaCYfJ3FfErQlRnO4NaunkY5EDhH2Qc6CtCiNkekq6pIZivYWVxV7eMGQiYUrq6IV3IoQs4UPg9LF2fZmet8zD0m5eT28pjuU0TdAUh97BNmxbiF6W3Xlx7zb8ihH5YVtBePH6YTbGsUPgnI8pKp8CBpxfzFTlgmO4QDq8SOPBjK0dW3ram8lWfABx+nKwDfmNWYhZ0Cjhhjsxg47ymW8bh4chh8eNd8VRBR3cIRx7Xmoeyt1haXlpdCjFQG4B1hChrC2Tn9mufbvoNaX8Fb3vRSX0KpdfG++z8Gi6GI8ffyT44rprYuAqxpPGSdTeVa/48/EdZO/L1+TJmWwgmfUYmqk+T9iZReGnOGDXm5uUR5+mSbm5LbHfnNsi13npDF3CV5qJxuZ47yVw7GuTaLejmfY9pXG++q7TqkpWrq6doBwKNAK6x38Ew2F9MDaE6HcL1wm88Vhmb91nwe5rAT3LIWeKSDOo7qqJkqy+yKvrNkCoaBHIVpWKP0y8el0+/qEjcJYQjnXdDenh4rpPC38P0SEOcuyDdFP7rwhAnJXAiPl0QX7fb7R8kG64JxjvyWxuMTTv3u5eFP7tcC4dO6lopTdYWpzYwXeP5iNwIk3cZPG/D8uXvWL7ghz25vruD8HTQ76SgD21J/tZRHt8LGMsqv9NNucJQAvQFQSAu85P+7mC8bV0s898LfNA+UjMc8WHPNeyaw18HcBSGh+XuOkYpCAknZfuhQjx0ZMoO4PwnNqv+OTRbvOrj94g5h6RwD0db7QJ/SU9nk3o6Y+rxOT24m9o6/ADkrUJacTe1dfixxpXMDz8AeVswPl3kd3sE5qoIzDsi/FZH+N0p+FlO906vccTuRarq+FFJnndh9ToM61zA4vHvBax1dbDwo5I8/jrAWl8HCz8qyeOvB6wNdbBuBywefwNg3VcHCz8qyePfB1jlOlj4UUkevwxYG+tgrQYsHn8jYG2qg4UfleTxNwHW5jpY+FFJHn8zYG2pg4UfleTxtwDW1jpY+FFJHn8rYN1fB+sswOLx7wesbXWw8KOSPP42wHqgDhZ+6I3HfwCwttfBuhywePztgPVgBJa9xredePwHAWtHHazDAIvHp7g9Alai8p+GkzvZfb3hWyb2Wy6kvxu46vKpDSd3BuPtyu2Db7nsErimBD/eF3E/rmeXoEfCWqOIda8i1jpFrPWKWBsUse5TxCorYm1UxNqkiLVZEWuLItZWRaz7FbG2KWI9oIi1XREL+7Kocb29ph1SUeN6isfbM1zuSkIcHp5jhM0bkoE8H9gRIz38HtpmR4i+MH7cNvTgutl5ir1eBFgTnafY66MAa6LzFHu9GLAmOk+x10sAa6LzFHu9FLAmOk+x1ycBFo+PbXu9eco15bFYPH6j85QXAdZE5yn2+uRgLNZE5yn2+hTAmug8xV6fClgTnafY6zRgTXSeYq8zgDXReYq9zgJWM/OUHGBFzVN21sHKAxaPvxOwdtXBKgAWj78LsHbXweoDLB5/N2A9VAerH7B4/IcA6+E6WAOAxeM/DFh76mANAhaPvwew9tbBOg2wePy9gPVIHaxnARaP/whgPRqBZd2Z5bFYPP6jgPVYHV7PBl48/mOA9XgdrOcAFo//OGDtq4N1OmDx+PsA64k6WM8FLB7/CcB6WR2sZYDF478MsJ6sg/U8wOLxnwSsl9fBOgOwePyXA9YrIrCsu7o8FovHfwVgvbIO1nmAxeO/ErBeFUSn8cxgLBaP/yrAenUdrLMAi8d/NWC9JgLLupvLY7F4/NcA1mvr8DobePH4rwWs19XBOgewePzXAdbr62CdC1g8/usB6w11sM4DLB7/DYD1xjpY5wMWj/9GwHpTHawLAIvHfxNgvbkO1oWAxeO/GbDeEoFlHe3m6hXivwWw3lqH10XAi8d/K2C9rQ7WxYDF478NsN5eB+sSwOLx3w5Y76iDdSlg8fjvAKx31sG6DLB4/HcC1rvqYF0OWDz+uwDr3XWwrgAsHv/dgPWeOlhXAhaP/x7Aem8drKsAi8d/L2C9rw7W8wGLx38fYL2/DtbVgMXjvx+wPlAH6xrA4vE/AFgfrIN1LWDx+B8ErA/VwboOsHj8DwHWh+tgXQ9YPP6HAesjdbBeAFg8/kcA66N1sF4IWDz+RwHrY3WwbgAsHv9jgPXxOlgvAiwe/+OA9Yk6WC8GLB6f4vYIWInKf3rO9Ul2X++5Uj6TAH2UDn6P6+8Grrp8as+5PhmMtyu3Dz7n+pTANSX44ZrjpwQ9nxL0SFjrFLHWK2JtUMS6TxGrrIi1URFrkyLWZkWsLYpYWxWx7lfE2qaI9YAi1nZFrAcVsXYqYu1SxNqtiPWQItbDilh7FLH2KmI9ooj1qCLWY4pYjyti7VPEekIR62WKWE8qYr1cEesVilivVMR6lSLWqxWxXqOI9VpFrNcpYr1eEesNilhvVMR6kyLWmxWx3qKI9VZFrLcpYr1dEesdiljvVMR6lyLWuxWx3qOI9V5FrPcpYr1fEesDilgfVMT6kCLWhxWxPqKI9VFFrI8pYuGaY719ci+pXEftk6N4fN0JX81MQhwenmOE7cNLBvL+uk/ESA+/h7b5RIi+MH7cNkOVa419f8OA1cy+vxHA4vEb3fd3KGBJ+/56hXi4T3RthB7rovaJro3Q84km9XxC0CO9p7iyPNbv1mB8WvE9RXuN7z6uZH5rwO82IV34niKvI/ieIi+D+J4iL1P4niIvI/ieIs9z/p4ivY9LNtpQud8FaaO6u6zyO92kk76uiHbk+ZYI+R8E459NWIflg3/5JzFJetomSQ+mZ42iHo51dvnp/1L9xeM7Gq2/PP7aECw62sA6/qXHFcyfh3+4UpYt9nfgqA1pj/qt7N7FEWmluFRHsH9bVvmdbs5lCH+DG/xcVP/I04RtCrddI+WL6+oGLG3bRaWN88dyyPvrOOOI9Q1idQl+LvJ0XUS6pT5E4iqlI6xucj1RpyBviODFw0eNn8iGfAyjaMNslA2lMdhETkEmu82HcPhlZWksilgB/J4P95JB9CnIPE+7QniS3nrtOI+P47C1wEv6T3rwHuqROJMefp4FP5X2XXA2A5U7fmQOf49qHvPn4ZOza5jvrWBK73mF1ZUE08fPwsCjlkhf2FFLK0L4fYj1e3ii5QohzfMiOBMmP2+Ec6ZzP5DDx2Ec6aiPFMeRpKsX+GL+YFqkPMFyd49ghzDbWsfHKXwcw8N/psFxCi/fOE7hnCiuNOfH0xglPVH9ZLegp9nxgaRH4oxzN+t4Pf8y1HMqD7zM87h0HkIHhP/NrBrmVyPqOe4fwjENtn1Yz0lfWD3HckPhvxFRz6Ux8+XlcM6Eyes554z1nMJ/F+q5o3GNWM9Jl9SPYT1vtB+T2nFJz7Qm9UwT9LjuL6eBnnWKejgWnsMUVl9/BvWV8lWqr9hv8/CfYPX1X6C+8vIelZ/Yd6wT9GKdCYJ4a5RR7yZjG2VdVN9RbaMi+o6oOYB1UXPcqDVhHo6HiVo3TUbo4OWJ36cxK+/TVkDY9RB2XUTYsPmcvS5Vrt3OuftHqS7wtV9y5FcWOJPfRhb+2nItHLok/OZpsmXl+zFOdJbmhuUQTLSpdXj6O6W5TcDdALi8DUB70XlrWP9nVhJj639nj4yH5cS6F1Tw3M4rB9KYv9xh/qJ90En5S7xt/nYtqOFiONTJ83Aj+PE2G8/4430kYVjbz68obdW6NJH60og9pfoi2ROfRXB7Ega3ZwdgnM7K+xFQ3ikM9hfWUf2hOkv2axfiW4djPwp/VEWntc/zF8j6o+pbEMjtArcDnjVaDmQuUpop7LOgPPI6plce8xnKx03Ameve7Eh3nPEa198j8CHe3YJfexNcC5n+/mxfvlgYHe4bKBRKCcAnrngP1w6lszp6hfBk661ObJ0rUlVLlmv4W5hdrWtnfpvBr4P5EUdbh65dMJb/Fkf849if608J4c8t18I1kpcpQQ/O1ZrBWjdBrFnB2Dog9YV8bIN9IR+/8PNgrw9pl+O0ddS2YbvP04nt4DXQ1pVZHMUylJfGo9jWbXKkO25bR/p7gvC87Rb8mmnrioV8Jj86WBgujuZKxf7RRDC+T0gK97Ctk8rtDCG847YiLbV12J61M79N4MfbOuIotXVu+sVcOo79uf6UEB7burh5mRL0YFvXDNa6CWJRW7eRxS9XrqW2DsepG4T08LYO52U3QJvk5pMO8hohtqmcr3V8Dr2B2Qntizj8Hh838zi4ZkPhS2zcPtwj86M0XCLwk/Yu8XTd2BMeboMQzi4h0TjqxtLqK28aWlUqXlkaWVVanQxkephETD5OpwIIZx1+uewO+I3LN7cCDnXBcb9cRv85lpR1HBu73peyKc8INGErQNeyyv90k06aOmJX6+bxWjb2tIL0dwfji5yLbR3S0ia3D3aPbh5LZNP2w034yMC6l5bH2wZ5UHmRHt1x+2FdiPOY8lZBT08g1yvpP+nBe6hH4ky/o5rasKZxB2sa1/XUwmNbE2fLVpxH8fweD38j+PFHdIkIfFxu2cTai0/DkisfUlE6qh8nZX6a9dnyGGVLWVhu+XAtrJ5Jnwuh8FFbyayjRxpRW4ukssXLEpURKZ+j6pSLR/+Snp4m9fQIelzX3R7QE/aobl9InQx7VJdm/jz8O9mjuichP8ParqfSVa75TVKdyTZaZ6R2KqrO1Ht1g2woPWK9vjzWTyrvaFfrbiyP5XCrwEHqT1NCfAoXZ5zC+enlUSb2OIX0T9Y4ZUVMu5J91rqxTzqqbK4V7INbAzDveNvN6740/ZEe9/F+AqeLH6hU9qgtBVF1R3oE/9T2P5gWuR4HYd1KMo4ZhkWfR3K97YO3l5gfimU/T+neEJFu1G+FPwaStttieJzzID6+IkXx+YffpbKF5fELbEz62R4ZMwiix6Rok85A7i/xsTeF/7wwjpTymD82/AL0q9yWuNVovWCHp7bSxejvpcf42N/fzrfSAS+p/ZHGVTiGb3RcJelBrLhbBCn8t1i+4AeX630WLc7WeG5b4iPZJmwbBtUN66idwboTVi553bgC0k/hf8jSfyl8PZTXv7DtQGGvNCaD6PKVAMGlOyspQb/0WMTKssrvdJMO27J2pqMs8MHHNz+H+kbLt0khrZJdNwp6+ZJxCvRuBL02H9ctGItJ3KYF4+uZlCe4LR153gT+FP7fWDv7C+irw7b0/2ePrLs7kMthWD3hXHk9XFMe60/hf8PsdV/I3IDzkbhKdZR/hL3ROnopcKXwv4+oo1FlSRrT4VYeqY4i7wTcj1suKPyfWbn4Y8QYjpeLnhljOeCWwnrtA44dllV+p5t0mJe8nkrtJeblFEjXxsr9pJBWKU/Lgt6NLAy2D2XQK7UP/JU+4nEzwwwrxx0CZ+uwzlH4aYwD1rkVQpqlciD1sVGvdPBXpqXwmBYKP5NxjVr3o/GA2zWMjLjux+tOR3lsuqXPBEtjK7RTEGInGrukgvptMt/GJc2Xbi7X/Hn44yo2f2rL3IyxaY1ak3D0OHIwAfrINvwe1z9ZaxKN5u1agT+t/0jhpTomrXnYZye4hsvbZNLLXw3fAPekdQpcjwqb2yyBtkFaA+PljuZyqNO6G8uyTo7LdUprndhONrImV88GUvmPUz4lPVHPlu5R1CNth42aM4aVV7wXtXbD22Nsm1yskdzHeMaZ75RZGuKMb6VXTqXtyVh320Nsh2skFP5W1vY+B+pVVBqt4/NS5CTNXXEdYGNQ0y1xxrkrhT+D9dH1Xp/j6bAO1wMo/NkME9cDNrL4cdpdaTvPRhaG+Eh1AueNfA5YBj0SNm7dk3A2Ag6mM2ysTRjS1jUryyq/0006wttcweNj3i0Cnw4IfyWU4/uDsTaNspmVrYJefkw2jrW3gl5prE3c+Fyc5zvmCT6XRp4456Lw17H6fA2MpXj/zvvTF8+QdfN5weYIrpsErhuZLpwXUPgbIuYF0pon5yqNyalO7o8xOW+3Ospj7SO1H1HriXHbD2lr4Qbw431+nCNA4vQxnSHhscxS+JcKc6qo13Ut/q0w3uJ6cD/APSwNUf0U5hWPa3XePkPG5X0Jt9kt5bHppfDDbM18NdTBsPWwu0LqoHTEhXXngm4KfzjTvQZsKD1Tinp2nxD84oxnV8TUszZETxBTj5QezXGztF4/Czg3+iyDx5+sPSKzQM96QY/jcXPsOTXp7w7G13sXc+qoYyG5XSm8tF6yLiJ8WQgvHT3F59S8DQ9AL59Tl+GeVM9xHbHROVbUPi/p+We9du7xBtu51eWaPw//q5k1zJdBO9dq+8pmN6lntqDHdZsxG9KzNiI9jZYpHn+yjs6YDXrC9sm9PeT5Q6NH0HyNlc93TbB8Rh13MVnHpLhYozkQ0vNMriOfU6ojn2R15K+gjkj70aKOO5monePqeSbk53pFPdLafL1y8+2QZ3pxyw2FfyMrN9+LUW4k24Qdlcn1TlZ5i8KKGltK+5Si1iWjnqHy8JSPfKxLZcHt68nx9wOT/m7gqsunNk/YGIy33X2C7aYHtbWpodIdmezAWaWRVWtuW42ZQYCpYKyRywBI4QP4jfEsqXYIs1bQYR0/T44XpBTEx4kI4sfhVC9sPX+pEt4Xks4giFcJefywShh2nleZ+fPwv2KLXHHO8+KFp5HzvMIakKSQhu6QeGh77MA5JynNFP6/ItK8vk6az4U0h52Xy39jOGnzzNRAXmCPehA5JxjLvdHyxONPVuc+B/SEdbqJ3locboewF39uYf48/F7W6bZXMBs9ow/P4WvUzpIe13bGs1jXR6Sn0XPGpXO9o/LpFhYmbHNWu4BpHb4YTeFnV/LS8dnc4jv+pAvLME+fLW9zlcrwFlaG50EZlha6JmtBrZG6kggmXlcmKz1RWFJ9SABnHt7rAW2mlI7TBnH93g9of5QYa+QyAFL4AH5jvKgBLYbFxpAKUrMDWolTWNhGB7R8JQkHtI2uEPP4/Ck4rxC6BSk77s1E/vS1zHTiyt69LA3SQC1sVT4Rgo8NJT/cRbId7oSi8IVKh2AHkJsqT/elvJobwi8I4uUVjz9Zq/lzQY+L3X7W4Vue9cpGGniFDWKfBwMA6QMQ0pNl/LhBng0AzoIBgLRKHPXUKM5pFdKOXamDkgaeYbsc6pVrtFG7gGld2AcgXgIDQjcn1BTS++9pdCF2p4wHN0lv3XQLfk0dutk/mkn39fXnRrNDA6VCH/ZdxBXvxXlSfYQQ3u2KXl48dJMP/K1rZ34bwK+D+RFH6SA6NwOmfDGO/bn+lBA+7G1iCcu6NgdYdHhc1BtfuOPJuqgPtlH4EdZ3xvkQylohPVEf6EjCb2zLsK2yblnlf70cHq3jArDbFIELviFHYW9hdtm6YGxapEPqqO1IRugIhHuJINx2qCMp4J1fHuu3PgY3acGOY9wTwtNiSJPuBZCWRhdTFgh8XD754jrrjV/WwPil3pOvs8o1fx5+MRu/rIPxi7QbB8dhiUAeO2Cbwt/EkxaEsR2g8BtZea/3ASueTuTIMeN+wIrC3w/jF0c72sQFLdI1WSfDIVZ7UNu1ztvHC8pjbUXhL61MSm0+7+xtDPPCEMyP9tYwH2oQ86IQzLcxzL0R5f6QYKy+RneU8vh46grOQ5dVfqebc9WPhd7mBr/6YcmVgi14mkh/sztoua7JejNSSltUPvOPQGNdkrBWNojVJfi5yNMVEenm+nsiuErpwHGFpOcQwSYU/vYIXjw81WFe9iku2ZB/XFvRhtmo/OYf+yb9E/lYKNntUAiHHwvltr8tBCuA34fCvWQgfyzUtpl/WWnnpX5peghn4lCvX+Lxsfy7aTP7R6Q3eclJb/JyjuiS8Jvztvk9f3YNF8NxDCzH+DHBqDY3DENa+6xX763ji/f0oPiO1StXlS5bdfNdQ6tLZ99VWrFaKL9TIX1Y7vCk59sgLF/P5OHw4exK+L0aft8p8EGHNuGuRwgX5urVj+PZ9UTqB48fta64sEk9CwU9UVjHC1hR7fdCIfyB0n4fDeFobtdM+3003Atrv5ELnz/RJhpex3Ds/AOYD7kZkwzmeoLxbRqlhXTf7kh3AvQFgTwuJf09Ah/i3S34NbOemx3IZTID5lFwKZ1PDxXTUXWM38M6uUoIf6IQnmy9OnBia/HDIquYXa1rZ363g18H8yOO0nqum3ZjMJb9uf6UEB7XS+LmpYR17gSxaD2Xt71Ut93W9cbHX/h2ZtSJlvy5BV97RieN2yi9T33YLsa4DZ+7ct5u5+WTZ0NeVtFJNqT0NmpDXtbQhm7q8uTZkNdRdJINKb3WhsUGbMjLGq5h87aJeLeafRPgx59DnVOuhUNXz4bPbcCG0jp4Mhhvp1sFLJyHFAU+lM47g7H8ef5Zh8+1ePw7AeueOljnAhaPH+fNOY51KWBF7V9YVwfrCsCKelNmfR2s2wEr6jTEDXWwVgFW1MlM99XBugOwwk6+tVKug7UasHj8MmBtrIN1J2Dx+BsBa1MdrLsAi8ffBFib62DdDVg8/uaQeLx9s65HuEd13e2H5zINf5BVmi+4WOOW7C6NC8l2WwSuKcGP99vcj+vZIuiRsFYoYt2riLVKEetORax7FLHWKmKtU8Rar4i1QRHrPkWssiLWRkWsTYpYtyli0TqytA56O+hpdB2Ux4+zDiq1odOD2jODp9bNzxy67Y47l5cCcHzcSjr479Uh+lNC/CACi8eJSgsf0+IaBbXzYV+wwD0dFP6cimJ+eleXEF9x3jEkvdRFjvywf+B+fNxK8w5pvsLLBzppTkLptbb4LJwOHQhY0rMFXiaOhDSsBv14D8s6j0/hJD0Lm9SzUNAThXWkgEXhpTlF1LMFaR+Z4y/hVJ8tSHM8aV4ykWcLZLf5EA6fLUhzPcQK4Pd8uFfv2QJxCXsBGJ8tUPjbK2W7S+Cqlx8Duaj3FtzuUx+I/WyB9PcIfPCkcNwPuWyCXEcHsumR3GgpXcgND4+ki1F1rNGTJI4WwrvdUzcgPlvg62DWtTO/deDXwfz4ieP4bMFNuzGQjmN/rj8lhMd+O25eamLRswXe9lLddlvXW/fZAt+T0Mi6OO8v8RACbsNj2TX3Iz54D/P9WIFrjxAvEfKf9OA91CNxxuco1vH9z5tStTi8XPH9zzzuPeWaPw+fYvuft0bs2cA5OpZVXjasw3rCT4WN0x9S+AfZWBn3P0vvVtxTDudMOtrZ/aj3tyj8Q9Anu+kX5f3PpCvqpDu0RxDU8iTq3TjpHTy3aewvSu8PkJPaG9xDy9cYcO9BmfmtAr+NzA/X9XBOz/02M7/V4CetrZHfVuaH76Tyk895GUUntZn8UJZvN9BmSl/qwTkht6+0D+k4ds39iCvew/LG498WEg/bEcd7njKO63R1X7H0zhZPE451pXX6OP0L1zVZ6+hS2qL2avB1BlxHlrDubRCrS/BzkaerItIttQkSVykduC4o1bPjBJtQ+HURvHh46bChyV4PkGyotR5AdlsK4XCvOC+D94ZgBfB7KdwLWw+Q2tEVITxJb712NO47Jny8+OmUrDPu+/4U/vfs/abPsmtck+NYy4OxfsuZ35rKteP9VQPSekcAtlvDdOMcaK2Qnrh9Nt9DdeoE91BxbhyT59/dLEzY2vPfsPH0J+bLmIlAnkPgmJ7KRNx3Gin8NyPG9BSmPSRdK0Mw/5WVxe+ElPVAwJTSdTukCzncBhwo/A+Edf0gGN/+8jJk3W3lsdxWCbqCkHvY56wK8YvSWy+uvb6LXaMflhW0lxV6PhVmUywrFP6nEWVFepcjak8pcsAwt4dw+GeBg+2PplX8R1betibkcVY7u8bmWcpKzIIVAk6YIzPY5FF1QBz6HVX8pO2vPO7tIRx5XH7GVbG0vLQ67HlfG4DdGqKsLZCd4/ei0tIefHLSPkLsN3hdXg5+dzA/3vaik/oU/j5V3OdmD055+nqyxiRxxhrW3VSu+fPwf2T1Dr8gdxvjIWHyr0djxYpaG6Hw9eZrpJ9sKY37o3RL+xop/LoGuUrPGvgYehVwjToksx7XcyeZ620NcpX2MfC22jRGN99VWnXJytUlXj2QRgDXXXAPw+A219tDqE6HcLiMjEeMYP+Ar/ndIfCTHHKWuCSD+g7PK+6pLB/bKvrNkCoaBNHbKaRtxnxo+WmYWkiPUKKKY5xjOXjTxDHOKtf8efi5LN3YNMX96C+Fl7bL8iVQXALm1QCPfeKP+fiSrnXtzE9xKl+UPt7HbdBRjp9eyT5lIbx0PGMKwnNbSY9acBmUd2H8rNxNUP6kI8ui0ha1hajyM/TjqreUa/48/PER5W+jwEE6b5bCS1uZN7IwuCRcZn4UVyp//JUK69qZn2L5K0nlj9sAy19UeiX7bBbC80cGlL8pCM9tRX68vJBOqf0jm/OjjqTHuImQ/8QV70U92r6kPFaPq4+b0GM2bC+loZy9TleuaajPba/5+A3rD1+C2CTwGfcR5Zlj07WF2Udq19PB2PCbBb38EdOtoHcz6OUfycUlZ+v4cuBZwHUjw8Zl96g0v4Q9Pj63ch01zMSjMS9g3B9YEB4f+0A+VsMjAKI+bCodE8bLJra3FP4yxnMHs7F1vM3jy+fWtTM/xbI62mifu5H5xelz6/UJ2K/y+oHTH2kqxW0eNv0J+yguP6qWh38ByyP8KC7v2/GDvvc0yD3uGPZelg48bjcqPyQemxiWFJ7XXx6+KNgEMXld4HlcDsG8kWF+p0HMW0Iwb4kYz0j9r3SuOra7PDzvk4mP9DrVFvDj3LHf3cz0Y9iXgn7ux+sW6g0i+GKfXY8vtrnkt5G12XdWrqUP0Lt4ZCrl5QlCeuLm5b0R6Ucs3r9ieZXq0GbBXutmypgdDWLeJ/R70lhpZbmme2NIn20d9tnWYdt0r8CLjwWk+Q0+BiRu24T6ut/mAJlSWuoPuR2xP5TmaVHf0SgL4fkcFOcAPPyt5bF+Ud8KkZbH4vY3/IjRuTG+xUI6o9Yr7PU8CE/p5m08LzOjzJ+H3xfRxpcFDtK2j6iyX2Zh8NhQnlcUN2pr9P4or1Hjt7KQ3g1N2AfLK2838dhtXl7wdUGt8pqA8iq1QVJeYv0pC3ykeop26gwJT3jYh749xriKc4h6VSDu+oLUx20OZN28bpYZPn4AlMK/t5Xa83QmI9UPblesH1E2tK7RMWK5ch31OqlUPzaBn7RWG6fdtS6q7lBc/hFYaW4cdgR0PZ3IUZovS209hf9sRFsv9b1RbX1ZCC+1AVLbQXH331xdLsvcBnHa+qj5zkYhfJmFiWrrcS4sbQWu13Z/LqL84WPluN8XiyorG4S0NfpsZH/m/WQ+Gwkbl6KtuE04ltQ2RK2pNDvetA6/pVtvvIlrkxT+Jw2ON6PK4UYhfJmFaenx5gTKYVlI7/4cb0ptEF8nfHtEG4RjPqn8RY3P6rVB+PkqqQ1KCrx4Xyy9Bmrdssr/dJMu6pmO4++UFhKgj+zB73H93YIdFflkovJVWgNw+zmn9FNfUJOex720PN42Ye0OtuH0LM26KxgOlVXc1mwdfz70J1hrksaBPC7pwHFg+6waZmLWWEzpWDXeBuP4VzpWzeI+DnWf2wTHH1KeR42Xy0yPFJ73TTx8VyWt0vxwo8Ahau2p3rMYnB+Xmd+mQNYt7TeQ+lIK38vSs//nh9nM/n7mj31W1NyRl8GNoEfqi6TXaKXXEPgcEOvrWpYuqW7hMYPS699hHK2j56RYL7FOSGlaXa758/CLhDKG9TBgmDPZvUbHI1FrSphHZQEr6lVnit8phOd4WMeOj9FmhK3roE0p/JIIm0p1Isqm9epEuXIdZ52qLGBxm55blrnGtSmFz0TYtN5aGdqUwucjbCrZKMqmcdehop5VxrUpbokmPXFtSuGfFWFT/rwojk0p/On70aY8zVsgXpn54fgY27vukHipCMyNIZh0n8eLOtpUykupTcO8PC8iL6V0bYyZrk1K6drUYLoo/CWO0rU2JF1rG0zXxjrpwueuFP6qGOmS1kmsw7V/Cn9NzLHd/lyrmMz1UlwT5WVjLfhJezajysRE5jd3wfyGh8OxmrSfnfPAMkDhR2OWgcnZUy6Xgajn+dI4OmpOVW9NB/NZOuZIKgO4piodyRJ3fM+PzLl9xthwnE8i5D/pxHttMdKGdYvPI7hdaR7RCntzOR9sN9fB2oO0N7cs4GD/GrY3F/dabQa90t7csLWXDcCV93Fx1l4o/B629rKxci2NeXD/bJn5YZsm9TG8PIT1MffHbF+IV6v1MRuZX5w+ppn9s2XAkvoRaf+stN6Az/Ck5zK2fHy5pz7/shAX60dnED0exPrxWMR4ZjOLI803MyGYT7Jy/8Sssenn+Uj7smy4183S0f3KiHmMNC+Jeua0VQgvHUXdCxx4XEw35tXroF2Q1rjQJnzczMPjuFnaB5kI6s8HNgtpRBt2hoTnbSUP/1ahnKWEdG4EfRK/uP33RsZ1Q4z2l3RGffrdOiwnUWMfe43PyPn6NX++9lT8cs1vctribHZ/j/Xw2SQvD3hsv9QWx31Gjp8fko7bsWVlXyUzcIz+KVaGcd+9NO6Xnqkj5mci2ivJblHlsCyEl/YiSGvO5Yh40nNSrmtZ5X86PdqUI30bK3hTBC6kF8daX2R23LpA5poYx7c5FzUX6ArkdldHdzadAH1BMH6uwfV3C7ZUnB9kotpraZzmdr6SGeXPdHn55c90ed5I4z9pnwafJ3wDxixSG8DbuVOZPw//PTZe+nYIZhBEt3f19oj9bPpY3LKAq7FmI7UtG8GPx8PnQDxPsO2v924T7oWk8D9hbUPUu4PEy+3e89H9vreWbCbtrY3zPgQvC2Hv03cG0fMufF7/y4jxYdT+3nUNct8gcMd6jnXnGzB25DrvjaGzmf2985g/D/+7SRw3HNzfOz58mYVpZH8vLy9x9/d+udJ2S+9lx/m8obTmHdVn8fJ9GPPn4adWjmFr5fNXyE6Oy192f+8xrh4lH4wvm7jOFbW3U/osjS1/76qUP5d27B9IV8e0lIf8WHnu2pk/D394pUx2s3TQ/6Y+SdI/lBnNDY0OFYaKxfzIEB4Tbx3lmT3mypaHubNrNiM7advMOsLvcINffW+4naU1KaSJ9FNZamPhEyH/g0Ces5CubsBSTlsmKm2cPz6vaQc+dB2G1d4gVleI3zKddFfzNBmRbtQfFl6qA3S/MwKfh6d2nZfhTrDFFDe2yEblWyfTSfoncgw2/V4A4fCzWNzeHSFYAfxeAPeSgXwMNrZLPcH4dFMcx21KNm47QPq7A6f1odoOdACfsLrLjzNcvnKoWDlZFZs8zDpuTg6Hycasq3aLcA+LQxvEo6Ge1IUiz4SAIZkAvwCeEPRLTUkyRG8Q1IorNh/1sOg6GcElDCMBGD0RGAerzsGqI7iDVSde1dEejWcHBvoGs8PpfH9xZLSYz9UbjWvrHxnuG86Xhkf6Mvm+XD5dbGQ2gKMNPutOCvbrgPDXsVk3PoFqi8C07qzyWEwK/8KImbw0KpLSGacZ4Hx6g/HlCmcQk1We+ocGhgdHBvND+b70SLq/byL5KaWb2/7u8tjwNLLsDKJnUx0Q/maWV7hbo5PFIayzyuMxkTPPHz5ix4+xUfhbGYfdsOrB7YBdIh9NK3ZBIwnQFwRyl0j6uwOnXXQG84P4oH3wSZijGc5wAvA5nymCfSgvpwp+hEUrQbyt4eGnsDTy8Pya4vN791bKVgowraPTUROCX1K4R/Z96pQ1GLrxvEmE/CdcvIczeG4bbMN4+8mfHJZD2g9uTx6X2g+si3tn1zA3V66l8QXmH7bJUeMEri+svcL+isI/wNoK/HgI9lc8nciR62sX9FqH7RWF3wUrcY7qvfjxSNIl9XeJQLZHEMRbhZL6xx5BD9lrWhC90hLVTkSteFGd6wwJT3gdEH5fRF82lcVJCrzOKsuYT0aMZbqEdEn1mu53C+G7hHT1BuPbP4orPZUg2zs+oXZEeirBbdhRrm+fKU3Yh8pACsJzW0lt6BTQU29qiU9xpVU03uby8VuvoB/TKdWHTiGdUfVBSh+W3Xc1OLbjH9qdEsIh7tiOwr+PcdgTMbbjfdkHZkdzxfaGz314+I+zvuzDkD/SKqjUDibBj+cl2Yi3g50CrlSfsUxIdYWHx7E2lf3OkPB8PMXDfyaiTHSzONL4EscMFP5zEW3ktGB8uvg8Bu0wXQg/LRhvh95gfBswPZB18/RwO+MHtCn8l4T0SO0uf6JgXTvzU2x3xa9xcLtiuxtlQ+vQ5j1CeG5LSl8KwnP7S3VnGvhxvVOBQ725DbbJ0niDtx3S8iq3AfHsEtKrl3cjmQToo/Txe1x/dzC+zLuYS8YtI2SfHjf2SUeVwR7BPsRnhhM+6RyVlZSgm7jSm+q8XeHhe5gNeXh+TfH5vV9Aee1l8Qg/BX7W4TyW+yWFe237CSslYHG7UZ7aevxjsAV+2Ur6T7h4Dzny/KQyH9VGTFQPx6LxjVSfrCyr/E435XJZSscMIR2km5crvbpT6I/b1pH+7sBpXc5ElWFuH5zrpgSuqWB8GV5XroWrV765Hglrb4tibVXE2qmI9ZAilqa9titi7VLE2qaItUYRSzONuxWxNHltVsTSrI+a+bhFEUuzDu1RxNLMR82y+qgilmb5elgR63FFLM1y36ptjmYa9ylirVXEekIRS9NemmMTzfLVquNCzXLfqmO5TYpYOxSxDoSxXKuWe82xycE+rTGsVh3LtWpbqDmW02wLNfNR016tOv66VxGrVcdf9ytiadZtzTqkaS/NfkizDrWq7TXbL811Oc2xSauWL82xb6uOMVux77DX+MxKo++QnvXyPYpdAg/N572EP8sRPtlqZoStuH589kv+0n/CQj/S1Q1YymnLRKUt6hkxfx7ObRCGNbNBrC7Bz0WepiLSzfX3RHCV0tGjaJMORSzc2ybt2ZCeq1L4WUJ4qZz0CropLuXtbOanmLfZqLzlbQTpn8jb22S3qyEcfc2hLRhfN2aGYAXw+2q4l2R43PUG48va1BCepBfvYVnh8XuAB/2mPS98DyztE5H29lhZVvmdbsr1ZaPaVrf9TF8ubttN+ier7Y5qw6zDvRFx2jDrNpRr4Zppd6x7TBHrIUWsrYpYmxWx9ipiaaZxiyLWGkUszTKxSRFLs0w8qIh1IJSJXYpYuxWxWrVua9pe0173K2JppnGHIpZmPmqW+22KWJrl/gFFLM0ysU8RS7NMHBx/PTPa6C2KWBsVsQ6EtvAJRSytNsde41y7GV6PlPWwNOuQZhut2ae16riwVfu0Vp1badpesw5p2kuzjT7Yd/jfd1inObfSbAsfVsQ6uKaw/+qQpu010/i4Ilarzoc0bb9dEWuLIlarjnMOthP7bzxxsJ3Yf7Zv1XYizviLnxOI5/JKz/EJa1YdrHMBi8efBViz62BdCljSfgaKNydEDz/zgu/BmCPolvAJQ9rHYWVZ5Xe6Kdc/1CWkQw8/W6Tn4XNZuhOV/6T7EHZf79l9Pvb5pKS/G7jq8qntJTgE+KB9cC/BoQLXFPhZVy7XwqFfUrjXFoG1WxFrryLWVkWsNYpYDyhibVLE2qOIpWkvzTRq8ZLa2VYpqw8rYmnWbc0ysUsR62D7dbD9cplGTdtvVsTSLPePKGJp1u1WrY+abXSr9rWa+bhFEetA6IcOhDRq8tJsV1ux37bXOG9vlfKlaa/HFLG2K2Jpjk1atU87WB/3Xxpbtd8+EOZpmm007h17Jpb7hxSxWnWt41FFLBdtNL4XaN2yyv90Uy6Xp7Vo/uwkEYzVy8ciiuvmpQToIxvxe1x/N3BV5lNdx5ee5XD7tIF93DznSBcTgM/5HCLYR3qugOPIeZXf/DkWD38ISyMPz68pPr/33EpEzXbSvm89WMFtoA5kR0YzuUKpv5DuG8oXin25bDHbny7mC6OZzEAmO5gfyOVGR/IDxYFsbjTbnx3pCcbnO9YBR3mcj1sH8FmWozoZ+SxrjpBHjT7Luq1cC9dK/S99vyfO+fFuykJueKJlwfX58VJZiDo/Pm5ZuK9cC9ds/mmOqTXnkjsUsTTHFlsUsTTHm5pj/VZdo2vV5wI7FbE05w2PKGIdCM/8WvEZvHUHnwPvP9sffA68/2x/vyKWZrlv1eeaB9uJ/Wd7zTQ+roilOZ5oVdvvU8Q6WIcaw9qoiHWwDu0/22vO3bcoYtE7FLiGZN2yyv90cy7bJehVws4T9jx97OoZtIc1j13EG4R9uD7vUcKer46dK9BaGv8mPP9G+FcqBYjKZuXzyGPW9fm3oduYPw9/0qE1zK9VMHsYbsAwrOsCvESgueaYTSdAXxDIa6Ckvxu46vKprYG2AR+0D66BJgWuKfCzbn25Fg79ksK9KKztilh7FLE2K2LtVsTC577NYG1VxHq4RXltUcRao4i1qUV57VXE0iz3mrw0bb9DEUszHzVtf78ilmYa9ylirVXEekIRS9NeuxSxWrVua/YdNJ6gd6/5+JG+R98bjB87TQN97cyP49O4tBP8l1V+p5tzGcKf6ga/+k2FKYKNeZpIP40zO1j4RMh/wkI/0tUNWNq2i0ob54/lZwrjg99ekLCmNIjVJfi5yNPOiHRz/T0RXKV0tINN2gU9CcEmdH9qBC8evlfQTXHJhl3MT9GG2Sgb8rpI+ifyPQqy20IIR+dYtAXjy+CUEKwAfi+Ee0mGxx3OuXkb2ROMbzNJr20fKX+OYP74LYsjmK6kcA/rC49/RAiWtNZg3U3lmj8Pn62sNVjsr88fi3mkwC+q7C4Uwh/JwhAfyTYUt0fQ3UgbynmlBA7JSdLTPkl6pk6Snq5J0tM5SXqwfV+oqGchC9MBehYp6lnEwkwHPUcp6jmKhcGx32Lmx9sb4nG0wIP6p2PYfcX+Kfb+XdLfDVyV+VTHWscAH7QP9i3HClxTgh/f+8r9uJ5jBT0SVlIRi8pGbzC+rBwNehYLehZH6Dla0EPl6nhIz7LK73RTLjtA+XJCMN6R34ns3svKNR7okvCb87Zt+qMLargYDnVyu54IfryOLQE/nldLwe845ndS5bo3GG9frpv7URrxHuYjj398hJ5jmtRzjKCnR4jXbFsp2QbzSUMPt9sxoOcYRT3cbseCnmMV9fCyeBzoWcDi8edt6w+txeHx+BiYx6Wz5jog/Dvm1zDLFUxqS05kvBTbkiFK25JgvCO/pUw3ltmTmB+Ws5OZH5aNU5gftzk6qX0iW9j26YMNtE8nMD9KE+UBxX+YPfPceejY+DwP8Z0Q3n9eAn7HCX4W/+zDa3y4HeyYncpNF4uL5YbCvw3Kipt+p69f6ltwLLXEke449VnqWzgf4t0t+LU3wXV0ZCCdS/f1FUt9+eFCfjQRjK9TSeEezluXCuGl7w2SrU9yY+ss1YVkuYbP+2Xr2pnfEvDrYH7E0dbVaxeM5b/UEf849uf6U0L4S1kaGslLl1i8PdDAmjJBrFnB+D6J2hzHY99BqQ0iJ9X5FPjxMjcT/Hh9wm9O876Mr/Whqzee/moD/RXvF5eEYFJfwOcC1Md0QNiPsb7tw9C38THhleWxfnzsRXosxtdh3EN6+Foz9ZPWrQzh9dVJGevki9JYB/uvpY50x+2/cP7D+RDvbsGvmf5rODOaK6WHh/PZ4WKhr68vqj/i97D/OkkIL51xS7Y+2Y2th6X+6yRmV+vamR/2bbz/Io5S/+Wm/80Px7E/158Swq9gaWgkL6ltl8ZNUltxa3msH5/z8bHu16GOuxknZoex3nAntfPYP/Ayif0Dn7Ng/3Aq82u0fyBbNNo/8HaSp4ljtrN7UhvfAeF/zPqIv4c+gvfppNuGu3be2HBLBd5u60z8tVbSL7WhLtZapTZRqndS+cP6zf0OZdfcj+s5WdAjYXUoYlG56A3Gl9GloOdEQc+JEXqWCnqoXPH6p5ePuTTlSzoY78gvw+41utZKvBtda+V2zYAfr2NZ8ON5lQM/3r7lK9e9wXj7ct3cj9KI9zAfefxTI/Sc1KSekwQ9PUK8RMh/0oP3UI9km6i1konqkdp7zHMNPdxuJ4OekxX18LJ4CujhY3S+1jp9Xi0Oj8fXWqW5dweEfwVba+2tYHYF4+vB/mpLpDKbZX5YznLMD8tGnvlxm6OT2ieyRaNrrbyt5mni3OOOTSj8EZBPjsYS6VmQLsmmUWugrTbGcTOfjh7jSP14o2Mcfr4Ytj2NjkuOUcSist0bBKHjkgT4cT1LI/RI46UDdYwjtSGTNcbBsWqjYw8e/5k2xglbo9LQI61vHGhjnPOVxjg72RjnIug73ay/6I5xsJy5GuPw9ZcPKs3B6q2VJEB32Fjo+eWn/+M6zQ3zapgvmBfO63im+1sH12nQHbDrNFF7nLDva3SPk7Rf5EAdw3C7TvYYhuvmfpTGemMLHv+ZNoaZrL13B+oYZrvSGGYdG8Ps9HCdBsuZT+s0/Hl+nLEJhX+yhdZpFgvpd7tHJf4Yh/R3A1dXYxypH5f2tkv9E8WV2h5cp5HGUicJeiSsYxSxcJ2GYy8GPdI7EcdE6JH2Pbvd15AtYf/PndRfNjrG4XsdGhnjcLtiW8jrWBr8Gl3f6Q3G27fZdT0e/+QIPcc3qed4QY/rvnqy9uNP1lhqf607hY1xPg9jHIoXd4xD4ZezMc4XJ2WdprG2RCqzaeaH5YyPI7BsSOs7cdunia7T8LYa2ye+VkLhpLUSqe44HkfE/gYOjiMcvc8YOY6Q+srpQe1d1xtLqy+7c3j5zSMXltbc8bwVxcuGVq2+eWj584rFVaU77uCpwVKDqcXSgmHoOiXc5xhL6qSC3vCXVkiWANbSOljnApa0Cx1bkTCsSwFLarmwR5JqG46meHjO5+Q6fK4oh/M5GbBOqYN1O2BJM0/COrUO1irA4vFPhXjpED08DG8N04JuCR/LbaYO5zvKYzlzXjg7y9bBWg1YPH4WsHJ1sO4ELB4/B/HyIXp4GD4LzjM9CeGexOeucjifPGAV6mDdDVg8fgGw+upg3QNYPH4fxOsP0cPD9LH7/UxPQrgn8TmrHM6H4sbp4ThXxR4l9q540j9ZPVw9u+JMeUDgmhL8cBYxIOgZEPRIWEsUsU5SxFqqiHWyItapilhpRayMIlZOESuriJVXxKI2UXoSMRv0NPokgsefrCcRs0EPX5Hjs82jD6vF4WWQzzZ5XOqLOiD89Wy2eVwFU1ohi3rig6sujdpZ0kN9DS/Diqv6fWRf3oeTIz/ezx3GrtFJs1Pi3ejqGbcr9sm8nRkAP95uDIIfr7unVa57g/H2xTZRGgfye1HlOBehJ92knrSgp0eI12y9lGzjuv7jqmhaUY80f8Dyo6FHmlvUa8/Og/aM4oW1Z2eVa/48/AWsPbuwgtkVjK8H+7MtwTIrjUvIb5D5Ydk4jflxm6OT2ieyRaOrZ7ytxvZJqhNdwfiytz+erpH+7mB8nXMxZ5DWBKQ+UGq/Ka5Unw5n11hvk8K9qLp5jCIWzSWjxg4J8ON6op6uSWMNx+ODPD6F564H0mxdo0/XJjo+4HYtgB+vY33gx/MK6y1vF6ktkvptLC+N9ts8/jNtfDBZT9cO1PHBxgbHB/h0jcKfxsYHW2B8wNfDWnV8gOXM1fiAbNHo+IDP7fsZPpYvHo7noVTWA+FeQsDBOpcJ0W/ddeWn/0tr63NAh9SX83tYvucIfKPqq9u+7OnTxbk+Sge/x/V3CzZxMUbKxbSrVLZyYHOpHGAZ4Xrygh4JC9vBqHXxjBt7xR7jkv7JWheXxotzBLtORvkOy+d0BB837X3tJPp6z4eIjz1ZpDMYX4ak52LImz9HontheRP1PDvq2WK954H4PDssDWF5FPU8W7JBB/h9qdKPWxu+57CxYeg57GdZmPdVrqV+Geu0o2ddses0Puvqc8Mn8lkXtw8vs1OC6LLD8y5sH8ApQlqxLJ9chxOW5Ub3HHAsLMtRew7SdbCwLPP4OC7gbTXubJN2guMclOM/tRvtsHD8dAR+JgI/F4Ev7YCV1rTz4MfnngWG/9UI/KUR+CdH4J8i4CMmtRsp5rcY/Cjs1ysYdoy88wiZL2FY5/ZUufhtCumfrJ3m0n6oqJ3m0j6lqLfWotqJqF24HGuJIhY9P3e7AzyXk9Y0yEnrV5O1A5znC9Z3bmdcv+L1Atev+J4E6icma2e2pKfZ8rJE0NMjxEuE/Cc9eC/OW56YTxp6pP2QmOcaeqS9klh+NPRE7QDn41W+RvUHWKOSdoBLY13cAb6ErVH9Edao3Lw9pbsDHMsZHxNi2WhmBzg/TfqDTb6hYncn09vZN5ZWX1hac/XQ8puLQ6tvXrniitLtd5buWN0OsFh9sJgvDaHLcYIIuta1gd8x4E+HarYFsouzbOGme4o/HCH9k7VsUW8LMw5HThG4pgS/+ewaq1JSuNcWgXWiIhZ+KIVj41JZo4cwHiNwPngI48FDGMP0HDyEcWJ6WuHl/rBHc3n4cAk/jD7OozkKfzgb9vRXMN1+lM3PQxjJFs28+IbtE/+YDR3MT35Hs3j4sSX+QS7+whx9zEbaDkIvgfXCb3tNHynsAF4vhPLAP2aoWB6qHwWQPiLl9gW/XOzXH8KmcZx3t+DXzEcBsqXhkb6hodHcyGh6ZGi0hHWduOK9NqYf214KP0MI7/hgsiGqL/yjALz+WtfO/PAVxA7mx19ExY8CuDlsMzcUx/5cf0oIfzFLQyN5KU35J/ohPPrAAP+4CX50l7dNWBfdtAPx5y6kvxu4KvOpzl2kjxkvEOwqTXUprjR2x4PJGt2iJ7XvGljU90h9xQLQI30Y+sgIPQsEzq30wSLrJutjndyuuETD6xguufG8wjEOr9O4lMrti+Wl0XaIx486yG5hk3oWCnpcL6UeCXpcfXga21xXH57eXx8FDZu7PBDy0cW4c5fqeIvNXXbAWBU/ZLys8jvdlGv842dYZvlyK5YzPt/EssHnK9zm6KT2iWzRzNwF2yepTrTq+OBIN3wixwdSH9jo+AAP9WqmTz9BEYvKRW8wPr+xX5FsszBCj9Q+HqjjA25XrH9RWzM0xgcu+m1Jz+Im9SwW9LgeH0xWv70Y9CxW1BO1dWiyxgdhH/P+TIzxQdTHvCn8Hw6vYX4Oxgdu+gTd8QGWs0Y/9B23fSJbNDo+4HO5JSGYHULYI8CPwn6d5dfvYS2Tx18UjPU7gvkdBX7S3FXqtzgG18HLHK/nN5XHpoHCf7fC29pyxwIZsy0Ek8qxtE7G58rWtTM/vfI7krG8R1kZ4DZ9Kr3lsWnibVJSCI9rkdK4g7dFiyrXccYw0trDInaP1tokexLH/WHPRYxjHHvy8I3ak2wUtc6TCMbnmzSOjbLnosq9/WFPzjGOPaWxeQJswsNze5KNUsF4Gx4HWIsELF7fcS2YsDuF8Ngm8fC/ZW3Op+eP5Sett5HfEQI2b3sTgMHT0S2kowf8eFyL+5VDxuJKzyWi8kY6LvBEQRe179LHu90+I8gOSfMFclIfj/1/3DUA7P/5noWoreDcJuiksQHZyZath9h2awzHr7kewsVyhGVmgcBRGgueWAe30TKDc1nfywyuKfEyg+XJhzLD228sM4sFjtL6Yr1jRrHMSFvn+Zgdy4x0QLJPH3lqdg8F+fHXVrhN0Ellhj/PbaTM1DtQP6rM8A8z4X6aU+rgYpmR9mRJ9YvKjLQny+1HNbKjPQJXcliepPyNe6g0rlVJr6RJ5YnbBJ1UZvgHNxopM/WO98UyI62nSVvPpdcspX15FF46FpXbA9sZ6bWtLiGeYjtT6BG4kiM//nok7qXkr3JiHyMd50h+/IgF3DfFj1jA4225k8oM2anRMiMd9Ru3naG40pEa9V7NxTIjvd4ct8xQXMdlpqWO5iK/ZzE/38rMeXBEJG+j8ZinTEydFL7ea+ZY/qTyytv3qPKHR5BSPL7GxvmfVa758/DDlTmuzY+vV66lNQmyk9s1iXRJWpPgdu0oj013lA2ta7TOk81Swfj2OAt+0nGRUXtVpWNPtcdGNF54poyNsJ+L+zGyVh0b8fkTtllLBI7Sh1mk1/alj3tGtWPc/lhmeLmguG6PQcxlegSu5KS8x76M5z2WCynvpXkWlkNe9/EzCtxJZYbs1GiZkdqDuGWGHw+wPUaZkd6LOlDLTJz24pleZs4/2M40VGZwredALDPTocycIOAeze7FeZ+CP5vE5xD8uRC+r8njteo+BHzWIH0sUlpvxv0evJxwm6CTygzZqdEycxzg8vyxLuo5BMW1ZWZ9ZbN+N+iy/5t6x6dYLGXymf7BgVI+Xxws4AdVraPyN82B/nxhqH9kqD+TGcxnSvlMXf3W/nNnj7VnO4vD865HuEe4VP47IO6yCaYDzZoAfUEg7xUl/d3AVZlPda9oB/BB++Be0U6Ba0rwozzoDcLzJAF+nEO7wCElxG+PgSWlZ3pFrLtj9cpVpTOHbrvjzuWlAByWFazTbSH6E0L8IAKLx3FRr0YKfcMjpnKlS5mnyuNk1+tCcXgg3Z8dGiyO9BVzhZHJ1l8azg/2Dw+OFNLF9GBmMNdIu9ITjC9biZD/1iUjsFMC1m3lp/9TG8TrkWYbRPhTgJ8SfnVc2CHYiXRPdZK20dG47Svp7w6ctvfV9nUq8EH74LuuXW7sU7JHNVLZ421Wp2Ab5DEFOHY74iitmRIn8mtnfsTDhvniEWM5tjni6LaOjhalMQrfi/zr+TW9PG/4mjUv923Mn4f/LXtX6T8q173B2H6Jt1PTmP8UwZ9+U361CWH5Nf4m7mhXHp7KZGdIWjshrRT+D2x9/tLZMia3H+fVFoL5R2HNnzD5XrSoOk/hpwnheR0jPr3B+Lo5DeJx7l3BWMfvSfmTgLDYB1M/xeOF/e4ScMI4TBVwsJ9ETNQpjfVwLpUU9PA6xfv8LkG/Yv9QkPpKctJYOwF+PO0vLNfCoZPmrpQmm97vw/MqHg75SHVNc2xE9zvYfdSL4/FOCMv7c7RZhwLHlKCnE3CnRPBPAE67EK8nkOuj9D8u34TAN2o+PFE9HOuG8lg9PJ/HfMYQ3kvg7XhSiHtNuebPw5+woIZ5XOW6Xp+GbQlPw4vKtXvYZuM4FuskPtfGvgvD8H6chz+5kg7ed2H7wLHsvVPBntIYQRr34RjhUmbPLNhTGgP0BuNtg2W4C3Tx8TH1L2iD0xiP/gXhusiuPRFptPeevUAOxznwcIgh9Z2EIdVritcr8MK6h21HZ4QOqT+TdHSAX7P5I/XbfKwhjWEkf96fcz14r00IX2/80R2CLeF2CjhSOz8V/BKCH7ZhPL28DcOxiTQn422jVO/C8i5q7C1xjzOu6ozgLtmPt0PaaznpgXQmPdJfGB3NFPuGhvP11nLo/pTy2HQ99Z/d62Dpsm4qDw9+XcyvvTxWf3fldzvTw7GIRweEH2Z5bV0ni0PxU4L+TtA/hrdwj5c1xEoK9yi8zdMXVDi6WKPLFgYHhgaH05nsaDabG+irl6+SnfjagXVka54XnULaOiD8LazPWQ7voHYI+my4eyPCJUL+P4Uh3Gsvj70n5REvuxSedHeXx3Mkv2nMrwP0TK/85vbiWMSjA8LfA2WXlzeKnxL0TwX9Y3gL97DsThPCTxPC2/y5Hdojnnbttb+ndAI+v4fc7nVYr/ryfZmBgaGBkb6R0cH8yPBkr72PDPaNDuZyw5ncYLE0mOmb9LX/fG54NDNq1v9zo+ncQGbSn30MpbPmWebwcCFTGhocHJ309GcymdG+/PBA30jWLDFO+rOX/Gj/UN9of7qQLeZL2eLQZOsf6i8N5vty2ZHc6ODQQHpgsvUPF/tG0oO5THFoqD/d3zcwkWdPuEZiHa1ROXpGHPt8o2o7HYwfy7p4ppIEPmgffGYtPXuWnsPROfoJwS/Oc2nXWL3B+PzGdQnJNskIPZhX1sXZJ+FqXTRumSP9k7VPIu6+Alxr5HFxTmkdlhNpP4b07MAXLIpvnbRWvLw81o/nMdo0blmltUVsS3uD8Lwh3TSX5fc7BL649vhxOPMX1xOXVX6nm3TYd3Bdjvcw9UnrZeR6hHRjvvM1EsxbfO7N/Xh/jPtruEvCb24Lq/uHMfbpSWUkAX6dQjqk9RnsaxICr6hn8lHrfFI/QWe2JwAzCKLXcaQ18nrjEXzmYZ3jsh97PEL6u4Px+eWib6i3XoZlPep5p7Q2mwA/rmeqoEfCalPEaof08PzAsuBoLBh7nED6u4PxNnVRFqQ6lxDsKo1N4+wRixqPxB1PtjpW1JwnTr5LerD8cz28f+fPJX8Jz9EoHn+OxuPiuX8Ufu0RNcxfw3q+lP+9Amccp0jlrC0i/ZKeLiHessr/dGMujzfc7mdLD+HYgDvymyakOSGEl8YNxLvRM1L5uGEa+PF+aDr48T6zB/x420vfyZDKCI5ZGi0jPH5UWexsUo80fnJd5ztAj+u9IFHjpInqkZ6zSfuBmtXDy+JU0MPj8bZy1hG1ODwebyt53CvKNX8e/hbWVs6FPZ1u9g6nB3EOwp00B8Eyy9sZLGfTmR+WjR7mh3uyuZPaJ7JFo2ek8n6gm+FjfUkKcaPWgxzNOWOP+Z8J781Yh+MpaR+BNLeIegdHAyuqP8D9bY32B9J6puO55AD2rdxJ7UGjZ6wT70bHD9yuXeAn1d2Jjjuk9QocI0vzWn4vqr+dEqGnvUk9UXsmXfWDkzVOwbm1i3eOpH5qssZDYeOHi2D8IO0B5XFxrkXhr2fjh0th/OCoT2ioLZHKbNyxBZYNPrbgNkcntU/VfUFBY+MHXiYoTXwfrbSuJPWLiWB8G4vrUFyftPZKcVttfIj5K81DpTzE/OXjQ6yvM5gftwm6emPHRt5dl8YPPBzuC0wIHKW6LpUBac2Iwkvv1+AeRuuk/a4Ut1XXJ6LqtlQusH3l5QLLYS/z4zZBV289pJEyI7UHccsM37NN88uoZxV0X1qD7BB0RnGUxsVx2yzcby29k4W6eT/H+YfNkzdV7FHvzDmyk+Mz5wrSmXPcrh3AKcqG1jVa5/EZu9QeS+MtXN+Qng3ztWDtvUH92ZHCUK4wmB4pFfqH+vob2RsU9T5BnHE3pV0aT1uHz7op/OMwrnLUhorPusP2qtN+Vay7OE6k8O9h48SXQduC65vcT5oTRL2LIr2ziflQ3Y8ayHUB00DhXxOzDaD0OG4D8lIbwOsttgFR771ah23AdCE870Px/Yyw8TH2B5LNsY/g45eoNh/nI29neYTfwuDluhu4S3Npab0E15Kk92Utly9AnXX0TLxfmoeTk55nJMCP1xMcE+G5A9xPmiclBA7S2IZs0egeEY12go/5rWuVesv7Z6y3UX1xEIyvt/XqOa0DpILxeYnlW+oLGqkz1l0M+qR39XidmcZ0dZZrYRXzoHo+FNk6yTi3l2vcSb/0jhKFq86L3XBNE1d6L4P6La6Tp6UNwuM1vgf1AzY/5Gnk+Rj1PpP0Tgh/V4Y4Su8PTSs3hjUVsKY0gUW8pPdkpkyQl4TVCViNvP/116xOSPvCwvZS/CjG+l7UXgoK/zs2bvsHGLdp7tmr11Zjm1e1ZSD3Vcsqv9PNudj7nkh/dzC+X3XxPEzqE6Q5NNlnmhs++aixotRH2XORZgTj84zzIyxpXh61LollvZ5tUkJ83AvK8zhqDyn2jXH2kPLyPi2Inl8mAEuqx9IYSbKFtDaD87X/ZfV+VuWjUlHvREv1F+u9tOeY/ML2HIeVrai1ix4hvDQ3Id287PXEwJoSoXuGEL4nQjfnxeOi7rA6Io1jyTb7Yw2Kjz1xHBs1n7Quji2lfExBeG47qR5HrU9NAz9e/7COS8+HeX2R1rj4vJb66MpnEcecJxAE+n0Hr3/a+APpfAGf1yjzzzne45xx/NwyTeXurHINX9rXIT27pTi2zlEdmBqw8xGC8eVcO28d2j49W+CP67A0trbppzqzYuXqm0fXnLmqNLS6VLzkzuXLbx69ubQqAJeA64RwnzS5bDX7B2qzOWqx+WyOu3bmz8PPrfzWXhkf7R/KjOaGRocKQ8VifqTuW8P8aTDn5arVmuMGPy2tnM1l13MgnXwnyjIlDoRH5UA6pa4N/PiOAs4voc9v3IcHkoIucpUJatVu1pE9/z9C/igF2hMHAA==","debug_symbols":"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38HX/ivHL3z+HXztv3L8wuffwdf+K8cvfP4dfO2/cvzC59/B1/4rxy98/h187b9y/MLn38HX/ivHL3z+HXztv3L8wuffwdf+K8cvfP4dfO2/cvzC59/B1/4rxy98/h187b9y/MLn38HX6CvHL3z+HXwtvXL8wuffwde8K8cvfP4dfG26cvzC59/B15Arxy98/h18rbdy/MLn38HXZCvHL3z+HXzttHL8wuffwdc4K8cvfP4dfC2ycvzC59/B1wwrxy97/vWDr+1Vjl/2/OsHX4OrHL/s+dcr2fOvH3z9q3L8sudfP/j6V+X4Zc+/Xvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+ld+9PWvKG4He6fNc/yjr39lw87/dmLho6Oir4OjPfZZNtFkjk1x++CUvh975zL4vN6Ny+D1Qjcug9ch3bgQuGS5DF43deMyeD3WjcvgdV43LoPXj924DF6X9uIy+npz3big3s1zQb2b54J6N8+FwCXLBfVunsuy9a7fjtVKmQyYZQveEphlK94SmGVL3gKY0dd47Adm2aK3BEZu1XuPX251eo+fhMcvt9q7xy+3KrvHL7d4uscvt8a5xy+3FPkd/+irUhbjlzux3+MXPv+OviplMX7h8+/oq1IW4xc+/46+KmUxfuHz7+irUpbiH31VymL8wuff0VelLMYvfP4dfVXKYvzC59/RV0V0MW3xe11qjGmXlN3aXS5pux//NdrR1/B7Mdp7/INfrYrxj321CiFsB4fwcA8v/9EmePd1tAnBPn70fbBjX9qYBzv2dZB5sGObFubBju1wmAc79nTIPNixvRPvYAdf/pB5sGPXOZ8ONpltsPGhqtgHO3ZRxDzYuSqowmBposFao7bi2BoTngc7UwVVHOxMFVRxsDNVUMXBzlRB3QarXgw2DL4m4oeDJb0dbcmo58HONM8WBzvTPFsc7FTzbGmwU82zNsV9sFq9/miXwnbpdillrmZTTcqfkPFqv8579VyIhsHXnmyTM3kyU033ZPfahpz+4a9ppu5KLZlszgy+EuenZPY7bJZSfB7sXCViYbBzlYiFwc5VIhYGS5MO1j28FbEPdqoSsTTYqaq+0mCnKuRKg52qNrNHIE6H1x+tfdzq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","names":["constructor"],"brillig_names":["get_contract_instance_internal","decompose_hint","lte_hint","discover_new_messages","notify_created_nullifier_oracle_wrapper","directive_invert"]},{"name":"repay_private","hash":"9746511837755778058","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"field"},"visibility":"private"},{"name":"stable_coin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreqznpvab95b1bA01nhp1kSQj7sGS+DcvtOMt0nsUtHDdWOH6scMJY4cSxwklDhXPWi+8Vjh4rHDNWOHascMa6K6ex7spprLtyGuuunMa6K6eh7spWDXVXtmqou7JVre/KL49iusVjB4uHBovHDRaPHyyeMFg8H9+b78NS1TCt6oZl70m354rbFh63p3euAE37YPfTfX3wx8Y6uZ0ObuZ120Tmdke0hc/2Su0bYCl7/Jg86a/4zeDxO7UJ4J21z/Fb4fGT8Pid8Pi98PiD8Pij8PiT7Pjzr6QIin/09bcUv/D11whff43w9dcIX3+N8PXXCF9/jfD11whff63w9dcKX3+t8PXXCl9/rfD11wpff63w9dcKX3+t8PXXCl9/Sfj6S8LXXxK+/pLw9ZeEr78kfP0l4esvCV9/Sfj6S8LXXyd8/XXC118nfP11wtdfJ3z9dcLXXyd8/XXC118nfP11wtdfL3z99cLXXy98/fXC118vfP31wtdfL3z99cLXXy98/fXC198gfP0NwtffIHz9DcLX3yB8/Q3C198gfP0NwtffIHz9DcLX3yh8/Y3C198ofP2NwtffKHz9jcLX3yh8/Y3C198ofP2NwtffJHz9TcLX3yR8/U3C198kfP1NwtffJHz9TcLX3yR8/U2y119SstdfUrLXX1Ky119SstdfUrLXX1Ky119SstdfUrLXX1Ky119SwtdfLXz9HX7/q1L8wtdf4ftfkfD9r0j4/lckfP8rEr7/FQnf/4qE739Fwve/IuH7X5Hw/a9I+P5XJHz/KxK+/xUJ3/+KhO9/RcL3vyLh+1+R8P2v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","names":["repay_private"],"brillig_names":["discover_new_messages","decompose_hint","store_in_execution_cache_oracle_wrapper","call_private_function_internal","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","directive_invert"]},{"name":"update_accumulator","hash":"4293992629430046295","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"asset::Asset","fields":[{"name":"interest_accumulator","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"loan_to_value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"oracle","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["update_accumulator"],"brillig_names":["update_accumulator"]},{"name":"deposit_public","hash":"11422368369089212507","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1bT28bRRSftXed2I5jt4BA4syJA97YTpxbUNNSkKBS+wn8Zy1FCm1Jkwq4sB+AGzfEveLQG1L5AD1xQ0h8Hrpkn/3zz28nu7HHSauMFO1uZub3/syb996+WXvmvJXf/HnpvU9XbDLmIL22l2vhCrHaLvn03hI+S28Jn2VHfM4ZbcJ0opCyyW4i2L/pTTV9LkH/CpkNq0R3lfj9dndYVeRbIf+daooZuMHvCn7FDX57I8X5Ip7hoyxCt0zjtDmN9N4zi2OkrwR996kP7fJL6kM7/irt23zz1zKz+w/S+yrx4cKmUJZVr8l7Cv8lkC1pd+KZPoRup73b7UZ7O1HYCQftnf1hv9fu9oa7/bAf9vq98U6/04n63f7e/nB/r70fdjtROOntdyYpXcE+jN3IJfh3Ad+Y1fuSe274D+vm3M7aKeNbZmZ/g+ffPng6ejKOPh+PT6Jnz3AP8J6ytSKYlQKYHzHmN2fHx0eTo+jk7vdHz04XsDcUbLkvGV025gvHYQuIxsfpNdHtLui2yTw/ih6Po5PrpFpxBZswftVbJsGsucHviJvBMFlWZBL64o43SF/aVbC4T2jVzKKprXK72mRD/sVMWzSedZCFVS2IVVX6XKzppkVupO+Yn1Dw647lrZnstUH6DUU/RW1YaNWM0/0f2mRD/tnu0F+gDrKwagWxrqtf0njV5AjWI8dQ+KqbxSZ9W/C/w3i+rwF8bdC8bZh3j+Y1YR7qixu/CqIuknn73gyXx7EcGIe3qA9tULCaCn9sq5oPs9m9zd86WuOpf9tygz/dC3VFFzWLzpfxb0JrXf5Nk822zhhLUAdZWPWCWFcZs1DXHLM0XjU5KuuRY6T5MEM8ow8LqG8b+qrU1wQs9m8tmFfUv4kuivo3fCdoUB/aoMgk/g39IttqQLzy/2yxOMiYJ9iGnj2FVkWhJbKV40W+ZY186FulP0jWZAxrwn4giOf7MD+opH1aLBDdNM3iWnKOX8mpp5Yyv5IDy1OwNJ1j/EqaD32udY56ZZ2jz2Kdo32KbE2Sm9cmyzY1PbUy5oueeN6BWU5H/dF+1Ovu7XgkE/KZdw9h7pw0H/pWvZ6/FdhDeddT9KqtJ++houu5qdDRysm81o7K4h2P6IkchuQW+jWzqBMXeVIRf8L7pEI6xz0u5WRP6StS59Cw8vIs/8+bC4odoo3KXMc5+Y5NT5hrCf3kKj5hWnu8Mzg+NtR8UoZWS/WMfq4n43jhaxnY2LRarSitpIxPBHrfkECPzkajN8XUO0+e/uBl8KdtZqNgf8jYD6PTs5PH48Hp4NHRjxHDVDLgtaNOLcbhvsV1M8Zu/2KD2pqLDTaIn4P0ub1cm9qg9g6Bdi/0L1BrsmpsZZsgbtZW4zlZFsMWdhjPz6tY8PDesVo7NhPAZUb6eDVGDxWCJ6HCVbnVI/6Qf5sLR3lQziysRkEsTkU0OptAI4/rx23PKWHRNF4LlXJSJWNfptek/wXRs5WfL+J9TWUHaxqr7W31FO5h9Dw6OTXULnIdGABsW11zHcl4UX1TweOl18QrKbxqS1/KwPKNbpKH8fmVTeWP9Or6A47bgGuIVpETTy1Aa00zXzxVuszW21B4d3yyGl7XEwzUk5dxFSzu45NVRzZnPVnN62LftZNVLRQ1LLy2MnhdgxwD7c3fEM/4FnYYz/dhdsmnUpgWcNUWq722Lyy0qq3oomjVFveJLRURma5DhbCsYF23CiF+QRHE832XrcriWnFMQZ3Y9KTFFN5Xjj7WDK/S/6BM7H9QT0VjitCqmcU1chFTNNls64x7i09Aip4ea1iO85DpmgYWuZF+w8KrJoe/Hjn2tb1viGfMtSrUh688HFPwVZxjCpcB5J6bFlNEF0VjChbSOH9DGxSZNP/GtlrUv7EPS1pVmXeQXtuXbL3JJBx2BwNbvPIVPrV4hXsqaX48L8PBkrymTT0BscUr9Akcr3i/JG1d8Uqj4y1Jx1Po2LA8BcvmX7UvK7WT8DXl7NOSh6/wqn15dOlKfZmElj5+xuIHO5MgAxub60o9GohR7hm7YKU+6yCgrMCzvzVm0f7R3mz+yFa3cBwbd2wxHve90L9EpR6tj7da0XLbRZX6kgUP79eVOmkmkPX6hldj9JRX8CTl9d3wb015NRPO8zq5TMrLKVnZQqcMNGxhRyvXsncrWq7F+dIXAF7SPk1vEr4/8ebpadvQz8k7vxY4KrFNXYan8Krt7SUq9ew6cCvYtnpWpf5TUreMwQo6msphfH7lJfwsvXH9czutgi606sZttrrXb8uvyaaZcmD0aOhDP47vpQD4diVXfwk+J3uDcNIZTAa9wXjcHQ1YT4b0tGr6wyiMOpPJpBMNupPdyYX08ad5y1bTEbtldBeIdLwV0tHscF1ulN9ik3YYn18T+e96Os3A6O6pDP04/mtwz/e9bBkrJL/2JsRroMlTUniqK3w9SEESW/qH/M9VpDG4RlyFvuj3XVxdLSlYTWUe61z7Nk/u8/627rpVr/HkI4jn+/Dkg6sBWKWy7U3+brLo3tS+o9X8EP/GySvIA+5zrqwFCg/oAyTd2IgBN57NSVo9nqeJY4yZ12HSNqGvngOrbsGqWrBqObFstJFXn/C30udKBn6VxjfSZx/Gbyj8BIT/BPxo7M2PEczvYMwZ7IP/x8YzGrx229injEe75PEia0LzJ/CjSWsCnVX70Sy+0RaEvqaDorFbaNUIa9U+bJVrYsPazokl+sT1Te5/Xs9a77AMJaPvM6E/9ZNu+JnaXjO261Tor8L2hNa6bE+TzWZ7OJ5tT8Nq5sQSfWr21nCjgw77dZOhA6SPz+jXMf7JXPbZv3rzOJq+MIZJLBK7akFfjfpuQd8W8Xs7XuQXsZrE723iV2KvZvMthf420UdaGn2Oy7eU8beU8Ymt/EI6rShzcX1Fp0nOd5PrzP7nE/66cp0XEGf+zMh1focxL68g13l1k+u807nOK7Cv1ze5jrHp9CbXyca6TK7z+i3JdXA8Yvg0fpv4TxrGGY5Lmh6RZp5comYZL89Yf9fyqIDG/025D+YfnPugDLcy+PVMvtynqYzX7Cqxnb8oFmLuI2vkooY/6u0OR93eoB2FyePORTX8/wDjwuJ5gFcAAA==","debug_symbols":"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","names":["deposit_public"],"brillig_names":["deposit_public"]},{"name":"borrow_public","hash":"3612872943401204485","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"1ZzRbts8DIXfJde5EEVRpPoqP34MaZsOAYK0SNsBQ9F3n5zWitd4M6rmZNbNMBckzxfHR5Qjyy+L2/X18/dvm93d/ePi6r+Xxfb+ZvW0ud/lo5fX5eJ6v9luN9+/Df+8cN0/3h3iHx9Wu+7w8Wm1f1pcEXtxy8V6d9v9n01yjbvNdr24Sul1eRruvO+jXfDH4DgSHGKk9+AQ1ZXgGEaCTZy8B5t4Ggb/v1x4Ogt8Sn00UbocvD8LvFg58zZx5klU++DI/Hf4JKn/pCly+AjPZ4Yn/xt8JxHwEjImocH6HBVnJUcYfEHEURrxrtDwFI1x6GlsYMQ/0KgvNKYfaXT83GgsNAOzjNJMfFxDCySwADu0AKEFPFqA0QIBLSBogYgWQDuZ0U7mrzvZR+q7vI96HOzIcacQHFyB4AoersBwhQBXELhChCsoXMHgCnBPC9zTAve0wD0tX/d05H6+HOV4V5HkUD5gywu2fMSWV2x5w5ZP0PLRYcsTtrzHlse6NmJdG7GujVjXRnj3jfDuG+HdV+HdV+HdV+HdV+EzaoXPqBU+o1b4jFrhnla4pxXuaYN72rBd2bBd2bBd2bBd2bBd2bBd2bBzacPOpQ07l07YuXTCujZhXZuwrk1Y16avu5bM9atGZGQfBbC+TVjfJqxvE9a35By4PoHre3D9M6wvUehXxY0tDRU+FXzACfPCkXnhTI8kMrHAnRfxqTzDQD4cl/9l7IkHdqFfnWfXRbwHvy0rkdO5AdncgNLMgMjNDYjmBuTnBsRzAwpzA5K5Ac1tpKbLj9R57tID5egh0EjjY+HS+NRO6K1p+tQyvXdN01PT9L5pem6aPjRNL03T/4P2mbTQD26TR+nzXb/2+PlTu3DCr43zW+P8qW1+do3zU+P8l++7OaLn95Km+CPFwh9ZT/gv33nZlfPPU6N/ZrayZcgp8Qn/5XuvL3tWMr9M8Wsa7BoKdMIvjfPHxvm1cX5rnD+1zR9c4/zUOL9vnJ8b52+8/4bG+29ovP+GxvtvaLz/hsb7r8yp/x6A5tRQD0Bz6pAHoMsPucGVFa8wecuZf9OiUpvdyQKZxMb5tXF+a5w/tc0fzzHCsZXnIPM9lB/yHzT8BTT4AhoBrzG+ZSPPzEtWkOPvfj6+PSE2vg1jMsuqslJN1vgWiMksqsryVVlclRWqssa/r+Mej+yZo7PD26Ux/jB6virLb8IxupMkqkmSGrxYk1R1IqwmKX0+yTtXk0Q1Sb4miT//5eZlj5okqUmKNUlak2Q1SakiiVxNEtUk+ZqkmiuCaq4I+vQV8ZqPfqz2m9X1dv3+fr27593N4HV7Tz8f1h/evPewv79Z3z7v1907+I6v3+uIPdnSK2eYDsVrWOZ7lc7q3VeU1Zek1B12J5/U58OQGTLHLw==","names":["borrow_public"],"brillig_names":["borrow_public"]},{"name":"public_dispatch","hash":"3678391008296609195","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"1602191554767750373":{"error_kind":"string","string":"Function _borrow can only be called internally"},"2830029349304997821":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"10435052277855889085":{"error_kind":"string","string":"Function _withdraw can only be called internally"},"13135008234568508716":{"error_kind":"string","string":"Function _repay can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"16022896159229267359":{"error_kind":"string","string":"Function _deposit can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["public_dispatch"],"brillig_names":["public_dispatch"]},{"name":"_deposit","hash":"151794834902147351","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"16022896159229267359":{"error_kind":"string","string":"Function _deposit can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_deposit"],"brillig_names":["_deposit"]},{"name":"withdraw_private","hash":"15962639502361009009","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","names":["withdraw_private"],"brillig_names":["discover_new_messages","decompose_hint","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","directive_invert"]},{"name":"init","hash":"10065254816640637986","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"oracle","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"loan_to_value","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"stable_coin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["init"],"brillig_names":["init"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Lending::deposit_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::deposit_public_parameters","fields":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"nonce","type":{"kind":"field"}},{"name":"on_behalf_of","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::repay_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::repay_private_parameters","fields":[{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"nonce","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"on_behalf_of","type":{"kind":"field"}},{"name":"stable_coin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::repay_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::repay_public_parameters","fields":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"nonce","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"stable_coin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::withdraw_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::withdraw_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"Lending::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::constructor_parameters","fields":[]}}]},{"kind":"struct","path":"Lending::_borrow_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_borrow_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"Lending::withdraw_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::withdraw_private_parameters","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"Lending::borrow_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::borrow_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"Lending::update_accumulator_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::update_accumulator_parameters","fields":[]}},{"name":"return_type","type":{"kind":"struct","path":"asset::Asset","fields":[{"name":"interest_accumulator","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"loan_to_value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"oracle","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::_withdraw_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_withdraw_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"Lending::_repay_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_repay_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"stable_coin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::init_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::init_parameters","fields":[{"name":"oracle","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"loan_to_value","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"stable_coin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::borrow_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::borrow_private_parameters","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"Lending::_deposit_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::_deposit_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Lending::deposit_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Lending::deposit_private_parameters","fields":[{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"nonce","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"on_behalf_of","type":{"kind":"field"}},{"name":"collateral_asset","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"PriceFeed"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000a"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Lending"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"collateral_asset","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"stable_coin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"assets","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"collateral","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"static_debt","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}}]}}]}],"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"UintNote"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"UintNote"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]}]}},"file_map":{"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"20":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"39":{"source":"// docs:start:add-trait\npub trait Add {\n    fn add(self, other: Self) -> Self;\n}\n// docs:end:add-trait\n\nimpl Add for Field {\n    fn add(self, other: Field) -> Field {\n        self + other\n    }\n}\n\nimpl Add for u128 {\n    fn add(self, other: u128) -> u128 {\n        self + other\n    }\n}\nimpl Add for u64 {\n    fn add(self, other: u64) -> u64 {\n        self + other\n    }\n}\nimpl Add for u32 {\n    fn add(self, other: u32) -> u32 {\n        self + other\n    }\n}\nimpl Add for u16 {\n    fn add(self, other: u16) -> u16 {\n        self + other\n    }\n}\nimpl Add for u8 {\n    fn add(self, other: u8) -> u8 {\n        self + other\n    }\n}\nimpl Add for u1 {\n    fn add(self, other: u1) -> u1 {\n        self + other\n    }\n}\n\nimpl Add for i8 {\n    fn add(self, other: i8) -> i8 {\n        self + other\n    }\n}\nimpl Add for i16 {\n    fn add(self, other: i16) -> i16 {\n        self + other\n    }\n}\nimpl Add for i32 {\n    fn add(self, other: i32) -> i32 {\n        self + other\n    }\n}\nimpl Add for i64 {\n    fn add(self, other: i64) -> i64 {\n        self + other\n    }\n}\n\n// docs:start:sub-trait\npub trait Sub {\n    fn sub(self, other: Self) -> Self;\n}\n// docs:end:sub-trait\n\nimpl Sub for Field {\n    fn sub(self, other: Field) -> Field {\n        self - other\n    }\n}\n\nimpl Sub for u128 {\n    fn sub(self, other: u128) -> u128 {\n        self - other\n    }\n}\nimpl Sub for u64 {\n    fn sub(self, other: u64) -> u64 {\n        self - other\n    }\n}\nimpl Sub for u32 {\n    fn sub(self, other: u32) -> u32 {\n        self - other\n    }\n}\nimpl Sub for u16 {\n    fn sub(self, other: u16) -> u16 {\n        self - other\n    }\n}\nimpl Sub for u8 {\n    fn sub(self, other: u8) -> u8 {\n        self - other\n    }\n}\nimpl Sub for u1 {\n    fn sub(self, other: u1) -> u1 {\n        self - other\n    }\n}\n\nimpl Sub for i8 {\n    fn sub(self, other: i8) -> i8 {\n        self - other\n    }\n}\nimpl Sub for i16 {\n    fn sub(self, other: i16) -> i16 {\n        self - other\n    }\n}\nimpl Sub for i32 {\n    fn sub(self, other: i32) -> i32 {\n        self - other\n    }\n}\nimpl Sub for i64 {\n    fn sub(self, other: i64) -> i64 {\n        self - other\n    }\n}\n\n// docs:start:mul-trait\npub trait Mul {\n    fn mul(self, other: Self) -> Self;\n}\n// docs:end:mul-trait\n\nimpl Mul for Field {\n    fn mul(self, other: Field) -> Field {\n        self * other\n    }\n}\n\nimpl Mul for u128 {\n    fn mul(self, other: u128) -> u128 {\n        self * other\n    }\n}\nimpl Mul for u64 {\n    fn mul(self, other: u64) -> u64 {\n        self * other\n    }\n}\nimpl Mul for u32 {\n    fn mul(self, other: u32) -> u32 {\n        self * other\n    }\n}\nimpl Mul for u16 {\n    fn mul(self, other: u16) -> u16 {\n        self * other\n    }\n}\nimpl Mul for u8 {\n    fn mul(self, other: u8) -> u8 {\n        self * other\n    }\n}\nimpl Mul for u1 {\n    fn mul(self, other: u1) -> u1 {\n        self * other\n    }\n}\n\nimpl Mul for i8 {\n    fn mul(self, other: i8) -> i8 {\n        self * other\n    }\n}\nimpl Mul for i16 {\n    fn mul(self, other: i16) -> i16 {\n        self * other\n    }\n}\nimpl Mul for i32 {\n    fn mul(self, other: i32) -> i32 {\n        self * other\n    }\n}\nimpl Mul for i64 {\n    fn mul(self, other: i64) -> i64 {\n        self * other\n    }\n}\n\n// docs:start:div-trait\npub trait Div {\n    fn div(self, other: Self) -> Self;\n}\n// docs:end:div-trait\n\nimpl Div for Field {\n    fn div(self, other: Field) -> Field {\n        self / other\n    }\n}\n\nimpl Div for u128 {\n    fn div(self, other: u128) -> u128 {\n        self / other\n    }\n}\nimpl Div for u64 {\n    fn div(self, other: u64) -> u64 {\n        self / other\n    }\n}\nimpl Div for u32 {\n    fn div(self, other: u32) -> u32 {\n        self / other\n    }\n}\nimpl Div for u16 {\n    fn div(self, other: u16) -> u16 {\n        self / other\n    }\n}\nimpl Div for u8 {\n    fn div(self, other: u8) -> u8 {\n        self / other\n    }\n}\nimpl Div for u1 {\n    fn div(self, other: u1) -> u1 {\n        self / other\n    }\n}\n\nimpl Div for i8 {\n    fn div(self, other: i8) -> i8 {\n        self / other\n    }\n}\nimpl Div for i16 {\n    fn div(self, other: i16) -> i16 {\n        self / other\n    }\n}\nimpl Div for i32 {\n    fn div(self, other: i32) -> i32 {\n        self / other\n    }\n}\nimpl Div for i64 {\n    fn div(self, other: i64) -> i64 {\n        self / other\n    }\n}\n\n// docs:start:rem-trait\npub trait Rem {\n    fn rem(self, other: Self) -> Self;\n}\n// docs:end:rem-trait\n\nimpl Rem for u128 {\n    fn rem(self, other: u128) -> u128 {\n        self % other\n    }\n}\nimpl Rem for u64 {\n    fn rem(self, other: u64) -> u64 {\n        self % other\n    }\n}\nimpl Rem for u32 {\n    fn rem(self, other: u32) -> u32 {\n        self % other\n    }\n}\nimpl Rem for u16 {\n    fn rem(self, other: u16) -> u16 {\n        self % other\n    }\n}\nimpl Rem for u8 {\n    fn rem(self, other: u8) -> u8 {\n        self % other\n    }\n}\nimpl Rem for u1 {\n    fn rem(self, other: u1) -> u1 {\n        self % other\n    }\n}\n\nimpl Rem for i8 {\n    fn rem(self, other: i8) -> i8 {\n        self % other\n    }\n}\nimpl Rem for i16 {\n    fn rem(self, other: i16) -> i16 {\n        self % other\n    }\n}\nimpl Rem for i32 {\n    fn rem(self, other: i32) -> i32 {\n        self % other\n    }\n}\nimpl Rem for i64 {\n    fn rem(self, other: i64) -> i64 {\n        self % other\n    }\n}\n\n// docs:start:neg-trait\npub trait Neg {\n    fn neg(self) -> Self;\n}\n// docs:end:neg-trait\n\n// docs:start:neg-trait-impls\nimpl Neg for Field {\n    fn neg(self) -> Field {\n        -self\n    }\n}\n\nimpl Neg for i8 {\n    fn neg(self) -> i8 {\n        -self\n    }\n}\nimpl Neg for i16 {\n    fn neg(self) -> i16 {\n        -self\n    }\n}\nimpl Neg for i32 {\n    fn neg(self) -> i32 {\n        -self\n    }\n}\nimpl Neg for i64 {\n    fn neg(self) -> i64 {\n        -self\n    }\n}\n// docs:end:neg-trait-impls\n","path":"std/ops/arith.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"46":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n","path":"std/slice.nr"},"51":{"source":"use dep::aztec::hash::pedersen_hash;\nuse std::ops::{Add, Sub};\n\n// Utility used to easily get a \"id\" for a private user that sits in the same\n// \"space\" as the public users.\n// It help us to have a single mapping for collateral that have both public and private users.\npub fn compute_identifier(secret: Field, on_behalf_of: Field, self: Field) -> Field {\n    // EITHER secret OR on_behalf_of MUST be set. But not both\n    assert(!((secret == 0) as bool & (on_behalf_of == 0) as bool));\n    if (secret != 0) {\n        pedersen_hash([self, secret], 0)\n    } else {\n        on_behalf_of\n    }\n}\n\npub fn covered_by_collateral(\n    price: u128,\n    loan_to_value: u128,\n    collateral: u128,\n    increase: u128,\n    decrease: u128,\n) -> u128 {\n    let price_precision = 1000000000 as u128;\n    let ltv_precision = 10000 as u128;\n\n    let collateral = (collateral + increase) - decrease;\n\n    let collateral_value = (collateral * price) / price_precision;\n    let debt_covered = (collateral_value * loan_to_value) / ltv_precision;\n\n    debt_covered\n}\n\npub struct DebtReturn {\n    debt_value: u128,\n    static_debt: u128,\n}\n\nfn div_up(a: u128, b: u128) -> u128 {\n    let div = a / b;\n    if div * b < a {\n        div + (1 as u128)\n    } else {\n        div\n    }\n}\n\npub fn debt_updates(\n    interest_accumulator: u128,\n    static_debt: u128,\n    increase: u128,\n    decrease: u128,\n) -> DebtReturn {\n    assert(interest_accumulator > (0 as u128));\n    let accumulator_precision = 1000000000 as u128;\n\n    let current_debt_value = (static_debt * interest_accumulator) / accumulator_precision;\n    let new_debt_value = current_debt_value.add(increase).sub(decrease);\n\n    // static_debt_increase = amount / accumulator\n    // rounding up new debt.\n    let static_debt_increase = div_up(increase * accumulator_precision, interest_accumulator);\n    // rounding down repayment.\n    let static_debt_decrease = (decrease * accumulator_precision) / interest_accumulator;\n\n    // We need to allow repaying of the entire debt as well etc. This is very prone to failing\n    // if you try to repay exact due to time diff between sim and execution.\n    let new_static_debt = static_debt.add(static_debt_increase).sub(static_debt_decrease);\n\n    DebtReturn { debt_value: new_debt_value, static_debt: new_static_debt }\n}\n\npub fn debt_value(static_debt: u128, interest_accumulator: u128) -> u128 {\n    let accumulator_precision = 1000000000 as u128;\n    div_up(static_debt * interest_accumulator, accumulator_precision)\n}\n","path":"/home/jean/work/noir/lending/contracts/src/helpers.nr"},"52":{"source":"use std::ops::{Add, Div, Mul, Sub};\n\n// Binomial approximation of exponential\n// using lower than desired precisions for everything due to u128 limit\n// (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3]...\n// we are losing around almost 8 digits of precision from yearly -> daily interest\n// dividing with 31536000 (seconds per year).\n// rate must be measured with higher precision than 10^9.\n// we use e18, and rates >= 4% yearly. Otherwise need more precision\npub fn compute_multiplier(rate_per_second: u128, dt: u64) -> u128 {\n    let base = 1000000000 as u128; // 1e9\n    let WAD = 1000000000000000000 as u128; // 1e18\n    let diff = WAD.div(base);\n    let mut res = base;\n    if dt != 0 {\n        let exp_minus_one = (dt - 1) as u128;\n        let exp_minus_two = (if (dt > 2) { dt - 2 } else { 0 }) as u128;\n        let dt = dt as u128;\n\n        // if rate_per_second < sqrt(WAD), then base_power_two and base_power_three = 0\n        let rate = rate_per_second;\n        let base_power_two = (rate * rate) / WAD;\n        let base_power_three = (base_power_two * rate) / WAD;\n\n        let temp = dt.mul(exp_minus_one);\n        let second_term = temp.mul(base_power_two).div(2 as u128);\n        let third_term = temp.mul(exp_minus_two).mul(base_power_three).div(6 as u128);\n\n        // throwing away precision to keep us under u128 :sob:\n        let offset = dt.mul(rate).add(second_term).add(third_term).div(diff);\n\n        res = base.add(offset);\n    }\n    res\n}\n","path":"/home/jean/work/noir/lending/contracts/src/interest_math.nr"},"53":{"source":"mod asset;\nmod position;\nmod interest_math;\nmod helpers;\n\n// Single asset CDP contract.\n// Shoving re-entries up the ass.\n// TODO's:\n// - Use asset address instead of 0. We only use 0, as there is only one collateral asset :shrug:.\n// - Update accumulator should be for specific asset, just abusing only 1 asset atm.\n// - A way to repay all debt at once\n// - Liquidations\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Lending {\n    use dep::aztec::prelude::{AztecAddress, Map, PublicMutable};\n\n    use crate::asset::Asset;\n    use crate::helpers::{compute_identifier, covered_by_collateral, debt_updates, debt_value};\n    use crate::interest_math::compute_multiplier;\n    use crate::position::Position;\n    use dep::price_feed::PriceFeed;\n    use dep::token::Token;\n\n    use dep::aztec::macros::{\n        functions::{initializer, internal, private, public, view, utility},\n        storage::storage,\n    };\n\n    use dep::aztec::protocol_types::traits::{FromField, ToField};\n\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[storage]\n    struct Storage<Context> {\n        collateral_asset: PublicMutable<AztecAddress, Context>,\n        stable_coin: PublicMutable<AztecAddress, Context>,\n        assets: Map<Field, PublicMutable<Asset, Context>, Context>,\n        collateral: Map<AztecAddress, PublicMutable<u128, Context>, Context>,\n        static_debt: Map<AztecAddress, PublicMutable<u128, Context>, Context>, // abusing keys very heavily\n    }\n\n    // Constructs the contract.\n    #[private]\n    #[initializer]\n    fn constructor() {}\n\n    #[public]\n    fn init(\n        oracle: AztecAddress,\n        loan_to_value: u128,\n        collateral_asset: AztecAddress,\n        stable_coin: AztecAddress,\n    ) {\n        let asset_loc = storage.assets.at(0);\n        let asset: Asset = asset_loc.read();\n\n        let loan_to_value = loan_to_value;\n\n        assert(loan_to_value <= (10000 as u128));\n        assert(asset.last_updated_ts == 0);\n        assert(asset.interest_accumulator == 0 as u128);\n\n        let last_updated_ts = context.timestamp();\n\n        asset_loc.write(\n            Asset {\n                interest_accumulator: 1000000000 as u128,\n                last_updated_ts,\n                loan_to_value,\n                oracle,\n            },\n        );\n\n        storage.collateral_asset.write(collateral_asset);\n        storage.stable_coin.write(stable_coin);\n    }\n\n    // Create a position.\n    #[public]\n    fn update_accumulator() -> Asset {\n        let asset_loc = storage.assets.at(0);\n        let mut asset: Asset = asset_loc.read();\n\n        let timestamp = context.timestamp();\n        let dt = timestamp - asset.last_updated_ts;\n\n        // Only update if time has passed.\n        if !(dt == 0) {\n            let precision = 1000000000 as u128;\n            let rate_per_second = 1268391679 as u128; // 4% yearly rate / (60 * 60 * 24 * 365)\n            // if rate_per_second < sqrt(WAD) our approx is eq precision + rate * dt\n            let multiplier = compute_multiplier(rate_per_second, dt);\n\n            // accumulator *= multiplier, and multiplier >= 1\n            asset.interest_accumulator = (asset.interest_accumulator * multiplier) / precision;\n            asset.last_updated_ts = timestamp;\n\n            asset_loc.write(asset);\n        }\n\n        asset\n    }\n\n    #[private]\n    fn deposit_private(\n        from: AztecAddress,\n        amount: u128,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        let _res = Token::at(collateral_asset)\n            .transfer_to_public(from, context.this_address(), amount, nonce)\n            .call(&mut context);\n        // docs:start:enqueue_public\n        Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, collateral_asset)\n            .enqueue(&mut context);\n        // docs:end:enqueue_public\n    }\n\n    #[public]\n    fn deposit_public(\n        amount: u128,\n        nonce: Field,\n        on_behalf_of: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        // docs:start:public_to_public_call\n        let _ = Token::at(collateral_asset)\n            .transfer_in_public(context.msg_sender(), context.this_address(), amount, nonce)\n            .call(&mut context);\n        // docs:end:public_to_public_call\n        let _ = Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, collateral_asset)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _deposit(owner: AztecAddress, amount: u128, collateral_asset: AztecAddress) {\n        let _asset = Lending::at(context.this_address()).update_accumulator().call(&mut context);\n\n        let coll_asset = storage.collateral_asset.read();\n        assert(coll_asset.eq(collateral_asset));\n\n        let coll_loc = storage.collateral.at(owner);\n        let collateral = coll_loc.read();\n        coll_loc.write(collateral + amount);\n    }\n\n    #[private]\n    fn withdraw_private(secret: Field, to: AztecAddress, amount: u128) {\n        let on_behalf_of = compute_identifier(secret, 0, context.msg_sender().to_field());\n        Lending::at(context.this_address())\n            ._withdraw(AztecAddress::from_field(on_behalf_of), to, amount)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn withdraw_public(to: AztecAddress, amount: u128) {\n        let _ = Lending::at(context.this_address())\n            ._withdraw(context.msg_sender(), to, amount)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _withdraw(owner: AztecAddress, recipient: AztecAddress, amount: u128) {\n        let asset = Lending::at(context.this_address()).update_accumulator().call(&mut context);\n        let price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n\n        let coll_loc = storage.collateral.at(owner);\n        let collateral = coll_loc.read();\n\n        let debt_loc = storage.static_debt.at(owner);\n        let static_debt = debt_loc.read();\n\n        // debt_covered will revert if decrease would leave insufficient collateral to cover debt.\n        // or trying to remove more collateral than available\n        let debt_covered =\n            covered_by_collateral(price, asset.loan_to_value, collateral, 0 as u128, amount);\n        let debt_returns = debt_updates(\n            asset.interest_accumulator,\n            static_debt,\n            0 as u128,\n            0 as u128,\n        );\n\n        assert(debt_returns.debt_value < debt_covered);\n\n        coll_loc.write(collateral - amount);\n\n        // @todo @LHerskind Support both shielding and transfers (for now just transfer)\n        let collateral_asset = storage.collateral_asset.read();\n        let _ = Token::at(collateral_asset)\n            .transfer_in_public(context.this_address(), recipient, amount, 0)\n            .call(&mut context);\n    }\n\n    #[private]\n    fn borrow_private(secret: Field, to: AztecAddress, amount: u128) {\n        let on_behalf_of = compute_identifier(secret, 0, context.msg_sender().to_field());\n        let _ = Lending::at(context.this_address())\n            ._borrow(AztecAddress::from_field(on_behalf_of), to, amount)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn borrow_public(to: AztecAddress, amount: u128) {\n        let _ = Lending::at(context.this_address())._borrow(context.msg_sender(), to, amount).call(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _borrow(owner: AztecAddress, to: AztecAddress, amount: u128) {\n        let asset = Lending::at(context.this_address()).update_accumulator().call(&mut context);\n        let price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n\n        // Fetch collateral and static_debt, compute health of current position\n        let collateral = storage.collateral.at(owner).read();\n        let static_debt = storage.static_debt.at(owner).read();\n\n        let debt_covered =\n            covered_by_collateral(price, asset.loan_to_value, collateral, 0 as u128, 0 as u128);\n        let debt_returns = debt_updates(asset.interest_accumulator, static_debt, amount, 0 as u128);\n\n        assert(debt_returns.debt_value < debt_covered);\n\n        storage.static_debt.at(owner).write(debt_returns.static_debt);\n\n        // @todo @LHerskind Need to support both private and public minting.\n        let stable_coin = storage.stable_coin.read();\n        let _ = Token::at(stable_coin).mint_to_public(to, amount).call(&mut context);\n    }\n\n    #[private]\n    fn repay_private(\n        from: AztecAddress,\n        amount: u128,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        stable_coin: AztecAddress,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        // docs:start:private_call\n        let _ = Token::at(stable_coin).burn_private(from, amount, nonce).call(&mut context);\n        // docs:end:private_call\n        let _ = Lending::at(context.this_address())\n            ._repay(AztecAddress::from_field(on_behalf_of), amount, stable_coin)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn repay_public(amount: u128, nonce: Field, owner: AztecAddress, stable_coin: AztecAddress) {\n        let _ = Token::at(stable_coin).burn_public(context.msg_sender(), amount, nonce).call(\n            &mut context,\n        );\n        let _ = Lending::at(context.this_address())._repay(owner, amount, stable_coin).call(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _repay(owner: AztecAddress, amount: u128, stable_coin: AztecAddress) {\n        let asset = Lending::at(context.this_address()).update_accumulator().call(&mut context);\n\n        // To ensure that private is using the correct token.\n        assert(stable_coin.eq(storage.stable_coin.read()));\n\n        let static_debt = storage.static_debt.at(owner).read();\n        let debt_returns = debt_updates(asset.interest_accumulator, static_debt, 0 as u128, amount);\n\n        storage.static_debt.at(owner).write(debt_returns.static_debt);\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_asset(asset_id: Field) -> Asset {\n        storage.assets.at(asset_id).read()\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_position(owner: AztecAddress) -> pub Position {\n        let collateral = storage.collateral.at(owner).read();\n        let static_debt = storage.static_debt.at(owner).read();\n        let asset: Asset = storage.assets.at(0).read();\n        let debt = debt_value(static_debt, asset.interest_accumulator);\n        Position { collateral, static_debt, debt }\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_assets() -> pub [AztecAddress; 2] {\n        [storage.collateral_asset.read(), storage.stable_coin.read()]\n    }\n}\n","path":"/home/jean/work/noir/lending/contracts/src/main.nr"},"55":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr"},"56":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"63":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"64":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"65":{"source":"use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr"},"66":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"70":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"87":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"91":{"source":"use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr"},"92":{"source":"use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr"},"95":{"source":"use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr"},"96":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"99":{"source":"use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr"},"101":{"source":"use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr"},"102":{"source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr"},"103":{"source":"use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr"},"104":{"source":"use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr"},"105":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr"},"106":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr"},"108":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr"},"109":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr"},"110":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr"},"111":{"source":"use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr"},"132":{"source":"use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr"},"135":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"138":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"139":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr"},"140":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"141":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"142":{"source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr"},"143":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"148":{"source":"use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"149":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"150":{"source":"use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"151":{"source":"use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr"},"153":{"source":"use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"155":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr"},"156":{"source":"use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"158":{"source":"use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"167":{"source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"181":{"source":"/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr"},"184":{"source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"185":{"source":"use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr"},"187":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr"},"188":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr"},"190":{"source":"use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/field.nr"},"192":{"source":"use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"220":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr"},"222":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"265":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"268":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr"},"270":{"source":"use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr"},"275":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, FromField, Hash, Serialize, ToField},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"282":{"source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"283":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"297":{"source":"use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"299":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"300":{"source":"use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"309":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"320":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"334":{"source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"338":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"339":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"355":{"source":"pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr"},"358":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"364":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/home/jean/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr"},"395":{"source":"use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n","path":"/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr"}}}