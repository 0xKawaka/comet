{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "Lending",
  "functions": [
    {
      "name": "deposit_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "decompose_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "_compute_collateral_debt_value",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8945853978429536226": {
            "error_kind": "string",
            "string": "Function _compute_collateral_debt_value can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_compute_collateral_debt_value"
      ]
    },
    {
      "name": "_borrow",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1602191554767750373": {
            "error_kind": "string",
            "string": "Function _borrow can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14687457983715723088": {
            "error_kind": "string",
            "string": "Asset is not borrowable"
          },
          "15333773746166717806": {
            "error_kind": "string",
            "string": "Insufficient collateral"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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CygABoBFAAUkAgAFAAAfuSUAABkhLQwBBy0MAggtDAMJLQwECiMAACBMCygABoBFAAUkAgAFAAAf4yUAABkhLQwBBy0MAggtDAMJLQwECiMAACBMCygABoBFAAUkAgAFAAAgDSUAABkhLQwBBy0MAggtDAMJLQwECiMAACBMCygABoBFAAUkAgAFAAAgNyUAABkhLQwBBy0MAggtDAMJLQwECiMAACBMLQwKBC0MBwEtDAgCLQwJAyYuAYADgAYLAIAGAAKAByQAgAcAACB4IwAAIIMuAIADgAUjAAAg6i4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAACDWLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAACClKAGABQQAAQMAgAYAAoAGIwAAIOomKgEAAQXFa8RaDhAAAjwBAQImLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAAIUwjAAAhvCQAgA0AACFZIwAAIXIuAIADgAUBAIAFAAKADi4CgAuADiMAACG3KACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAACG3IwAAIhAoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAAIhAoAIANBAADAQCABYANgAwLAIADgAWADSQAgA0AACJ0AQCACoAIgA8uAIAKgBAuAIAMgBELAIAQgA+AEiQAgBIAACJ0LgGAEIAOLgKADoARAQCAEAACgBABAIARAAKAESMAACJDAQCADIAIgAYm",
      "debug_symbols": "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",
      "brillig_names": [
        "_borrow"
      ]
    },
    {
      "name": "withdraw_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AAiAAygAgAQEAAElAAAHQS4IgAUACi4IgAYACy0OAgstDgkGLQ4KAQEoAAWARgACLQwCBSMAAAapLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAAB5AjAAAIACQAgA0AAAedIwAAB7YuAIADgAUBAIAFAAKADi4CgAuADiMAAAf7KACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAAf7IwAACFQoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAACFQoAIANBAADAQCABYANgAwLAIADgAWADSQAgA0AAAi4AQCACoAIgA8uAIAKgBAuAIAMgBELAIAQgA+AEiQAgBIAAAi4LgGAEIAOLgKADoARAQCAEAACgBABAIARAAKAESMAAAiHAQCADIAIgAYmLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAACRAjAAAJgCQAgA0AAAkdIwAACTYuAIADgAUBAIAFAAKADi4CgAuADiMAAAl7KACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAAl7IwAACdQoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAACdQoAIANBAADAQCABYANgAwBAIAMgASADQMAgAgAAoAOAQCADYAOgA8BAIAKgA6AEA0AgBCACoAOJACADgAACjQuAYAQgBEuAoARgA8DAIAQAAKAEAMAgA8AAoAPIwAACgMuAIAMgAYmKgEAAQXFa8RaDhAAAjwBAQIm",
      "debug_symbols": "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",
      "brillig_names": [
        "withdraw_public"
      ]
    },
    {
      "name": "get_total_deposited_assets",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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6HGzYuhxs2LocbNS6ANuVgw9blYMPW5WDD1uVgy9nxm98xt6l2Lt6JhX8u62sPoE3txRTu1O26Kc2m22RTm1e2yLcmo32Bbl1O6uKco4tVtri3Jq99UW5dRuqi3Kqd1RW5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKhNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKjNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKgttphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxHKvOB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFsuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mEsiy4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4nZaoTS4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4na+i9K7xX4c7V2In1DujMSnFYkJ5mkkeW/ccckfB0f79Mk5/BbJ4qM6EAmH1oFIeL8ORMJVdiCSRyT9IuGEOxAJj92BSLj3DkQiF+hAJBIH/SI5EocORCJx6EAkEocORJo7ccjr0c7b8Ono33A8cI7hzO2wK3DmdrYVOHM7ygqcuZ1cBc7cDuocjp/buVTgzO0YKnDm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",
      "brillig_names": [
        "get_total_deposited_assets"
      ]
    },
    {
      "name": "borrow_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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gAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAAB0UjAAAHtSQAgA0AAAdSIwAAB2suAIADgAUBAIAFAAKADi4CgAuADiMAAAewKACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAAewIwAACAkoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAACAkoAIANBAADAQCABYANgAwLAIADgAWADSQAgA0AAAhtAQCACoAIgA8uAIAKgBAuAIAMgBELAIAQgA+AEiQAgBIAAAhtLgGAEIAOLgKADoARAQCAEAACgBABAIARAAKAESMAAAg8AQCADIAIgAYmLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAACMUjAAAJNSQAgA0AAAjSIwAACOsuAIADgAUBAIAFAAKADi4CgAuADiMAAAkwKACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAAkwIwAACYkoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAACYkoAIANBAADAQCABYANgAwBAIAMgASADQMAgAgAAoAOAQCADYAOgA8BAIAKgA6AEA0AgBCACoAOJACADgAACekuAYAQgBEuAoARgA8DAIAQAAKAEAMAgA8AAoAPIwAACbguAIAMgAYmKgEAAQXFa8RaDhAAAjwBAQIm",
      "debug_symbols": "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",
      "brillig_names": [
        "borrow_public"
      ]
    },
    {
      "name": "update_accumulators",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "12348881442450494403": {
            "error_kind": "string",
            "string": "Function _compute_utilization_rate can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17134621154673181869": {
            "error_kind": "string",
            "string": "Function _compute_borrow_rate can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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ABy2IwAAHCgLKAAFgFcABiQCAAYAAByGIwAAHD0LKAAFgFkABiQCAAYAABxWJwINBAA8CQENCygADIBEAAUkAgAFAAAcayUAABESLQwBBy0MAggtDAMJLQwECi4IgFoACyMAAB42CygADIBEAAUkAgAFAAAcmyUAABESLQwBBy0MAggtDAMJLQwECi4IgFgACyMAAB42CygADIBEAAUkAgAFAAAcyyUAABESLQwBBy0MAggtDAMJLQwECi4IgFMACyMAAB42CygADIBEAAUkAgAFAAAc+yUAABESLQwBBy0MAggtDAMJLQwECi4IgFQACyMAAB42CygADIBEAAUkAgAFAAAdKyUAABESLQwBBy0MAggtDAMJLQwECi4IgFUACyMAAB42CygADIBEAAUkAgAFAAAdWyUAABESLQwBBy0MAggtDAMJLQwECi4IgFYACyMAAB42CygADIBEAAUkAgAFAAAdiyUAABESLQwBBy0MAggtDAMJLQwECi4IgFcACyMAAB42CygADIBEAAUkAgAFAAAduyUAABESLQwBBy0MAggtDAMJLQwECi4IgFkACyMAAB42CygADIBEAAUkAgAFAAAd6yUAABESLQwBBy0MAggtDAMJLQwECi4IgFsACyMAAB42CygADIBEAAUkAgAFAAAeGyUAABESLQwBBy0MAggtDAMJLQwECi4IgFwACyMAAB42LQwKBC0MBwEtDAgCLQwLBS0MCQMmJQAADogtCAELJwIMBAQAEAEMAScDCwQBACgLAgwtDAwNLgqARgANACgNAg0uCoBGAA0AKA0CDS4KgEYADS0IAQwnAg0EBQAQAQ0BJwMMBAEAKAwCDS0MDQ4uCoBGAA4AKA4CDi4KgEYADgAoDgIOLgqARgAOACgOAg4uCoBdAA4tCAENAAABAgEtDgsNLQgBCwAAAQIBLQ4MCy0IAQwAAAECAS4KgEUADC0IAQ4AAAECAS4KgEQADicCDwQQLQgAEC0MDREtDAsSLQwMEy0MDhQtDAQVABAADwAlAAAO1i0EAAAnAgQEDy0IAA8tDA0QLQwLES0MDBItDA4TLQwGFAAQAAQAJQAADtYtBAAALQ0OBAsoAASARAAGJAIABgAAH3YnAg8EADwJAQ8nAgQEDy0IAA8tDA0QLQwLES0MDBItDA4TABAABAAlAAAP/y0EAAAtDQ0ELQ0LBi0NDA8tDgQNLQ4GCy0ODwwuCoBHAA4BKAAGgEgACy0NCwQLKAAFgEwABgsoAASARgALJAIABgAAIeAjAAAf5AsoAAWAUwAGJAIABgAAIbYjAAAf+QsoAAWAVAAGJAIABgAAIYwjAAAgDgsoAAWAVQAGJAIABgAAIWIjAAAgIwsoAAWAVgAGJAIABgAAITgjAAAgOAsoAAWAWAAGJAIABgAAIQ4jAAAgTQsoAAWAWgAGJAIABgAAIOQjAAAgYgsoAAWAWwAGJAIABgAAILojAAAgdwsoAAWAXAAGJAIABgAAIJAnAgwEADwJAQwLKAALgEQABSQCAAUAACClJQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgoLKAALgEQABSQCAAUAACDPJQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgoLKAALgEQABSQCAAUAACD5JQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgoLKAALgEQABSQCAAUAACEjJQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgoLKAALgEQABSQCAAUAACFNJQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgoLKAALgEQABSQCAAUAACF3JQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgoLKAALgEQABSQCAAUAACGhJQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgoLKAALgEQABSQCAAUAACHLJQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgoLKAALgEQABSQCAAUAACH1JQAAERItDAEHLQwCCC0MAwktDAQKIwAAIgotDAoELQwHAS0MCAItDAkDJioBAAEFZGGIqMbPlMs8AQECJioBAAEF7cpnKDUwRK08AQECJioBAAEFRafKcRlB5BU8AQECJi4BgAOABgsAgAYAAoAHJACABwAAImwjAAAidy4AgAOABSMAACLeLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAAIsouAYAKgAguAoAIgAsBAIAKAAKACgEAgAsAAoALIwAAIpkoAYAFBAABAwCABgACgAYjAAAi3iYqAQABBb4eP/8+pPb6PAEBAiYqAQABBcVrxFoOEAACPAEBAiY=",
      "debug_symbols": "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",
      "brillig_names": [
        "update_accumulators"
      ]
    },
    {
      "name": "get_total_borrowed_assets",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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6HGzYuhxs2LocbNS6ANuVgw9blYMPW5WDD1uVgy9nxm98xt6l2Lt6JhX8u62sPoE3txRTu1O26Kc2m22RTm1e2yLcmo32Bbl1O6uKco4tVtri3Jq99UW5dRuqi3Kqd1RW5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKhNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKjNtphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxXKgttphhK30wwlbqcZStxOM5QelK1Q4naaocTtNEOJ22mGErfTDCVupxHKvOB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mF0uN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuJ2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuF2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFMuN2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mFsuB2mqHE7TRDidtphhK30wylB2UrlLidZihxO81Q4naaocTtNEOJ22mEsiy4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4nZaoTS4nWYocTvNUOJ2mqHE7TRD6UHZCiVupxlK3E4zlLidZihxO81Q4na+i9K7xX4c7V2In1DujMSnFYkJ5mkkeW/ccckfB0f79Mk5/BbJ4qM6EAmH1oFIeL8ORMJVdiCSRyT9IuGEOxAJj92BSLj3DkQiF+hAJBIH/SI5EocORCJx6EAkEocORJo7ccjr0c7b8Ono33A8cI7hzO2wK3DmdrYVOHM7ygqcuZ1cBc7cDuocjp/buVTgzO0YKnDm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9F29db2r+j4kfVdvXe9Qvg9J39Vb17t970PSd/XW9c7Z+5D0Xb11vQv1PiR9V29d7+i8D0nf1VvXuyPvQ9J39db1TsP7kPRdvXW9a+8+JH1Xb13vgLsPSd/VW9e7ye5D0nf11vXOrPuQ9F29db3L6T4kfVdvXe8Yug9J39Vb17tv7kPSd/XW9U6W+5D0Xb11vSvkPiR9V29d77C4D0nf1VvXuxXuQ9J39da15/99SPqu3rr2or8PSd/VW9ce6fch6bt669q7+z4kfVdvXXtK34ek7+qta6/j+5D0Xb117cF7H5K+q7eu/VjvQ9J39da1H+Z9SPqu3rr2I7wPSd3V2+jaD+4+JHVXb6NrP677kNRdvc2i7uptdO3ncx+Suqu30bWfyn1I6q7eRtdmGb+HpGsnifuQ9F29de1BcB+Svqu3rl+v34ek7+qt63fP9yHpu3rr+sXsfUj6rt76fmtp9P3W0uj7raXR91tLo++3lkbfby2Nvt9aGn2/tTT6fmtp9P3W0uj7raXR91tLo++3lkbfby2Nvt9aGn2/tTT6fmtp9P3W0uj7raXR91tLo++3lqbRb5qW9BiSSU9D+v0lP//9zf00d+00f+20cO20eO20dO20fO20cum0n/8+4X6auXbatSqJ16okXquSeK1K4rUqideqJF6rknitStK1KknXqiRdq5J0rUrStSpJ16okXauSdK1K0rUqSdeqJF+rknytSvK1KsnXqiRfq5J8rUrytSrJ16okX6uSfK1KyrUqKdeqpFyrknKtSsq1KinXqqRcq5JyrUrKtSopl6rELsu108y10+y109y10/y108K10+K109K10/K1065ViblWJeZalZhrVWKuVYm5ViXmWpWYa1VirlWJuVYl5lqV2GtVYq9Vib1WJfZaleyvz/i4nfbptTiP08L+aeZxml3+6zwTyMv2oh732Kb2FkfsHFvyGmiU8vnY+3CiruEkXcPJuoZTVA1nf71EbjhG13CsruE4XcPxuoaj66rsdF2Vna6rstN1VXbvvipvr+kzy2K/jscvysZjlI3HKhuPUzYer2w8P74230+L105Ll05rtDHf6VKfbbTVXuVL3Du+xL/jS8I7viS+40vaPJTgzeNLQnn6kp+thN+HlPUNqagbUqNN6H4wJH+Li9crlf1aSY22oGs4IKttQG9/mKx2A3z/7nPVEQV1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",
      "brillig_names": [
        "get_total_borrowed_assets"
      ]
    },
    {
      "name": "_compute_utilization_rate",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "precision",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "deposit_accumulator",
            "type": {
              "kind": "struct",
              "path": "accumulator::Accumulator",
              "fields": [
                {
                  "name": "value",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "last_updated_ts",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "borrow_accumulator",
            "type": {
              "kind": "struct",
              "path": "accumulator::Accumulator",
              "fields": [
                {
                  "name": "value",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "last_updated_ts",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "12348881442450494403": {
            "error_kind": "string",
            "string": "Function _compute_utilization_rate can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBcJwAABAMnAggEBycCCQQAHxgACQAIgFQdAIBWgFYGHQCAV4BXBh0AgFiAWAUdAIBZgFkGHQCAWoBaBS4IgFQAAS4IgFUAAi4IgFYAAy4IgFcABC4IgFgABS4IgFkABi4IgFoAByUAAACSJQAAARguBAABgFsoAgACBIBbJwIDBAE7DQACAAMoAIBDBAADKACARAEAACgAgEUEAAAoAIBGAAAAKACARwEAASgAgEgEAAEoAIBJAAAkKACASgAAJSgAgEsAACooAIBMAAAsKACATQAALigAgE4AADAoAIBPAAAzKACAUAAANSgAgFEAADgoAIBSAAA7KwCAUwAAAAAAAAAAAgAAAAAAAAAAJiUAAAOYLQgBCAAAAQIBLgqARAAILQgBCQAAAQIBLgqARgAJLQgBCgAAAQIBJwILAAItDgsKHgIACwAeAgAMADM4AAsADAANJAIADQAAAWwlAAADwR4CAAsBHgIADAAKOAsMDSQCAA0AAAGIJQAAA9MnAgsABicCEQQSLQgAEi0MCBMtDAkULQwKFS0MCxYuCIBJABctDAEYABAAEQAlAAAD5S0EAAAtDBMMLQwUDS0MFQ4tDBYPLQwXECcCFAQVLQgAFS0MDBYtDA0XLQwOGC0MDxktDBAaLQwCGwAQABQAJQAACEAtBAAALQwWCy0MFxEtDBgSLQwZEy8MABMADBwMDA4GHAwODQAcDA0MBicCDQAHJwIVBBYtCAAWLQwIFy0MCRgtDAoZLQwNGi4IgEoAGy0MARwAEAAVACUAAAPlLQQAAC0MFw4tDBgPLQwZEC0MGhMtDBsUJwINBBUtCAAVLQwOFi0MDxctDBAYLQwTGS0MFBotDAIbABAADQAlAAAIQC0EAAAtDBYBLQwXCC0MGAktDBkKLwwACgACHAwCDQYcDA0KABwMCgIGBDgMBAonAg4GAAo4DgQNJAIADQAAAvIGOAoEEAo4EAwPJAIADwAAAvIlAAAMEgY4CgMEBDgCBgonAg0GAAo4DQYMJAIADAAAAyUGOAoGDwo4DwIOJAIADgAAAyUlAAAMEgY4CgMCLQgBBgAAAQIBJwIKBgAtDgoGCjgCCgwkAgAMAAADiiMAAANOBDgCAwEnAgcGAAo4BwMFJAIABQAAA3wGOAEDCQo4CQIIJAIACAAAA3wlAAAMEgY4AQQCLQ4CBiMAAAOTLQ4KBiMAAAOTLQ0GASYoAIAEBHgADQAAAIAEgAMkAIADAAADwCoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEFq2AKPqas08M8AQECJiUAAAOYLQgBDCcCDQQEABABDQEnAwwEAQAoDAINLQwNDi4KgEYADgAoDgIOLgqARgAOACgOAg4uCoBGAA4tCAENJwIOBAUAEAEOAScDDQQBACgNAg4tDA4PLgqARgAPACgPAg8uCoBGAA8AKA8CDy4KgEYADwAoDwIPLgqAUwAPLQgBDgAAAQIBLQ4MDi0IAQwAAAECAS0ODQwtCAENAAABAgEuCoBFAA0tCAEPAAABAgEuCoBEAA8nAhAEES0IABEtDA4SLQwMEy0MDRQtDA8VLQwEFgAQABAAJQAADCQtBAAAJwIEBBAtCAAQLQwOES0MDBItDA0TLQwPFC0MBhUAEAAEACUAAAwkLQQAAC0NDwQLKAAEgEQABiQCAAYAAAUQJwIQBAA8CQEQJwIEBBAtCAAQLQwOES0MDBItDA0TLQwPFAAQAAQAJQAADU0tBAAALQ0OBC0NDAYtDQ0QLQ4EDi0OBgwtDhANLgqARwAPASgABoBIAAwtDQwEJwIGABsKOAUGDAsoAASARgAGJAIADAAAB/sjAAAFgCcCDAAdCjgFDA0kAgANAAAHyyMAAAWXJwIMACEKOAUMDScCDAA0JAIADQAAB50jAAAFsycCDQAiCjgFDQ4nAg0AMiQCAA4AAAdvIwAABc8LKAAFgEkADiQCAA4AAAc/IwAABeQLKAAFgEoADiQCAA4AAAcPIwAABfknAg4AJwo4BQ4PJAIADwAABt8jAAAGECcCDgAoCjgFDg8kAgAPAAAGryMAAAYnCjgFDQ4kAgAOAAAGfyMAAAY5CjgFDA0kAgANAAAGTycCDgQAPAkBDgsoAAaARAAFJAIABQAABmQlAAAOYC0MAQctDAIILQwDCS0MBAouCIBQAAsjAAAIKwsoAAaARAAFJAIABQAABpQlAAAOYC0MAQctDAIILQwDCS0MBAouCIBPAAsjAAAIKwsoAAaARAAFJAIABQAABsQlAAAOYC0MAQctDAIILQwDCS0MBAouCIBLAAsjAAAIKwsoAAaARAAFJAIABQAABvQlAAAOYC0MAQctDAIILQwDCS0MBAouCIBMAAsjAAAIKwsoAAaARAAFJAIABQAAByQlAAAOYC0MAQctDAIILQwDCS0MBAouCIBNAAsjAAAIKwsoAAaARAAFJAIABQAAB1QlAAAOYC0MAQctDAIILQwDCS0MBAouCIBOAAsjAAAIKwsoAAaARAAFJAIABQAAB4QlAAAOYC0MAQctDAIILQwDCS0MBAotDA0LIwAACCsLKAAGgEQABSQCAAUAAAeyJQAADmAtDAEHLQwCCC0MAwktDAQKLQwMCyMAAAgrCygABoBEAAUkAgAFAAAH4CUAAA5gLQwBBy0MAggtDAMJLQwECi4IgFEACyMAAAgrCygABoBEAAUkAgAFAAAIECUAAA5gLQwBBy0MAggtDAMJLQwECi4IgFIACyMAAAgrLQwKBC0MBwEtDAgCLQwLBS0MCQMmJQAAA5gtCAELJwIMBAQAEAEMAScDCwQBACgLAgwtDAwNLgqARgANACgNAg0uCoBGAA0AKA0CDS4KgEYADS0IAQwnAg0EBQAQAQ0BJwMMBAEAKAwCDS0MDQ4uCoBGAA4AKA4CDi4KgEYADgAoDgIOLgqARgAOACgOAg4uCoBTAA4tCAENAAABAgEtDgsNLQgBCwAAAQIBLQ4MCy0IAQwAAAECAS4KgEUADC0IAQ4AAAECAS4KgEQADicCDwQQLQgAEC0MDREtDAsSLQwMEy0MDhQtDAQVABAADwAlAAAMJC0EAAAnAgQEDy0IAA8tDA0QLQwLES0MDBItDA4TLQwGFAAQAAQAJQAADCQtBAAALQ0OBAsoAASARAAGJAIABgAACWsnAg8EADwJAQ8nAgQEDy0IAA8tDA0QLQwLES0MDBItDA4TABAABAAlAAANTS0EAAAtDQ0ELQ0LBi0NDA8tDgQNLQ4GCy0ODwwuCoBHAA4BKAAGgEgACy0NCwQnAgYAHwo4BQYLCygABIBGAAYkAgALAAAL1yMAAAnbCygABYBLAAskAgALAAALrSMAAAnwCygABYBMAAskAgALAAALgyMAAAoFCygABYBNAAskAgALAAALWSMAAAoaCygABYBOAAskAgALAAALLyMAAAovCygABYBPAAskAgALAAALBSMAAApECygABYBQAAskAgALAAAK2yMAAApZCygABYBRAAskAgALAAAKsSMAAApuCygABYBSAAskAgALAAAKhycCDAQAPAkBDAsoAAaARAAFJAIABQAACpwlAAAOYC0MAQctDAIILQwDCS0MBAojAAAMAQsoAAaARAAFJAIABQAACsYlAAAOYC0MAQctDAIILQwDCS0MBAojAAAMAQsoAAaARAAFJAIABQAACvAlAAAOYC0MAQctDAIILQwDCS0MBAojAAAMAQsoAAaARAAFJAIABQAACxolAAAOYC0MAQctDAIILQwDCS0MBAojAAAMAQsoAAaARAAFJAIABQAAC0QlAAAOYC0MAQctDAIILQwDCS0MBAojAAAMAQsoAAaARAAFJAIABQAAC24lAAAOYC0MAQctDAIILQwDCS0MBAojAAAMAQsoAAaARAAFJAIABQAAC5glAAAOYC0MAQctDAIILQwDCS0MBAojAAAMAQsoAAaARAAFJAIABQAAC8IlAAAOYC0MAQctDAIILQwDCS0MBAojAAAMAQsoAAaARAAFJAIABQAAC+wlAAAOYC0MAQctDAIILQwDCS0MBAojAAAMAS0MCgQtDAcBLQwIAi0MCQMmKgEAAQVkYYioxs+UyzwBAQImJQAAA5gtDQMGLQ0EBwsoAAeARAAIJAIACAAADEonAgkEADwJAQkLKAAGgEMAByQCAAcAAAzZIwAADF8tDQEGLQ0CBy0NAwgtDQQJDSgACIBDAAokAgAKAAAMhCUAAA5yLgQABoADKACABAQABCUAAA6ELgiABQAKACgKAgsAOAsIDC0OBQwBKAAIgEgABQ44CAUGJAIABgAADMQlAAAPEi0OCgEtDgcCLQ4FAy0OCQQjAAANTCcCBgQHLQgABy0MAQgtDAIJLQwDCi0MBAsAEAAGACUAAA1NLQQAAC0NAQYtDQIHLQ0ECC4EAAaAAygAgAQEAAQlAAAOhC4IgAUACQAoCQIKASgACoBFAAstDgULLQ4JAS0OBwIuCoBIAAMtDggEIwAADUwmJQAAA5guCIBFAAUjAAANXQ0oAAWAQwAGJAIABgAADc0jAAANci0NAQUtDQIGLQ0DBy0NBAgtDQYJACgJAgktDgkGJwIJBAQtCAEKJwILBAUAEAELAScDCgQBACgGAgsnAgwEBAAoCgINPw8ACwANLQ4FAS0OCgItDgcDLQ4IBCYtDQMGDDgFBgcBKAAFgEgABiQCAAcAAA3rIwAADlctDQEHLQ0CCC0NAwktDQQKACgIAgwAOAwFDS0NDQsAKAcCDQA4DQUOLQ0ODAA4CwwNLgQACIADKACABAQABSUAAA6ELgiABQALACgLAgwAOAwFDi0ODQ4tDgcBLQ4LAi0OCQMtDgoEIwAADlctDAYFIwAADV0qAQABBQLcbieAdhKdPAEBAiYqAQABBcVrxFoOEAACPAEBAiYuAYADgAYLAIAGAAKAByQAgAcAAA6fIwAADqouAIADgAUjAAAPES4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAA79LgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAA7MKAGABQQAAQMAgAYAAoAGIwAADxEmKgEAAQVFp8pxGUHkFTwBAQIm",
      "debug_symbols": "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",
      "brillig_names": [
        "_compute_utilization_rate"
      ]
    },
    {
      "name": "_liquidate",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "debt_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "user",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "debt_to_liquidate_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1840251649407153602": {
            "error_kind": "string",
            "string": "Insufficient borrowed amount"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14434150440419769526": {
            "error_kind": "string",
            "string": "collateral >= debt"
          },
          "15333773746166717806": {
            "error_kind": "string",
            "string": "Insufficient collateral"
          },
          "16523063005220065570": {
            "error_kind": "string",
            "string": "Function _liquidate can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_liquidate"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3bjiu7kp77Lut6XSQPyYNfxTCMtt3baKDRbbTbG9gw+t23xlBlSjUrVVRxRCYZ5HezUGMuphT8/lAy/kiJ/L9/+x//+N/+z//8r//0L//Pv/7vv/2n//x///bP//rf/+Hf/+lf/+X2r//7N+N+/7f//b/+4V9+/fN///s//Nu//+0/WZ/M3//2j//yP25/BuP+4+9/+3/+6Z//8W//ySzLf/z9y2hvjP8Y7c267KOD/4//8ve/GX/6O6xH72BsNMvHRcamsBbew9rotojc8ogox4PByaaPsSnExwv7ezyhs3hiZ/GkzuLJfcVjl+vjSevH2Lz4T/EcvHDI22Cb4uOFbQwHo43dp2psTo/RIR+MDmG7K6QlP72yOWS43xSSXc1jdDqKOma/RR1ztoXRbrX7/SY8xi6HPGzKD9C2MNq4ZRttnE2l0YvdAjHLk+S/Rv/KFEOmkClvZYolU8iUtzLFkSmaMiWasPGIbilpH3dZTMz2DzPFkylkyluZso6UKeaRKe5Z/cNMMavdqJvb2xRGkyt/s4FcIVfezJXYea64Zc+V5Au54kzaRjuTn6iHw9EPMs74x3rlzEJde5griVwhV97MlUyukCvv5YrrvVtLrvSTK733a8mVfnKl944tudJPrvTesyVX+skVT66QK2/mSu99W3Kln1zpvW9LrvSTK/RtyZV3c4W+Lbnybq7QtyVX3swVT9+WXHk3V+jbkivv5gp9W2W50u77K56+Lbnybq74kXLlFsemvkupkCuo/zc/VCcW9X+o/lC9Ve929X0ypXXCLPGxTjxN8fDrttlt38s3+WlRMfE3xaG6judRtMuyB7JY90zx6+B1p7Hmx/ebTfoNfKjW3ZnA/X5nWUL+A+BD9b9OBG7W7Wv51jwFcr9PrEN1hk6k+Gyybfo+bY17rIcum78iH6rBogP5UH2KXpCvZu8krd7W38nXoToDw6njUecEdfYf1d6WZ/8H6gzllYdTZywvu99RburYgjo+563sXJc1f6+OX/O+51Xwy/PgXxTH8rLPFEudY+P3HDfepe8phrh72RDtF4pjGdRWFMdynY0ohrFcZyuKYxnJ8yimfauBkHz4K8WxvGErimN5uFYUPRQFKI7liU6jGHPcHzYuJn4/2Cz58cWhJa9foI9rdTqGjjN6C3qydt/DzAb7h9AxUudDz3+Fju+6HnpsYNO+2yw6ms7iGdc6nNjec3/NsnGtw5UUfUuKZv3y2ZApwp3d2/Z+Md/H4xaz0XS/tfz+gz39N+1iQKLeJYpI1LtEMnbA7yCtf1oJ8u/vr0SZ6nfda0O7PnVNDpVdb8vXtjS54D4tZLeI0tJdRKa7iGTKw3Xdl+RbBfB9RDe3ui3J2XyJx3UWj+8snrWzeIJQRi+PeNa/3FnS8QLj0sNzuhzCp/f4ddmLm17Oj2/hGRsKoSW3zT6tqfBRy+vjaxZPP6MIh3fstO7R5+XJtq2/79gpXxx8WPZKOZinX2geBn9bUfekuP2d1ufht+jzojf62z/+27/90z//8z/9z//66WS25df/HG8u6nfdfV4+m4zbv8yvkcdnkKXFPhohjwsPZ+i3tTesn34C8F9eHSgm9eLpT198P1kupL/+BOT4qK8fvfh244jLXyM/PrdL5MVv/7DfyLqnecr5rRnnPdXzGr8Pypglbrl++/vpaIxf3+e6/cP9Dux48jYvmxhu+XTLtL+DOz7AqniVrbrKVV3lq65aq64KVVfFqqtS1VW55ipXlRuuKjdcVW64qtxwVbnhqnLDVeWGq8oNV5Ubrio3fFVu+Krc8FW54atyw1flhq/KDV+VG74qN3xVbviq3FircmOtyo21KjfWqtxYq3JjrcqNtSo31qrcWKtyY63KjVCVG6EqN0JVboSq3AhVuRGqciNU5Uaoyo1QlRuhKjdiVW7EqtyIVbkRq3IjVuVGrMqNWJUbsSo3YlVuxKrcSFW5kapy47jZ6Za9G+CW/OS+lvV+lau6ylddtVZdFaquilVXHeaGM8vWQXDW5k9XHVjYNTzOVTNPXwBZjs5V88k9GtiPseuHplkgnrTsjjqZVIhnDbv/XkN69AXWcPf3S28Bmd4Csr0F5HoLyPcW0NpbQKG3gGJvAaXeAursTm2X6+/Ucd9YZo2rfw7o6KGYeTyki+b7wWndwkjxaZH0h0/bzP4TZmuevhDx6xf4XwenR0n1aehvggaCf0jQQvAPCToI/iFBD8E/JLhC8A8JBgj+IcEIwT8kmCD4hwQzBP+MoMGT/ClBPMmfEsST/ClBPMmfEvQQ/EOCeJI/JYgn+VOCeJI/JYgn+VOCeJI/JGjxJH9KEE/ypwTxJH9KEE/ypwQ9BP+QIJ7kTwniSf6UIJ7kTwm28CTmQTB9D8Wk/RusJj8fl3X40sbnxxkU0T6/9O+55nnm6paJ5mommqudaK5uorn6iea6TjTXMNFc40RznahuchPVTX6iuslPVDf5ieomP1Hd5Ceqm/xEdZOfqG7yE9VNfqK6yU9UN60T1U3rRHXTOlHdtE5UN60T1U3rRHXTOlHdtE5UN60T1U3rRHVTmKhuChPVTWGiuilMVDeFieqmMFHdFCaqm8JEdVOYqG4KE9VNcaK6KU5UN8WJ6qY4Ud0UJ6qb4kR1U5yobooT1U1xoropTlQ3pYnqpjRR3ZQmqpvSRHVTmqhuShPVTWmiuilNVDelkeomm8M2V7eYpUgm+p2MeXrtdBRJWLajjMPz0Y1pvWMcqSRrhzGPVO01xDhSIdkQ40g1akOMI5W/DTF6MEpgHKlob4hxJD/QEONIVqMhRlyMCEZcjABGt+BiRDDiYkQwjuRi3LJvJOWWXArEmGj3Fzd5eXp1Y8/GPpLrUYTdg70F9pFclSLsI7kwRdhHcm2KsI/k8hRhH8kV6sFuRnKRirCP5DoVYcelNsGOS22C3YO9BXZcahPsE7tUu6xbJMbeZlzAbm8yfQy3Jj1BSelodFz20dE+vtsX7tgndqktsU/sUltin9ilNsRuJ3apLbFP7FJbYp/YpbbEPrFLbYndg70F9oldakvsuNQm2HGpTbDjUptgx6W2wD7U6YI/xe5S2rF7X2r82rDHYkNYH6OzO4rF2O3Fb93159HmaLSLe+Quu0+jf8s0s6tVJNPMLliRTDO7ZkUyeWTSINPMrlyRTDO7eEUyzez6Fck0c5dAkUwzdxX0yDTUWb0Dy0QXQoVMdCFUyEQXQoVMHpk0yEQXQoVMdCFUyEQXQoVMdCFUyEQXQoNMQ518P7BMdCFUyEQXQoVMdCFUyOSRSYNMdCFUyEQXQoVMdCFUyEQXQoVMdCE0yBToQqiQiS6ECpnoQqiQiS6ECpk8MmmQiS6ECpnoQqiQiS6ECpnoQqiQiS6EBpkiXQgVMtGFUCETXQgVMtGFUCGTRyYNMtGFUCETXQgVMtGFUCETXQgVMtGF0CBToguhQia6ECpkoguhQia6ECpk8sikQSa6ECpkoguhQia6ECpkoguhQia6EBpkynQhVMhEF0KFTHQhVMhEF0KFTB6ZNMhEF0KFTHQhVMhEF0KFTHQhVMhEF0KBTH6hC6FCJroQKmSiC6FCJroQKmTyyKRBJroQKmSiC6FCJroQKmSiC6FCJroQGmQydCFUyEQXQoVMdCFUyEQXQoVMHpk0yEQXQoVMdCFUyEQXQoVMdCFUyEQXQoNMli6ECpnoQqiQiS6ECpnoQqiQySOTBpnoQqiQiS6ECpnoQqiQiS6ECpnoQmiQydGFUCETXQgVMtGFUCETXYiTZLJ+3RGmkkw+7zKty5K/yuSRSYNMdCFUyEQXQoVMdCFUyEQXQoVMdCE0yOTpQqiQiS6ECpnoQqiQiS6ECpk8MmmQiS6ECpnoQqiQiS6ECpnoQqiQiS6EBplWuhAqZKILoUImuhAqZKILoUImj0waZKILoUImuhAqZKILoUImuhAqZKILoUGmQBdChUx0IVTIRBdChUx0IVTI5JFJg0x0IVTIRBdChUx0IVTIRBdChUx0ITTIFOlCqJCJLoQKmehCqJCJLoQKmTwyaZCJLoQKmehCqJCJLoQKmehCqJCJLoQGmRJdCBUy0YVQIRNdCBUy0YVQIZNHJg0y0YVQIRNdCBUy0YVQIRNdCBUy0YXQIFOmC6FCJroQKmSiC6FCJroQKmTyyKRBJroQKmSiC6FCJroQKmSiC6FCJroQCmS6/Tdk0iATXQgVMtGFUCETXQgVMnlk0iATXQgVMtGFUCETXQgVMtGFUCETXQgNMhm6ECpkoguhQia6ECpkoguhQiaPTBpkoguhQia6ECpkoguhQia6ECpkoguhQSZLF0KFTHQhVMhEF0KFTHQhVMjkkUmDTHQhVMhEF0KFTHQhVMhEF0KFTHQhNMjk6EKokIkuhAqZ6EKokIkuhAqZPDJpkIkuhAqZ6EKokIkuhAqZ6EKokIkuhAaZPF0IFTLRhVAhE10IFTLRhVAhk0cmDTLRhVAhE10IFTLRhVAhE10IFTLRhdAg00oXQoVMdCFUyEQXQoVMdCFUyOSRSYNMdCFUyEQXQoVMdCFUyEQXQoVMdCE0yBRm7kKExewyxefAD2W6vaTZoTzL9ELUtGyiRpNLo+2St9HWxk+jf8s0cxdCkUwzdyEUyTRzF0KRTB6ZNMg0cxdCkUwzdyEUyTRzF0KRTDN3IRTJNHMXQo9MkS6ECpnoQqiQiS6ECpnoQqiQySNTDzJ557bRPpUeqQRvPwaH8JDUhaNZ5sfDmuUpjOPBweyjg12XwmgTTdh43/7OrvTqeecdsnnKxXQwON0eLX0MTjbY58G/85a2DHmrMW/pU5G3GvOWxh15qzFv6WSStxrzltYueaswbxO9bvJWY97S/CdvNeYtT0PIW415y+Mh8lZj3nrylrxVmLc8LyNvNeYtz8vIW415y/My8lZj3vK8jLzVmLc8LyNvFeZt5nkZeasxb3leRt5qzFuel5G3GvOW52Xkrca89eQteaswb3leRt5qzFuel5G3jxe2a9zzNpVe2qSwR/3rb/9p/O/s4qkW2XVedvHsiew6L7t4QkR2nZVdYeE5Dtl1XnbxtIXsOi+7eCZCdp2XXTy5ILvOyy5PdpFdp2UXTwHIrvOyi1492XVedtGrJ7vOyy569WTXedlFr57sOi27DL36k7Ir7t9Nuf35efRv8LSxG4Gnw9sIPM3PRuA94NuAp2XWCDzdpEbgabQ0Ak8PohF47Hkb8Bbn2gg8zrUReJxrI/A410bg/bzgnYtbD9k4v9oCSnMLZm/1mhQfP8wLh+AXu4O39mnsb+wT+9aW2Cd2rS2xT+xZ/RL3uL3xsYD99qj7Y/QtWR9j03oHObEHlQU5sacUBekm9oiyICf2fLIgJ/ZwsiAn9mSyID0gZUBO7JpkQU7sg2RB4myEQOJshEDibGRAepyNEMiZnU3weQcZil9qti5uJK3LT936lH/cdPMz+6CG2Gd2TQ2xe7C3wD6zI2uIfWb/1hD7zG6vIfaZvWFD7DM7yXbY15l9Z0PsuNQm2HGpTbDjUptg92BvgR2X+jZ2b/YtG7xfPmH/jRLnKYYSNymGEocohhLXJ4Uy4OTEUOLOxFDiuMRQ4qLEUHpQSqHE7YihxO2IocTtiKHE7YihxO1IoYy4HTGUuB0xlLgdMZS4HTGUHpRSKHE7YihxO2IocTtiKHE7YihxO1IoE25HDCVuRwwlbkcMJW5HDKUHpRRK3I4YStyOGErcjhhK3I4YStyOFMqM2xFDidsRQ4nbEUOJ2xFD6UEphRK3I4YStyOGErcjhhK3I4YStyOEMi64HTGUuB0xlLgdMZS4HTGUHpRSKHE7YihxO2IocTtiKHE7YihxO1IoDW5HDCVuRwwlbkcMJW5HDKUHpRRK3I4YStyOGErcjhhK3I4YStyOFEqL2xFDidsRQ4nbEUOJ2xFD6UEphRK3I4YStyOGErcjhhK3I4YStyOF0uF2xFDidsRQ4nbEUOJ2xFB6UEqhxO2IocTtiKHE7YihxO2IocTtSKH0uB0xlLgdMZS4HTGUuB0xlB6UUihxO2IocTtiKHE7YihxO2Ioh3I7zu8oXQyl0SFtJN2tQ/YE0vxGsw7lXmTRDOVGZNEM5S5k0QzlFmTReNC8QjNUNS+LZqjqXBbNUNW2LJqhqmdZNFTDr9AEquGXaKiGX6KhGn6Jhmr4JRoPmldoqIZfoqEafomGavglGqrhl2iohl+hGetsdVk0VMMv0VANv0RDNfwSjQfNKzRUwy/RUA2/REM1/BIN1fBLNFTDr9CMdfa2LBqq4ZdoqIZfoqEafonGg+YVGqrhl2iohl+ioRp+iYZq+CUaquFXaMY6m1kWDdXwSzRUwy/RUA2/RONB8woN1fBLNFTDL9FQDb9EQzX8Eg3V8As0aayze2XRUA2/REM1/BIN1fBLNB40r9BQDb9EQzX8Eg3V8Es0VMMv0VANv0Iz1tmusmiohl+ioRp+iYZq+CUaD5pXaKiGX6KhGn6Jhmr4JRqq4ZdoqIZfoRnr7E9ZNFTDL9FQDb9EQzX8Eo0HzSs0VMMv0VANv0RDNfwSDdXwSzRUw6/QjHU2pCwaquGXaKiGX6KhGn6JxoPmFRqq4ZdoqIZfoqEafomGavglGqrhV2jGOjtQFg3V8Es0VMMv0VANv0TjQfMKDdXwSzRUwy/RUA2/REM1/BIN1fArNJxF9xoN1fBLNFTDL9FQDb9E40HzCg3V8Es0VMMv0VANv0RDNfwSDdXwKzScRfcaDdXwSzRUwy/RUA2/RONB8woN1fBLNFTDL9FQDb9EQzX8Eg3V8Cs0nEX3Gg3V8Es0VMMv0VANv0TjQfMKDdXwSzRUwy/RUA2/REM1/BIN1fArNJxF9xoN1fBLNFTDL9FQDb9E40HzCg3V8Es0VMMv0VANv0RDNfwSDdXwKzScRfcaDdXwSzRUwy/RUA2/RONB8woN1fBLNFTDL9FQDb9EQzX8Eg3V8As0mbPoXqOhGn6Jhmr4JRqq4ZdoPGheoaEafomGavglGqrhl2iohl+ioRp+hYaz6F6joRp+iYZq+CUaquGXaPy0aLxb7Mdo79bwCc1BJD5uSMxqniJJR3GHJX0MDvbpldN6hz5vnd0Q+rwVfEPo83qDhtDndR0Noc/rZ9pBn/icwobQ5/VgDaHP6+4aQp/XNzaE7oF+PXQcaQPoONIG0HGkDaCP5UjTNtp5u34a/XuyYznB7yc72NmYhcmO5XwKkx3LcRQmO1alX5isn2myY1W2hcmOVVEWJjtWJVeY7EwV1GCnL34/2cHOUyxMdqYKarAzDwuTnamCGuxcwsJkZ6qgBjs7sDDZmSqowc73K0x2pgpqsDP4CpOdqYIa7Jy8wmRnqqAGO8uuMNmZKqjBzpsrTHamCmqwM+EKk52pghrs3LbCZGeqoAY7W60w2ZkqqMHOPytMdqYKarAzygqTnamCGuwcscJkZ6qgBjvrqzDZmSqowc7jKkx2pgpqsDOzCpOdqYIa7FyrwmRnqqAGO3uqMNmZKqjBzocqTHamCmqwM5wKk52pghrsnKXCZGeqoAY7C6kw2aEqKO8eky3+JtDE7Xd7dnm8sk3uYGzaeSSXC2PzTjznz2N/Ax+qitMAfKhKUgHwsc530gB8qIpaA/ChqnoNwIdyFhqAe4BfC3woh6UB+FAuTwNwnObFwHGaFwMfy2mmfX+l5E0JuE37jknO+cdosxy99mp2Mde0fBp9A2mWsQ5Fa0pyLG/YkuRYpq8lybHcXEuSHpJCJMfyXy1JjmWsWpIcyzG1JDmWFWpJEo8jRHKso+6aksTjSJHE40iRxONIkfSQFCKJx5EiiceRIonHkSKJx5EiiccRIjnWIXVNSeJxpEjicaRI4nGkSHpICpHE40iRxONIkcTjSJHE40iRxOMIkRzrGLimJPE4UiTxOFIk8ThSJD0khUjicaRI4nGkSOJxpEjicaRI4nGESI51UGNTkngcKZJ4HCmSeBwpkh6SQiTxOFIk8ThSJPE4UiTxOFIk8ThCJMc6SrUpSTyOFEk8jhRJPI4USQ9JIZJ4HCmSeBwpkngcKZJ4HCmSeBwhkmMddtyUJB5HiiQeR4okHkeKpIekEEk8jhRJPI4USTyOFEk8jhRJPI4QybGOI29KEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeIZMLjSJHE40iRxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHESKZ8ThSJPE4UiTxOFIk8ThSJD0khUjicaRI4nGkSOJxpEjicaRI4nFkSJoFjyNFEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeIpMHjSJHE40iRxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHESJp8ThSJPE4UiTxOFIk8ThSJD0khUjicaRI4nGkSOJxpEjicaRI4nGESDo8jhRJPI4USTyOFEk8jhRJD0khkngcKZJ4HCmSeBwpkngcKZJ4HCGSHo8jRRKPI0USjyNFEo8jRdJDUogkHkeKJB5HiiQeR4okHkeKJB5HiOSKx5EiiceRIonHkSKJx5Ei6SEpRBKPI0USjyNFEo8jRRKPI0USjyNEMuBxpEjicaRI4nGkSOJxpEh6SAqRxONIkcTjSJHE40iRxONIkcTjCJGMeBwpkngcKZJ4HCmSeBwpkh6SQiTxOFIk8ThSJPE4UiTxOFIk8ThCJBMeR4okHkeKJB5HiiQeR4qkh6QQSTyOFEk8jhRJPI4USTyOFEk8jhDJjMeRIonHkSKJx5EiiceRIukhKUQSjyNFEo8jRRKPI0USjyNFEo8jQ9IueBwpkngcKZJ4HCmSeBwpkh6SQiTxOFIk8ThSJPE4UiTxOFIk8ThCJA0eR4okHkeKJB5HiiQeR4qkh6QQSTyOFEk8jhRJPI4USTyOFEk8jhBJi8eRIonHkSKJx5EiiceRIukhKUQSjyNFEo8jRRKPI0USjyNFEo8jRNLhcaRI4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE4wiR9HgcKZJ4HCmSeBwpkngcKZIekkIk8ThSJPE4UiTxOFIk8ThSJPE4QiRXPI4USTyOFEk8jhRJPI4USQ9JIZJ4HCmSeBwpkngcKZJ4HCmSeBwhkgGPI0USjyNFEo8jRRKP8x5Jb2P+GO3dagujjY/7a6/mKe50NMuwpI/BwYanseuHRh6NutcIX9a/Rji+/jXCS/avES61f43wv91rFHHW/WuEZ+9fI7oB/WtEn6F/jTwada8RfYb+NaLP0L9GE/cZ3B6ICYsrULd2WT5GW+8+a3QnOXE3QJjkxJ5dlmSa2FkLk5zY/wqTnNilCpOc2EsKk/SQFCI5sS8TJjmxexImiceRIonHkSKJxxEimfE4UiTxOFIk8ThSJPE4UiQ9JIVI4nGkSOJxpEjicaRI4nGkSOJxZEi6BY8jRRKPI0USjyNFEo8jRdJDUogkHkeKJB5HiiQeR4okHkeKJB5HiKTB40iRxONIkcTjSJHE40iR9JAUIonHkSKJx5EiiceRIonHkSKJxxEiafE4UiTxOFIk8ThSJPE4UiQ9JIVI4nGkSOJxpEjicaRI4nGkSOJxhEg6PI4USTyOFEk8jhRJPI4USQ9JIZJ4HCmSeBwpkngcKZJ4HCmSeBwhkh6PI0USjyNFEo8jRRKPI0XSQ1KIJB5HiiQeR4okHkeKJB5HiiQeR4jkiseRIonHkSKJx5EiiceRIukhKUQSjyNFEo8jRRKPI0USjyNFEo8jRDLgcaRI4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkRzK46R1J5kX/2n0fbZD+ZDSbONQXqE426Hq+eJsh6q5i7Mdqi4uztZPNduh6svibIeqAYuzHapOK852qlpqrDPPS7Md61zy4mynqqXGOt+7ONupaqmxzskuznaqWmqs86aLs52qlhrr3ObibKeqpcY6/7g426lqqbHOES7OdqpaaqzzeIuznaqWGutc2+Jsp6qlxjoftjjbmWopP9Y5q8XZzlRL+bHOKy3OdqZayi9+qtnOVEv5sc7PLM52plrKj3UOZXG2U9VSY53nWJztVLXUWOciFmc7VS011vmCxdlOVUuNdU5fcbZT1VJjnXdXnO1UtdRY58YVZztVLTXW+WvF2U5VS411jllxtlPVUmOdB1ac7VS11FjnahVnO1UtNdb5VMXZTlVLjXXOU3G2U9VSY52XVJztVLXUWOcOFWc7VS011vk9xdlOVUuNdQ5OcbZT1VJjnSdTnO1QtVQ26z7bUBptYvoYbJ92wLHJHYxNO4/kcmFsTlvIOX8eeyfuIX4x8aFqShXEh6prc9zC9sYvhdE2Orshj/l5dDxifmO1QbcmfBp9JzlUzdyU5FD1eFOSQ9X6LUmOddZMU5JDeZSmJIfyP01JjuWtWpL0kBQiOZYXakkSjyNFEo8jRRKPI0USjyNEcqyzZpqSxONIkcTjSJHE40iR9JAUIonHkSKJx5EiiceRIonHkSKJxxEiOdYZOU1J4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE4wiRHOvsqqYk8ThSJPE4UiTxOFIkPSSFSOJxpEjicaRI4nGkSOJxpEjicYRIjnWmXFOSeBwpkngcKZJ4HCmSHpJCJPE4UiTxOFIk8ThSJPE4UiTxODIk17HOemxKEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeI5FhnsDYliceRIonHkSKJx5Ei6SEpRBKPI0USjyNFEo8jRRKPI0USjyNEcqyzkZuSxONIkcTjSJHE40iR9JAUIonHkSKJx5EiiceRIonHkSKJxxEiOdaZ5U1J4nGkSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE4wiR9HgcKZJ4HCmSeBwpkngcKZIekkIk8ThSJPE4UiTxOFIk8ThSJPE4QiRXPI4USTyOFEk8jhRJPI4USQ9JIZJ4HCmSeBwpkngcKZJ4HCmSeBwhkgGPI0USjyNFEo8jRRKPI0XSQ1KIJB5HiiQeR4okHkeKJB5HiiQeR4hkxONIkcTjSJHE40iRxONIkfSQFCKJx5EiiceRIonHkSKJx5EiiccRIpnwOFIk8ThSJPE4UiTxOFIkPSSFSOJxpEjicaRI4nGkSOJxpEjicYRIZjyOFEk8jhRJPI4USTyOFEkPSSGSeBwpkngcKZJ4HCmSeBwpkngcGZJhweNIkcTjSJHE40iRxONIkfSQFCKJx5EiiceRIonHkSKJx5EiiccRImnwOFIk8ThSJPE4UiTxOFIkPSSFSOJxpEjicaRI4nGkSOJxpEjicYRIWjyOFEk8jhRJPI4USTyOFEkPSSGSeBwpkngcKZJ4HCmSeBwpkngcIZIOjyNFEo8jRRKPI0USjyNF0kNSiCQeR4okHkeKJB5HiiQeR4okHkeIpMfjSJHE40iRxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHESK54nGkSOJxpEjicaRI4nGkSHpICpHE40iRxONIkcTjSJHE40iRxOMIkQx4HCmSeBwpkngcKZJ4HCmSHpJCJPE4UiTxOFIk8ThSJPE4UiTxOEIkIx5HiiQeR4okHkeKJB5HiqSHpBBJPI4USTyOFEk8jhRJPI4USTyOEMmEx5EiiceRIonHkSKJx5Ei6SEpRBKPI0USjyNFEo8jRRKPI0USjyNEMuNxpEjicaRI4nGkSOJxpEh6SAqRxONIkcTjSJHE40iRxONIkcTjyJCMCx5HiiQeR4okHkeKJB5HiqSHpBBJPI4USTyOFEk8jhRJPI4USTyOEEmDx5EiiceRIonHkSKJx5Ei6SEpRBKPI0USjyNFEo8jRRKPI0USjyNE0uJxpEjicaRI4nGkSOJxpEh6SAqRxONIkcTjSJHE40iRxONIkcTjCJF0eBwpkngcKZJ4HCmSeBwpkh6SQiTxOFIk8ThSJPE4UiTxOFIkR/I43uyjvcnh0+jfs/Uj+ZDybEfyCuXZjlTPl2c7Us1dnq2farYj1a7l2Y5UX5ZnO1INWJ7tSHVaebZT1VJDnXlenu1UtdRQZ4eXZztVLTXUGdzl2U5VSw11lnV5tlPVUkOdCV2e7VS11FBnK5dnO1UtNdQZxeXZTlVLDXXWb3m2U9VSQ52ZW57tVLXUUGfPlmc7VS011Bmu5dlOVUsNdRZqebZT1VJDnSlanu1UtdRQZ3OWZztVLTXUGZfl2U5VSw11VmR5tlPVUkOduVie7VS11FBnF5ZnO1UtNdQZgOXZTlVLDXWWXnm2U9VSQ51JV57tVLXUUGe7lWc7VS011Blp5dlOVUsNddZYebZT1VJDndlVnu1MtVQa6uwr743bZhvNcjDboWqp4myHqqWKsx2qlirO1k8126FqqeJsh6qlirMdqpYqznaoWqo426FqqdJshzpjpzzbqWqpoc6qKc92qlpqqDNfyrOdqpYa6uyU8mynqqWGOoOkPNupaqmhzvIoz3aqWmqoMzHKs52qlhrqbInybKeqpYY6o6E826lqqaHOOijPdqpaaqgzA8qznaqWGmrv/fJsp6qlhtrDvjzbqWqpofaCL892qlpqqD3Vy7OdqpYaa9/z4mynqqXG2ve8ONupaqmx9j0vznaqWmqsfc+Ls52qlhpr3/PibKeqpcba97w425lqqdyg5xjiNnoNyT3P9h5RA/7Lg/8SvkbkDyOybhPCuZgKEbmQl210Wp5/4BE/3mS94k3CFW8Sr3iTdMWb5Ave5IVTFX4Tc8Wb2CvexF3xJld84v0Vn3h/xSfeX/GJ91d84v0Vn/j1ik/8esUnfr3iE79e8Ylfr/jEr1d84tcrPvHrFZ/49YpP/HrFJz5c8YkPV3ziwxWf+HDFJz5c8YkPV3ziwxWf+HDFJz5c8YkPV3zi4xWf+HjFJz5e8YmPV3zi4xWf+HjFJz5e8YmPV3zi4xWf+HjFJz5d8YlPV3zi0xWf+HTFJz5d8YlPV3zi0xWf+CTxiU9xH50Xc/Am6Yo3yRe8SV6ueBNzxZvYK97EXfEm/oo3WYXfxNiDN5H4xKf98Y/Ldvn0Jl9Hp/0RS3KPJyz21zOaL2NvN6SPsTl/HnsPPmoOPmkOPqsN3i7Lojl4ozl4qzl4pzl4rzn4VXPwelfYW/B6V9hb8HpX2FvwmldY0/cKG7ax5rYiHUTf9xJbir7vNbYUfd+LbCn6vlfZUvR9L7Ol6CXW2WzjHv0aC9F//x3DW0Sxu4hSdxHl3iKyS3cRme4ist1F5LqLyHcX0dpdRN3ds213d0h7/R3y22+q28W57iK6/rMW7SMiG79GtHYXUeguothdRKm7iBp8+n3YI1r9c0RfB1u/B2K991/C94vu8I3u8K3u8J3u8L3u8Ffd4Qfd4cfOw7fpEf7Xgswn3eH3vup+H/7a+aq7rlvNY9fgvh8cbo/rPwaHW3/161w7X6J/Mtc1x/ztXDtfz9e992vXaL4fnJbthZN/+qG1Xz6m2vnaLzlVP89UO68pJKfaef0hOdXOaxXBqYbeV9afTHXd+o4phk9TPXhh47aYrVkfL+zt0eC0LXlu+TT0jrD3BVsBwpHqgEYIR6ovGiH0IPxThCPVQ40QjlRnNUI4Uv3WCGHn/S4NCDvvuSlAGHEnf4wQd/LHCHEnf4wQd/KnCNOsWbhkuyN8+qrUIcKUtiA+/Tj48IXN7b23V779HZ++gp3TB/NZ07Ylcw/zy5nPattbMp/V57dkPmtjoCXzWTsJLZnP2npoyDzP2qtoyXzW5kZL5vjQ65njQ69n7mF+OXN86PXM8aHXM8eHXs8cH3o9c3zo1czNgg+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzA0+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzO3+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17O3OFDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfPeTzAdkjk+9Hrm+NDrmeNDL2eu6gzF9P3gGLaxMX6ieJ+ppuz6s5n6aWbawtE/DqhfC8F/99L3+IPy+KPy+JPy+LPu+JucHykZv+k6fr+47QBlv+RceGnn92LB+fQU9vpxt21yzmK72bqpZuunmm3fdYP0bPuuMqRn23dNIj3bvisY6dn2Xe8Izzb2XR1Jz3aqWirqraXu8eutju7xe+Xx661g7vHrrUnu8eutMu7xd143mL2h6J3xhZdOi9+a7e4xV5vcwdicthfO+fPYO5fOK4xWXFLntUgzLp1XLc24dF7fNOPSed3UjIuHyyGXzuu8Zlw6rx+bcem8Lm3GhXr3mAv17iGXTL17zIV695iL75yL2fqR3tiDfkDuvc4oxd97PVCKv/d1uxR/7+trKf7e18Hv47dL7+tVKf7e15VS/L33O0rx996XKMWve/21i+711y6611+76F5/7aJ7/bWL8vXXKF9/jfL11yhff43y9bfJ/v6S8Stff43y9dcoX3+N8vXXKF9/rfL11ypff63y9dcqX3+b7GssGb/y9dcqX3+t8vXXKl9/rfL11ylff53y9dcpX3+d8vW3yX6OkvErX3+d8vXXKV9/nfL11ylff73y9dcrX3+98vXXK19/vfL11ytff73y9dcrX3+98vXXK19/V+Xr76p8/V2Vr7+r8vW3yZ6DkvErX38730mwHL/y9bfznQTL8StffzvfSbAcv/L1t/e9AYvxK19/e9+/rxi/8vW39z32ivErX3973wevGL/y9bf3veqK8Stff3vfT64Yv/L1t/f95IrxK19/e99Prhi/8vW3+/3kSvErX3+735+tFL/y9bf7/c5K8Stff7vfP6wUv/L1t/v9uErxK19/u9/fqhS/8vW3+/2iSvErX3+z8vU3K19/le9/ZZXvf2WV739lle9/ZZXvf2WV73/llO9/5ZTvf+WU73/llO9/5Rbd66/rfv+r0/YVDdtYsyz20+A7mGk3ui6BmXan6xKYabe6LoGZdq/rApjuNy9rBkbvKSb3+PWeNnKP3yuPX29Vc49fb/Fxj19vjXCPX+9Sfo9f74r7O/7udxUrxa/3tIZ7/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexQvzd7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKl+JWvv93vKlaKX/n62/2uYqX4la+/3e8qVopf9/rru99VrBS/7vXXd7+rWCl+3euvX3Svv17xrmL3+HWvv17xHl33+HWvv17xjle/41e8MdU9fuXrr/L9r7zy/a+88v2vfO/7XwWXt/jT4gov/aON5dI2w5w/j71z6Xxdb8al83qhGZfO65DzuHy/QaPvfYOxZmB637msHZjOS7J2YDqv9dqB6byIbAfG9w0m7S/tky+BicF9DI4x7GO9/Zhq54Ws5FQ7r00lp9p5ufnNVO/xd14WFuPvvHorxd/59nSr8es22IQDe9759nTl+PsuWcrx911ZlOP3yuPve1Uvx9/3Ul2Ov+/1txx/3+tvOf6+19/n+K2xX+PvfHu6cvx61t/j+PWsv8fx61l/j+PXs/4ex9/5+htN3AenfBB/5+tvMf7O199i/J2vv8X4O19/S/F3vj1dOf7O199i/J2vv8X4O19/i/F3vv4W41e+/na+PV05fuXrb+fb063JLdvgHFLhpX3eJ/v8VaZkD8bauGzHGdtoH5Vt+ODS+breikvn2+m149J5HSLE5T7XzmsW0bl2Xt+IztVPNNfO6ybRuXZeY4nOtfN67EdzvbXctsE+Hcx1pNqtNNeR6rHCXDvfMlF2riPVTaW5jlQ3leY6Ut1UmqufaK4j1U2luY5UN63rXjelg7qp820mZec6VN1UmOtQddP3c+18q0vZuQ5VNxXmOlTdVJjrUHVTYa5+orkOVTcV5jpR3dT59qDfzfUev95a6B6/3vrmd/ydbw9ajl9vHXKPX29tcY+/73ohLMsWSHDBHMTvlcff97pejr/vtbocf9/rbzn+vtffcvx9r7+l+NfOtwctx9/3+luOv+/1txy/7vV3XXSvv2vn24OW49e9/q6dbw9ajl/3+rt2vj1oMf7Otwctx698/e18e9By/MrX3863By3Hr3z97Xwbz3L8ytffzrfFLMevfP3tfJPJcvzK19/Ot2wsx698/e18A8Ry/MrX3863KizHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18/8Fy/MrX3873HyzHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18/8Fy/MrX3873HyzHr3z97Xz/wXL8ytffzvcfLMevfP3tfP/BcvzK19/O9x8sx698/e18P79y/MrX38730ivHr3z97XzPu3L8ytff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M0/40OuZ40OvZ44PvZ45PvR65h7mlzPHh17PHB96PXN86PXM8aHXM8eHXs4840OvZ44PvZ45PvR65vjQ65l7mF/OHB96PXN86PXM8aHXM8eHXs8cH3o187zgQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxodczx4dezxwfejlzgw+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzC0+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzN3+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17O3ONDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfMVH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZB3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZx7xodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZx5wodezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5hkfej1zfOj1zPGh1zPHh17P3MP8cub40OuZ40OvZ44PvZ45PvR65vjQi5m7ZcGHXs8cH3o9c3zo9czxodcz9zC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYGH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZW3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZ+7wodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZy5x4dezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5is+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzMP+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17OPOJDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfOED72eOT70eub40OuZ40OvZ+5hfjlzfOj1zPGh1zPH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+E3SFW+SL3iTF4/Mhd/Enf7RzBL3sG9/u5byev5bhPPfIp7/Fun8t8hnv0VelvPfQmI9+faHWXmx57+FO/8t/NkLb17W898inP8W8fy3SOe/RT79Lcxy/luY89/Cnv8Wh0m7rlvXdE3PlZ79uCjWXJRqLjpOlSXus/r1d/5LRZJfPOZaYt5L2OX2oPjLZabuMlt3mau77PhmudweKD0ue9qEfbtsrbss1F0Wqy5zL3TLj+3olxzMl8tekMxp25bemGX5QtL5usvWusti3dxS3WUvPjg5u6cg179e5pe6y0zdZbbuMld3ma+7bK277PiDcxuaH5fZ5yz5+89z6ng/Lek3SVe8Sf7zN/n+WWQ+fkIo+xbm/LewP32L+2Wu7jJfd1ndLfLF87niZbHuslR3Wa66LCx1l5m6y2zdZXULaahbSF886ojrfmON8flnqkefFhuX/RtG0dovb5FPf4sXjzpE38Kc/xb2/Ldw57+FP/8t1vPfIpz/FvH8tzj/0x3P/3Sn8z/d6fxPdzr/053O/3Sn8z/d6fxPdzr/053O/3SnH3+675flqsvyUneZqbvM1l3m6i7zdZetdZeFusti3WV1WZJrsmRdlqXuMlN3ma27zNVd5usuW+suC3WXxbrLUt1ldVli6rLE1GWJqcsSU5clpi5LTF2WmLosMXVZYuqyxNRlia3LEluXJbYuS2xdlti6LLF1WWLrssTWZYmtyxJblyWuLktcXZa4uixxdVni6rLE1WWJq8sSV5clri5LXF2W+Los8XVZ4uuyxNdlia/LEl+XJb4uS3xdlvi6LPF1WbLWZclalyVrXZasdVmy1mXJWpcla12WrHVZstZlyVqXJaEuS0JdloS6LAl1WRLqsiTUZUmoy5JQlyWhLktCXZbEuiyJdVkS67Ik1mVJrMuSWJclsS5LYl2WxLosiXVZkuqyJNVlSarLklSXJakuS1JdlqS6LEl1WZLqsiTVZUmuy5JclyW5LktyXZbkuizJdVmS67Ik12VJrsuSut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZoXvde8f8PQZG8OLnuRJfuWfiZn++myo618hQ4KuYUT+won9RVO7iqcV73tVuGYvsKxfYXj+grH9xXO2lc4fd2VU1935dTXXTn1dVfOfd2Vc1935dzXXTn3dVfOV9+Vvz3j6hbP2lk8obN4YmfxpM7iyV3FY4+f4Npb6fpxmbVmLcRzc+jLHn6If9294PYm5oo3sVe8iRN5ExcebxLc05sc/CIvuW1jILc87/u0HG+nuux7ri3u8dv7bD/i953Hv+78w+rc1/hX5fEH5fFH5fEn5fFn3fGbRXn8Rnn8Vnn8va+/pfiVr79G+fprlK+/Rvn6a5Svv0b5+muVr79W+fprla+/Vvn6a5Wvv1b5+muVr79W+fprla+/Vvn665Svv075+uuUr79O+frrlK+/Tvn665Svv075+uuUr79O+frrla+/Xvn665Wvv175+uuVr79e+frrla+/Xvn665Wvv175+rsqX39X5evvqnz9XZWvv6vy9XdVvv6uytffVfn6uypff1fl629Qvv4G5etvUL7+BuXrb1C+/gbl629Qvv4G5etvUL7+BuXrb1S+/kbl629Uvv5G5etvVL7+RuXrb1S+/kbl629Uvv5G5etvUr7+JuXrb1K+/ibl629Svv4m5etvUr7+JuXrb1K+/ibl629Wvv5m5etvVr7+ZuXrb1a+/mbl629Wvv5m5etvVr7+Zt3rr1t0r79u0b3+ukX3+uu63/+qFL/u9dcp3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yivf/8or3//KK9//yivf/8ovutdfr3z/K9/9/lePlw4xm+f4jwZvUYcUHi+c1o+59r5WS86193Vdcq691wCCc+1+vy7JufZeW0jOtfM6ZM1reszVfj9XH/MWh08u7YNtTodhm7hH7fw+2rn8wabzGqcpGw+bl2w6r83i6u3H6BiW8D0b57axzj8FfTR0DesW8hqXp8G/6r+vMee8v/KypE+j7xg7LxG1YOy8+tSCsfPCVgvGzmtmJRh7375PC8bOK30tGDs3EVowdu43tGD0YJTAiIsRwYiLEcGIixHBiIsRwYiLkcDY+yaoWjDiYkQw4mJEMOJiRDB6MEpgxMWIYMTFiGDExYhgxMWIYMTFSGDsfStpLRhxMSIYcTEiGHExIhg9GCUw4mJEMOJiRDDiYkQw4mJEMOJiJDD2viG/Foy4GBGMuBgRjLgYEYwejBIYcTEiGHExIhhxMSIYcTEiGHExEhh7P9ZEC0ZcjAhGXIwIRlyMCEYPRgmMuBgRjLgYEYy4GBGMuBgRjLgYCYy9Hw6lBSMuRgQjLkYEIy5GBKMHowRGXIwIRlyMCEZcjAhGXIwIRlyMBMbej9jTghEXI4IRFyOCERcjgtGDUQIjLkYEIy5GBCMuRgQjLkYEIy5GAmPvB5VqwYiLEcGIixHBiIsRwejBKIERFyOCERcjghEXI4IRFyOCERcjgHHt/bhnLRhxMSIYcTEiGHExIhg9GCUw4mJEMOJiRDDiYkQw4mJEMOJiJDD2fgi9Foy4GBGMuBgRjLgYEYwejBIYcTEiGHExIhhxMSIYcTEiGHExEhgtLkYEIy5GBCMuRgQjLkYEowejBEZcjAhGXIwIRlyMCEZcjAhGXIwERoeLEcGIixHBiIsRwYiLEcHowSiBERcjghEXI4IRFyOCERcjghEXI4HR42JEMOJiRDDiYkQw4mJEMHowSmDExYhgxMWIYMTFiGDExYhgxMVIYFxxMSIYcTEi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",
      "brillig_names": [
        "get_contract_instance_internal",
        "decompose_hint",
        "lte_hint",
        "discover_new_messages",
        "notify_created_nullifier_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "_deposit",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "951653053333916160": {
            "error_kind": "string",
            "string": "Deposit cap exceeded"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5235018679007078561": {
            "error_kind": "string",
            "string": "Invalid asset or market id"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16022896159229267359": {
            "error_kind": "string",
            "string": "Function _deposit can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AgAMAAAccSMAABwsJwILAGoKOAULDCQCAAwAABxHJwINBAA8CQENCygABoBFAAUkAgAFAAAcXCUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BCygABoBFAAUkAgAFAAAchiUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BCygABoBFAAUkAgAFAAAcsCUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BCygABoBFAAUkAgAFAAAc2iUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BCygABoBFAAUkAgAFAAAdBCUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BCygABoBFAAUkAgAFAAAdLiUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BCygABoBFAAUkAgAFAAAdWCUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BCygABoBFAAUkAgAFAAAdgiUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BCygABoBFAAUkAgAFAAAdrCUAABc+LQwBBy0MAggtDAMJLQwECiMAAB3BLQwKBC0MBwEtDAgCLQwJAyYqAQABBWRhiKjGz5TLPAEBAiYuAYADgAYLAIAGAAKAByQAgAcAAB3/IwAAHgouAIADgAUjAAAecS4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAB5dLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAB4sKAGABQQAAQMAgAYAAoAGIwAAHnEmKgEAAQXFa8RaDhAAAjwBAQImLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAAHtMjAAAfQyQAgA0AAB7gIwAAHvkuAIADgAUBAIAFAAKADi4CgAuADiMAAB8+KACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uAoALgA4BAIAOAAKADi4CgAmADiMAAB8+IwAAH5coAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4CgAuADwEAgA8AAoAPLgKADoAPIwAAH5coAIANBAADAQCABYANgAwLAIADgAWADSQAgA0AAB/7AQCACoAIgA8uAIAKgBAuAIAMgBELAIAQgA+AEiQAgBIAAB/7LgGAEIAOLgKADoARAQCAEAACgBABAIARAAKAESMAAB/KAQCADIAIgAYm",
      "debug_symbols": "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",
      "brillig_names": [
        "_deposit"
      ]
    },
    {
      "name": "_compute_total_collateral_value",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "4270187767586857285": {
            "error_kind": "string",
            "string": "Function _compute_total_collateral_value can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_compute_total_collateral_value"
      ]
    },
    {
      "name": "compute_total_deposited_assets",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "deposit_accumulator",
            "type": {
              "kind": "struct",
              "path": "accumulator::Accumulator",
              "fields": [
                {
                  "name": "value",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "last_updated_ts",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "compute_total_deposited_assets"
      ]
    },
    {
      "name": "_compute_borrow_rate",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "asset",
            "type": {
              "kind": "struct",
              "path": "asset::Asset",
              "fields": [
                {
                  "name": "asset_address",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "loan_to_value",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "oracle",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "is_borrowable",
                  "type": {
                    "kind": "boolean"
                  }
                },
                {
                  "name": "optimal_utilization_rate",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "under_optimal_slope",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "over_optimal_slope",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "deposit_cap",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "utilization_rate",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "precision",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17134621154673181869": {
            "error_kind": "string",
            "string": "Function _compute_borrow_rate can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBPJwAABAMnAgsECicCDAQAHxgADAALgEQdAIBFgEUGHQCAR4BHAR0AgEiASAYdAIBJgEkGHQCASoBKBh0AgEuASwYdAIBMgEwGHQCATYBNBi4IgEQAAS4IgEUAAi4IgEYAAy4IgEcABC4IgEgABS4IgEkABi4IgEoABy4IgEsACC4IgEwACS4IgE0ACiUAAAC5JQAAALouBAABgE4oAgACBIBOJwIDBAE7DQACAAMmJQAAAeUeAgALAB4CAAwAMzgACwAMAA0nAgsBASQCAA0AAADjJQAAAg4eAgALAR4CAAwACjgLDA0kAgANAAAA/yUAAAIgLQgBCwAAAQIBJwIMBgAtDgwLDDgJBQwkAgAMAAABpCMAAAEjAjgJBQEOOAUJAiQCAAIAAAE6JQAAAjIEOAEHAicCBAYACjgEBwMkAgADAAABaAY4AgcJCjgJAQgkAgAIAAABaCUAAAJEAjgKBQEOOAUKAyQCAAMAAAF/JQAAAjIGOAIBAwA4BgMBDjgGAQIkAgACAAABmyUAAAJWLQ4BCyMAAAHgBDgJBgEnAgMGAAo4AwYCJAIAAgAAAdIGOAEGBwo4BwkEJAIABAAAAdIlAAACRAY4AQUCLQ4CCyMAAAHgLQ0LASYoAIAEBHgADQAAAIAEgAMkAIADAAACDSoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEF7cpnKDUwRK08AQECJioBAAEFKIaSsEfc/UM8AQECJioBAAEFZGGIqMbPlMs8AQECJioBAAEFRafKcRlB5BU8AQECJg==",
      "debug_symbols": "vZfRbrMwDIXfhWsu4thJ7L3Kr18TbemEhGhF20lTtXdf2IB2JYzNqnpTJdX5OCcmAXzONuXq9PJcNdvdIXv6d87q3bo4Vrsmzs7vebZqq7quXp6v/85M9wMCn8BhXzTd/HAs2mP2BGjJ5VnZbLoxsokX2VZ1GWcmjqd6Y+0gN2RHtYSEmMSEXkwCfhR7lxAzEfdiJk/X4v95jO/vE19kkAPIw+Jbc6fqOx6rzwvVBxeG+OARf44vDqkXS+Qm8eXe8cF+i9+ZAD3AxNpHmISkCYjgQMUdAQsmzrDp5XHIC/vPwbAAdmhubyCmlx1ThEsiDAuJ7nki8Dc1QvmWqOPI6jhnlJxLcTbY8XTFMV9q4fALExXmSYfp3ALOYONTMkqIb7H0q8QGLzRigXCCeQ2GBnSYqDCgOQwvWIAJJirM6tyszi195Bax9IlbxnRuc+dtAfMmjYXgRowhTDCnwoLOLbAKY1wuCQNPsBk3791PmKAOU7mR8SoMQIXZmftGdHlOxjfbBHMqDHVuqHMj1GGswpzOzYMO83OYHzFn3S0WQIWx+fvmeo+z16KtilVd9s3Y9tSsr3qz49u+vGnT9u1uXW5Obdk1bFe9WufPPhfoOp9uDcJ5/B6JJtHoAw==",
      "brillig_names": [
        "_compute_borrow_rate"
      ]
    },
    {
      "name": "get_position",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "position::Position",
            "fields": [
              {
                "name": "collateral",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "scaled_debt",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "debt",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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lLKSMk0pKynTlLJGZJ1RVlKmKWUlZZpSVlKmKWUlZZpSVlKmGWWNpExTykrKNKWspExTykrKNKWsEVlnlJWUaUpZSZmmlJWUaUpZSZmmlJWUaUZZEynTlLKSMk0pKynTlLKSMk0pa0TWGWUlZZpSVlKmKWUlZZpSVlKmKWUlZZpR1kzKNKWspExTykrKpERWH9OGsJ7JGtsma1qW9l1WUqYpZY3IOqOspExTykrKNKWspExTykrKNKWspEwzylpImaaUlZRpSllJmaaUlZRpSlkjss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLJWUqYpZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrKNKOsjZRpSllJmaaUlZRpSllJmaaUNSLrjLKSMk0pKynTlLKSMk0pKynTlLKSMk0o6+1/Q9YZZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrKNKOsjpRpSllJmaaUlZRpSllJmaaUNSLrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oqydlmlJWUqYpZSVlmlJWUqYpZY3IOqOspExTykrKNKWspExTykrKNKWspEwzyhpImaaUlZRpSllJmaaUlZRpSlkjss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLJGUqYpZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrKNKOsiZRpSllJmaaUlZRpSllJmaaUNSLrjLKSMk0pKynTlLKSMk0pKynTlLKSMs0oayZlmlJWUqYpZSVlmlJWUqYpZY3IOqOspExTykrKNKWspExTykrKNKWspEwzylpImaaUlZRpSllJmaaUlZRpSlkjss4oKynTlLKSMk0pKynTlLKSMk0pKynTjLJWUqYpZSVlmlJWUqYpZSVlmlLWiKwzykrKNKWspExTykrKNKWspExTykrK9HNZ8+I2WcvzxHdlvX2k26A8y/qiCOqyFkFx7exov7T1aO/Lb0f/krWRMk0pKynTlLKSMk0pKynTlLJGZJ1RVlKmKWUlZZpSVlKmKWUlZZpSVlKmCWXNCynTlLKSMk0pKynTlLKSMg0pawxhPTrWs1uEOfqvg3N+lEDIe6tsj5uPy9M09g/Objs6+7ScHO2Ky1tVlb/uTx5/ett45+aearfu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",
      "brillig_names": [
        "get_position"
      ]
    },
    {
      "name": "get_accumulators",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "tuple",
            "fields": [
              {
                "kind": "struct",
                "path": "accumulator::Accumulator",
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "last_updated_ts",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ]
              },
              {
                "kind": "struct",
                "path": "accumulator::Accumulator",
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "last_updated_ts",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ]
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7f3druw8dqUJ34uPfSD+k30rjQ+F+nEXDBh2wVX1AY2C771jv7GkiJ1LIa7NZMScJJ8Te2emFEE+Yy5pjkEF9X/+4b/903/53//9P/3zv/4///Y//+H/+r//zz/8y7/91//8v/753/719p/+z3/84z/8l3//53/5l3/+7//p+b/+h+3X/zEu/HXC//wf//lff/3n//m//vO//69/+L/M5o37x3/4p3/9b3/9O9nbh/w///wv//TrP23/8Y/fjk85fh2dN38cG9PJocGGr0ND2B4f6+1//P/+8Tac2GM42aV9OKFcD8e78nWoj/n7cFKX4WS/D6fk6+HEbacTbfw+nNxjOMXar6OLC5Xh5O3r0LSdiFVOh+PytuO/HRJjZTi2bObrcLf9dvT9W/z2kW8xH/kW+5FvcR/5Fv+Rbwkf+Zb4kW9JH/mW/JFv+cjffvjI3374yN9++MjffvjI3374yN9++MjffvjI3374yN9++MjffvjI3378yN9+/MjffvzI3378yN9+/MjffvzI3378yN9+/MjffvzI3378yN9++sjffvrI3376yN9++sjffvrI3376yN9++sjffvrI3376yN9++sjffv7I337+yN9+/sjffv7I337+yN9+/sjffv7I337+yN9+/sjffv7I3375yN9++cjffvnI3375yN9++cjffvnI3375yN9++cjffvnI3375xN++3baPfEuXv323hXh8S0lPR4f7t9iPfIv7yLf4j3xL+Mi3xI98S5e/fXdby9u/xdry27d8P/oWY+5jumVaz0uA5WzVM+8LhsE9jSN8/Y1kgfHnY+Xz1pvnyvhDTMcqcszuODrE+wTK4BMw2+gTMKNPwI4+ATf6BPzoEwijTyCOPoE0+gRGvxMb/Xfi5PfGKaTgnydw4i7C8aSVDclcH5zDPoycnmboT22LOR5Zu103Hh/s7dnB+WFxfjv0F3Grv3WYjbj+Xmc24vqbs9mI6+8mZyPuIf5h4vr79dmI6zcYsxHX74hmI67fws1GHM/5YeIOz/lp4njOTxPHc36aOJ7z08Q9xD9MHM/5aeJ4zk8Tx3N+mjie89PE8ZwfJu7xnJ8mjuf8NHE856eJ4zk/TdxD/MPE8ZyfJo7n/DTxETyneRDP1xBNPn5xYop1lY82vuyb2pnwtB3c1zOZfgR3KMVmBB8nxCaM4Lik2IzgjaTYjOBipNiM4Dek2HjYvGQzQg8vxWaEbluKDX3xazb0xa/Z0Be/ZBPpi1+zoS9+zYa++DUb+uLXbDxsXrKhL37Nhr74NRv64tds6Itfs6Evfskm0Re/ZkNf/JoNffFrNvTFr9l42LxkQ1/8mg198Ws29MWv2dAXv2ZDX/ySTaYvfs2Gvvg1G/ri12zoi1+z8bB5yYa++DUb+uLXbOiLX7OhL37Nhr74JZtCX/yaDX3xazb0xa/Z0Be/ZuNh85INffFrNvTFr9nQF79mQ1/8mg198Ss2bqMvfs2Gvvg1G/ri12zoi1+z8bB5yYa++DUb+uLXbFbui2+OaWdzu2FvVZLJHyTN02fns5HELX8dHO0Tvhzu2FduuQWxr9zNy2Ef4K2xU2Jf2YMIYl/Z3ghiX9k5CWL3YJfAvrLfE8S+spUUxI5LFcGOSxXBjkuVwD7EC8onxL6yS72t96QDe6kNxJhkjw83ZXv6dGPfLdPKrnYgmVZ2wQPJ5JFpBJlWdtkDybSyKx9IppVd/EAyrez6B5Jp5ZRgHJmGeAU9Mg3x3npkGuJl98jkSCGGkMkj0wgykUL8WCa7hX0kxt5mXJHJ3mT9Otya/AQl57Oj03YcnezjWer7o9SOFGIImUghhpCJFGIImUghRpDJk0IMIRMpxBAykUIMIRMpxBAyeWQaQSZSiCFkIoUYQiZSiCFkIoUYQiZSiJ/L5HI+ZPK+tpBh4zEWG2N4HF3cKUK7f7gz4floc3a0S8fIXXG/Hf1L1kBqMaWspBxTykoqMqWspChTyuqRdUZZSWmmlJVUZ0pZSYGmlJXUaEpZSZlmlDWSMk0pKynTlLKSMk0pKynTlLJ6ZJ1RVlKmKWUlZZpSVlKmKWUlZZpSVlKmGWVNpExTykrKNKWspExTykrKNKWsHllnlJWUaUpZSZmmlJWUaUpZSZmmlJWUaUZZMynTlLKSMk0pKynTlLKSMk0pq0fWGWUlZZpSVlKmKWUlZZpSVlKmKWUlZZpR1kLKNKWspExTykrKNKWspExTyuqRdUZZSZmmlJWUaUpZSZmmlJWUaUpZSZkmlNVvpExTykrKNKWspExTykrKNKWsHllnlJWUaUpZSZmmlJWUaUpZSZmmlJWUaUZZDSnTlLKSMk0pKynTlLKSMk0pq0fWGWUlZZpSVlKmKWUlZZpSVlKmKWUlZZpRVkvKNKWspExTykrKNKWspExTyuqRdUZZSZmmlJWUaUpZSZmmlJWUaUpZSZlmlNWRMk0pKynTlLKSMk0pKynTlLJ6ZJ1RVlKmKWUlZZpSVlKmKWUlZZpSVlKmGWX1pExTykrKNKWspExTykrKNKWsHllnlJWUaUpZSZmmlJWUaUpZSZmmlJWUaUZZAynTlLKSMk0pKymTElmtDwfCXJPVl0PWsG3lu6ykTFPK6pF1RllJmaaUlZRpSllJmaaUlZRpSllJmWaUNZIyTSkrKdOUspIyTSkrKdOUsnpknVFWUqYpZSVlmlJWUqYpZSVlmlJWUqYZZU2kTFPKSso0paykTFPKSso0paweWWeUlZRpSllJmaaUlZRpSllJmaaUlZRpRlkzKdOUspIyTSkrKdOUspIyTSmrR9YZZSVlmlJWUqYpZSVlmlJWUqYpZSVlmlHWQso0paykTFPKSso0paykTFPK6pF1RllJmaaUlZRpSllJmaaUlZRpSllJmSaU9fbfIeuMspIyTSkrKdOUspIyTSmrR9YZZSVlmlJWUqYpZSVlmlJWUqYpZSVlmlFWQ8o0paykTFPKSso0paykTFPK6pF1RllJmaaUlZRpSllJmaaUlZRpSllJmWaU1ZIyTSkrKdOUspIyTSkrKdOUsnpknVFWUqYpZSVlmlJWUqYpZSVlmlJWUqYZZXWkTFPKSso0paykTFPKSso0paweWWeUlZRpSllJmaaUlZRpSllJmaaUlZRpRlk9KdOUspIyTSkrKdOUspIyTSmrR9YZZSVlmlJWUqYpZSVlmlJWUqYpZSVlmlHWQMo0paykTFPKSso0paykTFPK6pF1RllJmaaUlZRpSllJmaaUlZRpSllJmWaUNZIyTSkrKdOUspIyTSkrKdOUsnpknVFWUqYpZSVlmlJWUqYpZSVlmlJWUqYZZU2kTFPKSso0paykTFPKSso0paweWWeUlZRpSllJmaaUlZRpSllJmaaUlZTp57LGzRyypueBn8p6+0hzQHmW9UUR5G0vgmRK7Wi7lf1oa9NvR/+SNZMyTSkrKdOUspIyTSkrKdOUsnpknVFWUqYpZSVlmlJWUqYpZSVlmlJWUqYZZS2kTFPKSso0paykTFPKSso0pKzeuf1on2tLhNHbr4NjfJSAi2ezLI/Fx+1pGOcHR3McHW3YKkebZOJRVemv9cnrTy8H71jMU+3mk4Pzban06+Bso30++K8699Q5db5AnZNDUucr1DnBLHW+Qp2TVFPnK9Q50T11vkKds5ZBnc9f53FjcYc6X6HOWe2izleoc5b/qPMV6pz1UOp8hTr31Dl1vkCdsx5Kna9Q56yHUucr1DnrodT5CnXOeih1vkKdsx5KnS9Q54b1UOp8hTpnPZQ6X6HOWQ+lzleoc9ZDqfMV6txT59T5AnXOeih13l7nNqSjznPto02Ox6h//dv/dvxf1ciqJdWopxpZW6Qa9VQjK4BUo55qZJ2OalRTjZbVNKpRTzWy5kU16qlGVqaoRj3VyPoR1ainGj3VSDWqqUbWYqhGPdXIWgzVqKcaWYuhGvVUI2sxVKOeamQtRkk1puNZq9s/fz/6l1COZYpBhCLBH0Qowu1BhCL3HUQoj1BjCEVaOIhQBGmDCEXGNIhQxC+DCEUyMYZQnmRiEKFIJgYRimRiEKFIJn4slHPJHlB8sBX05jaYY+nC5PT4IXQ8FWqzh1DWPh37l0wemUaQiVRiCJnIJH4sk9/SMW5vfKrIFLfH1g9PAHO4gydjEAJPZiAEngxABnzA0wuBx6MLgcdzC4HHQwuB94CXAY/PFQKPcxUCj3MVAo9zFQKPc5UBH3GuPwd/C1gO8LH6oxbr0k7euvK0GpbLH4fIEZ87hEy44iFkwkMPIZNHphFkwp8PIRNufgiZ8P5DyERSMIRM5AojyJRIIYaQiRRiCJlIIYaQiRRiCJk8Mr1LJm+OLaW8336T6S/0JAti6EkLxNCTAIihx9WLocepS6HPuG8x9DhqMfS4ZDH0OF8x9B70Uuhxs2LocbNi6HGzYuhxs2LocbNS6AtuVgw9blYMPW5WDD1uVgy9B70UetysGHrcrBh63KwYetysGHrcrBD6tOFmxdDjZsXQ42bF0ONmxdB70Euhx82KocfNiqHHzYqhx82KocfNSqE3uFkx9LhZMfS4WTH0uFkx9B70Uuhxs2LocbNi6HGzYuhxs2LocbNS6C1uVgw9blYMPW5WDD1uVgy9B70UetysGHrcrBh63KwYetysGHrcrBR6h5sVQ4+bFUOPmxVDj5sVQ+9BL4UeNyuGHjcrhh43K4YeNyuGHjcrhd7jZsXQ42bF0ONmxdDjZsXQe9BLocfNiqHHzYqhx82KocfNiqHHzUqhD7hZMfS4WTH0uFkx9LhZMfQe9FLocbNi6HGzYuhxs2LocbNi6HGzUugjblYMPW5WDD1uVgw9blYMvQe9FHrcrBh63KwYetysGPql3azzB3qXYu3omHfyLrnwBN7cUS7tTruiTEu7zb4ol3aPfVEu7Qb7olza3fVF6UHZC+XS7qsvyqXdVF+US7ujvihxO91Q4nZ6ocy4nW4ocTvdUOJ2uqHE7XRD6UHZCyVupxtK3E43lLidbihxO91Q4nZ6oSy4nW4ocTvdUOJ2uqHE7XRD6UHZCyVupxtK3E43lLidbihxO91Q4nY6ocwbbqcbStxON5S4nW4ocTvdUHpQ9kKJ2+mGErfTDSVupxtK3E43lLidXigNbqcbStxON5S4nW4ocTvdUHpQ9kKJ2+mGErfTDSVupxtK3E43lLidXigtbqcbStxON5S4nW4ocTvdUHpQ9kKJ2+mGErfTDSVupxtK3E43lLidXigdbqcbStxON5S4nW4ocTvdUHpQ9kKJ2+mGErfTDSVupxtK3E43lLidXig9bqcbStxON5S4nW4ocTvdUHpQ9kKJ2+mGErfTDSVupxtK3E43lLidXigDbqcbStxON5S4nW4ocTvdUHpQ9kKJ2+mGErfTDSVupxtK3E43lLidXigjbqcbStxON5S4nW4ocTvdUHpQ9kKJ2+mGErfTDSVupxtK3E43lLidXigTbqcbStxON5S4nW4ocTvdUHpQ9kKJ2+mGErfTDSVupxtK3E43lLidXigzbqcbStxON5S4nW4ocTvdUHpQ9kKJ2+mGErfTDSVupxtK3E43lLidXigLbqcbStxON5S4nW4ocTvdUHpQ9kKJ2+mGErfTDSVupxtK3E43lLidTijLhtvphhK30w0lbqcbStxON5QelL1Q4na6ocTtdEOJ2+mGErfTDSVupxdKg9vphhK30w0lbqcbStxON5QelL1Q4na6ocTtdEOJ2+mGErfTDSVupxdKi9vphhK30w0lbqcbStxON5QelL1Q4na6ocTtdEOJ2+mGErfTDSVupxdKh9vphhK30w0lbqcbStzOT1F6t9mvo70L8TeUJyPxaUdignkaST4bd9zy18HRPn1yDneRPCLpFwmHNoBIeL8BRMJVDiASfnUAkXDC+kXyeOwBRMK9DyASucAAIpE4DCCSRyT9IpE4DCASicMAIq2dOOT9aOdt+O3ov+Cs7fQrcNZ22NdwwtrOtgJnbUdZgbO2k6vAWdtBVeB44LyGs7ZjqMBZu1OvwKFDvoBDh3wBhw75NZxIh3wBhw75Ag4d8gUcOuQLOB44r+HQIV/AoUO+gEOHfAGHDvkCDh3yaziJDvkCDh3yBRw65As4dMgXcDxwXsOhQ76AQ4d8AYcO+QIOHfIFHDrk13AyHfIFHDrkCzh0yBdw6JAv4HjgvIZDh3wBhw75Ag4d8gUcOuQLOHTIr+Es/vb5Chw65As4dMgXcOiQL+B44LyGQ4d8AYcO+QIOHfIFHDrkCzh0yC/h3OZKi3xFhx75ig5N8hUduuQrOh46F3Tok6/oLN0oe/egU91aw6R9+wu7PT7ZZndybD54ZFcqx5ZDolt/9duxd4WW7taHUGhpyzCEQkv7lhEUWvsF6EMotLR/G0KhpT3kEAot7WOHUMijkHKFlvbzQyhEpqBdITIF7QqtnSnkY8vb7E1NIZuPTWyd84+jzSmSYA71Q95+O/pOfu2sQJC8XTsDkCS/treXJL+2Z5ckv7YXlyTvIS9Efm3vLEl+bU8sSX5trytJHg8rRR4PK0Te4WGlyONhpcjjYaXI42GlyHvIC5HHw0qRx8NKkcfDSpHHw0qRx8MKkfd4WCnyeFgp8nhYKfJ4WCnyHvJC5PGwUuTxsFLk8bBS5PGwUuTxsELkAx5WijweVoo8HlaKPB5WiryHvBB5PKwUeTysFHk8rBR5PKwUeTysEPmIh5Uij4eVIo+HlSKPh5Ui7yEvRB4PK0UeDytFHg8rRR4PK0UeDytEPuFhpcjjYaXI42GlyONhpch7yAuRx8NKkcfDSpHHw0qRx8NKkcfDCpHPeFgp8nhYKfJ4WCnyeFgp8h7yQuTxsFLk8bBS5PGwUuTxsFLk8bBC5AseVoo8HlaKPB5WijweVoq8h7wQeTysFHk8rBR5PKwUeTysFHk8rAz5G0jIC5HHw0qRx8NKkcfDSpH3kBcij4eVIo+HlSKPh5Uij4eVIo+HFSJv8LBS5PGwUuTxsFLk8bBS5D3khcjjYaXI42GlyONhpcjjYaXI42GFyFs8rBR5PKwUeTysFHk8rBR5D3kh8nhYKfJ4WCnyeFgp8nhYKfJ4WCHyDg8rRR4PK0UeDytFHg8rRd5DXog8HlaKPB5WijweVoo8HlaKPB5WiLzHw0qRx8NKkcfDSpHHw0qR95AXIo+HlSKPh5Uij4eVIo+HlSKPhxUiH/CwUuTxsFLk8bBS5PGwUuQ95IXI42GlyONhpcjjYaXI42GlyONhhchHPKwUeTysFHk8rBR5PKwUeQ95IfJ4WCnyeFgp8nhYKfJ4WCnyeFgh8gkPK0UeDytFHg8rRR4PK0XeQ16IPB5WijweVoo8HlaKPB5WijweVoh8xsNKkcfDSpHHw0qRx8NKkfeQFyKPh5Uij4eVIo+HlSKPh5Uij4cVIl/wsFLk8bBS5PGwUuTxsFLkPeSFyONhpcjjYaXI42GlyONhpcjjYWXI2w0PK0UeDytFHg8rRR4PK0XeQ16IPB5WijweVoo8HlaKPB5WijweVoi8wcNKkcfDSpHHw0qRx8NKkfeQFyKPh5Uij4eVIo+HlSKPh5Uij4cVIm/xsFLk8bBS5PGwUuTxsFLkPeSFyONhpcjjYaXI42GlyONhpcjjYYXIOzysFHk8rBR5PKwUeTysFHkPeSHyeFgp8nhYKfJ4WCnyeFgp8nhYIfIeDytFHg8rRR4PK0UeDytF3kNeiDweVoo8HlaKPB5WijweVoo8HlaIfMDDSpHHw0qRx8NKkcfDSpH3kBcij4eVIo+HlSKPh5Uij4eVIo+HFSIf8bBS5PGwUuTxsFLk8bBS5D3khcjjYaXI42GlyONhpcjjYaXI42GFyCc8rBR5PKwUeTysFHk8rBR5D3kh8nhYKfJ4WCnyeFgp8nhYKfJ4WCHyGQ8rRR4PK0UeD/se8v52If862rtgK0cbn47PDuZp3PlslnHLXwdH+yRNDl+a4o7n09Sj6XSa4ujn05SsYD5NSSHm05R8Yz5NSU6m07SQycynKWnPfJqSI82nKTnSfJp6NJ1OU3Kk+TQlR/qxpu4YiImbq6hk7bZ9HW29+13TO3nSHinyZDJS5ElOZMi7jXxDijwphBR5sgIp8jh6KfIe8kLkccdS5PGwUuTxsFLk8bBS5PGwQuQNHlaKPB5WijweVoo8HlaKvIe8EHk8rBR5PKwUeTysFHk8rBR5PKwQeYuHlSKPh5Uij4eVIo+HlSLvIS9EHg8rRR4PK0UeDytFHg8rRR4PK0Te4WGlyONhpcjjYaXI42GlyHvIC5HHw0qRx8NKkcfDSpHHw0qRx8MKkfd4WCnyeFgp8nhYKfJ4WCnyHvJC5PGwUuTxsFLk8bBS5PGwUuTxsELkAx5WijweVoo8HlaKPB5WiryHvBB5PKwUeTysFHk8rBR5PKwUeTysEPmIh5Uij4eVIo+HlSKPh5Ui7yEvRB4PK0UeDytFHg8rRR4PK0UeDytEPuFhpcjjYaXI42GlyONhpch7yAuRx8NKkcfDSpHHw0qRx8NKkcfDCpHPeFgp8nhYKfJ4WCnyeFgp8h7yQuTxsFLk8bBS5Jf2sDkc5Mvmfzv6Tmdpn1mls7QXrNEpS/u1Kp2lPVWVztK+p0pnaW9SpeOhc0Fn6R6/SmfpPrxKh175ig698hUdeuXXdPxGr3xFh175ig698hUdeuUrOh46F3Tola/o0Ctf0aFXvqJDr3xFh175go6hV76iQ698RYde+YoOvfIVHQ+dCzr0yld06JWv6NArX9GhV76iQ698QcfSK1/RoVe+okOvfEWHXvmKjofOBR165Ss69MpXdOiVr+jQK1/RoVe+oOPola/o0Ctf0aFXvqJDr3xFx0Pngg698hUdeuUrOvTKV3Tola/o0Ctf0PH0yld06JWv6NArX9GhV76i46FzQYde+YoOvfIVHXrlKzr0yld06JUv6Kz9DvQqHXrlKzr0yld06JWv6HjoXNChV76iQ698RYde+YoOvfIVHXrlCzprv2u5Sode+YrO0r1yMeGgE2tHm5S/DrZPO6ja7E6OzQeP7Erl2JL3IZfy+7F3hZbu14dQyKOQcoWW9i0l7cP2xm+Vo21ydpcoleej05lGtxxzF8ma+NvRd/JLeyJR8kv7LVHyS3s5UfJL+0RJ8mu/K1mU/NL+VpT82t5ZkvzanliSvIe8EHk8rBR5PKwUeTysFHk8rBR5PKwQ+bXflSxKHg8rRR4PK0UeDytF3kNeiDweVoo8HlaKPB5WijweVoo8HlaI/NrvjxYlj4eVIo+HlSKPh5Ui7yEvRB4PK0UeDytFHg8rRR4PK0UeDytDPqz9XndR8nhYKfJ4WCnyeFgp8h7yQuTxsFLk8bBS5PGwUuTxsFLk8bBC5A0eVoo8HlaKPB5WijweVoq8h7wQeTysFHk8rBR5PKwUeTysFHk8rBB5i4eVIo+HlSKPh5Uij4eVIu8hL0QeDytFHg8rRR4PK0UeDytFHg8rRN7hYaXI42GlyONhpcjjYaXIe8gLkcfDSpHHw0qRx8NKkcfDSpHHwwqR93hYKfJ4WCnyeFgp8nhYKfIe8kLk8bBS5PGwUuTxsFLk8bBS5PGwQuQDHlaKPB5WijweVoo8HlaKvIe8EHk8rBR5PKwUeTysFHk8rBR5PKwQ+YiHlSKPh5Uij4eVIo+HlSLvIS9EHg8rRR4PK0UeDytFHg8rRR4PK0Q+4WGlyONhpcjjYaXI42GlyHvIC5HHw0qRx8NKkcfDSpHHw0qRx8MKkc94WCnyeFgp8nhYKfJ4WCnyHvJC5PGwUuTxsFLk8bBS5PGwUuTxsELkCx5WijweVoo8HlaKPB5WiryHvBB5PKwUeTysFHk8rBR5PKwUeTysDPm44WGlyONhpcjjYaXI42GlyHvIC5HHw0qRx8NKkcfDSpHHw0qRx8MKkTd4WCnyeFgp8nhYKfJ4WCnyHvJC5PGwUuTxsFLk8bBS5PGwUuTxsELkLR5WijweVoo8HlaKPB5WiryHvBB5PKwUeTysFHk8rBR5PKwUeTysEHmHh5Uij4eVIo+HlSKPh5Ui7yEvRB4PK0UeDytFHg8rRR4PK0UeDytE3uNhpcjjYaXI42GlyONhpch7yAuRx8NKkcfDSpHHw0qRx8NKkcfDCpEPeFgp8nhYKfJ4WCnyeFgp8h7yQuTxsFLk8bBS5PGwUuTxsFLk8bBC5CMeVoo8HlaKPB5WijweVoq8h7wQeTysFHk8rBR5PKwUeTysFHk8rBD5hIeVIo+HlSKPh5Uij4eVIu8hL0QeDytFHg8rRR4PK0UeDytFHg8rRD7jYaXI42GlyONhpcjjYaXIe8gLkcfDSpHHw0qRx8NKkcfDSpHHwwqRL3hYKfJ4WCnyeFgp8nhYKfIe8kLk8bBS5PGwUuTxsFLk8bBS5PGwMuTThoeVIo+HlSKPh5Uij4eVIu8hL0QeDytFHg8rRR4PK0UeDytFHg8rRN7gYaXI42GlyONhpcjjYaXIe8gLkcfDSpHHw0qRx8NKkcfDSpHHwwqRt3hYKfJ4WCnyeFgp8nhYKfIe8kLk8bBS5PGwUuTxsFLk8bBS5PGwQuQdHlaKPB5WijweVoo8HlaKvIe8EHk8rBR5PKwUeTysFHk8rBR5PKwQeY+HlSKPh5Uij4eVIo+HlSLvIS9EHg8rRR4PK0UeDytFHg8rRR4PK0Q+4GGlyONhpcjjYaXI42GlyHvIC5HHw0qRx8NKkcfDSpFf2cN6cxztTYm/HX2ns7LPrNKJK3vBOp2V/Vqdzsqeqk5nZd9Tp+Ohc0FnZf9Qp7Nyj1+ns3IfXqdDr3xFh175gk6iV76iQ698RYde+YoOvfIVHQ+dCzr0yld06JWv6NArX9GhV76iQ698QSfTK1/RoVe+okOvfEWHXvmKjofOBR165Ss69MpXdOiVr+jQK1/RoVe+oFPola/o0Ctf0aFXvqJDr3xFx0Pngg698hUdeuUrOvTKV3Tola/o0Cu/ppM3euUrOvTKV3Tola/o0Ctf0fHQuaBDr3xFh175ig698hUdeuUrOvTKF3QMvfIVHXrlKzr0yld06JWv6HjoXNChV76iQ698RYde+YoOvfIVnaV7ZW/cTieZ7Tudpd+vXqezdK9cpbN0r1yls3SvXKXjoXNBZ+leuUpn6V65SmfpXrlKZ+leuUqHXvmCztLvca7ToVe+okOvfEWHXvmKjofOBR165Ss69MpXdOiVr+jQK1/RoVe+oLP0+2LrdOiVr+jQK1/RoVe+ouOhc0GHXvmKDr3yFR165Ss69MpXdOiVL+gs/V7KOh165Ss69MpXdOiVr+h46FzQoVe+okOvfEWHXvmKDr3yFR165Qs6a7+3r0qHXvmKDr3yFR165Ss6HjoXdOiVr+jQK1/RoVe+okOvfEWHXvmCztrv7avQKQOk7jHtR4eY3TOd+wwG6Pa3h75b/D4D32UG1u2F4VzKlRm4WLb96Lw9f3b6GlTQOKiocVBJ46CyxkEVhYPqlKV0HpTROCircVBO46A0XtGjxit61HhFjxqv6FHjFT1qvKInjVf0pPGKnjRe0ZPGK3rSeEVPGq/oSeMVPWm8oieNV/Sk8YqeNV7Rs8YretZ4Rc8ar+hZ4xU9a7yiZ41X9Kzxip41XtGzxit60XhFLxqv6EXjFb1ovKIXjVf0ovGKXjRe0YvGK3rReEUv+q7odtv0XdFvg9J3Rb8NSt8V/TYofVf026D0XdFvg9J3Rb8NSt8V/TYoiSt6TsfRZTMng8oaB1UUDspsGgdlNA7KahyU0zgor3FQQXhQxp4MSuKKno/HxVyx22+D+n50Ph6Zyu7xxJT99YzWt2NvIdLXsbfu9bdj75NNK002rzTZstBk7bbSZM1Kk7UrTdatNFm/0mTDSpNdqYOyK3VQdqUOyq7UQbm5Oqi4H3sbpz2Z7VwtVG22c/VQtdnO1UTVZuuXmu1cbVRtthJ9VLHpmG1Ildle/0bwNoM0/Azy8DMoo8/Ab8PPwAw/Azv8DNzwM/DDzyAMP4Ph78l++Dua139Hu9x5wG7n++a6251un/jt3+7pvK+O8HxH2R+c5xvPC43nxcbzUuN5ufG80nbe+W/Xf3CeaTyvsV5iY73ExnqJjfUSG+slNtZLbKyX2FgvqbFe0k/qJWzfz7ON57nG83zjeaHxvNh4Xmo8LzeeV9rOy1vjeY31khvrJTfWS26sl9xYL7mxXnJjveQX9RLMsdnR7Z5sn8/73kSYmI58KD5l9ibmk6Pt7b/+Otqa/Dg6nvUnpviyH7yZdH1wMvtkU3xqk8LZsT7vnxued70KX89W5bIqF7M/sRtc+s6lbHA55WLgcsrFwuWUi4PLKRcPl1MuYSYu24NLqXBx9vETEmf8cbRzZxsp3kKOfQnMbE9jduHs6Gz2MWfnK8fGQ5/4ZH9+HXvXJ6KPan0S+qjWZyofMqE+En4oHPrcovSaPsXuk/21+UA4Drcl/zUFs23jT8GMPwU7/hTc+FPw408hjD+FqHsKPpV94dFnl08mkEafQB59Asrvy9UJGOV35foElN+T6xNQfkeuT0D5/fhqAicD8ceDucY/PcX7yxDcp6v83t17usrv872n+6onyMez3Vs07nm69/NS43m58bzSdp7dGs8zjefZxvNc43m+8bzQeF5jvdjGerGN9WIb68U11otrrBfXWC+usV5cY724n9SLTd/Pi43npcbzcuN5pe08vzWeZxrPs43nucbzfON5jfXiG+vFN9aLb6wX31gvobFeQmO9vHqg9mmntC2Z1Led0f/AjXn1wPD8XC4Xfs2rB6KX5xLgcsolwuWUS4LLKZcMl1MuZSYu0y1Im1c/bEEfJfoY9FGtz1Q+ZEJ9JPxQ3+Xt6MefQhh/CnH8KaTxp5DHn0IZfgpp0z2F6lJ3MqNPwI4+AeX35foElN+V6xNQfk+uT0D5Hbk+AeX3486PZCTl9+7e01V+n+883ax/p6frPXpM1r/TU7KPGTwviu4z0L/7Ym0G+veqqs1ggL2qrmdQ9O++WJuB/t0Xk4/HDIJ/nsHJZd0fA7He++/T1b9VY9fp6t/Xset0/VrTHaCP6DndAZqOntMdoEPpOd0B2pme0x2g9/mj6dr8mO43w2C3ARqlntOdrauqTHeyriqEvWe2Ibrrg+O2Hauqm/Hf2UzWgv0Jm1BSuWTjJ2NzvA3DhmSuD87b/sHZP4VVfvtCM1lv1xPNZH1gTzST9Yw90UzWX/ZEM1kv2hGNma2z+RM0YX/ELaf4G5qz5RS3j/nXD5WOo3/9Svr7wXlvIdz226F35LM1TAMg9yD/NPKV+zsh5Cv3jULIV+5HhZCv3OcKIV+5f5ZBbifLk0dAPlmmPQJy3OfHkeM+P47cg/zTyHGfn0buqPKfId+KPZA/PXp8ijwfWx8VYysfbG7fvX/y7d/p6aXyX78ysI4/C/0akeLo14jYR79G5ET6NSJYUq+RJ4nSrxHRlX6NyLr0a0Q4pl8jj0bqNSJn0K8ROYN+jcgZ9GtEzqBfI3IG9RoFcgb9GpEz6NeInEG/RuQM+jXyaKReI3IG/RqRM+jXiJxBv0bkDPo1ImdQr1EkZ9CvETmDfo3IGfRrRM6gXyOPRuo1ImfQrxE5g36NyBn0a0TOoF8jcgb1GiVyBv0akTPo14icQb9G5Az6NfJopF4jcgb9GpEz6NeInEG/RuQM+jUiZ1CvUSZn0K8ROYN+jcgZ9GtEzqBfI49G6jUiZ9CvETmDfo3IGfRrRM6gXyNyBvUaFXIG/RqRM+jXiJxBv0bkDPo18mikXiNyBu0auW3mv6N8fXCK+7Ep/Ub9Tmbm6v37yMycTf19ZEZIhMyDTGWyVx99n+8I6UrP+Y6QVHScrxnB9fec7wgOuud8R3CjPec7grP7+Xz95srXwX4rpfLRzh/NoPP5adjh6+5lPHQu6IzQD8rRGaEnlKMzV1/Ym85cXWRvOnP1nJ3p2Lk61N505upne9OZq/vtTYde+YqOX4bOfb7rdL/3+a7Tz97nu06Hep/vOj3nfb7rdJF/zddN1heaY0HD33KaykfnzX8dnN2Djc3u5NiS9w8u5fdj7xwn6yDFOE7Wa4pxnKwrFePo4diF42R9sRjHyfptMY6T9fFiHCfzB2IcJ/MdUhw9fqYPR/xMH474mT4c8TN9OM7WP5p9/cEbe5JvDfFu+J7zna0fq813tr6pMt8h3v/dc76z9SG1+c7WL9TmO9t9vTZfv9h8Z8v9avNdrL8a4p24Pee7WH81xLtaO853iPee9pzvYv3VEO/j7DnfxfqrId4T2XO+i/VXQ7y/sOd8F+uvhnivXs/5LtZfDfG+t57zXay/GuI9ZD3nu1h/NcT7sXrOd7H+aoj3NvWc72L91RDvE+o538X6qyHec9Nzvov1V0O8f6XnfBfrr4Z4L0jP+S7WXw3xvoqe812svxriPQo957tYfzXE/v4957tYfzXEvvM957tYfzXEfug957tYf1UW66/KYv1VWay/Kmv1V35bq7/y21r9ld/W6q/8tlZ/5Te/2HzX6q/8EO+06DnftforP9mbKurzXay/muxNFfX5LtZfTfamivp8F+uvZnv3RHW+i/VXs70fojrfxfqr2d7hUJ3vYv3VbO9ZqM53sf5qtnchVOe7WH812/sKqvNdrL+a7X0F1fku1l/N9r6C6nwX66+me19Bbb6L9VfT7f9fm+9i/dV0++nX5rtYfzXd/vS1+S7WX02333ttvov1V9Ptn16b72L91XT7kdfmu1h/5f1i812sv1ps/3a/2P7tfrH92/1i+7f7xfZv94vt3+4X27/dL7Z/u19s/3a/2P7tfrH92/10+7e/7b1KcT/2hsD+dvAdJC9C7ASSNyH2ATndVvZiIHkXYieQvAyxE0i/DMj7fNd5e/h9vuu85fs+33W60Pt812kW7/Ndp6f7a77T7XJfm+86HdJ9vus0Mvf5rvP25ft8/WLzXay/mm6X+9p8F+uvptvlvjbfxfqr6Xa5r813sf5qul3ua/NdrL+abpf72nwX66+m2+W+Nt/F+qvpdrmvzXex/mq6Xe5r812sv5pul/vafBfrr6bb5b4238X6q+l2ua/Nd7H+arpd7mvzXau/CtPtcl+b71r9VZhul/vafNfqr8LmF5vvWv1VmG6X+9p81+qvwnS73Nfmu1h/Nd0u97X5LtZfTbfLfW2+i/VX0+1yX5vvYv3VdLvc1+a7WH813S73tfku1l9Nt8t9bb6L9VfT7XJfm+9i/dV0u9zX5rtYfzXdLve1+S7WX023y31tvov1V9Ptcl+b72L91XS73Nfmu1h/Nd0u97X5LtZfTbfLfW2+i/VX0+1yX5vvYv3VdLvc1+a7WH813S73tfku1l9Nt8t9bb6L9VfT7XJfm+9i/dV0u9zX5rtYfzXdLve1+S7WX023y31tvov1V9Ptcl+b72L91XS73Nfmu1h/tdBm9Pf5LtZfLbS1+32+i/VXC22Ufp/vYv3VYvu3h8X2bw+L7d8eZtu/PbqyzzdvrvLRf/Rih7zPsJTfj71znKxvE+M4WT8oxXG2fezfx/H6hS1htg3y5UBO1hnLgZys5ZYD6QHZB+RkJkEO5GTuIx8f7bOvgUzRfR2c0mOK3n6hmcyo9EQzmffoiWYyO3GB5q/5zvZ6hep8J+vOq/Odq4kOxof9YBNP4qnJXq9Qn69fbL5zdY71+c7V4NXnO1fXVp/vXK1Yfb5z9VfV+U72eoX6fOfqr57na409me+8/dX5fOftr87n6xeb77z91fl85+2vzuc7WX+VTDoOzuVkvpP1V9X5TtZfVeYbJ3u9Qn2+k/VX1flO1l9V5ztZf1Wdr19svpP1V9X5TtZfVee7Vn8VJ3u9Qn2+i/VXk71e4bY+tO0Hl5grH+3LAef5UehsT461abNfB9tkH84rfnGcrG8T4zhZPyjGcbI+sxPHOxsPm5dsJutfu7KZrNftymayvrgrm8l66K5sJuu3/4jNLcLfD/b5O5vJXs3Rl83K/XaNzco9dI3Nyn1xjY2HzUs2K/fFNTYr98U1Niv3xTU2K/fFIRx9cT7piyd7TUpXNpO9UqUvm6X74gqbpfviCpul++IKGw+bl2yW7osrbJbuiytslu6LK2zoi1+zWacv/mu+k73epj7fdfrX+3zX6Unv812nz7zP1y8237n6wbht+0Bu7Zw5me9cPV59vnP1bfX5ztWL1ec7V39Vne9kr7epz3eu/qo+37n6q/p85+qv6vP1i813sf5qstfb1Oe7WH812ett6vNdrL+a7PU29fku1l9N9nqb+nwX668me71Nfb6L9VeTvd6mPt/F+qvJXkNTn+9i/dVkr3Wpz3ex/mqyl6TU57tYfzXZK0fq812sv5rsBR71+S7WX032qo36fBfrryZ7f0Z9vov1V5O9P6M+38X6q8nen1Gf72L91WTvz6jPd7H+arL3Z9Tnu1h/Ndn7M+rzXay/muz9GfX5LtZfTfb+jPp8F+uvJnt/Rn2+i/VXk70/oz7ftfqrNNn7M+rzXau/SpO9P6M+37X6q7T5xea7Vn+VJnt/Rn2+a/VXabL3Z9Tnu1h/Ndn7M+rzXay/mux9FPX5LtZfTfYuiPp8F+uvJntnQ32+i/VXk71boT7fxfqryd6BUJ/vYv3VZO8qqM93sf5qsncK1Oe7WH812d7/9fku1l9Ntkd/fb6L9VeT7aVfn+9i/dVke97X57tYfzXZ3vT1+S7WX022h3x9vov1V5Pt9V6f72L91WT7t9fnu1h/Ndn+7fX5LtZfTbZ/e32+i/VXi+3fnhbbvz0ttn97Wmz/9rTY/u1psf3b02L7t6fF9m9Pi+3fnhbbvz0ttn97Wmz/9rTY/u1psf3b02L7t6fF9m9Pi+3fnhbbvz0ttn97Wmz/9jTb/u0+7wfHYOzJfCfrr1w69L2dWPnovPmvg7Mrx7E2u5NjS94/uJTfj71znKxvE+M4WT8oxXG2fezFOE7Wv4pxnKwvFuM4Wb8txtHDsQvHyfyBGMfJfIcYR/xMH474mT4c8TNdOM723ggxjviZPhzxM3044md+yDHux94Q2BOQHpB9QOJoOoHE0nQCiafpBBJT0wfkbG/dCLnsIKOpgTShbG6fZijGHcfHLzqT3Yov6NznO9kdszrfuW5st8xsP/gWV5TKR/96JOTr6F+rEc8ffYcz182qM5y5bkCd4cwVlXWFkyd770RnOHO1I53hzJVUdYYzV/zUGY5fGk6xO5z81AUecOZqejvDWbtDrsBZuUN2dtvNlbM2fYezcodchbNyh1yDM9mbQzrDWblDvsHZLuH4leF4sx/tvN2+w1m5z6nCWbnPqcJZus+pwVm6z3ElH3DMdv3RoaT91hZKObl6L90U/QnJuB33wbidGJPJ3g3ymZo8J7l0u+Xd0Yv6YP6+v+7J3mfyGZLnNbly1On88aiE8yV/h+OB8xrO2hagAmdtC1CBs7YFeMAJT09RHXCWtgA1OEt39RU4k71kpjOcpXtv9xhIMOn6o03Mux80yT9tDuO3L5RLt4zp2DrHpeL+Phsz2Wtl3kiyFlJM9sKaz9TkOcmlO9fHR7u/WaQ/uVBu5Xjg27jt5EK5dJ97c88HylL5aH8Q8fb3O84J9kckZ25x+nG0O7Av3UHLYV+6NxfDPtmrj4bBvrSfkMO+dPAvh31pyyeH3YP9h9jdbg/98wwPkEvbw54gJ/vRedef+ObZXoPVmc5km171pTPbK7Y602FrgSs6k2071ZnOZJtJdabjoXNBZ51NLFroTLaX05/Scf5BJ9gnOudH26ej4zeWi3fWXVku3od3Zbl41/4HLL058hxvnx6z+CI520veBEku7gY6klzcOXQkubjL6EjSQ7ITycXdS0eSOJ1eJPE5vUjicnqRxON0IjnbCwYFSa7ucV6lEiefnY9fLCT39CPtF59d8j7JG/anl/3e9LqTX90TyZFf3UP1IX9n6WHZjeXqPuoyIe70UjhzvInAWVsqdEze9k1KTTbPLMspne1BZ4vPdO4zKPpnYB8zONmsrNOL0CRnYIafgR1+Bm74GXj9M/DxcaWu/MTM+uOWYb3//mO9Tm+lGma6ca3pprWmO0Af0XO6AzQdHadbBuhQek53gHam53QH6H3+aLo2P6b73TCUARqlntP1a013sq4qhL1ntiH+nRttlMlasD9hU9s6o0zWrwXjDjapss9k3vYPzv5pzPvvxspkvV1PNJP1gf3QlG2ynrEnmsn6y55oJutFe6KZrbP5EzRhH0ZO8Tc0Jx9s3GOl8mmL5V/b4X0/+LH71vbboXfkszVMAyBfuQ8TQr5yfyeEfOW+UQa5WbkflUFuV27m/gT59ni9pHl6xOEU+W2h9+vYYqqbFN2++3j8I6f0ON6W/KXRZGnolBp5NFKvEe5Mv0bYOf0a4f/0a4Rh1K8RDlO9Rg5Lql+jlddqRtGInEG/RuQM+jXyaKReI3IG/RqRM+jXiJxBv0bkDPo1ImdQr5EnZ9CvETmDfo3IGfRrRM6gXyOPRuo1ImfQrxE5g36NyBn0a0TOoF8jcgb1GgVyBv0akTPo14icQb9G5Az6NfJopF4jcgb9GpEz6NeInEG/RuQM+jUiZ1CvUSRn0K8ROYN+jcgZ9GtEzqBfI49G6jUiZ9CvETmDfo3IGfRrRM6gXyNyBvUaJXIG/RqRM+jXiJxBv0bkDPo18mikXiNyBv0akTPo14icQb9G5Az6NSJnUK/RCC+AX14jcgb9GpEz6NeInEG/Rh6N1GtEzqBfI3IG/RqRM+jXiJxBv0bkDOo1KuQM+jUiZ9CvETmDfo3IGfRr5NFIvUbkDPo1ImfQrxE5g36NyBn0a0TOoFwjt23kDPo1ImfQrxE5g36NyBn0a+TRSL1G5Az6NSJn0K8ROYN+jcgZ9GtEzqBeI0POoF8jcgb9GpEz6NeInEG/Rh6N1GtEzqBfI3IG/RqRM+jXiJxBv0bkDOo1suQM+jUiZ9CvETmDfo3IGfRr5NFIvUbkDPo1ImfQrxE5g36NyBn0a0TOoF4jR86gXyNyBv0akTPo14icQb9GHo3Ua0TOoF8jcgb9GpEz6NeInEG/RuQM6jXy5Az6NSJn0K8ROYN+jcgZ9Gvk0Ui9RuQM+jUiZ9CvETmDfo3IGfRrRM6gXqNAzqBfI3IG/RqRM+jXiJxBv0YejdRrRM6gXyNyBv0akTPo14icQb9G5AzqNYrkDPo1ImfQrxE5g36NyBn0a+TRSL1G5Az6NSJn0K8ROYN+jcgZ9GtEzqBeo0TOoF8jcgb9GpEz6NeInEG/Rh6N1GtEzqBfI3IG/RqRM+jXiJxBv0bkDOo1yuQM+jUiZ9CvETmDfo3IGfRr5NFIvUbkDPo1ImfQrxE5g36NyBn0a0TOoF6jQs6gXyNyBv0akTPo14icQb9GHo3Ua0TOoF8jcgb9GpEz6NeInEG/RuQM2jW6IUcj9RqRM+jXiJxBv0bkDPo18mikXiNyBv0akTPo14icQb9G5Az6NSJnUK+RIWfQrxE5g36NyBn0a0TOoF8jj0bqNSJn0K8ROYN+jcgZ9GtEzqBfI3IG9RpZcgb9GpEz6NeInEG/RuQM+jXyaKReI3IG/RqRM+jXiJxBv0bkDPo1ImdQr5EjZ9CvETmDfo3IGfRrRM6gXyOPRuo1ImfQrxE5g36NyBn0a0TOoF8jcgb1GnlyBv0akTPo14icQb9G5Az6NfJopF4jcgb9GpEz6NeInEG/RuQM+jUiZ1CvUSBn0K8ROYN+jcgZ9GtEzqBfI49G6jUiZ9CvETmDfo3IGfRrRM6gXyNyBvUaRXIG/RqRM+jXiJxBv0bkDPo18mikXiNyBv0akTPo14icQb9G5Az6NSJnUK9RImfQrxE5g36NyBn0a0TOoF8jj0bqNSJn0K8ROYN+jcgZ9GtEzqBfI3IG9Rplcgb9GpEz6NeInEG/RuQM+jXyaKReI3IG/RqRM+jXiJxBv0bkDPo1ImdQr1EhZ9CvETmDfo3IGfRrRM6gXyOPRuo1ImfQrxE5g36NyBn0a0TOoF8jcgbtGtmNnEG/RuQM+jUiZ9CvETmDfo08GqnXiJxBv0bkDPo1ImfQrxE5g36NyBnUa2TIGfRrRM6gXyNyBv0akTPo18ijkXqNyBn0a0TOoF8jcgb9GpEz6NeInEG9RpacQb9G5Az6NSJn0K8ROYN+jTwaqdeInEG/RuQM+jUiZ9CvETmDfo3IGdRr5MgZ9GtEzqBfI3IG/RqRM+jXyKOReo3IGfRrRM6gXyNyBv0akTPo14icQb1GnpxBv0bkDPo1ImfQrxE5g36NPBqp14icQb9G5Az6NSJn0K8ROYN+jcgZ1GsUyBn0a0TOoF8jcgb9GpEz6NfIo5F6jcgZ9GtEzqBfI3IG/RqRM+jXiJxBvUaRnEG/RuQM+jUiZ9CvETmDfo08GqnXiJxBv0bkDPo1ImfQrxE5g36NyBnUa5TIGfRrRM6gXyNyBv0akTPo18ijkXqNyBn0a0TOoF8jcgb9GpEz6NeInEG9RmVmD5uvD05xPzal36jfyczsHP8+MjP7tb+PjB+AjHmQqUz26qPv8x3BcfSc7wjde8/5jtAJ95zvCF1lz/mO0KH1m6/bRlhV+ZP5hv02Z4p1lY82vpT96PDUC94++g5nhFZQDM4I3aAYnBEawnfBsTkd7WMupXL0r3vMPklnHp3pTtJDshPJ2VpTOZKzNb1vJOliOUjm9ETy+7HeHNS9Nekb9dla7zGoz2YA/oz6MctbLrhVjs7HHLN7TNFmd3JsyfswSvn92Dv12WzIENTNymZIjvrKLkuO+sr2TY762r5QirqHugD1tf2mFPW1vakU9bW9qRR1vKkEdbypAHWLN5WgjjeVoI43fQv1uB97A2ZPsGNORbB7sEtgx56KYMefimDHoIpgX9qhlscq9FbFbnw6WAbz9Nn5bCRx2xeto33Cl8MX96U9qhx3t7RLFeS+tE8V5L60UxXkvrRVFeS+dPf+Tu5+PzgGc8KdfuZN3I+fA8eYv3Mf4mXtSrgHcww7OP8b9ztLepR+LOk7+rGkl+jH0sPyx/epYyA3lqFyn7p9ffaPoZRvz+kP8YrwOcnTE0uRXzrUFiVPri1FfmUn6DaXDvKlNpDKL9uGeEH2GCRXdnZ9Sa7s6/6MpDExHFBMfNp+zpizbeIqv+ke4hXSc5L3kBciv7JnfDP5fr/AH+KFz6i0shf9U5WSPT7clM1VVLIpHY9vpaftKHfyK3tRWfJ4USHyQ7x0eUzyXZ+XGOLFy+jkhnj5Mjq5IV7AjE5uiJcwo5Mb4kXM6OSGeInsEjpdP6c5xAswl9Dp+rnOIV6COahOtWfEhni55azsPezF2NNrybFnDeV99+WuzzcN8apJlPqlFJ5kFKVYpxlEqcy6zihK4fR/rJTdwoHe3mZcUcrelP063Jr8BCXns6PTdhydrP2mE05/DJ1IBcbQyaOTgE539iQIcuxJEOTYkwnIscfly7HHt4uxLzjxt7G3x8MO9vbvE/Z4azn2+GU59vT3cuzpc97GPvhtZx/CGXv6HCn2fqPP6cP+TpPOpSdNepGeNEnYf07TmnLQtM/XzYbf2fvNQ16IPB21FHny8reR77Zrgd9I1kdQCW/aqFI0J30QbrMjTYN/7EkT//hzmre1yYOm99UdNaI9EsDono4u7os9bvMz7NMJe7zpR9h7e8Lew/5t7I+x2BjDb+zPxhK3YyzxCWExp/NMR+CTs6scne0+zezNb8feawCfTA3g2KkB8gBqgLSBGiAjWb4GLMkONUAeRQ2Qiy1QA2F/HD6HdFID5HML1IA/rgNPAB814KmBlWogupMaIB8YsQZscDsUG4I90RXPP6auj7cERBNOdMXHT6mrw5vPqSt+e05d8dBz6oovnlNXj65T6orPGTLDKI8HZ8tZRu3wOVPq6vE5c+qKz5lTV3zOnLric+bU1aPrjLoG+iYlulofDoQ5VHR1Mbv96JjLia70TXPqSt80p670TXPq6tF1QF29O14LeouCT55vCvwOckhdy5H7+5JPnl0M/LZxcF3Dtp1dh3kecU5dWaebU1fW6abUNZI3zakredOcupI3zakredOcunp0nVJX8qY5dSVvmlNX8qY5dSVvmlNX8qYpdU3kTXPqSt40p67kTXPqSt40p64eXafUlbxpTl3Jm+bUlbxpTl3Jm+bUlbxpSl0zPkeJruZ4m5Uzofo7Dnfo6tzZc+HZo+voupaT33FkfM6cuuJz5tQVnzOnrvicOXXF50ypa2FdfU5dWVefU1fW1efUlbxpTl09uk6pK3nTnLqSN82pK3nTnLqSN82pK3nTjLreFtvRdUpdyZvm1JW8aU5dyZvm1NWj65S6kjfNqSt505y6kjdNqavB53xE12Qruqa4b9if0gO3t18yYVuGkAkXMoRMHpneJVNK++E2b64iU3F5R1j8lh5H59N7WS6Pe9nTwelsHCWbY5abvT7YmC0d4pjfoOSvisGuSFTMnT2W4m3ssy0H+7CdsGfZ6n3soz/YPyPc2VvuUj9nH9wxbhuSqbAvaX+LktnM083hNvA7ei73P0cfN3OgT88DP0V/+8jjxmyf3e6Lri/vbxW9fXapHW3McSsxPlWOzmWHUszJpc9y26EGSL2oAZ7Imr8GSnFHQ7Dl34rg+8GxHLOMxVRca761gl8HZxvtN2dp6bApr/eVl+P5NMrrjeXF8hHl9cbyYtmL8npjebFcR3m9sbw85UV5va+8CKkprzeWF/n30uV1LwICcIrAkYBTBI6cev4iMJvdjirwW6XdMCUeD7yUMs2zfp7QaYFKd9k91LTfr3eebIgqCN5TBYtVQTmpApIWqiB4AhGqIHgSEaogeCIRusPgyUSoghB4xI4qCIEn4aiCEMgOqYIQyA6pghA8VUAVBLJDqiAEUiOqIARSoyGrwG7HLinW/l4Fd13JgabUNZLszKkrWc2cupK+zKkrecqcunp0HVJXHw5d03aiK5nHnLryBNScuuJfp9Q10Q+Pqevxexbr/mYkd13ph4fU9ZYUHroWd6KrR9cpdaUfnlNX+uE5dWW1dk5dWX+dU1f865S6ZtZf59SV9dchdfVuf77J+uwqR0e/v2Mlxsfaj4tns8xhR5Jz+e3Ye72QY1Evf1Iv5GPUy5/Ui6deqJenY8vjTW6bKZWDw604dm1M9pWjY3TbMQ5nToqRsJBiVFOMJJwUo5piJJalGNUUI1kyxaimGAnAKUYtxVhI7SlGNcXIUgPFqKYYWcegGNUUI4skFKOaYvQUI8WopRhZgaEY1RQjKzAUo5piZAWGYlRTjKzAUIxqipEVGIpRSTHGjRUYilFNMbICQzF+qBiTO6ok3YicFCMrMBSjmmJkBYZiVFOM5IwU48eKMYejGJ9wP4qRaIdi/FQxentcGW/j/16MBgNDMaopRk8xUowfKsYcdiApx7Ni5EEJirG9GP2xPXzwZjspLywJ5fXG8uJhBsrrjeWFh6W82ssrHRFJyNvJsprhgQPK633lZXmEgPL6O8orbkd52ZrPNG6zhzpu+xuneQb8If3t39HUjg/hYGhC3E5u1hYnS7nrLfdjlr/KvTYa43M4Bu9zOllfcZ5yp9w/Ve7GHh/uTDi5+jquvpSjonIkd6QcFZUjOSXlqKgcyTUpx7+jHJ+1SSflRa5Jeb2vvDy5JuX1xvLiWUHK643lxc+XKK83lhc/SKK83lhenvKivN5XXuRklFd7eZXjHWGh5HBSXuRelNcby4vci/J6X3kFci/Kq7m84nY8LhqNOem9ArkX5fXG8iL3orzeWF7kXpTXG8vLU16U1/vKi6dnKa83lhdPw1JebywvUnvK633lFT3lRXk1l5fx6Sivsx2QIr0X5fXG8qL3orzeWF70XpTXG8uLJyYorzeWF09MUF7vK6/EExOU199RXsfR0f7Nz2i/H52t36sk22gfg85ftcjjFdSillrkWQxqUUst8uAGtailFj21SC0qqUWWJahFLbXIGga1+KFaNDEcL7i5/fupGh+xDmselKOicmSNhHJUVI6sqVCOesoxswZDOX6uHJN5lGM+K0fiRsrxY+UYsz/KMW0nzzZnTzlSjp8qx2QfN+vk40k5EjpSjorKkdyRclRUjuSOlKOiciR3pBwVlSO5I+WopxwLuSPlqKgcefybcvxcOeb4KMcn4I9y5AlwylFRObIqQzkqKkdPOVKOnyrHvG1HOWZjTsqRVRnKUVE5sipDOSoqR1ZlKMfP9Y5PD5hlY2vH24f0t39HUzs+hHwESSGUclLurPpQ7guVO6tKlPsy5Z42Vq0o94XKnVUxyn2hcmfVjXJfqNxZ1aPcFyp3T7lT7uuUO6uSlPtE5X4sM4W4bSflzqon5a633I9Z/ir32miMzw+B/N9+/l/lbkhmKPd5yj3kR7mnfFLuJDOU+0LlTjJDuS9U7p5yp9zXKXeeiKTcP1fu4enXNPGsHHlikXJUVI48UUg56ilHyxN/lKOiciT3pRwVlSO5LOWoqBzJTSlHReXoKUfKUU858kQY5fixcswH79u/QzopR57YohwVlSOrMpSjonJkVYZyVFSOrMpQjnrK0RGDU44fK8fy+LFKLNGflCMxOOWoqBwJeijHz5VjfNysSyrfy9HzCAXl+KlyTNYc73S9/TuclCOLhJTj58oxuEc55pMfLntPOVKOzeVoQzrKMae/4+h7MdI5UoxqipEFQorxQ8Vocnz8zOv27xNX7VkgpBwVlSMLhJSjonJkgZBy1FOOgcyRclRUjqxXU46KypH1aspRUTmyIkM5KipHTzlSjnrKkTUZyvFj5ZjMQ/ibbTkpR1ZlKEdF5ciqDOWoqBxZlaEcFZUjqzKUo55yjKzKUI6KypFVGcpRUTmyKkM5KipHVmUoR0XlSO5IOX6sHPN2vF41Z3Pys62Is6YcP1aO5enqWNzJ1THhrJWUY/L+KEf/+9F3pTCdoyiFHxtFKazKKEp5lBpEKR47GkUpnLEWpdLDiiRzohQPq4yiFM9xjKIUQcwgSmUyilGUIqMYRSmPUkqUKo8uvcQTpej9lCiV/Z7U2xzciVL0fqMoRe/XR6m/aBb6s5406aF60mQtpidN1kt60vTQ7EiTdYef0yz2eEzJlpIq/VTcHltXPwHM4Ys86whS5PGGUuTxelLk8W4y5POGz5MiT9/9NvLHQxLx6dcDD/L0Nm8jHx8PSecT8vQ2PybvXLIHFB9shby5DebYPMrk9PiZQjxdodj2D7fJ2qdj7zrRCY2hE33TEDoZuiwJne7syd7l2JPUy7HHX8ix97AXY8+agRx7nPUb2R+/bTambOayHy0m7SMv5uk3xbtO+PAxdMKHD6GTxWOMoZNHJx062SMvKdbmbzrRw42hE/3eGDrR7/XR6U6TrqwnTdYwOtJ0rDT0pElf35MmqwE9aZLv/5xmMA+a4Sm3fND00OxIE//WkyYuqydNvFBPmnihnjTxQh1perxQT5p4oZ408UI9aeKFetL00OxIEy/0c5qxHGseLpnfaZ58ui37T6ycM4/XZX+tenh8kxR5PJYUefzY28jfjj/I//ZsyfdjvTlU8tZ8ew7F4/MGUCngHxtVsid9UMA//gHNXJ5oxhOa+Mef00zOPGgG8/fdYQNeU4q8h7wQeTzs28h37FfwuyOohDduVCmakz4Iv/snXWV+onnyTFHAl/6Ypt/SMW5v/N+5G1TEa0qRx5dKkcfDSpHHw0qR95AXIk/f/Tby1/st8j7y95G/3m+R94v/AXnnjhUM7/7mrU3fj7cp7Z9+++e3X1zyvnAx8vQ2UuQ95N9E3qTojnmm6L+zJ6GXY0/uLseerl6OPdm7GHveyvtG9umxy+Ht3+Ubew/797FP+cE+x2/s6XN+zt4/WPpg/W/s7zTpXHrSpBfpSZPuoidNVvY70uTtyF1p0sv2pEny3JMmaXJPmh6aP6YZ/fEbEB+z+43mnx5/p493kqSP15Kkjzd7F/0biH3g1m1PTyzk8sUeJyfHHt8nxb7wbmVB9njKj7A39oQ9DlSOPX5Vjr2H/bvYuyNasK6E39ifHH35Nt6y4YPH0AnHPIZOeGsJne7s8dZy7PHWYuwN3lqOPd5ajj3eWo493vpt7IPfp2nD8z4vB3sPezH2+GU59nhgOfb092LsLX3Ou9jf1svs8enPRx/s6XPk2PuV2Tt/sHcpVo4ucZ/jDcIjlLQ3rHeUS7ctfVEu3YX0Rbl0WP5HKJ92QXfJPRlyY75YLh1+d2a5dLPbl+XaL2HvzHLpsLkzy6VNVWeWS5ukziw9LLuxxPX0Y4nt6ccS39OPJb6nH0t8TzeWa79wvTNLfE8/lviefizxPf1Yelh2Y4nv6ccS39OPJb6nH0t8Tz+W+J5uLNd+UfgfsfSb2ffW9cb7E5b4nn4s8T39WOJ7fszSpHKwLNtvLE8++/LV02Xtl34LcsdPyXDHe72Je7dXeJe1X+E9iEZ4xR9rZN3R+9in13qda+Rz2T/bF2srR4e0f3QoT/jyl0iYUP0irf1q8lFEwjYPIBJ+fACRMPpvEunWNx8ixfI9Yln73eii5DH77yJfjmvNZk9ixYjdfxt5e5D3+YQ8Jv5t5I9hbyGekMeaS5HHbwuRT5joH5N3x26j3v0Nyz87+k4eZyxFHrsrRR4P+x7yxqdje4dgnvdvORt33PYVimifPjmHL5U8Kg2gEt54BJXw0SOohOceQSX8+QAqZXyNCpX8fnAM5kQlj0oaVIr7R8eYT1Six3uTSsEckwzO/6bSnTx9mxR5ejEp8vRXUuRZ/3jX3fgY9o18qNyNb4PN/jHw8u3h3cJqyRg64UHG0ImVmDF0Yt1mDJ380jrl/Wjnbfjt6DudpZ1FPp61/PVG6L+l47dt5d7Gm+Nob0o8obPyFfB2kTqeOUpmO6Gz8nWnTmflFK9OZ+WkzafH03x52ypH52OO2T2m+OsVHt+PLcfNsJTfj71TX/leKEd95YRNjvrK6ZoY9aXfhC1HfeXkS476yjmWHPWlPZkYdQ91AepLe0gx6nhTCep4UwnqeFMJ6nhTAeoWb/oW6pfvGL5hx5yKYMedimDHnopg92CXwI5BFcG+tFeqPbVhl/Y0VTpLe48aHbe0R7DHLL31+YTO0q18lc7SHXeVztKNcZWOh84FnaXbzCqdpdcrXNiH7f1Tr3x+dIzHLgb50bBba75ILt1XdyW5dA/eleTS/frFc8QntvnYd92Y8vTR4Qvl0m+E74xy6d/w1X5Vs/Zryat0PHQu6Cy9+0s59kz49e6LytEm7XdOuz2OPY9UO64jr/1C8iEUWvo3n0MotPSuMzoUqiwyrf1O9iEkWvtV72NItPSmNGNItLSXHUOipQ31GBL5pSU69n/1xtfCNZvcvluQTc+vod7SqUhhD+5uLP1vR9/Jr50YSJJfOwmQJL+2w38jeXNsIZ6tiSfk13bukuTXNuSC5Nd+6bwo+bXtsyT5tV2xJPm1za4keQ95IfJ4WCnyeFgp8nhYKfJ4WCnyeFgh8mu/812UPB5WijweVoo8HlaKvIe8EHk8rBR5PKwUeTysFHk8rBR5POybyMdjkjll+518xsNKkcfDSpHHw76J/I3aTr5kc0IeDytF3kNeiDweVoo8HlaKPB5WijweVoo8HlaIfMHDSpHHw0qRx8NKkcfDSpH3kH8L+bLZ7evosrlwQh4PK0UeDytFHg8rRR4PK0UeDytD/gYS8kLk8bBS5PGwUuTxsO8in8pO/q/P+0beQ16IPB5WijweVoo8HlaKPB5WijweVoi8wcNKkcfDSpHHw0qRx8P+lLx7vKPX2Rwr5E16jCRF/zzsO3gPeBnwOFgh8BhYIfD4VyHw2Fch8LhXGfAW8yoEHu/6JvCl7EfbbasMO27bvmQYN3OiEj5XgUqhHKb4XCU88btUOt4xazdnr4ftD9rePv383G+nV8diHpfHYh/DtiV/ieoRdT5R8fITikpOMKGoZBATikq+MaGoZCfzierIZSYUlcxnQlGJiCYUlURpQlE9os4nKonShKKSKE0oKonShKKSKE0oKonSfKJ6EqUJRSVRmlBUEqUJRSVRmlBUj6jziUqiNKGoJEoTikqiNKGoJEoTikqiNJ+ogURpQlFJlCYUlURpQlFJlCYU1SPqfKKSKE0oKonShKKSKE0oKonShKKSKM0naiRRmlBUEqUJRSVRmlBUEqUJRfWIOp+oJEoTikqiNKGoJEoTikqiNKGoJErziZpIlCYUlURpQlFJlCYUlURpQlE9os4nKonShKKSKE0oKonShKKSKE0oKonSfKJmEqUJRSVRmlBUEqUJRSVR0iCq21+b6FP+TdS7SB6R9ItE4vMekaw5JmnN00j211VmUhkh8CQnQuBJN4TAk0C8C7xzB/hSOrbAruR9it6Y42i337YL+cN0kpI+TCcp2cN0kpI8TCepR9LZJCXVmE5S8pLpJCWJ0SDpdUBcSG3Ui2S3peMAlw/s3obfjr7TWdpZV+ksbVKrdJb2e9496KRYOdqk/XZ/o3Yca7M7OTYfPLIrlWPLIVEpvx97V8ijkHKFlnZjQyi0tLnSoVDcj73BtScSLW2WxpBoaas0hkRLL4UPIZFZ2suOIdHShnoMiZZ29RcS3eng6q/oeOhc0FnbzeZ9li57U7v42XxcpZzzj6PNKZJbAHeQ9/G3o+/k13apkuTXNp+S5Nf2lG8kH44fmbmQtxPya1tFQfJ2bQcoSX5tYydJfm2/Jkl+bS8oSd5DXog8HlaKPB5WijweVoo8HlaKPB5WiLzDw0qRx8NKkcfDSpHHw0qR95AXIo+HlSKPh5Uij4eVIo+HlSKPhxUi7/GwbyJf3PEz+q3kE/J4WCnyeFgp8njY95D/1Tbu5G2wJ+Q95IXI42GlyONhpcjjYaXI42GlyONhhcgHPKwUeTysFHk87LvIp7KTd39D/s+OvuuE4x1DJ49OQ+iEm9agk/HHppkmmKdx57NZxm3fICHaJ2ly+NIUnz6fpiQA82lKtjCfpqQW02kayUPm0xQfOaCmfj84BnOiKX3vgJpGu2sa84mm9L0qNA3mQBKePzvHL53oZcfQif50CJ0SPecYOrFip6PnOCZ50ylUeo7b1B5DKbak4/hdVVYDZ1QVzzejqh5VJ1SVdckZVSWh+bGq7kE+Pm2D/0Kni6Pv5MlRpMiTjEiRJ+t4D3lrt/3Vqta7k6eKMumFFHnyCCnyZAZS5PH1UuQ95IXI44+lyONhpcjjYaXI42GlyONhhcgXPKwUeTysFHk8rBR5PKwUeQ95IfJ4WCnyeFgp8nhYKfJ42DeRD3Y/2oazPQYKHvZN5L0rB/m4VY7OB7/sHvhuqycnx5a8T7GU34/9pajb8MazKYrnnk1RvPxsipIRzKaoR9HJFCXTmE1RspLZFCWDmU1Rsp3ZFCUzmkxRQ2Y0m6JkRrMpSmY0m6JkRsMpGo/fUG+bPZHUI+lskpIaTScpsdF0kpIbTScpwdFsklpc6ZskDTEdkpb6zollc/uHh/K0D3D80mmdnuc+33Uagvt8J7tbFneUc/G+8tE2xX0gNiX3/NF3OJPdd/rCmSz77wrHTRaj94Uz2b2/L5zJwt2+cCbLSfvC8cB5DWeyPvYP4ZT99R02G/8dzmRNb184a3fIFTgrd8jObuUx7PQdzsodcg2OX7lDrsJZuUOuwlm5Q3aPH9Cew1m5z7n93ewffauS7TuclfucKpyV+5wqnKX7nBqcpfscV/IBx2zXHx3K8VqHUMr3q3dYuin6E5JxO+6DcTsxJmHpDqqxJs9JLt1uPRbIb62V+Tv/uldOL1tJntekX5pkigfJkr/DWdsCVOCsbQEqcNa2ABU4a1uAB5zw9DzXAWdpC1CBE5fu6mtwlm7Ua3CW7r2dPZ6SDCZVPjrm3Q+a5J8ee/TbF0q/MsqUjwQnFff32Zi4dH/5JyRrIUVcuhltrMlzkkt3ro+Pdn+zSH/y0Vs5Ptq47eRCuXSfm+0x7FwqH+0PIt7+fsc5GcYjkjO3OP042h3Yl+6gxbCnpXtzOexLd/1y2Jf2E3LYlw7+5bB7sEtgX9of/hF2t9tDn/L3TjwtbQ97guT3418gdf/YOLGd4BA6ZTYJHEMnNllQopPzD52eXr4TXxxtn46O31Rl+78ZVWULwBlV9ag6nKreHA7X26eF511TtgGcT1P2AZxPUzYCnE9Tkpz5NCX1mU7TQkI0n6akSfNpSpY0n6YkSfNp6tF0Ok3JkebTlBxJi6avcvmTz87u+BWWeRbn/LPLMctbATzN8lY59xogd6IGyKnmqoG7qiRV86nqN7Iq7aredcLX/lgnm4+W1jlfIe/t8ePKX9s91XTy6dEuPz1zZvLpT2D9fnB82vTnNvcvTT2ajqdp2vnFm47fNcXXzqcpvnY+TfGp82mK7xxRU3NoGk80xXVOp6nBc86nKc9HDKhp3DOHGPOJpjwfMZ+m5EjzaerRdDpNyZHm05QcaT5NyZHm05QcaTpN7dL+1PlDU5di5WjvNvtQ6fmZAfP3q3S9ImqXdpx6VLrO2e3SHnIYlTwqDaDS0j5vGJWWdm6KVLpcg7BLe7FhVFraXQ2j0tLr7npUuna1bumV9GFUInsYQSWyhxFUInsYQSWPSgOoRPYwgkpkDyOotLRf2tyh0lZqAzE++n0Z8Pbv/PxLSntyvA1533Xi9s8nKLd//8XeL+2ChNkv7W2E2S/tWITZL+1DhNl72IuxX9ozvJd9OrbisunX2+e+sV/aCQizX3ptUZj90iuGwuzxtWLsA/3929jHsg/89k93wp4+523sc94Pt2ULJ+zpc97F/haQPj7dnvT3gT5Hjj19jhx7+pz3sU/2+PT8+732z47+S6lI2j+KUqwN6FAq5nD87Co/7dj8tbdoxGeMoRNrDmPo5NFJh07lgBKLTd90wuOPoRN5wBg6kR2MoRM5wxg6kUkMoVMikRhDJ/IILTo9toEp4btO5BFj6EQeMYZOHp2G0Ik8YgydyCPG0Ik8QkKnv9hnPNG72FefXcv4HDn2eBc59viRt7H/7Vllf8Lew16MPb5Bjj1eQI49/f372NsHe1fzYc6W/Vejzhn/tz4ss944hk6sNw6hU8FbK9HJxXLolJ/zpz859q4pnn0+TckC5tOUjGE8Tb057qfemu+aejSdTlMykfk0JWuR0PTOnqzlfexjOtinfMKe/OR97POxppRKOWFPJvKRuj9hHzZyDjn25BFy7D3s38U+h32at3+escc3yLGnv5djT38vx57+/n3svb1kb+hz3sf+ep+/YFgfkWPPOoYcew97Mfb0mHLsydJ+zt657WB/o1Jhb1IKbj/+9u8HlvvaSbBkaXLs6THl2NNjvpF9yg/2T28R39nTY8qx97AXY0+GLMee/l6OPRmyHHsyZDn2+Fox9g5fK8ee/v7n7Ld0jNsbnyrs42Njm2CekrTwRd5D/l3kj6NjDifk6e2lyNPZS5Gnr5ciT1f/PvLmIB9PyNPTC5H3dPRS5Fmnehv5uD+GFmM+Ic8qlRR5PKwUeQ95IfJ4WCnyeFgp8nhYKfJ4WCnyeFgh8oF+/sfknTu2kjfutphaIW9Mzscqlinb89tXvx9dTNpHXsy33ZxCoPsfQyePTjp0smaHUqz9rhPOYgyd8CFj6IRrGUMnPI4WnZw5dHLlm044oiF0iqwBjqETK4Zj6EQeMYZO5BFj6OTRSYlOm3305fmbTuQRY+hEHjGGTuQRY+hEHjGGTuQRQ+iUyCPG0Ik8YgydyCPG0Ik8Ygyd8E8/1skWe+xqaEv5O3+JnXBEbyN//dvIhMeRIo9rESKf8SFS5HEW7yN/+avUjFeQIk/3L0XeQ/5d5K9/uZFZMZQij4eVIo+HlSKPh5Uij4cVIl/wsFLk8bBS5D3kf0w+buYgn54Hfkr+9pHmgBJD5WibyuM993+zA+5dKfp/JUpluy+P2ezyiVL4hVGUwl+MohR+RItSB3GbTTpRCv8yhlJxw++MohT+aBSlWBMcRSnWEEdRyqPUIEqRUYyiFBnFKEqRUYyiFBmFFqWOHzzc/plPlCKjGEQpQ0YxilJkFKMoRUahRalj5DelyolSZBSjKOVRahClyCi0KOXzoVRwJ0qRUYyiFBnFKEqRUYyiFBnFIEpZMopRlCKjGEUpMopRlMJPKVEqHts23T671I72zu1H++wqR0f/+BXJY+XLxbNZlrwXjNmehnF+8K18doDR5tpH/9qZ6vjxS85m++34ezliGinHz5Wjfwj/fHV8lCPOmHJUVI7Yf8pRUTmScVCOMuUY7fdydAQ5lOMHy9E/yjGF2qeXg3csz08f5pODsz0+O9unSr8dfC90cjAKfYlCJ0ak0JcodJ4Uo9CXKHRPoVPoKxQ662oU+hKFzoodhb5EobMWSKEvUeisMlLoHyv0Yg+At3/H347/qxw9aTfl+Lnrbnk8oVa2kyfUvKccKcePXR3NQ/jizEk50pVSjoqujvSOlKNM7+jOypEn1ChHPeUYeEKNclRUjjhrylFROfK0F+X4uXJ0j4C9eH9SjjyTRTkqKkdPOVKOesqR55soR0XlyFNIlKOicmRVhnJUVI6sylCOnyvH2pp1YFWGctRTjpFVGcpRUTmyKkM5KipHVmUoR0XlyKoM5aioHD3lSDnqKUdWZShHReXIqgzlqKgcyR0px/ZyNMfRt8rcauWYrDs+PN2m8L0cE7kj5aioHMkdKcfPlWN0j3JM5aQcyR0pR0XlSO5IOSoqR085Uo56ypHckXL8WDm67VAn3QrlpBzJHSlHReXI0+CUo6Jy5GlwyvFz5eifyjGEk3JkVYZy1FOOmVUZylFRObIqQzkqKkdWZShHReXIqgzlqKgcPeVIOeopR1ZlKMfPlaN7LseTF3lkVmUoR0XlyKoM5aioHFmVoRw/V47HHH/9u5yUI6sylKOeciysylCOisqRVRnKUVE5sipDOSoqR1ZlKEdF5egpR8pRTzmyKkM5fq4c01M5lpO3bhVWZShHReXIqgzlqKgcWZWhHD9Wjt4cL/JI3p7s0VNYlaEc1ZRj2liVoRwVlSOrMpSjonJkVYZyVFSOrMpQjorK0VOOlKOecmRVhnL8XDluz+XoT8qRVRnKUVE5sipDOSoqR1ZlKMePlaPNj91vvQu1470zx/H+bAO+tLGKQ/nqLV8XHuUbTPX4HI7B+5zy93I3rBJR7nrLPfhHuceTZMCwqkT5jnG1Pi1fVqEo34HLl1Urynfg8vWUL+U7bvmyKkb56i3fFB/lW2yHpIJVN8pdb7mXx9X6tkRyUr6s0lG+Q1ytz8uXVT3Kd+DyZVWP8h23fC2rdJTvwOXLKh3lq7Z8vUmP8nXu708qLKt6lLvecndPV2sfTsqXVT3Kd4yr9Wn5esqX8h23fFnVo3wHLl9W6SjfgcuXVTrKV0X53suRVTfKUVE5sopGOeopR8eqGOX4uXIMj3K0eTspR1a5KEdF5cgqFOWoqBxZVaIcFZWjpxwpRz3lyKoP5aioHFnFoRwVlSOrMpSjonJkVYZy1FOOntyRcvxUOcYSj6qKJZWTciR3pBw/dnXcHsLf/h1PypHckXJUVI6ecqQc9ZQjuSPl+LnesWxP5WhPypHckXJUVI7kjpSjonIkd6QcFZUjT4NTjnrKMfA0OOWoqBxZlaEcFZUjqzKUo6JyZFWGclRUjuSOlGNzOYZbcezamOwrR99C7v2zb/88eYAikDpSjGqKkcyRYlRTjCSOFOOnijGaXfcUbfpejJG8kWJUU4ykjRSjmmIka6QY1RQjSSPFqKYYyRkpxk8VY8h7ldyM80noHXHTFOOnijGVfdApO/O9GBNummJUU4y4aYpRTTHipilGNcWIm6YY1RSjpxgpxg8VYw7mKMboToqRX1JTjGqKkZyRYlRTjDzPSDGqKUaeZ6QY1RQjKzAUo5ZizKzAUIxqipEVGIpRTTGyAkMxqilGckaK8VPF+Pw849kKTCZnpBjVFCM5I8WophjJGSlGNcVIzkgxfqwY4/HUTkz5ezEWTzFSjB8qxnTwS8n4k2LETVOMaooRN00xqilG3DTF+LGesaRHMYaTYsRNU4xqihE3TTEqKca8sTZNMX6sZzxeRX37pz8pRn4dSDF+rBiffh1oXOVo43M4huLzSS6ZN0/xUrwfKt5s4lG8Jys2t7KgGClGgSvpaTGSS1KMaoqRXJJiVFOM5JIUo5piJJekGLUUo+HXhBSjmmIklxyyGK3fEVqbtt+Ovuvq0XVEXZ3dP9s67050Jf2aU1eCpDl1JZMZ8/6aH7r+zUjuuhJvzKkrScGUulpM95y6shvOnLry8N6cupI3zamrR9cpdSVvmlNX/OvPdd3CQ9fbjKvst3xk8/Ypm8/5iz0eU4y9wwfKscervY+9PxanbXC/sT8Ziy27Us49/cI5fumE9xpDJ7yUEp1cLIdOOT3p9CfH3jX1aDqdpnio+TRlvX48Tb057qfemu+aslY/n6bkHPNpSn7yNk3d47lSl7aKpiHtBRDKE8Avu++JWoaQiVRmCJkIZYaQiUxmCJk8Mr1LJv9YevTPn34qUyzHmmksT62eOTs4W7/zzjba76oStMyoKlHLjKoStsyoKnHLjKoSuEyoaiCfmVFV4pwZVfWo+i5Vgz2WMYINv6l6Z0+n+j72/nioOYSTRwYj96j3sT8OtyHmE/bcSeTYk/bLsSfCl7jet9wdPEoNohTJvA6l4s1K7K4kp8eGcF+P1kSy9jF0wpOMoRN5uBKdygElFvvtkcJIwj2ETok8YAydyA7G0ImcYQydyCTG0Mmj0xA6kUdo0elY+IwlfNeJPGIMncgjxtCJPGIMncgjhtApk0eMoRN5hIROd/Ye9j9lb5I9PtyUrfaWKePTDsUE8/wT/LORx8efSDBPx4YvnfBESnRKh3XN4UQnPNEYOuGJxtAJTzSGTngiLTodP2zI8btOBU80hk54ojF0Yo1WiU7x8U7ffKITa7Rj6OTRaQidyCPG0Ik8YgydyCPG0Ik8YgydyCNG0KlsK/snWx7bLm9mq+nUcT3ppjLc38P9Mictm4e7CPeV/Yok95X9hyT3lf3Ee7lf5cFlW9kfSHJfud8X5G5WXk98K/dr32RWXh+U5I5fleGOX5Xh7uEuwh2/KsMdvyrDHb8qwt2ec0/Hy+KflgNsdidfkA/k2ZXKsSXvVEr5/dj7YLKmwRRFg3GbpsEYTYOxmgbjNA3GaxpM0DSYqGkwmq7ATtMV2H32ChyPu+q22e+j8Zuq0RhVo7GqRuNUjcarGs351caXcrSUwV73tnnb/2qzf2qx/fb1Dfnt31De/Q0v3r7T8xvM27/Bvv0b3N//DWF3YDnF377hxCVtZbcy1myPo/3ZQ0o57+8NKcbWPvjmLPcP9ttjMdUdE/WrTDSsMtG4ykTr1/v020TvZ+Wms0rLWdG9+zoV/du/Ibz9G+Lbv+HtnUF8e2cQyyJ/1mlbZaJmlYnaVSbqWu4SyTedFZrOOr+KbHGnYMxz7B5OQ/oj/7dPNsxZc3JsKn4XLpXybNr82RpH2IXz5qGb3c6OtaYcr1OyW/nt6L+m+mKLtCmnataZql1nqm6dqfp1phrWmWpcZ6ppnanmdaa6TrdU1umWyjrdUlmnWyrrdEtlnW6prNMtlXW6pbJOt1TW6ZbKKt1S2LZVuqXbVOfplmzes1Hrnh8gOaY6T7dUneo83VJ1qn6dqc7TLVWnOk+3VJ3qPN1SdarzdEvVqc7TLdWmaubplqpTXadbMut0S2adbsms0y2Zdbols063ZNbplsw63ZJZp1uy63RLdp5uKZljGMltJ1Odp1uqTnWebqk6Vb/OVOfplqpTnadbqk51nm6pOtV5uqXqVOfplmpTdfN0S9WpnndLJu8/tzbWh9+mej/Ntp3m/vS071MKoeyvaA4lPB29nf2+Ox4/XUhPsB4Dim3zSE2nvdgSoXpam0Y+tJ3WhiS0zS20ze3FL4yrp7UhefHzztppsW1usW1usa0mY+PcStNpqa1KklF23UhW24C0XVmzNsmyNsmyNsmKNsmKNsmKMsnMpkwysymTzGzaJDPaJDPaJDPaJLPaJLPaJLPaJHPaJHPaJNPmxY3XJpnXJpnXJlnQJlnQJlnQJlnUJlnUJlnUJtky+6sEs8z+KreprvKL4dtUV/nF8G2qq/xi+DZVv85UV/nF8G2qq/xi+DbVVX4xfJvqKr8Yvk11nW5pmf1VblNdp1taZn+V21TX6ZaW2V/lNtV1uqVl9le5TXWdbmmZ/VVuU12mW7Lr7K9i19lfxa6zv4pdZ3+V2/9fZ6rL/GLYrrO/il1nfxW7zv4qdp39Vew6+6vYdfZXsevsr2LX2V/FrrO/il1nfxW7zv4qdp39Vew6+6vYdfZXsevsr2LX2V/FrrO/il1nfxW7zv4qdp39Vew6+6vYdfZXsevsr2LX2V/FrrO/im3bX8W27a9iO/+mK2brH0ef/nQhxX0lMqX8ODbmrwHFtnk07S5hfRu1to1SrG/aOcO27Xhi23Y8sSG1ndY4tzbd4tZ2mlFW7Z1/ytRhQNquB3++/8u7B6SthpK2GkpF2YCythrK2mooZ20D0lZDRVsNlaRtQNpqqCirIbdFbQNSVkNuU1ZDzgRtA9JWQ0ZbDVmvbUDaashqqyFtKYRz2mrIaashf35zjSbtA4r2kYU5d3fg7sWmr9XTTPU0509Os22nuabTzr2zuzVGX6c5Zx6nxa+TfMtJoeWk079652I5Tsrp6aR//INj71+Q3v0F+d1fUP7eL/Dm0MBb8+0LztOMnl9g3v0FpxrYlNKRaj9dLvaTSsNJ5669dtL5hcInv//phueFgnxG4HbE18E3D/F0bPj6Cvv+r3Dv/wr//q8IXb/CbydfEd//Fen9X5Hf/xXl7/+KuO0Xhud79PEVLxKSrl9h3v8V9v1f4d7/Ff79XxHe/xXx/V+R3v8V+f1f8fa/br9t7/8K8/6vsO//Cvf+r/Dv/4rw/q/o8Xfh94NjMN+/wvSoqLg/3BFjPvmK84oKJhxf8eQVf33F/TTXdppvOy20nfbi+uvN47RQwWeKzQftclu1+JuO3b/IDzt/Sf7El5QPfMmL58Y7f4l7+5+m7XENS+HIs8LJV4T3f0V8/1ek939Ffv9XlLd/hdve/xU97ifJHF9xcld09v1f4d7/Ff7tN14X3v8V8f1fkd7/Ffn9X1He/hV+e/9XvL9b9Pb9X3FatCHsqWnIz52e/ToptZyUW0568dB6Omb169/lbzuSF+tGWypHC7vlp4ev99NM22m27TTXdtr5xXLLzj1OC9u300LbabHttNR02osHdbcSjn51K9F8O+0FyZL3FUxjtu0byRcvQqyeFtpOS21zy22nvfjDKcU9DTL87WlpazvNtJ1m205zbaf5ttNC22kvnprYtvI4zT5XyT/+eU2l9IkvyZ/4kvL3f8n1WqR/9Vxvz68w7/8K+6dfcT/NtZ3m205ru0S+2hu+dlpqOy23nVaaTnu1l3btNNN2mm07re1GWtpupC+WOlI4LqwpPS1ObvH0B3Lb3gnaZO23ryjv/orwYqmj61eY93+Fff9XuPd/hX//V4T3f0V8/1ek939Ffv9XvP+v27z/r9u8/6/bvP+v27z/r9u8/6/bvP+v27z/r9u8/6/b/PFf9/200nSa3dpOM22n2bbTXNtpvu200HZabDsttZ3WViW2rUpcW5W4tipxbVXi2qrEtVWJa6sS11Ylrq1KXFuVuLYq8W1V4tuqxLdViW+rEt9WJb6tSnxblfi2KvFtVeLbqiS0VUloq5LQViWhrUpCW5WEtioJbVUS2qoktFVJaKuS2FYlsa1KYluVxLYqiW1VEtuqJLZVSWyrkthWJbGtSlJblaS2KkltVZLaqiS1VUlqq5LUViWprUpSW5WktirJbVWS26okt1VJbquS3FYlua1KcluV5LYqyW1VktuqpLRVSWmrktJWJaWtSkpblZS2KiltVVLaqqS0VUlpqpK4bW2nmbbTbNtpru0033ZaaDsttp2W2k7Lbae1VYlpqxLTViWmrUpMW5WYtioxbVVi2qrEtFVJW/Ya27LX2Ja9xrbsNbZlr7Ete41t2Wtsy15jW/Ya27LX2Ja9xrbsNbZlr7Ete41t2Wtsy15jW/Ya27LX2Ja9xrbsNbZlr7Ete41t2Wtsy15jW/Ya27LX2Ja9xrbsNbZlr7Ete41t2Wtsy15jW/Ya27LX2Ja9xrbsNbZlr7Ete41t2Wtsy15jW/Ya27LX2Ja9xrbsNbZlr7Ete41t2Wtsy15jW/Ya27LX2Ja9xrbsNbZlr7Ete41t2Wtsy15jW/Ya27LX2Ja9xrbsNbZlr7Ete41t2Wtsy15jW/Ya27LX2Ja9xrbsNbZlr7Ete41t2Wtsy15jW/Ya27LX2Ja9xrbsNbZlr7Ete41t2Wtsy15jW/Ya27LX1Ja9prbsNbVlr6kte01t2Wt6kb2W4wlDU7w5Oe1FlRxb+pnnl+38Ou37Y4x5238rm93jZ6I2n+1hWvL+rp1Sfj/2PpykazhZ13CKquG8yralhmN0DcfqGo7TNRyvazhB13B0XZWNrquy0XVVNrquylbXVdnquipbXVdlq+uqbD99VY7HLivb83uqj/EEZeOJysaTlI0nKxtP0TWe8xVca/K+z4i1JlTGY2556+OtB+nb7gXpfL2395fYT3yJ6/IlLj6+JLqnLzn5RV52+8ZAbnve92k73051O/Zc29zjt/fFfo3fKx9/OPjf1trc9/GHwccfBx9/Gnz8efDxl7HH77fBx28GH78dfPza77+18Q9+//WD33/94PdfP/j91w9+//WD33/D4PffMPj9Nwx+/w2D33/D4PffMPj9Nwx+/w2D33/D4PffMPj9Nw5+/42D33/j4PffOPj9Nw5+/42D33/j4PffOPj9Nw5+/42D33/T4PffNPj9Nw1+/02D33/T4PffNPj9Nw1+/02D33/T4PffNPj9Nw9+/82D33/z4PffPPj9Nw9+/82D33/z4PffPPj9Nw9+/82D33/L4PffMvj9twx+/y2D33/L4PffMvj9twx+/y2D33/L4PffMvb9N29j33/zNvb9N29j33/zNvb9N29j33/zNvb9N29j33/zNvb9N29j33/zNvj91wx+/zWD33/N4PdfM/j91wx+/zWD33/N4PdfM/j91wx+/zWD33/t4PdfO/j91w5+/7WD33/t4PdfO/j91w5+/7WD33/t4PdfO/j91w1+/3WD33/d4Pdf9ftf1cY/+P138P2v8uD7X+XB97/Kg+9/lQff/yoPvv9VHnz/qzz4/ld58P2v8uD7X+XB97/Kg+9/lQff/yoPvv9VHnz/qzz4/ld58P2v8uD7X+XB97/Kg+9/lQff/yoPvv9VHnz/qzz4/ld58P2v8uD7X+XB97/Kg+9/lQff/yoPvv9VHnz/qzz4/ld58P2v8uD7X+XB97/Kg+9/lQff/yoPvv9VHnz/qzz4/ld58P2v8uD7X+XB97/Kg+9/lQff/yoPvv9VHnz/qzz4/ld58P2v8uD7X+XB97/Kg+9/lQff/yoPvv9VHnz/qzz4/ld58P2v8uD7X+XB97/Kg+9/lQff/yoPvv9VHnz/qzz4/ld58P2vyuD7X5XB978qg+9/VQbf/6psY99/y+D7X5XB978qg+9/VQbf/6oMvv9VGXz/qzL4/ldl8P2vyuD7X5XB978qg+9/VQbf/6oMvv9VGXz/qzL4/ldl8P2vyuD7X5XB978qg+9/VQbf/6oMvv9VGXz/qzL4/ldl8P2vyuD7X5XB978qg+9/VQbf/6oMvv9VGXz/qzL4/ldF/f5Xj4+OqZjn8Z8dvI865vj44By+5qr9Xt1zrtrv6z3nqr0H6DhX9ft19Zyr9t6i51yV9yGhhPyYq72eqym3vnwfSLndI4/Dbclf81Xet3Sfr19svsr7ou7zVd5HdZ+v8l6q+3yV91Pd56u8p0rB26+jU9zi9Xyd2491/mnQZ4eGGPYhh7Q9HfzLO30f8w3kMeYt/3b0Xxi1b+82CkblneAoGJU3maNgVN67joLRg7EHRuWd9igYlTfwo2BU7gtGwajcboyCERfTA6P2TTJHwYiL6YIRF9MFIy6mC0YPxh4YcTFdMOJiumDExXTBiIvpghEX0wOj9q2GR8GIi+mCERfTBSMupgtGD8YeGHExXTDiYrpgxMV0wYiL6YIRF9MDo/YN20fBiIvpghEX0wUjLqYLRg/GHhhxMV0w4mK6YMTFdMGIi+mCERfTA6P2116MghEX0wUjLqYLRlxMF4wejD0w4mK6YMTFdMGIi+mCERfTBSMu5u/HGDftLw8aBSMupgtGXEwXjLiYLhg9GHtgxMV0wYiL6YIRF9MFIy6mC0ZcTA+M2l/BNgpGXEwXjLiYLhhxMV0wejD2wIiL6YIRF9MFIy6mC0ZcTBeMuJgeGLW/yHIUjLiYLhhxMV0w4mK6YPRg7IERF9MFIy6mC0ZcTBeMuJguGHExPTBqfx3wKBhxMV0w4mK6YMTFdMHowdgDIy6mC0ZcTBeMuJguGHExXTDiYnpg1P6S8lEw4mK6YMTFdMGIi+mC0YOxB0ZcTBeMuJguGHExXTDiYrpgxMX0wBhwMV0w4mK6YMTFdMGIi+mC0YOxB0ZcTBeMuJguGHExXTDiYrpgxMX0wBhxMV0w4mK6YMTFdMGIi+mC0YOxB0ZcTBeMuJguGHExXTDiYrpgxMX0wJhwMV0w4mK6YMTFdMGIi+mC0YOxB0ZcTBeMuJguGHExXTDiYrpgxMX0wJhxMV0w4mK6YMTFdMGIi+mC0YOxB0ZcTBeMuJguGHExXTDiYrpgxMX0wFhwMV0w4mK6YMTFdMGIi+mC0YOxB0ZcTBeMuJguGHExXTDiYrpgxMV0wGg2XEwXjLiYLhhxMV0w4mK6YPRg7IERF9MFo3IXE0rIO8ZsSgVjyvvBLj8N22/b2bC93QdifHoolPPZR5u87R9tyuNgG89G7TZ7YDf+gd2Zs4FkE/3X0dk+iWSzPznap819He3TrxLZPzvEL0mVOyok/XNJlbs7JP1zSZU7TST9Y0mNcteLpH8uqXIHjqR/LqnyNABJ/1xS5ckEkv65pB5JZ5NUeWKDpH8uKenRdJKSHk0nKenRdJKSHs0mqSU9mk5S0qOfSepN2T/aZ1uRNGzmWAHdfHrMcadOwCNBnQxGgrqHugB1kgwJ6oQNEtTJAySoY9klqOOqBag7jK8EdbypBHW8qQR1Vd70PiSvb0iqXM19SKpa/vuQVPXD9yGpahbvQ1LVSf01JK+qzbgPSdU9+D4kVTeo+5D0Xb29vqu313f19vqu3l7f1dvru3rresf9X0PS9b74+5D0Xb11vcf8PiR9V29d79e+D0nf1VvXe5/vQ9J39db1PuL7kPRdvXW9J/c+JH1Xb13vb70PSd/VW9d7Re9D0nf11vW+y/uQ9F29db2H8T4kfVdvXe8HvA9J39Vb13vr7kPSd/XW9T61+5D0Xb11vefrPiR9V29d75+6D0nf1VvXe5HuQ9J39db1vp77kPRdvXW9R+Y+JH1Xb13vN7kPSd/VW9d7N+5D0nf11vU+iPuQ9F29db2n4D4kfVdvXfvn34ek7+qta1/3+5D0Xb117Td+H5K6q7fVtQ/2fUjqrt5W1/7M9yGpu3rbTd3V2+rag/c+JHVXb6trP9b7kNRdva2u/TD/GpKu/RzvQ9J39da1n959SPqu3rr2M7sPSd/VW9d+Uvch6bt669rP5z4kfVdvXfup3Iek7+qta7OM+5D0Xb11bbNwH5K+q7euH+jfh6Tv6q3rp933Iem7euv6UfB9SPqu3rp+Tnofkr6rt77fWlp9v7W0+n5rafX91tLq+62l1fdbS6vvt5ZW328trb7fWlp9v7W0+n5rafX91tLq+62l1fdbS6vvt5ZW328trb7fWlp9v7W0+n5rafX91tJ2+k3Tlh5DMulpSPcv+ePr8f202HZaajstt51Wmk77899s3E8zbafZttNc22m+7bS2KkltVZLaqiS1VUlqq5LcViW5rUpyW5XktirJbVWS26okt1VJbquS3FYlua1KSluVlLYqKW1VUtqqpLRVSWmrktJWJaWtSkpblZSmKnHb1naaaTvNtp3m2k7zbaeFttNi22mp7bTcdlpblZi2KjFtVWLaqsS0VYlpqxLTViWmrUpMW5WYtioxbVVi26rEtlWJbasS21Yltq1KbFuV2LYqsW1VYtuqxLZViWurEtdWJa6tSlxblbi2KnFtVeLaquR8fcbH47TfXovzOC2fn2Yep9ntP64zgbwdL+pxj21qb17h5NiS90CjlN+PvQ+nqBrO+dqJ3HCMruFYXcNxuobjdQ0n6BpO1DWcpGs4uq7KXtdVOei6KgddV+Xw6avy8Zo+s232ZDxO2Xi8svEEZeOJysaTlI3nj6/N99NK02lxazvtjy3Lny/1uU5b7VW+JH7iS9InviR/4kvKB76k0yZ03jy+JJSnL/mzlfD7kIy+IVl9Q3KfHpI3ZX8vjbcnleS1DShoG9DHHyar3QA/v/tcdURZ3YiKthF9fuu56oiMuhFZdSNy6kbk1Y0oqBuRumt2VnfNFthyLmzb/tnBl9pnl3B8dMnmaQL+awJF+QRycfvRm/t9AicO2ZrDIttQOzoVvz9qmkqxlaNvkdTe4Jj4OHY7O9aa8uC3ld+O/gu7wCZ8YL9hN2CXwG7BLoHdgV0Cuwe7BPYAdgnsEewS2BPYJbBr93uTYselCmD3Gy5VBDsuVQQ7LlUEOy5VBLsHuwR2XKoIdlyqCHZcqgh2XKoIdlyqBHaDSxXBjkt9B3abyz5q9/zEyYEdlyqCHZcqgt2DXQI7LlUEOy5VBDsuVQQ7LlUEOy5VArvFpYpgx6WKYMelimDHpYpg92CXwI5LFcGOSxXBjksVwY5LFcGOS5XA7nCpIthxqSLYcaki2HGpItg92CWw41JFsONSRbDjUkWw41JFsONSJbB7XKoIdlzqO7AnswOxyW0n2HGpIthxqSLYPdglsONSRbDjUkWw41JFsONSRbDjUiWwB1yqCPbPX9uz2yfrNuMqnx1K2N+UkbfyOPpG6T7+PPj4y9jjj5vu8cdwvNYoBncyfjP4+O3g43eDj98PPv4w+Pjj4ONXfv+tjl/5/bc6fuX339r40+D33zT4/TcNfv9Ng99/O71MUG78g99/0+D33zT4/TcNfv9Ng99/8+D33zz4/TcPfv/Ng99/P/9qyM7jH/z+m5Xff5/yw5ieou1f//w+kFv4vT9Udfu3ewzclvw133Hy6j7zHSff7jPfcfLw+nxv3c0+jtuFPn+fbVHePXSerfJeo/NslXcmnWervI/pPFu/1GyV90idZztQR5XT946wDNQhnY5/oI7ndPwDdTAn4w/bQD3J6fgH6jJOxz9Q33A6/oE6gdPxD3RvPx3/QHfr0/Erv/+m4Pfn71L8dcQ/XHQbzu3HOv806LNDQwz7kEPang7+lfp8H/PNSh9j3vJvR/+F0Si/jOjA6LayBxLuNx6nR6djxOk40u+8lV/2puOt/DI9HW/lt5XpeHMb/Cxv5bZ5Ot7Kbf50vJXHErPxtspjlOl4K499puONv/wsb/zlZ3l7eH+UN/7ys7zxl5/ljb/8LG/85Wd54y8/ytvhLz/LG3/5Wd7a+0Gb4zH6rVzzNjdy+zhSfNpqxp2ukG/7TjPBb78deyejvXOTI6O9x5Ijo70bkiOjvW8RI+O1dxhyZLT3AnJktKfCcmS057dyZDxkXpBZuAeO+/6JoeTKsd6GHaP/a8vEJ9PxF8ew7p0sHwc/P2t7fqx1dj/Yej/MFpemPGR8grdvcRnCundr1A9h3Y4E9UNYt+tC/RA86i+s/rrdM+qHsG5KjvpB+7b2qP9W9ddd7UD9oP2VCqj/TvW1v5AC9d+qPlnfyuqT9a2sPlnfyup71F9YfbK+ldUn61tZfbK+ldUn61tZfbK+hdXX/vI71H+r+mR9K6tP1jex+jbvPyO1brMn6pP1ray+R/2F1SfrW1l9sr6V1SfrW1l9sr6V1SfrW1h97S/aRv23qk/Wt7L6ZH0rq0/Wt7L6HvUXVp+sb2X1yfpWVp+sb2X1yfpWVp+sb2H1C1nfyuqT9a2sPlnfyuqT9a2svkf9hdUn61tZfbK+ldUn61tZfbK+ldUn61tX/biR9a2sPlnfyuqT9U2sfjI7PJvcdqI+Wd/K6nvUX1h9sr6V1SfrW1l9sr6V1SfrW1l9sr6F1TdkfSurT9a3svrrZn3F7nMsIVSODVs6XnxutudacV8c103N+nL0cOzCcd0kpy/HhTOR7PaDty3Wbo8mHrdH69Iot8fKdrbRLByKIH80C6ciyB/NwrEI8ke7cC6C/NEuHIwgf7QLPwWF/NEu/BgU8kfrkX9l+Rd+EAr5oyX1W1p+Ur+l5Sf1W1p+Ur+V5XekfkvLT+q3tPykfkvLT+q3tPwe+VeWn9RvaflJ/ZaWn9RvaflJ/WaWv7bpjSP1W1l+T+q3tPykfkvLT+q3tPykfkvL75F/ZflJ/ZaWn9RvaflJ/ZaWn9RvaflJ/VaWP5D6LS0/qd/S8pP6LS0/qd/S8nvkX1l+Ur+l5Sf1W1p+Ur9/WFl+Ur+l5Sf1W1n+SOq3tPykfkvLT+q3tPykfkvL75F/ZflJ/ZaWn9RvaflJ/ZaWn9RvZvlrr7qLpH4ry59I/ZaWn9RvaflJ/ZaWn9Rvafk98q8sP6nf0vKT+i0tP6nfyvLnqXx/tP6QP1UVLdt+tC3BVY7227ZXi9/8c2l9vQs9T3Ub/SOSbtvMMZBc5e7s8ZfkvRnlL6m2Q2ae6j6K/n+s/1Q3UvT/Y/2nWj9D/z/Wf6oFNPT/U/3Lup00+v/Sf6olNPT/Y/2nWkND/z/Wf6pFNPT/Y/09+i+tP/nf2vqT/62tP/nf2vqT/62tP/nfyvqnjfxvbf3J/9bWn/xvbf3J/9bW36P/0vqT/62tP/nf2vqT/02tf2X/jLSR/62tP/nf0vob8r+19Sf/W1t/8r+19Sf/W1t/j/5L60/+t7b+5H9r60/+t7b+5H9r60/+t7T+lvxvbf3J/9bWn/xvbf3J/9bW36P/0vqT/62tP/nf2vqT/62tP/nf2vqT/y2tvyP/W1t/8r+19Sf/W1t/8r+19ffov7T+5H9r60/+t7b+5H9T6195k1Zy5H9r60/+t7T+nvxvbf3J/9bWn/xvbf3J/9bW36P/0vqT/62tP/nf2vovnP+ZLe8DMSFVjvap7APx2W9PR7svkgsnaZ1JLpxJ9SUZFk53OpNcOCcx6SBpbY2kNfG4T1qXRrlP1vbJDQvnJOh/03/hnAT9b/p79F9a/4VzEvS/6b9wToL+N/1XzknQP4WV0x30T2HlTAr9U1w5SUP/FMn/1taf/G9t/cn/1tbfo//S+pP/ra0/+d/a+pP/ra0/+d/a+pP/La1/Iv9bW3/yv7X1J/9bW3/yv6n1r+2Tkzz6L60/+d/a+pP/ra0/+d/a+pP/ra0/+d/S+mfyv7X1J/9bW3/yv7X1J/9bW3+P/kvrT/63tv7kf2vrT/63tv7kf2vrT/63tP6F/G9t/cn/1taf/G9t/cn/1tbfo//S+pP/ra0/+d/a+pP/ra0/+d/a+pP/rax/3sj/1taf/G9t/cn/1taf/G9q/SvvycubR/+l9Sf/W1t/8r+19Sf/W1t/8r+19Sf/W1p/Q/63tv7kf2vrT/63tv7K/X8oYRcpZVPR36V8KJqfhu237WzYzqV91LfDj6NzPjnYu11Pn594hO0Lo3IbPQpG5W50FIzKTd0oGJV7o0EwWuUWYxSMyjt1LRhD2GcY4hlG5Q3vKBiVrxurwZi2HWMqJxg9GHtgxMX8DGPZbzFxcycYcTFdMOJi/hSjMScYcTFdMOJifoQxph3IbVXsO0aHi+mCERfzM4x5H3Qs/gQjLqYLRlzMjzDeVl72YZh8gtGDsQdGXMyfYrTxBCMupgtGXEwXjLiYn2Es+6DzdnanxsX0wOhxMT/CmI8/6nx2p/a4mC4YcTE/w+jcjtHbE4y4mC4YPRj/EGM4SXg8LqYLRlzMjzAWsx9bztpvj4vpghEX8zOMbgdS/MlajMfF9MAYcDE/w3g8w1PiyR91wMV0wYiL+VOM6SSaCLiYLhg9GH+C0Wxhf6TsNtCTBjzgYzqBXNjJeLsPxPinH6SdgnQm7yCdKY+DbTwbtdviY45Pz0Q6s50Oe9sfEnLpqaX6dfRdpIV90jgiLezCxhFpYY83jEhxYQc5jkgL+9NxRFrY/Y4j0sLeehyRPCLpF2nhVGAckUgcBhCJxGEAkUgcBhCJxEG/SInEYQCRSBwGEInEYQCRSBwGEMkjkn6RSBwGEInEYQCRSBwGEInEYQCRSBz0i5RJHAYQicRhAJFIHAYQicRhAJE8IukXicThLSJZexztc0WkbOLjBTLb4+jzV8L4tO0/JvfJPPY2cCF+SUo+MZ2kpBnTSUr2MZ2kJCWzSVrIVaaTFO84nKTHRoe3f8YTSel4R5M0b/uvzv3t8BNJ6XjlJdXyYlNTHqo/vRf2eLFpoZemWH5cLHTpFMsPi6Vs9P8Uy4+LhfVdiuXHxcI6M8Xy42Ihs6BYflwsnmKhWH5aLKz/Uyw/LhZyVorlx8VCgkux/LhYSHAplh8XCwkuxfLTYjEkuBTLj4uFBJdi+XGxkOBSLD8uFhJciuXHxeIpForlp8VCgkux/LhYSHAplh8XCwkuxfLjYiHBpVh+XCwkuBTLrox1D9W9/V4slgSXYvlxsZDgUiw/LhZPsVAsPy0W3BDFsiuTzC6jTW47KRbcEMXy42LBDVEsPy0WhxuiWH5cLLghiuXHxcLzLBTLj4uF51kolh8Xi6dYKJafFgvPs1AsPy4WnmehWH5cLCS4PysWa/fN+ZzLuVIswzx04Mhkl5aflHVl+T256dLyk4QuLT/Z5tLyk1YuLb9H/pXlJ1FcWn4ywqXlJ/VbWn5Sv6XlJ/VbWf5A6re0/KR+S8tP6re0/KR+S8vvkX9l+Un9lpaf1G9p+Un9lpaf1G9p+Un9Zpbf5rLr6LaTrToiqd/S8pP6LS0/qd/S8pP6LS2/R/6V5Sf1W1p+Ur+l5Sf1W1p+Ur+l5Sf1W1n+ROq3tPykfkvLT+q3tPykfkvL75F/ZflJ/ZaWn9RvaflJ/ZaWn9RvaflJ/VaWP5P6LS0/qd/S8pP6LS0/qd/S8nvkX1l+Ur+l5Sf1W1p+Ur+l5Sf1W1p+Ur+Z5a+9yqmQ+i0tP6nf0vKT+i0tP6nf0vJ75F9ZflK/peUn9VtaflK/peUn9VtaflK/n8nv3SG/z6YivzPbcbTxT/xO8SW/wzYpPh2cTg6Ofq+rGNzzoTc107YR4s2kJpncWGoewsSnG8ShJhHbYGpuO47t5G+TxOyHapryUNNW1Azb0a6EzadnNe/UPdQFqJMPSVAnlpGgThoiQZ0QQoI63l+AusGjS1DHS0tQx/NKUMebSlD3UBegjjd9A3V/WxY8qIfyH5epmg9lT7F99Nt3iTCy6iXC9aqXCIusXiL8tHaJLOZbvUQ4dfUSYevVS0QGoF4ij0TaJSJd0CWR+y4R6YJ6iUgX1EtEuqBeItIF7RI50gX1EtHRNUgUKxIZfzyFbbzL1xLFze8fHbeyXR9sbkfsR9/+HeJ3RWkAZ1OUfnE2RWkvZ1OUbnQyRT3N62yKspI2tKLlu6IsvM2mKOt0synqUXQyRcmMZlOUzGgyRePK99Etv1D0jmblG1IFzcpX9gqaqS6ROfgDTdpqaMy2b/1izNMknTk72ptjOzbvH8eefvIbN3oz5SHMVn47+q7nVKE6esapInX0jFMF6uiZporT0TNNFaajZ5oqSkfPNFUAgJ7Jo+dUek4VtaBnIh+aS0/yobn0JB+aS0/yoan0zORDc+lJPjSXnuRDc+lJPjSXnh49p9KTfGguPcmH5tKTfGguPcmHhtLT5v0BaOs2e6In+dBUehbyobn0JB+aS0/yobn0JB+aS0+PnlPpST40l57kQ3PpST40l57kQ3PpST40k563KaHnVHqSD82lJ/nQXHqSD82lp0fPqfQkH5pLT/KhufQkH5pLT/KhufQkH5pKT0M+NJee5ENz6Uk+NJee5ENz6enRcyo9yYfm0pN8aC49yYfm0pN8aCg9k9lJ2+S2Ez3Jh6bS05IPzaUn+dBcepIPzaUn+dBcenr0nEpP8qG59CQfmktP8qG59JwrHyrHRxfrK3q645P90zDOX8B6eqjx5QviVKFMcfsfhd9iDWK2Zj8622AqpSu30ZZxUwUtk2o0VXgyqUZTBSKTajRVyDGpRh6N1Gs0VRgxqUZTBQyTajRVaDCpRlMFAZNqRM6gXiNPzqBfI3IG/RqRM+jXiJxBv0YejdRrRM6gXyNyBv0akTPo14icQb9G5AzqNQrkDPo1ImcQ16j2A8lAzqBfI3IG/Rp5NFKvETmDfo3IGfRrRM6gXyNyBv0akTOo1yiSM+jXiJxBv0bkDPo1ImfQr5FHI/UakTPo14icQb9G5Az6NSJn0K8ROYN6jRI5g36NyBn0a0TOoF8jcgb9Gnk0Uq8ROYN+jcgZ9GtEzqBfI3IG/RqRM6jXKJMz6NeInEFco9rGwZmcQb9G5Az6NfJopF4jcgb9GpEz6NeInEG/RuQM+jUiZ1CvUSFn0K+Rqr7uPiRVbcx9SLJ3bVer5JvN3cvt5qbyozjt1/jz4OMvQ4/fbtvg4zeDj98OPn43+Pj94OMPg48/Dj7+se+/dhv7/mu3we+/ZvD7rxn8/msGv/+awe+/ZvD7rxn8/msGv/+awe+/5uP3X2fc/qZkdwvCKp9tnd1na72vxUWjbP55+9/BLoDdbmCXwG7ALoHdgl0CuwO7BHYPdgnsAewS2CPYJbAnsEtgx6WKYMelSmB3uFQR7LhUEey4VBHsuFQR7B7sEthxqSLYcaki2HGpIthxqSLYcakS2D0u9R3YK9tfWI9LFcGOSxXBjksVwe7BLoEdlyqCHZcqgh2XKoIdlyqCHZcqgT3gUkWw41JFsONSRbDjUkWwe7BLYMelimDHpYpgx6WKYMelimDHpUpgj7hUEey4VBHsuFQR7LhUEewe7BLYcaki2HGpIthxqSLYcaki2HGpEtgTLvUd2Csb0d/+d7BLYMelimDHpYpg92CXwI5LFcGOSxXBjksVwY5LFcGOS5XA/vl3uDtr3Y7dZlvDbuKB3bo0Cvbaz4E//1p2sP/CbsEugd2BXQK7B7sE9gB2CewR7BLYE9glsGewS2AvYBfAXnCpIthxqSLYcaki2HGpItg92CWw41JFsONSRbDjUkWw41JFsONSBbC7DZcqgh2XKoIdl/oO7JWfFbgNlyqC3YNdAjsuVQQ7LlUEOy5VBDsuVQQ7LlUCu8GlimDHpYpgx6WKYMelimD3YJfAjksVwY5LFcGOSxXBjksVwY5LlcBucaki2HGpIthxqSLYcaki2D3YJbDjUkWw41JFsONSRbDjUkWw41IlsDtcqgh2XKoIdlzqO7BXtmhzDpcqgt2DXQI7LlUEOy5VBDsuVQQ7LlUEOy5VArvHpYpgx6WKYBdwqWU/+OYazG+ffR9S0DekqG9IH++F/Ob2z/ZbqP29XB19n0AefQJF9wRiDvs1KOZknj75r+GHbezhm7GHb5UPv2z7LSkWm74N3409fD/28MPYw49jD1/5nbc2fOX33drwtd91r4cftd91K8PXftetDH/su24c+64bx77rxrHvunHsu24c+64bx77rxrHvumnsu24a+66bxr7rprHvup9/+3Lf4Y99103q77r+iKlK+D589Xfd6+Grv+teD1/9Xfdy+Fn9Xfd6+OrvutfDf/Nt6/4lH7+82ez2663bjKt8dighfx2dsnnsy/trkfXbwbfLxX7wTfzHsP22nQ3bH684Nj49FmJzPvtok5/envy0ahtPF/82a4+jfT6OdmbTvNbstn093Tpjfjv6XiyJYqFYflosmWKhWH5aLIVioVi+lKn9MOfzr0ekWMYtFkOxUCw/LRZLsVAsPy0WR7FQLD8tFk+xUCw/LZZAsVAsPy0WElyK5cfFQoJLsfy4WEhwKZYfFwsJLsXyw2LxGzmLfLGY+CiWLVfk96nsw7798zESF+KXpKQho0maj6uFfybykNQj6WiSHjsi+OzsiaQkC9NJiv+fTlJc+nSS4qWnkxTHO5ukhieLhpN0S4ekdjuRlOd/ppOU9Gg6SUmPppPUI+lskpIeTScp6dF0kpIezSbp+esKbjM8znoM3xTzdVJqOSm3nHSahASzF1yw7reTzirosTlzzk+75eb7N5zv6d31G8zbv8G+/Rvc27/Bv/0bwtu/Ib79G9LbvyG//Rve/jcd3v43Hd7+N32+E2o49nUIPn2/XJ7vgBnSsRmE376fdL5xY+WbzrdLDMf9N0R/ctL5VSTvt79Q3MlJvuWk0HJSbDkptZyUW04qDSedb28Wjv4klBOdzjcVq51kW05y1yfF7WxO5xWRynFSPjnptCKi2elFV05OipVvOvt7Ot8YqfJHeL4dUe2klj/3881fjA37pIyNJyiybzsttJ0W205LbaflttNK02nnPzKvn2baTrNtp72okpyO054e7Hyc5uunnbT5JbSdFttOS22nnVfJzb7tp7mzC8/548u108K2tZ1m2k6zbae5ttN822mh7bQXusVDbpe+32XC+fKeefR4Jnh7ctoLJOX4e/NbODnN108rJ6eFttNi22mp6TS7tZ12TvI5iHHm5DTfdto5SR+347QYT07LL057zC19vwkH92Jux6PwtyDopCadbzsttJ12XiW3i/zxF7CdzS21nZbbTitNp53HPre/7kO3W0WcnGbaTrNtg3Rtp/m200LbabHpOnmeZNRPy22nlabTgm26coW2K1dou3KF0HJaPL8HBLtPLZy8Ey6e3wFqJ+WWk0rDSed3mtpJpuUk23KSaznJt5wUWk5qqQh7XhFlb67i09LK46TcclJpOMltLSeZlpNsy0mu5STfclJoOSm2nNRSEa6lIlxLRby4Xz0W4W5ri2enpbbTzu9XN6eyn/a85Pc4rTSddh58108zbaed3x1NPJCYfIIkvPIsDz9Wzr4ttp2W2k7LbaeVptPi1naaaTvtXLebT3s0Q+nkNNd2mm87LbSdFttOS22n5bbTXnSjD9MYcvl+WtraTjNtp9m201zbab7ttNB2Wmw77VUCeJzm7MnfWypNp+Wt7TTTdpptO821nebbTgttp8W201LbaW1Vktuq5MVqgjuWb40LJ5egF6sJ1dNs22mu7TTfdlpoOy22ndbWYJS2BqM0NRhp29pOOxWg9ub49CKoj48s9XYpPTkttp2W2k7LbaedC5DS/vsvk8r3fUnS+e+/6qeZttNs22mu7TTfdlpoOy22nZbaTsttp7VViW2rEttWJbatSmxbldi2KnmxLlMet8Viz06LTaedxxA2m/25Jpvj44J3/qhwdkfymt3TmtH50bUndNN5yCE6pPPFE9khGX1DsvqG5PQNyesbUtA3pKhvSEnfkPRdvX2Pq7c9nvHM3qTa0X+4+9rx/hx/axu/TyBso0/AjD4BO/oE3OgT8KNPIIw+gTj6BNLoE8ijT2D0O3Ec/U4cR78Tx9HvxHH0O3Ec/U4c1d8HrndjTkn7VajmyNLnr0JaNk835bFRw/Z9fTslC5pXaBxoXqHxoHmFJoDmFZoImldoEmheocmgeYWmgOYFmryB5hUauuGXaOiGX6KhG36JxoPmFRq64Zdo6IZfoqEbfomGbvglGrrhV2gK3fBLNHTDL9HQDb9EQzf8Eo1fFo11DzT+5FHzsm43XEWzbjdcRbNuX1NBk7d171CVH+Tlbd07VBXNuneoKpp171BVNOveoapo1s1rqmjWzWuqaNbta2pozLp5TRXNunlNFc1pN+y24wfQbnva0+t8ssZEc/w620Rbg2PtsRvarVt/bP3lbv++D8r1GFR47Ftr4tOrM8bOSvL5NgrAucMJwHkNJwLnNZwEnNdwMnBewynAeQnnfKsa4NzhGOC8hmOB8xoOHfIFHA+c13DokC/g0CFfwKFDvoBDh3wBhw75NRxHh3wBhw75Ag4d8gUcOuQLOB44r+Gs3CHbvM/Suu3k6Sm3codchbNyh1yFs3KHXIWzcodcg+NX7pCrcFbukKtwVu6Qq3BW7pCrcDxwXsOhQ76AQ4d8AYcO+QIOHfIFHDrk13ACHfIFHDrkCzh0yBdw6JAv4HjgvIZDh3wBhw75Ag4d8gUcOuQLOHTIr+FEOuQLOHTIF3DokC/g0CFfwPHAeQ1n5Q659qvcuHKHXIWzcodchbNyh1yFs3KHXIOTVu6Qq3BW7pCrcFbukKtwVu6Qq3A8cF7DWXfzMHe8HtE6Y07QrLt5WBXNupuHVdEsvClqxY0v/OqjKpp1Nw+roll3K90qmnW30q2i8aB5hWbhzd5raBbe7L2GZt1uuIpm3W64ioZu+BUagZfY/NnL61PZ0dz++Zju/vL6LPCqmT+bQD4q4fbPcjIBr30C1h0TcPZkAmH0CcTRJ5BGn0AefQJl7AmUbdM+gS0dE7DbyQTM6BPQfieuTkD9nbg2AfV34toE1N+JaxNQfyeuTUD9nbgygfMdgZLfR5R8/GYiyvl+Jw9TU0I+Oak0nHS+P0btJNNykm05ybWc5FtOOtXJbMfrJswWw8lpse201HZabjutNJ12/svQ+mmm7TTbdpprO823ndZWJaGtSs5/slK5dpz/lKMcl6liT06KLZeB8we4a9/kW04KLSfFlpNSC4iWy3VsuVyfP2hX4l4RJZ2U0fkDaLWTbMtJtcv16Uktl+sUWk6KLSe1VERqqYjUUhG55S83t9zAc8sNPLfcwPOfVsR/3P7j//8///s//+f/8i//9D9vp/z6X//3v/7X//XP//avX//xf/2//2P/X/7Lv//zv/zLP//3//Q//v3f/us//bf//e//9J/+5d/+66//7R+2r//zf6eQwj+mUOJtOL9QpWLcP946LHP7z+6v/z2a2/+efv3nv96d5ovd/vH2f8Kv/+KvM6Kx/3j7P/42ttv4/j8=",
      "brillig_names": [
        "get_accumulators"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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sld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV3cte3XXsld3LXt117JXdy17ddeyV/ciey37NwxdEXdw2osq2bf0c6X4X0472sq30YNCbsMppobzKivWGo6zNRxvazjB1nDE1nBWW8OJtoaTbA3H1lU527oqF1tX5WLrqlxsXZWLratysXVVLrauyuXTV+XTZ1zdxpOMjScbG08xNR6/LMbG44yN53gD9Vtj/3Wa926tjOeWBzyepBzT3+9ecHuT8Ik3kU+8ydrkTUJ8vEkMT29y8Iu8HLaNgcLyvO/Tcryd6rLvubaEx2/vi/8afzQ+/nXnH9cQvo8/dT7+3Pn4S9/jP/7iQ0fjd52P33c+/tD5+KXz8Vu//9bG3/n913V+/3Wd339d5/df3/n913d+//Wd33995/df3/n913d+//Wd33995/df3/n913d+/w2d339D5/ff0Pn9N3R+/w2d339D5/ff0Pn9N3R+/w2d339D5/df6fz+K53ff6Xz+690fv+Vzu+/0vn9Vzq//0rn91/p/P4rnd9/187vv2vn99+18/vv2vn9d+38/rt2fv9dO7//rp3ff9fO779r5/ff2Pn9N3Z+/42d339j5/ff2Pn9N3Z+/42d339j5/ff2Pn9N3Z+/02d339T5/ff1Pn9N3V+/02d339T5/ff1Pn9N3V+/02d339T5/ff3Pn9N3d+/82d339z5/ff3Pn9N3d+/82d339z5/ff3Pn9N3d+/y2d339L5/ff0vn9t3R+/y2d339L5/ff0vn9t3R+/y2d339L3/ffsPR9/w1L3/ffsPR9/w1L3/ffsPR9/w3m97+qjb/v+2/ofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1XofP+r0Pn+V6Hz/a9C5/tfhc73vwqd738VOt//KnS+/1Xo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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "_withdraw",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5235018679007078561": {
            "error_kind": "string",
            "string": "Invalid asset or market id"
          },
          "6787403583199288031": {
            "error_kind": "string",
            "string": "Insufficient balance"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10435052277855889085": {
            "error_kind": "string",
            "string": "Function _withdraw can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15333773746166717806": {
            "error_kind": "string",
            "string": "Insufficient collateral"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_withdraw"
      ]
    },
    {
      "name": "_repay",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5235018679007078561": {
            "error_kind": "string",
            "string": "Invalid asset or market id"
          },
          "6787403583199288031": {
            "error_kind": "string",
            "string": "Insufficient balance"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13135008234568508716": {
            "error_kind": "string",
            "string": "Function _repay can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_repay"
      ]
    },
    {
      "name": "repay_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "repay_public"
      ]
    },
    {
      "name": "add_asset",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "oracle",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "loan_to_value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "is_borrowable",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "optimal_utilization_rate",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "under_optimal_slope",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "over_optimal_slope",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "deposit_cap",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "add_asset"
      ]
    },
    {
      "name": "borrow_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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h17PHB96PXN86PXM8aHXM/cwv5w5PvR65vjQ65njQ69njg+9njk+9HLmDh96PXN86PXM8aHXM8eHXs/cw/xy5vjQ65njQ69njg+9njk+9Hrm+NDLmfd+gumQzPGh1zPHh17PHB96OXNVZyim94Nj2MbG+Inifaaasuv3ZuqnmWkLR/84oH4tBP/upe/xB+XxR+XxJ+XxZ93xNzk/UjJ+03X8fnHbAcp+ybnw0s7vxYLz6Sns9eNu2+ScxXazdVPN1k81277rBunZ9l1lSM+275pEerZ9VzDSs+273hGebey7OpKe7VS1VNRbS93j11sd3eP3yuPXW8Hc49dbk9zj11tl3OPvvG4we0PRO+MLL50WvzXb3WOuNrmDsTltL5zz57F3Lp1XGK24pM5rkWZcOq9amnHpvL5pxqXzuqkZFw+XQy6d13nNuHRePzbj0nld2owL9e4xF+rdQy6ZeveYC/XuMRffORez9SO9sQf9gNx7nVGKv/d6oBR/7+t2Kf7e19dS/L2vg+/jt0vv61Up/t7XlVL8vfc7SvH33pcoxa97/bWL7vXXLrrXX7voXn/tonv9tYvy9dcoX3+N8vXXKF9/jfL1t8n+/pLxK19/jfL11yhff43y9dcoX3+t8vXXKl9/rfL11ypff5vsaywZv/L11ypff63y9dcqX3+t8vXXKV9/nfL11ylff53y9bfJfo6S8Stff53y9dcpX3+d8vXXKV9/vfL11ytff73y9dcrX3+98vXXK19/vfL11ytff73y9dcrX39X5evvqnz9XZWvv6vy9bfJnoOS8StffzvfSbAcv/L1t/OdBMvxK19/O99JsBy/8vW3970Bi/ErX39737+vGL/y9bf3PfaK8Stff3vfB68Yv/L1t/e96orxK19/e99Prhi/8vW39/3kivErX39730+uGL/y9bf7/eRK8Stff7vfn60Uv/L1t/v9zkrxK19/u98/rBS/8vW3+/24SvErX3+739+qFL/y9bf7/aJK8Stff7Py9TcrX3+V739lle9/ZZXvf2WV739lle9/ZZXvf+WU73/llO9/5ZTvf+WU73/lFt3rr+t+/6vT9hUN21izLPbT4DuYaTe6LoGZdqfrEphpt7ougZl2r+sCmO43L2sGRu8pJvf49Z42co/fK49fb1Vzj19v8XGPX2+NcI9f71J+j1/vivtH/N3vKlaKX+9pDff4la+/3e8qVopf+frb/a5ipfiVr7/d7ypWil/5+tv9rmKF+LvfVawUv/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvErX3+731WsFL/y9bf7XcVK8Stff7vfVawUv/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvErX3+731WsFL/y9bf7XcVK8Stff7vfVawUv/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvErX3+731WsFL/y9bf7XcVK8Stff7vfVawUv/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvErX3+731WsFL/y9bf7XcVK8Stff7vfVawUv/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvErX3+731WsFL/y9bf7XcVK8Stff7vfVawUv/L1t/tdxUrxK19/u99VrBS/8vW3+13FSvErX3+731WsFL/u9dd3v6tYKX7d66/vflexUvy611+/6F5/veJdxe7x615/veI9uu7x615/veIdr/6IX/HGVPf4la+/yve/8sr3v/LK97/yve9/FVze4k+LK7z0jzaWS9sMc/489s6l83W9GZfO64VmXDqvQ87j8n6DRt/7BmPNwPS+c1k7MJ2XZO3AdF7rtQPTeRHZDozvG0zaX9onXwITg/sYHGPYx3r7MdXOC1nJqXZem0pOtfNy881U7/F3XhYW4++8eivF3/n2dKvx6zbYhAN73vn2dOX4+y5ZyvH3XVmU4/fK4+97VS/H3/dSXY6/7/W3HH/f6285/r7X3+f4rbFf4+98e7py/HrW3+P49ay/x/HrWX+P49ez/h7H3/n6G03cB6d8EH/n628x/s7X32L8na+/xfg7X39L8Xe+PV05/s7X32L8na+/xfg7X3+L8Xe+/hbjV77+dr49XTl+5etv59vTrckt2+AcUuGlfd4n+/xVpmQPxtq4bMcZ22gflW344NL5ut6KS+fb6bXj0nkdIsTlPtfOaxbRuXZe34jO1U80187rJtG5dl5jic6183rsR3O9tdy2wT4dzHWk2q0015HqscJcO98yUXauI9VNpbmOVDeV5jpS3VSaq59oriPVTaW5jlQ3reteN6WDuqnzbSZl5zpU3VSY61B10/u5dr7Vpexch6qbCnMdqm4qzHWouqkwVz/RXIeqmwpznahu6nx70Hdzvcevtxa6x6+3vvkj/s63By3Hr7cO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meNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzA0+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzO3+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17O3OFDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfPeD7gdkjk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzIc6vFwLc3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZB3zo9czxodczx4dezxwfej1zD/PLmeNDr2eOD72eOT70eub40OuZ40MvZx7xodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZx5wodezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5hkfej1zfOj1zPGh1zPHh17P3MP8cub40OuZ40OvZ44PvZ45PvR65vjQq5nnBR96PXN86PXM8aHXM8eHXs/cw/xy5vjQ65njQ69njg+9njk+9Hrm+NDLmRt86PXM8aHXM8eHXs8cH3o9cw/zy5njQ69njg+9njk+9Hrm+NDrmeNDL2du8aHXM8eHXs8cH3o9c3zo9cw9zC9njg+9njk+9Hrm+NDrmeNDr2eOD72cucOHXs8cH3o9c3zo9czxodcz9zC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYeH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40MuZr/jQ65njQ69njg+9njk+9HrmHuaXM8eHXs8cH3o9c3zo9czxodczx4dezjzgQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxodczx4dezxwfejnziA+9njk+9Hrm+NDrmeNDr2fuYX45c3zo9czxodczx4dezxwfej1zfOjlzBM+9Hrm+NDrmeNDr2eOD72euYf55czxodczx4dezxwfej1zfOj1zPGhlzPP+NDrmeNDr2eOD72eOT70euYe5pczx4dezxwfej1zfOj1zPGh1zPHh17M3C0LPvR65vjQ65njQ69njg+9nrmH+eXM8aHXM8eHXs8cH3o9c3zo9czxoZcz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",
      "brillig_names": [
        "discover_new_messages",
        "decompose_hint",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "withdraw_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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4le+/na/q1gpfuXrb/e7ipXiV77+dr+rWCH+7ncVK8WvfP3tflexUvzK19/udxUrxa98/e1+V7FS/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexUvzK19/udxUrxa98/e1+V7FS/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexUvzK19/udxUrxa98/e1+V7FS/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexUvzK19/udxUrxa98/e1+V7FS/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexUvzK19/udxUrxa98/e1+V7FS/MrX3+53FSvFr3z97X5XsVL8ytff7ncVK8WvfP3tflexUvzK19/udxUrxa98/e1+V7FS/MrX3+53FSvFr3v99d3vKlaKX/f667vfVawUv+711y+611+veFexe/y611+veI+ue/y611+veMer3/Er3pjqHr/y9Vf5/lde+f5XXvn+V773/a+Cy1v8aXGFl/7RxnJpm2HOn6+9c+l8XW/GpfN6oRmXzuuQ87i836DR977BWDMwve9c1g5M5yVZOzCd13rtwHReRLYD4/sGk/aX9smXwMTgPi6OMezXevsx1c4LWcmpdl6bSk6183LzzVTv8XdeFhbj77x6K8Xf+fZ0q/HrdrEJB/a88+3pyvH3XbKU4++7sijH75XH3/eqXo6/76W6HH/f6285/r7X33L8fa+/z/FbY7/G3/n2dOX49ay/x/HrWX+P49ez/h7Hr2f9PY6/8/U3mrhfnPJB/J2vv8X4O19/i/F3vv4W4+98/S3F3/n2dOX4O19/i/F3vv4W4+98/S3G3/n6W4xf+frb+fZ05fiVr7+db0+3JrdsF+eQCi/t8z7Z568yJXtwrY3LdpyxjfZR2YYPLp2v6624dL6dXjsundchQlzuc+28ZhGda+f1jehc/URz7bxuEp1r5zWW6Fw7r8d+NNdby2272KeDuY5Uu5XmOlI9Vphr51smys51pLqpNNeR6qbSXEeqm0pz9RPNdaS6qTTXkeqmdd3rpnRQN3W+zaTsXIeqmwpzHapuej/Xzre6lJ3rUHVTYa5D1U2FuQ5VNxXm6iea61B1U2GuE9VNnW8P+m6u9/j11kL3+PXWN7/j73x70HL8euuQe/x6a4t7/H3XC2FZtkCCC+Ygfq88/r7X9XL8fa/V5fj7Xn/L8fe9/pbj73v9LcW/dr49aDn+vtffcvx9r7/l+HWvv+uie/1dO98etBy/7vV37Xx70HL8utfftfPtQYvxd749aDl+5etv59uDluNXvv52vj1oOX7l62/n23iW41e+/na+LWY5fuXrb+ebTJbjV77+dr5lYzl+5etv5xsgluNXvv52vlVhOX7l62/n+w+W41e+/na+/2A5fuXrb+f7D5bjV77+dr7/YDl+5etv5/sPluNXvv52vv9gOX7l62/n+w+W41e+/na+/2A5fuXrb+f7D5bjV77+dr7/YDl+5etv5/sPluNXvv52vv9gOX7l62/n+w+W41e+/na+/2A5fuXrb+f7D5bjV77+dr7/YDl+5etv5/v5leNXvv52vpdeOX7l62/ne96V41e+/na+N105fuXrb+d7yJXjV77+dr7XWzl+5etv53uyleNXvv52vndaOX7l62/ne5yV41e+/na+F1k5fuXrb+d7hpXjV77+dr63Vzl+5etv53twleNXvv52vldWOX7l62/n+1+V41e+/na+/1U5fuXrb+f7X5XjV77+Kt//alW+/9WqfP+rVfn+V6vy/a9W5ftfBeX7XwXl+18F5ftfBeX7X4VF9/oblO9/FZTvfxWU738VlO9/FZTvfxWU738VlO9/FZTvfxWU738Vet//yqft4rAaexB/5+uvizv/28DCS6fFf1yc3OOscJvcwbU5bS+c8+dr71w6X9ebcem8XmjGpfM6pBmXzuubVlx637esGZfO67FmXDqv85px6bx+bMbFw+WQC/XuMRfq3WMu1LvHXKh3j7lQ7x5y6X2fwGZcpq13w3atWRZ7AGbagrcEZtqKtwTGA+YYzLQ1bwnMtEVvCUznVcya8gbm9gSm8NJmzYvbprtm4/brw322ve/h92a29/g7XxGK8fd9444xbhfH+FTDHb+0jWH9uNrG6J5f+j7Zvm/GwpPt+wYrPNm+WwXCk+3b/wtPtu/lUHayne9oKDzZvu238GT7rnN+Otlst8mmp6pin2zfRZHwZP1Mkx2pgnJ22YpjZ238OtmRKqjiZEeqoIqTHamCKk52pArqNtnl3WQ73xPxh5P1Zrvaebt8nexI62xxsiOts8XJDrXOliY71Drrctona5b3L73muN2615wP7mZDLco/IROW/T4floNCtPO9J6/JmWMyQy333u21jV/Nn32aOt8v8xoyhznT+U6cPyWzP7pzPqevkx2rRCxMdqwSsTBZP9NkxyoRH5Ndn56K75MdqkQsTXaoqq802aEKudJkh6rN3COQ1cT3L21C2up5E/3Tj2H9ckfT+WakP0QT95/+upjdn5WtnW9zeiKZkgnsfAPVa3LmmIwfisz+0u4vD6UObjRL3r9wZtxycKMZqm5K1u9ocuGl/bIF7e3nO/ABxkdLwtzad/vVbsc4VEXWDuNQtV47jENVke0wDlWfNsPY+cbEajAOZQnaYRzKP/wIo9vsg3+e4Q5mKPsgCabzHy3J/gSl922chWfb+Y/qhWfb+U/lhWc700/HYu/bTwvPtvMfqwvPVu/PAmtmq/dHhDWz9WPN1vnHbFf7NNvjq+3T1eELm8EqL1E2g9VpomwGq+p+wMab3f96+/QYciMzWAUoSGawalGOTO8bqzckM1gVKkhmsIpVkMxg1a0gGQ+ZF2TmrYNLZOatgktkqIFfkaEGfkVmtBr4lUs8eO20fyMzuqcfHb147Zy2Sd4wPh3GcuP/m2Tvm+orIjlajS1D8s5mtCpbks1odfbbjteLTdPNvhOjszYXZmvSsm3aY5J5ZpMPZ7s8ZruE59neI4rXR2QfEX3dDCG+2Ci8ZUS5t4hebI7dMiLTXUT2+oh8eNxZCl/5tn6/xVnv/dfwne7wve7wV93hB93hR93hJ93hZ9Xh+6Xz8G16hP+1IPNGd/i9r7qF8Dtfddd1q3nsGv7sh4jRd75E/2SuhZ8WRt/5er4at881FvZFSfsJw8k/xfzxPejoO1/7JafaeZ0gOdXOawrJqXZefwhOde28VpGcau8r60+mum5hpBg+TfXghY17dM6ftrz6tZ3E14sfv6ZfPl16R9j7gq0A4Uh1QCOEI9UXjRCOVLc0QjhSPdQGYRyp+PgJwuVxXIB5eiR2iDClLYhsij9qvr33/vgvxfh0TlpOH8w77+4MybzzltSQzGet9lsy9zC/nPmsfqIl81kNSEvmszqWlsxntTgtmY/Ue1bCPOFDr2eOD72eOT70eub40OuZe5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfOMD72eOT70eub40OuZ40OvZ+5hfjlzfOj1zPGh1zPHh17PHB96PXN86NXM04IPvZ45PvR65vjQ65njQ69n7mF+OXN86PXM8aHXM8eHXs8cH3o9c3zo5cwNPvR65vjQ65njQ69njg+9nrmH+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczt/jQ65njQ69njg+9njk+9HrmHuaXM8eHXs8cH3o9c3zo9czxodczx4deztzhQ69njg+9njk+9Hrm+NDrmXuYX84cH3o9c3zo9czxodczx4dezxwfejnz3g+4HZI5PvR65vjQ65njQ69n7mF+OXN86PXM8aHXM8eHXs8cH3o9c3zo5cyHOrxcC3N86PXM8aHXM8eHXs/cw/xy5vjQ65njQ69njg+9njk+9Hrm+NDLmQd86PXM8aHXM8eHXs8cH3o9cw/zy5njQ69njg+9njk+9Hrm+NDrmeNDL2ce8aHXM8eHXs8cH3o9c3zo9cw9zC9njg+9njk+9Hrm+NDrmeNDr2eOD72cecKHXs8cH3o9c3zo9czxodcz9zC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYZH3o9c3zo9czxodczx4dez9zD/HLm+NDrmeNDr2eOD72eOT70eub40KuZ5wUfej1zfOj1zPGh1zPHh17P3MP8cub40OuZ40OvZ44PvZ45PvR65vjQy5kbfOj1zPGh1zPHh17PHB96PXMP88uZ40OvZ44PvZ45PvR65vjQ65njQy9nbvGh1zPHh17PHB96PXN86PXMPcwvZ44PvZ45PvR65vjQ65njQ69njg+9nLnDh17PHB96PXN86PXM8aHXM/cwv5w5PvR65vjQ65njQ69njg+9njk+9HLmHh96PXN86PXM8aHXM8eHXs/cw/xy5vjQ65njQ69njg+9njk+9Hrm+NDLma/40OuZ40OvZ44PvZ45PvR65h7mlzPHh17PHB96PXN86PXM8aHXM8eHXs484EOvZ44PvZ45PvR65vjQ65l7mF/OHB96PXN86PXM8aHXM8eHXs8cH3o584gPvZ45PvR65vjQ65njQ69n7mF+OXN86PXM8aHXM8eHXs8cH3o9c3zo5cwTPvR65vjQ65njQ69njg+9nrmH+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczz/jQ65njQ69njg+9njk+9HrmHuaXM8eHXs8cH3o9c3zo9czxodczx4dezNwtCz70eub40OuZ40OvZ44PvZ65h/nlzPGh1zPHh17PHB96PXN86PXM8aGXMzf40OuZ40OvZ44PvZ45PvR65h7mlzPHh17PHB96PXN86PXM8aHXM8eHXs7c4kOvZ44PvZ45PvR65vjQ65l7mF/OHB96PXN86PXM8aHXM8eHXs8cH3o5c4cPvZ45PvR65vjQ65njQ69n7mF+OXN86PXM8aHXM8eHXs8cH3o9c3zo5cw9PvR65vjQ65njQ69njg+9nrmH+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczX/Gh1zPHh17PHB96PXN86PXMPcwvZ44PvZ45PvR65vjQ65njQ69njg+9nHnAh17PHB96PXN86PXM8aHXM/cwv5w5PvR65vjQ65njQ69njg+9njk+9HLmER96PXN86PXM8aHXM8eHXs/cw/xy5vjQ65njQ69njg+9njk+9Hrm+NDLmSd86PXM8aHXM8eHXs8cH3o9cw/zy5njQ69njg+9njk+9Hrm+NDrmeNDL2ee8aHXM8eHXs8cH3o9c3zo9cw9zC9njg+9njk+9Hrm+NDrmeNDr2eOD72auVnwodczx4dezxwfej1zfOj1zD3ML2eOD72eOT70eub40OuZ40OvZ44PvZy5wYdezxwfej1zfOj1zPGh1zP3ML+cOT70eub40OuZ40OvZ44PvZ45PvRy5hYfej1zfOj1zPGh1zPHh17P3MP8cub40OuZ40OvZ44PvZy50+SJ0vuLY9iujfETxd8z9ZqcyJ/NVFP9/2czbVF1m8dMC8G/e+l7/E55/F55/Kvy+IPy+KPy+FPn8a/bbdlk6wovbXzO29XrU61we+n7ZPNEk21y3nSzyZqBJmtT3MuLlHPhanerhLdJ3lJ8v3oj03uB0Y5M76VLOzJ+XjIu5J1Mik9kvl7rzU7RWxO/UOy9NNNBsfcC8WcUl7hRzGYpXJ32OSb3mKJN7uDanLYwcv587Z1i72WqDoojFcvtKI5UhTejGEYq79tRHMs3tKI4lsdoRXEsP9KKooeiAMWxvEsringXCYp4FwmKeBcJingXAYoR7/ItimG71iyLPcCIeRHBiHsRwYh9EcHowSiBEQMjgnEoB5MfT6WWIkbj485mNU+vnY4iCcv2ECvYp2/LpvWD41AepiHHoVxMQ45D+Zh2HNNQTqYhx6GsTEOOHo7f4+i3i8NqDjiyXn+T4/7znBDSAceJ1+vV7GGvzn/ieGcz8RpcYpMnXleLbCZeK4tshurl/fC+vQdyY7MW7tu3t0/+EUr+8r3LPFQ7rylJD0khkkM19ZqSnLmvJ0tyJKfgFhd3krkUSOGb+3mk2l+WzEiVvyQZu4xU9/+MjDFh3S6//f20PYcxR9tovP8Nl11GcgltSY7kKdqSHMlTnExS7Bd0dvFQb0B9JK/yU+rR7i9+a+W5AnUb4/71hvi0nc5GciSv0pbkvF5FmuS83uanJCWfb9plXufUlLuZ2Ze15D6zi2vJfWbP15L7zA6xJXdq7JO4v/2ekTXUMydxf/u9JGupZ77NvfCdC2upUeRYUnfIsaSWkGPpYfntdUry+wXW0kduRZ6auBV5+tStyNPXbkV+Yid4e1i6o7y1mn2B/O1p6+O0mfQEJaXDJznLfnW09q/c3cROsCn3iV1jU+4TO0xB7neWEztMcZYelmIsJ/aM4iwndoHiLCf2deIsJ3ZqP2Vp94eftwb7csAS7yXG0uOn5FhSX8qxZB3/NsvVLxvLdT1iyToux5J1/JjlnQ4r8xs6Qx3xKE9n5g6jNft5mbdHyEvhLlX43d5QZ0i2JTlzRSdL0kPyuyTlftU41JmWeqjP7F0+UQ/mYJ2f2Y2U6czsL8p0ZvYXLqWdjvfFX8QGu3dYgnu6Ot/3irdDnUh5Jct4wHJm7/IHLL09YDmze/kpyz0WG8L6ieVRLGHZYwlPCLM5nGfcDXtKrnB1sts0kzefrr1rOrOPGlVTj6bDaTqzXxxV05nd6KiazuyhR9V0Zuc/qqb0K4bTdKjTcKfRdN2+npnWeKAp/RuFmvr9c/oE8KEpfSTVmgZ3oCn+tAdN7eo2KLdHzPZAJzxnHzo9dkUNZj3QCR+pQye8oQ6d8HsqdBrqHOCRdcKX6dAJr6VDJ+ryLjxxfnzRLR/1GIc6z3pknajLdehEXa5Cp6HOER9ZJ+pyHTpRl+vQiTriJJ2sX3eEaS3o5EJy29Uh5QOdqCM06ORmPpdYlU7UETp0oo7oQSfv9mNyvEvuQCd+Z9OFTnnvw/qc0oFOHp360mldlqP7Ht830qETzzV06MRzDR060Y/QoRP9CBU6zXwetyqd6Efo0Il+hA6d6Efo0Mmjkwqd6Efo0Il+hA6d6Efo0Il+hA6d6Eeo0MnSj9ChE/0IHTrRj9ChE/0IHTp5dFKhE/0IHTrRj9ChE/0IFTo56vKTdDL76QC3Znfxe8tu18m5o+9ZOury7nTKB99bdtTlOnTy6KRCJ+pyHTpRl+vQibpch048J9ShE88JVejkeU6oQyf6ETp0oh+hQyf6ETp08uikQif6ETp0oh+hQyf6ETp0oh+hQyf6ESp0WulH6NCJfoQOnehH6NCJfoQOnTw6qdCJfoQOnajLq3SKtqBTDNuGrzGG/Vpv79gDZXYT7FTNTbBTBH8be4zb5TYtroA9u7QhzH55OnY9Ha4FKT/WgqeL41EcOZl9lot9f7ExS9zFMZ+gpI8MoLyWyIA7Sw/L77JMNu8s1+WAJW3+77MMfmcZwleWcea7/Or2uO0aTYFljtsu82YxTzfXW+B3lDPfLsNidpTxOfBDlLeX3Bcq++yeXlQ1aTtV6PbauXS1Mfut2PhYuDrlDUo2B7eaOPNte1RNZ+5yjKrpzN/Q0Kppzm5fUJf0SdSvF4e8zzJkU3BN6VYafVycbLBfnE2cuYIkXX6cLjN/X4V0+XG6zNyeJ11+mi5p5scKpMuP02XmxyGky4/TZeYGH+ny43ShiUm6/CBdPOkyUrrcRaVBOqCodEgHFJU+pj5RzWKXXVW/FJZrk8P+wD/nYb5blGl6KMzcmz3YAnfZfr0fZXoTI6pKC0G7qvlAVZz+iKp6VB1QVRz5iKpiyUeslvDkI6rKV4BGVJVv6oynql/oLY2oKr2lEVWltzSiqvSWRlSVLsSIqtKF6EJVu+y/erf2s6p3negr6NCJToEOnfD+KnQyuHkdOuHPdeiE4+5Dp/3o7ZtMy4FOeGgdOnl0UqET/kmFTpZ6rw+d9u97W/eXSO46Ue91oZNb98/Tp82id52o93ToRL2nQyePTip04mmVDp14/qRDJ/yTDp14/qRDJ54/daGTd9v3I6xPrnB18Nse4CE8eusuHM0yrRuSlPKna3/r7+hzzK0//ZO59acvM7b++XFSx2Jy4eLVuO2x7WqSL1wdglv2OJw5SC6aSSTXacnlSS6S66zkom1Hcp2WXPQaSa7TkosGKcl1WnLR1SW5TksuWtEk11nJ5elzk1ynJRdNdJLrtOSiQ09ynZZcdOhJrtOSy5NcJNdZyUWHnuQ6Lbno0JNcpyUXHXqS67TkokNPcp2WXHToSa7K5Ipuz5J4I/I1uVY69CTXaclFh57kOi25PMlFctUmV1r35HrC/UguWhEkV21yebvfuW7xHyQXBT3JdVZyBR5ck1y1yZXWDUhM4Si5eHBNcj208ft2s6s3y0G6eNKFdPl+uvBwmXT5Qbrg0UiXJ212S7+m5eAxSuABMOnyg3ThkS7p8qRNWPZ0sSUfZdxid3Xc8hcndQT8If3t72BK16/rztCsYTlYHCNOjfS9Ln33Wf5K31I0xqd1D96neNB/T3SxSN/q9DV2f3Fn1oO7Y+LuSHqdmF6e9CK9zksv+mSk14npRV+N9HqhTTxIF/pqpMsP0oW+Gunyg3Thu1Kky/fTJfNzBtLlB+nCDxRIlx+kC11p0uUH6UKfhnR5aJP3M0HWnNaDdKHvQrr8IF3ou5AuP0gX+i6ky+OFl/3rb8GYo9qFvgvp8u10WRf6LqTLD9KFvgvp8oN0oe9CuvwgXfh2H+nyg3TxpAvp8v10oatLunw/XQy1C+nyeGHj454uBztsrIbahXT5Qbp40oV0+X66ULuQLj9IF55Iky4/SBeeSJMuP0gXnkiTLk/psl8d7F9+lvb16mT9liXJBvsIOn3kFo+vya2TcsvyrJvcOiu3eDBObp2VW3Siya2zcou2Nbl1Vm55covcqsstE9Z9A/zb30/ZtbchLD1x0uvE9KKHTnqdmF703EmvE9OLHj3pVZ9e0TzSKx2kl6PdRXpVp1dIfk+vuBx899LR8SK9qtMr2sfiGH04SC+aXqTXienlSS/S67z0ou9Fep2YXvS9SK8T04u+F+l1YnrR9yK9Tkwvvp5KetWnVwqP9HoCvqeX5xuqpNeJ6UXXnvQ6Mb3o2pNe1emVlv1k3JCMOUgvuvak14np5Ukv0uu89KJrT3rV115PX8hJxpaurziWfm98rGvOB+nLUwHSV3H68tSB9FWcvjzVIH0Vpy9PTUhfvem78lSG9FWcvjz1IX0Vpy9PlUhfxenLUyvSt+P03R9brGFZDtLXk76k72Xpu8/yV/qWojE+PQTyf339e/rSeSB9+03fNT3SNx58oyrQeSB9FacvnQfSV3H60nkgfRWnL984I33r03d9+rZ/OEovvhFGep2YXnxji/Q6Mb34RhXpdWJ60Xckvc5Lr0hfkPQ6Mb3o25FeJ6YXfTXS68T04hs3pFd1eqWd9+3v9WBv6uhJL9LrvPSia096nZhedO1JrxPTi6496XVietFWJb2q0ys/vhwfcvBf0yvRViW9TkwvGhOkV316hcfimGM+SC8eaZNetekVrdnPZLv9vX5Nr8xDIdKrPr1W90ivdPBDw8xDIdLr8cJ2jXt6pfgHV9+Ti8qL5DotuTzJRXLVJZdJ4fGzj9vfB64x80CI9DoxvXggRHqdmF48ECK9Tkwvel6k14npxfNG0uu09AoLzxtJrxPTi4496XVietGxJ71OTC969qRXdXpF8xA+ruYgvTzpRXqdl1507UmvE9OLrj3pdWJ60bUnvU5ML7r2pNeJ6UXXnvQ6L70MXXvS68T0omtPep2YXp70Ir1q0yst+3FnKZnlIL1wjqRXdXrlp7tXdkd3L5zjSekVvd/Ty3+++k4eU9WIvMVvtCJPKd6KPN8taUWer120Iu8hfxL5+Cidozkgz8P6VuR5jt2KPEa9FXk8bCvyeNhG5B31/Fnk86OqzOGAPLXNSeST3zqhNq3ugDy1TSvy1DbH5O90qD/e0aFGeEPH04t+R4d+8Ts61IDv6Mzcd812/1qBzTkW1v+wPLaefKp40/pB0kNSiOTM3kGW5MxeQJbkzLW9LMmZfYAoyXXmuu+HJPeHoOHp26kPkqzd3yYZHl/aSwckJ167nYsbG+P8agskzS2YfTMKk+Lja63hsOO62L3jau3TtXfuE6/0TblPXBc05T5xFSHI/c5y4t6jNMswcadSnOXE9a04y4m7oOIsJ+6ZirP0sPw+y/23WMbkxbytn7KJW+TZPP0GauOOT2vDHZ/Whjs1bhPukbrjJO5298fZ2vSFOzVKG+4e7k24U88cc7/Toep4R4ce7js6dFrf0aGufEMn0Q19R2fm/uZqHnTWp77Qg87MzqFMZ+b6vkzHQ+cNnZlr5TKdmWvlMp2Za+UynZlr5TKdmWvlIp08c61cpkOt/I4OtfI7OjPXyrf7yk4nms90Dl7d5u0r586Zx/FoH13W7CEpRHLmGlyW5Mz1+g9J3q7fSX56Vvv1Wm926t6aL89188w+oB31mf3FJ+r2aJ2f2V/c3NUTna878sSZT/120ZkHndX80YoTZz7gWpjkzL5FluTMHueHJMXW47h4qDegPrN3+kQ9mIN1fmo/9Dgm5EbHHtCZ2Lf4Je5xe+P/bPeBOPNpmsIkJ/YtsiRnPiNRmOTEHkeY5MQeR5jkxHXfT0m+3e8mznye2U9Jvt3vJs58Ppl3bu/IeveXXcC/Xm9j3F799udff8ERZz5vTJjkzGu3LMmZ1+6fkTQxuH2eMfivLCfuUIqz9LAUYzlzVSnNcuLeozhLKsvvs4yPXWZuf+e/spz5HKCfs4zpwTKFLyxnXsf9g41frf/E8k5n5pW5TGfmtbZMZ+bVs0xn5id3ZTozd/TKdGaupYp0Zj5d6Rt0Zu6mlenMXFkHv3/n1ofkSpX12+vvNGeureVpemgK0py5dv8ZzRuILXDrlqcnjCl/sJy50pdmObMvkGY5s4uQZjmz5/gDlsZ+ZbnO7FCkWc7sZ6RZ4n6+zdLtVtK6vH5ieXD129N/bk974N6Eu4d7E+54Lwnud5Z4LzmWeC85lngvOZZ4LzGWM59oJ84S7/VtlqvfpmnX59857yzxXnIs8VNyLD0sxVhSX4qxjKzj32V56+fb/dWfr95Zso7LsRxqHXd+Z3m7fRWuzmGbo1mWR9PH3jDd0Qy1LMuiGWqVlUUzVLPwR2iedkH89WXzp1uT+WAzVPNPmM1QxZYwm6Gac8Jshmq2ybIZ6wA0YTZDFdHCbOYtists5q2Ky2w8bF6yoS5+zYa6+DUb6uLXbKiLX7OhLn7JZqzDzoTZUBe/ZkNd/JoNdfFrNh42L9lQF79mQ138mg118Ws289bFfjHbXlzeeH/AZt66uMQmjXVIlzCbeetib2Le2eTlE5uD1357VFQa69CthhznrbdlOXo4fo+j2BFaaawjtJQwn9dLeOv2td0+bbN+zNynvL22z9YWrl7j9tJrfsKXPqDPa1IaQp/Y/bSDPrGtagZ9rAPHtECf2Aj+DHpeH9BD/mqpxzqbrCnJic3gD0nm/bO92IM2j/GQ/C5Ju5P06YDkxCbvpyT3sJc1HJDEukmRxI9JkZzYZLl9tyTv/sLmZ1ffSU7snGRJjnWGY1OSE3ucH5E0Pu4/h1zN8++Lj+J+f8JwGuu8RzXUJ/ZODal7qDegPrEna0h9Yv/WkDp19SnU/XZxWM1X6mOdddkP9bC9dAjpgDo1zDepr2af5Or8J+p3kh6SQiSpNaRIUj9IkZy4//vD1WkP+0ZyLaxOt2CTfwSev3z5bKzzQRVxpwZuwn2sM00Vcadv3Yb7WK4vbVc7b9dPV99nO1Rlm/bvFrm8+IPZjrR2e7Nf7U0OX2c71Plktw/5/sw/muVgtiN9bsuzHalLUp6tH2m28fHtlbQshavTPsdbBbxf+2uL2q/X5v1mn/Pna+8UR7rXt6M4UgejHcWRuhftKA5VzzSjOFJnoRnFoU63akdxqJq9GcWhvEAzikN5jGYUPRQFKOJdJCjiXSQo4l0kKOJdvkXx/RlFKWBeJDAOdaZfQ4zYFxGM+BcRjBgYEYxD1d6lp6ZDHWxXnu1QtWxxtkPVnHbZd1KxPh3MdqjSsDTboQ6IK892qEKrONuh6qHibIcqW4qz9SPN1q1b2N4/1VLHV4ew/+ovPQo6az92LhjqmDVZMkPVaKJkhqrn3nwv7MDG7PsiGpOfXnrd0AxV/ImiGesQsdK3gMc6Fqw426G+z16c7VC/Hs77bwBdDqWrTdxWBru4QstH8DnOWAeCqSA+1G82VBAf6lfLfRAvNJ3HOhNNB/KhftmsA/lQP2rWgDyPdTCcDuRDGS4dyIdyfXnfX8obX2p22Oi2X4/b+Hws1RIPoa9bIyUt0X+6+k5yLEfZkqSHpBDJsRzgiSTNvsVfsiYckBzL2bUkOZZha0lyLB/WkuRY9qohybGOZ2tKciwz1JIkHkeKJB5HiqSHpBBJPI4USTyOFEk8jhRJPI4USTyOEMmxzlxrShKPI0USjyNFEo8jRdJDUogkHkeKJB5HiiQe55skwz7JFJM9IInHkSKJxxEi6fA43ySZwxZJyskckMTjSJHE40iRxONIkfSQFCKJx5EiiceRIonHkSKJx5EiiccRIjnWiYVNSeJxpEjicb5HMi92+bg6L8+nOe4k8ThSJD0khUjicaRI4nGkSOJxpEjicaRI4nGESK54HCmSeJzvkox5I/n79b6QxONIkcTjSJH0kBQiiceRIonHkSKJx5EiiceRIonHESI51InSbUnO63Hc40wgZ1MokDTxEUkM/jnsO8h5LY4wyHkdjjBID0gZkPP6G2GQ89obYZDzuhthkPOaG2GQ83qbH4LMebvaLksh7LAs2yOKsJiv1Ic6m7ob6mveTdMxdTzTd6nvZ/LYxdn3Yfun0wCffp72K6SDu1E2j9tRto+wbU4fIuHHFIiE11Mgkkek/kXCoyoQCf+rQCS8tQKR8O0KRKIn0L9IiRaCApHoOCgQiY6DApHoOCgQySNS/yLRcVAgEh0HBSLRcVAgEh0HBSLRcehfpEzHQYFIdBwUiETHQYFIdBwUiOQRqX+R6DgoEImOgwKR6DgoEImOgwKR6Dj0LpJfFjoOCkSi46BAJDoOCkSi46BAJI9I/YtEx0GBSHQcFIhEx0GBSHQcFIhEx6F/kQwdBwUi0XFQIBIdBwUi0XFQIJJHpP5FouOgQCQ6DgpEouOgQCQ6DgpEouPQv0iWjoMCkeg4KBCJjoMCkeg4KBDJI1L/ItFxUCASHQcFItFxUCASHQcFItFx6F8kR8dBgUh0HM4QyW3HsviYPol0h04HoQF0OgLfg27NPklrniK5H29zA+kBKQMSZy0EEvcrBBKH+l2Qzu0gcxYs2VxO2xS9MfvVbl/G8KfdS4Q77V0ijzftXiKcafcS4WO7lwjX271EHol6lwinfoZE7xt2HlffAPpQ9tKlHaO366er77MdyqmVZrsOZXqKsx3KP3j3mG0MhatN3Jaz21OT/Vqb3MG1aeeRXC5cm3fkOX++9k58KDuggvhQ1b0K4h7i0sTDdq1ZFnuAfKjiWwfyoUpvHciHevSmA/lQXkcH8qEMlwrkYSjX9wb5fbazuL77bGdxXPfZjuV20tagdsmb0s3Dpv1T7px/XG2Ww9e2607Sh09X30l6SAqRHMuctCQ5luc4keS6f6nfrWk5IDmWlWhJciyH0JLkWIV/Q5JxrHq+JcmxvEJLkmP5kJYk8ThSJD0khUjicaRI4nGkSOJxpEjicaRI4nGESCY8jhRJPI4USTyOFEk8jhRJD0khkngcKZJ4HCmSeBwpknicb5LMbv/Z3JLTAUk8jhDJjMeRIonH+R5Jbx8k7WoPSOJxpEjicaRIekgKkcTjSJHE40iRxONIkcTjSJHE48iQNAse57skY95Iur+Q/NnVd+44ojbc8U9tuOO2zuBu/L5pkVnNU9zpaJZh2X7gGOzT7zvS+qGRR6PuNcIh9q8R3rN/jXC1/WuEX+5eI4OP6UAjv10cVnOgkUej9hoFu2kU0oFG1HWnaLSaHcn6/NopfHCnVmvDnfqrDXdqqjbceWJxzhq8T/LGfS2swbepPULJNsf9+g+VLE9DNKiE59CgEk9aNKjEcxkNKvl5VXIPkuFpW84X3N9cfSc5sc8WJjmxcxYmObEX/hFJa5ftaBzr3cG3DOzE7laY5MR+VZakm9hTCpOc2PcJk5zYmwmTnNg/CZP0kBQiiceRIonHkSKJx5EiiceRIonHESLp8ThSJPE4UiTxOFIk8ThSJD0khUjicaRI4nG+SXK129V2PfqNo8fjfJOkd3knGZbC1XJnQxuPd+pdITxZ5wqteL3eFcJD9q4Q3rR3hfC8vSvkUahzhfDovSuE9+9dIXoKvStET6F3hegpdK5QoKfQu0L0FJorFPbfiC2LPZCIpkL3EtFV6F4ij0S9S0RfoXuJaCx0LxGu6JsSrSHuEuXyTkB5cduLr/lpX7iP3/JHvTXAPX69C+Q9/s5Xj+z29MneF17axrAFYmN0zy99n2zn92HZyXbeK5WdbOdtR9nJdr5WiU42dd4Mk51s530l2cl23qGRnWzndc4PJ5u37XttMv7rZP1Mkx2rgipMdqQKytklP8KOXyc7UgVVnOxIFVRxsiNVUKXJ9n5w908nu7yd7Ejr7K0xs72083b5OtmR1tniZEdaZ4uTHWqdLU12qHXW5bRP1izvX3rN+zaqa84Hd7OhFuWfkAnLfp8Py0Eh2vuZt5fkzBEZ2/sZtj+8dewPhJx/Os2n5tNkez9l9hIyxzkzUivG+Rh2Mjl9nexYJWJhsn6myY5VIhYmO1aJ+Jjs+vR8fp/sUCViabJDVX2lyQ5VyBUma4aqzZzdv2Wymlh46ZC2et5E//S1Eb98oBmqBIlpd7wxuz8rW81Q9cpPyBRMoO39KM9LcuaYzFCV0OOl3V8eSh289JL3lzZuObjRDFU3JbuHnXLhpf2y3a+9/XwHPgjj0ZIwt/bdfrXbMQ5VkbXDOFSt1w7jUFVkM4y9n/ioBeNQjcZ2GIeyBO0wDuUffoTRbfbBx/S1Euz9HMF2YPi90q/XvvrHMJaj7xpxZ9OSNtz50d1J3J1/cH/anDm8uNo+XR3+qhJH9qlQiS1JNKjEriTtVfr1vbrdXpn4RSO2JelfI49G3WvExiT9a4TT718jugL9a0QHoX+N6DZ0rxFHZyrQiE5D/xrRZ+hfI/oM/Wvk0egkjV71SQ9eO7n9W/UmhNJr532WN0GfZnnLhLum9CXG05Q+Rt+a3lWik6FBJXoZV6v0m/vMB1XatJdszvkCSW/3H794txa5+/goB5++g2LS4U+O/HZxePpR/W3uHxpN7Kv60Shu/MJNl68aTeyr1Gjk0ah7jSb2SWo0mtj3dKSR2TUKBxpN7HrUaDSx51Gj0cTPb/vRKGweNoT0VaOZj65UoxF9hv41os/Qv0b0GfrXyKNR9xrRZ+hfI/oM/Ws0lD9yftfIxVC42rvFPqg/P9M0f079/ROhOJTj6Yf6+75nHMrDqKE+lCtRQ30on6GGuof6KdTf9nh7P454UOpDVfdqqA/1XLAf6u9dUu8nRQ9KHW/agHrvZ2cPSh1v2oI63rQFdbxpC+oe6g2oD1WvL26nvuRSIMYHvz3WuP2dnn8ZYw+ut2vaflV7+/MJyu3vO8uhqvDGLIeqrduy7P2sdFUsh6qDG7McqrptzHKomvVclnHfSuP2QGQ5YOlhKcZyqGcfjVkO9USjMUt8jxRLt1BffptlyFvgtz/dAUvW8W+zTGm7/GZx1gOWrOPfZXlrQD1e3eYDlqzjcixZx+VYso5/n2W0+6unz2vPz66+k6fb2Yo8vdFzyIe07l+LT0878t33sroBhnsT7vRc23CnP3sS97xDCdnGL9zxgG24e7g34Y63bMMdH9qGO561DXccaxvu+NWzuD9+xp3XL9wtfrUNd/xqG+741Tbc8attuHu4N+GOX5XgfmdJTf5dlsXvjljqbDGWjtpZjiX18LdZfvqunT9gSY0rx5K6VY6lh6UYS+rL77O0D5auVNffKqTtVzS3Rcn/ta53PA9pw53nIW24471O4u5C3rmn5/7BT669a4Sn614jj1fsXyM8aHuN3p9L7zzetn+N8Mz9a+TRSECjO0u8+PdZPk4OjzEdsMRff59l2nvqMecDlnjmqrw8ZIkPlmOJXxVjuVIPf5tlWrdp3v48YkndKsfSw1KMJfWlHEvqy++z9PY9S9bx77Ms7EMz1vnRjVnSx5VjSX0px9LDUozlzL0N55adpcuhwNLEuLrt+tvfDywfveAwc29DmuXMNZEwy7FOmD2bZUwPlk+nrm0sZ66JpFnOXBNJs5y55ybN0sNSjOXMPTdpljP33KRZ4nvkWOJ7xFiOdfbjD1ku+4nqxhsfCyzD44fjq3nqbKwfJGeuLn9I8u1J9m6sMxqbkvSQFCI5c10pS3LmqvKnJM1OMhyQnLmmlCU5c0UpS3LmPvoPSb49vddNfbKnLEk8jhRJPI4USTyOFEkPSSGSeBwpkngcKZJ4HBmSfuaTPJ3bt6o0zq+2QNKYlPYuu8nL8+k5X6/OJm6RZ/NldwK/TFx9NuU+ca16LndrNijZ2q/cJ65sm3L3cG/CfeKquSn3iWvsk7k7s3N3+Qv3iSvyptwnfkbRlPvETzRacp/5RN6m3PGrbbjjV8/ivthHHZm+cMevtuHu4d6EO361DXf8ahvu+NU23PGrbbjjV5twn/lE3qbc8attuPt5udts911xbM5/9ssxP/OZoz8l+fa3Jd5OXGMLk5y4ahYmOXEdLExy4sr2xyTf/UrHz3wCrjDJiatPYZITP//4Kcn33/Sd+exbYZIekkIk8ThSJPE4UiTxOFIk8ThSJPE4QiRnPnHShsXsJONz4Ickby9pdihhLVxtY36cq/eXHcju5GeuP08ln+zWvrfJpQPyHvKNyM9c37YlP3M9fC75ZT/DLpl4QH7m+rkt+Znr7bbkZ67Pm5JfZ35m0Zb8zM842pLHw7Yij4dtRd5DvhF5PGwr8njYs8jHx1m48aB7sOJhW5HHw7Yij4dtRH7m06JPJr9HfiOfD8jjYVuRx8O2Io+HPYu8Tzv51R2Q95BvRB4P24o8HrYVeTxsK/J42Fbk8bCNyEc8bCvy1PMnkQ/7tgi3186lq71z29U+ucLVwT++pfzo/LtwNMuc9rN6l6cwji8Odt0ABptKL/1r54f9y9UpmeXT9ff08qQX6VWdXv4h/PPd65FeODPS68T0wn6SXiemFx6b9JJJr2AP0otGAun1B+nlH+kV19Kr5513yM/fRkoHFye7v3ayT5l7u/ieuPRhSFyNiZtoY5G4KhOXb7KQuCoTly8CkbgqE5fnLiSuysT1JC6JqzFxeVZE4qpMXJ5CkbjViZvtDvD2d/h0/T296LaSXvX3xfz4BlBeDr4BlHHopFf93cs8hM/OHKQXVR3pdeLdi9qL9JKpvdxRevENINLrxPTiG0Ck14nphXMkvU5Lr3Xh2zSkV316uUfDNnt/kF5854X0OjG96HuRXiemF98fIb1OTC9PepFe56UXXXvS68T0omtPetWnV+GZ47rQtSe9Tkwvuvak14npRdee9DovvQxde9LrxPSia096nZhedO1JrxPTi6496XViennSi/Q6L73oe5Fejxc2+9W3TFtK6RWt21883qZwkF70vUivE9OLvhfpVZ9ewT3SK+av6WXpe5FeJ6YXfS/S68T0ou9Fep2YXvS9SK/q9HLLrk68JcpBennSi/Q6L734tirpdWJ68W1V0qs+vfxTeq3rQXrRtSe9Tkwvuvak14npRdee9DovvRxde9LrxPSia096nZhedO1JrxPTi6496VWfXu45vcJBennSi/Q6L73o2pNeJ6YXXXvSqz699jn++jsfpBdde9LrxPSia096nZhedO1Jr/PSy9O1J71OTC+69qTXielF1570OjG96NqTXvXpFZ/SKx+cyuE96UV6nZdedO1JrxPTi6496VWdXt7sG49Hbw/2mPB07UmvE9OLrj3pdWJ60bUnvc5Lr5WuPel1YnrRtSe9Tkwvuvak14npRdee9KpPr+U5vQ5ORFs96UV6nZdedO1JrxPTi6496VWdXjY9dif0bi1d753Zr/eHGzatdPlJx+vS0a2PdFxN8fq07sH7FNNB+vIUgfS9Ln1X/0jfcOR8eepAOra5mx6lY+ApBenYUTryVIN07CgdeQpCOnaUjjw1IR2vS8cYHumY7Z878eBJX9L3svTNj7vpreV+kI48xSEdm9xNj9ORpz6kY0fpyFMf0rGjdOQpDunYUTryFId0vCwdvYmPdHTuz5145KkP6Xtd+rqnu6k/2Hk98tSHdGxzNz1MR576kI4dpSNPfUjHjtLRk46kYz/pyFMc0vGUdLynF09lSK8T04unLKTXienFUxPSqz691kd62XSwvWTkKQjpdV56JZ5SkF4nphdPHUivE9OLpwik14npxVMB0uvE9PKkF+l1XnrRtSe9Tkwvuvak14npRd+L9KpNr5DD/kg75Ji/plem70V6Vd+9lofwt7/DQXrR9yK9Tkwv+l6k14npRd+L9KqvvfLylF72IL086UV6nZde9L1IrxPTi74X6XVievFtVdLrxPTi26qk14npRdee9DotvcJC1570OjG96NqTXiemlye9SK9dG+Pypo1JvnB19GF77duf+SC56HqRXKclFz0vkuu05KLjRXLVJlcwm+4x2HiQXPS7SK7TkotuF8l1VnIZel0k12nJRaeL5DotuTzJRXJVJteatiyJaz5oohrcIslVm1wxb0HH5MxBcuEWSa7Tkgu3SHKdlVwWt0hynZZcuEWS67Tk4reMJFdtcqXV7Ml1cJp7sPySkeQ6Lbk8yUVynZVcfJ+L5Dotufg+F8l1WnLRoSe5TksuOvQk12nJRYee5DoruRwdepLrtOSiz0Vy1SbX8/e5jjr0zpNcJNdZyUWfi+Q6Lbnoc5FcpyUXfS6Sqzq5wv6tiBDT1+TyfCuC5KpNrrjzi9H4g+TCLZJcpyWXJ7lIrrOSC7dIclXXXDk+kms9SC7cIsl1WnLhFkmus5Jr5dkiyVVdc+1HMd7+PKi5Vn79Q3JVJ9fTr3+MK1xtfFr3UHw66out9MVIxtpkTCbsyXjU0V/pi5FcEne6w+TyJBfJdVZy0RcjuU5LLvpiJNdpyUVfjOQ6Lbn4tRDJdVZyBfpiXSSX9RtCa+Py6eq7TrSMutDJ2e21rfPuQCe6Lzp08uikQid6An2sT+mh018iueuEvdahE05Vh06YPh06sduCCp0iXy7SoRP9CB060Y/QoRP9CB06zeyflvWh023GRZZL2nul9qlXmtIHy5k9jjTLmX2INMuZvcJPWfr9YZtd3SeWB7HYvJF37ukXd+HOPc1c+7fkPnMtfyr32+PbnXuKT9x/cu1do5nreC0azVzDa9HIo1FzjbzZ1yNvzVeNZn6WqEUjfHD/GuGvv62Re3yvy8WloNEaN0HX/ATwwz4mrHgT7Lj2Ftgzpr0Jdjx7E+zY8G9j949HKf751Q+x3+4j29W33I7P4L9enKzfeCcb7FeVMOIaVPKopEAlzLgGlbDjGlTCkGtQCf+uQSXsfv8qxQW/9G2VVru3iVe7flLpzpJK7Pss/f6lv3VdDlhyj/8+y/1yu4Z0wJI7sRhLQzdVjiUtUon7ZcXd1bDqtyJP5/Mc8iGtG8Lbc/XHBi3hg7uHexPu1MRtuNNvPIl73qHcHjbGL9zpILbhjl9swx1v2YS7xYe24Y5nbcMdx9qGO371LO77g5mQ16/cPdybcMevtuGOX23DHb/ahjt+tQ13/KoE998s3cQ1ubmtWNuLm7yUdrE3Pm5QzGqef2J4FHl4pPBqnq5dP7hPXJOfyz3uViitB9w93Jtwn7gmb8p94pq8KfeJa/KTue9fnP31379wn7gmb8p94pq8JXc/8TOkc7mHx5lV6YD7xM+QmnLHr7bhjl9tw93DvQl3/Gob7vjVNtzxq024ryPV7zY/ttVbzFLiLtlPX0eqx0/l+L5vtY5UX7fkOFK93JKjh6MIx5Hq2XM5vu23rSPVpy05jlRvtuQ40vOOUzkW6vCRnl805BjwMzIc8TMyHPEzMhzxMzIcPRxFOOJnRDjGQ44m7of3PbVDbXIHb5B25MnlwrU5bVRy/nztPZjQUzCxp2BST8HkjoI5Ps+wVTCmp2BsT8G4noLxPQXT0x049XQHTtfegcO+qi6LPYgmdRVN7imavHQVjekqGttVNMd3G5/zXlKu9n1tm5btU5v8U4ntl493CKe/Qzz9HdLp75BPfoe0LKe/g/nzd1g3B5Zi+PQOBy5pyZuVsWZ5XO2PvqSR0rbPcza29MIub/O0fnk8PHP7RO0sE3WzTNTPMtHy/T5+muh9VKgaFWtGGXP2fcrY09/Bnf4O/vR3WE9/h3D6O8RJPtYmzTLRPMlE7TLLRE3NKmFt1ShXM+rF3gx2PwfaOfPYeGMb5GsGrTWDjr+C9IMjrV9fe3+DePYbpLPfIP/pG7w/9Tu9+Nml4BuYs9/gUAN7e+yxfXpvDx2+DMoVg46/4l4a9OIu8ZNHX7crPi5en58Ffjz6Sqs9/y3c+W/hz3+LVfQt/HLwFuH8t4jnv0U6/y3yn79FWLYbQ7Bfv1KYwnL+W5jz38Ke/xbu/Lfw57/Fev5bhPPfIp7/Fun8tzj/0x3P/3TH8z/d8fxPdzz/0x3P/3TH8z/dUeJz8fbXfSlJZNTbL0KlF9+WWM3+FbHV+U9vcR/m6ob5umFr3bAX99/9C223YWsBn8k27bSzzV8MxYun9cJvkq54k3zBm7x4ZC78Ju70j2aWuIe9/e1ayuv5bxHOf4t4/luk898in/0WeVnOfwuJ9eTtD7PyYs9/C3f+W/izF968rOe/RTj/LeL5b5HOf4t8+luY5fy3MOe/hT3/LQ6Tdl23rumanis9+zEo1gxKNYOOU2WJ+6x+/Z3/UpHkF4+5lpj3Ena5PSj+MszUDbN1w1zdsOOb5XJ7oPQY9rQJ+zZsrRsW6obFqmHuhW75sR39koP5MuwFyZy2bemNWZYvJJ2vG7bWDYt1c0t1w158cHJ2T0Gufx3ml7phpm6YrRvm6ob5umFr3bDjD87t0vwYZp+z5O8/z6nj/bSk3yRd8Sb5z9/k/bPIfPyEUPYtzPlvYX/6Fvdhrm6YrxtWd4t88XyuOCzWDUt1w3LVsLDUDTN1w2zdsLqFNNQtpC8edcR1v7HG+Pwz1aNPi43L/g2jaO2Xt8inv8WLRx2ib2HOfwt7/lu489/Cn/8W6/lvEc5/i3j+W5z/6Y7nf7rT+Z/udP6nO53/6U7nf7rT+Z/udP6nO53/6U7nf7rTjz/d92G5alhe6oaZumG2bpirG+brhq11w0LdsFg3rC5Lck2WrMuy1A0zdcNs3TBXN8zXDVvrhoW6YbFuWKobVpclpi5LTF2WmLosMXVZYuqyxNRlianLElOXJaYuS0xdlti6LLF1WWLrssTWZYmtyxJblyW2LktsXZbYuiyxdVni6rLE1WWJq8sSV5clri5LXF2WuLoscXVZ4uqyxNVlia/LEl+XJb4uS3xdlvi6LPF1WeLrssTXZYmvyxJflyVrXZasdVmy1mXJWpcla12WrHVZstZlyVqXJWtdlqx1WRLqsiTUZUmoy5JQlyWhLktCXZaEuiwJdVkS6rIk1GVJrMuSWJclsS5LYl2WxLosiXVZEuuyJNZlSazLkliXJakuS1JdlqS6LEl1WZLqsiTVZUmqy5JUlyWpLktSXZbkuizJdVmS67Ik12VJrsuSXJcluS5Lcl2W5Losqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qup672aut6rqeu9mrreq6nrvZq63qt50XvN+zcMTfbmYNiLLNm39DM520/DjrbyFToo5BZO7Cuc1Fc4uatwXvW2W4Vj+grH9hWO6ysc31c4a1/h9HVXTn3dlVNfd+XU110593VXzn3dlXNfd+Xc1105X31XfnvG1S2etbN4QmfxxM7iSZ3Fk7uKxx4/wbW30vVjmLVmLcRzc+jLHn6If9294PYm5oo3sVe8iRN5ExcebxLc05sc/CIvuW1jILc87/u0HG+nuux7ri3u8dv7bD/i953Hv+78w+rc1/hX5fEH5fFH5fEn5fFn3fGbRXn8Rnn8Vnn8va+/pfiVr79G+fprlK+/Rvn6a5Svv0b5+muVr79W+fprla+/Vvn6a5Wvv1b5+muVr79W+fprla+/Vvn665Svv075+uuUr79O+frrlK+/Tvn665Svv075+uuUr79O+frrla+/Xvn665Wvv175+uuVr79e+frrla+/Xvn665Wvv175+rsqX39X5evvqnz9XZWvv6vy9XdVvv6uytffVfn6uypff1fl629Qvv4G5etvUL7+BuXrb1C+/gbl629Qvv4G5etvUL7+BuXrb1S+/kbl629Uvv5G5etvVL7+RuXrb1S+/kbl629Uvv5G5etvUr7+JuXrb1K+/ibl629Svv4m5etvUr7+JuXrb1K+/ibl629Wvv5m5etvVr7+ZuXrb1a+/mbl629Wvv5m5etvVr7+Zt3rr1t0r79u0b3+ukX3+uu63/+qFL/u9dcp3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yinf/8op3//KKd//yivf/8or3//KK9//yivf/8ovutdfr3z/K9/9/lePlw4xm+f4jy7eog4pPF44rR9z7X2tlpxr7+u65Fx7rwEE59r9fl2Sc+29tpCca+d1yJrX9JirfT9XH/MWh08u7RfbnA7DNnGP2vn9aufyB5vOa5ymbDxsXrLpvDaLq7cfV8ewhPdsnNuudf4p6KNL17BuIa9xebr4V/33Neac91delvTp6jvGzktELRg7rz61YOy8sNWCsfOaWQnG3rfv04Kx80pfC8bOTYQWjJ37DS0YPRglMOJiRDDiYkQw4mJEMOJiRDDiYiQw9r4JqhaMuBgRjLgYEYy4GBGMHowSGHExIhhxMSIYcTEiGHExIhhxMRIYe99KWgtGXIwIRlyMCEZcjAhGD0YJjLgYEYy4GBGMuBgRjLgYEYy4GAmMvW/IrwUjLkYEIy5GBCMuRgSjB6MERlyMCEZcjAhGXIwIRlyMCEZcjATG3o810YIRFyOCERcjghEXI4LRg1ECIy5GBCMuRgQjLkYEIy5GBCMuRgJj74dDacGIixHBiIsR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",
      "brillig_names": [
        "discover_new_messages",
        "decompose_hint",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkAAAAA//////////8AE4f8NrKrWywznQqG\nhzXI476Hddj4NUP/TXEjxCHPqi8aohG26mIbtUEIA4CoaZuS8vrwUHJlOScer6LBPT8QPy+hxXG7\nEmIyvrBcHsrSJDADpEvOoHdc32GFmriQ5PocAlP4F6fwKkPADIdFgulYSmGcSMwCWtSmToDRq7t9\nB6YuSDUjWIqhd8t0dZvhoGGI9I2la+2Lc37LBckeP0XTNy4+LwHZRb79MXOSMoZxfww3Fmah3la1\nK50J1ep8pafrCb9zjZ+v9heZnhwHVylr7GGssEqV2Cpkv+GHpPi3yWks4mtrdLxRkKzWmvnbHU/q\n9UtyETriuXFSwVO1mVJHqR0szhtOUVPKeBfSNYi6LY8bXvTIn6yX0BkjgqDhN0eYCFbAw64q067o\nrWeYms6AsvkMC9wBgy05/Kefvc2DbK4c7ytIBkglgkuERK14E/E17at+zRDP8aBoxT7WLMrB4w8H\nqwWpgW28thKFI19Xi+A6KGCa8v1pSZkHTvw8SNTjIuSmLVifXcWOAD4X0sKeZqqcjXq3WBuYEO2n\nPlPhfd8OP4PTyf+mJHwLpRXOLm9SrLCVbfb6d5ltuCSwof5icAWAOdGTIloJDBxD6rJm2uBK2eUa\nTtY3AGgmVXq4Em0rBT5bIVQbAIXof+fe3dWp52EULvP6uuwTnmbsSVeRCscXVRLx5rt1bzt2/3ZN\nuiNTS0jbSg4dwtKxKE/JF0O7jhzb0JzBg38Kgqd5EoIDcgMmTlsD6seM9pFQr1CC0z8rFBJcRAuc\n+FPnUAAcQeyOoMwNNP5lXcyJjU+f46Opdmwror7nvog5DaBlqdEFoPk5kVppnlK/yLlA6mj0g7rC\nNRxQB88rrhfp0vxeXOODJDgDisdO9pvUO73UKqpQJKv+BlgGiTOf86hGeVae2tgwKINa6VLDSfY6\nzW4e+dRuXDAUoX18ClXS1F7o7fbsFlwRPSgrmEfVYv1BQCIOR+GCrxpw0tC/U/KBmNxua015bsn0\nE4YWuRKVxKct3D6sKlhhBKPAVJbx4iZbVFCwXy6Z3gl2josHROSNZhQ03gkdW9UCi+FP3Kyr+6Fo\nkZdNqBbVLtMYmiA76El/6KK/jec6AAo+N1hCM0U/IGtFlmhdw4XZX9/p6CDpwqNN1jIzommpGCYF\nRBjTTOrkbvKJMks2ABCotQaHcKFM6o/+Gzp8vYgNhURjv9vYcswQW2bE1v74S5CaRIeFajSKHfcz\n2Sp/Xg8+MgllV7fA7z6gxGrIludoPLyr0h0GM94s0Zp9IBpZI70PNNRfEb0IQqZ+ZM57uLw9Zz+X\n1pT/qULt3AlhwzoH9XRzmxhn4Rpv455FoEj2HC5L7GVXnF3oRyxXHgAsnS1xlZ1eHhzmKNEgubEU\n277/mgkIUjFHnTgLeLkVl2r7D6tyuwOu/Ptk5tR5ovb1HhxfAc4xpdZuaLDyjH8SExUOjQN5iecz\nZJVCxMrGhWlOkIuU8ncElWaaJJ6qUggRZwinH0cWVmdNtG21S4BO5g8wg7X0FZKDr4CGX3FxxnQ5\nJ5iqUkWOVFyelZ73X5IHfMiKZUjUdpS2o1Cv984dywUW1P9JxLgKfWPS2RvBQ08JlX0rCPlfITV4\nSm74gB+FkCXBIRfYeDypHQwN5gfltbMWPntHV1/2leJZJ6/v3t+SF2QB+ai4mEmpAfJHIt58gRN0\nXxEygK9gfxFj5oR3t4kiDyCPt4eNqJGCy8wFckbiMdiCrhEFWVEj97F9BnhYUAUi4f3ZjK/ZCBat\nmp1bWZjNMEtIyqbV9R7Ov7ERtpu3ADJ7hsGRbllkv31CHD4+T2ATNeS8Wl3VEJxLtZ9LedYFs1HZ\nbS5URkPB+lK+1KYScD9b03Zif5VJ4xGYyjP3FSTWvHWd/IyUcPmmHlCqR1Gc+Wlcp8yPYCr7/6iW\nKoxoFrrWO/J20yopZbBGS4Dg+XBj6s+1vuEvoTj1TED/XgsF+d37hYhDIQ+I3KPgKkXzd0fli04q\n3pCfVR6ykxCzmCGxPS1MgeUKgMU302ghQxecbQNrEFnEE0rNRgN5dQ5GFsp+JZndkmQspDVI1R+c\nnjdbR1FZXbc42Iv5BABlXYMpH/2Vm8T6LK0gU+xDvqefhWipXhrCZPJbmhQZIwSMyw7WXkKxGe9B\nZzEuX3hU5Wfta0fJKZOa4pIPLxgyKlSwAvnkq7aZzHvUUQk6+5Otfh5qJJR1B4gKxHentAPG7qEA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAACCvoo6rtcp8yNqsI17MHPtT0xwmc38cDD/iaaYV8VmiwNS9DTUM4kISxrrTu0rJrfhq5Z\nPvjaw7YL6WvnfXhn4ADENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMk\ngqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJiS18GKk8\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "deposit_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "deposit_public"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "951653053333916160": {
            "error_kind": "string",
            "string": "Deposit cap exceeded"
          },
          "1602191554767750373": {
            "error_kind": "string",
            "string": "Function _borrow can only be called internally"
          },
          "1840251649407153602": {
            "error_kind": "string",
            "string": "Insufficient borrowed amount"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4270187767586857285": {
            "error_kind": "string",
            "string": "Function _compute_total_collateral_value can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5235018679007078561": {
            "error_kind": "string",
            "string": "Invalid asset or market id"
          },
          "6787403583199288031": {
            "error_kind": "string",
            "string": "Insufficient balance"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8945853978429536226": {
            "error_kind": "string",
            "string": "Function _compute_collateral_debt_value can only be called internally"
          },
          "10435052277855889085": {
            "error_kind": "string",
            "string": "Function _withdraw can only be called internally"
          },
          "12348881442450494403": {
            "error_kind": "string",
            "string": "Function _compute_utilization_rate can only be called internally"
          },
          "13135008234568508716": {
            "error_kind": "string",
            "string": "Function _repay can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14434150440419769526": {
            "error_kind": "string",
            "string": "collateral >= debt"
          },
          "14687457983715723088": {
            "error_kind": "string",
            "string": "Asset is not borrowable"
          },
          "15333773746166717806": {
            "error_kind": "string",
            "string": "Insufficient collateral"
          },
          "16022896159229267359": {
            "error_kind": "string",
            "string": "Function _deposit can only be called internally"
          },
          "16523063005220065570": {
            "error_kind": "string",
            "string": "Function _liquidate can only be called internally"
          },
          "17134621154673181869": {
            "error_kind": "string",
            "string": "Function _compute_borrow_rate can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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IwAAjQULKAAMgEUABSQCAAUAAIy6JQAAx64tDAEHLQwCCC0MAwktDAQKLgiAaAALIwAAjQULKAAMgEUABSQCAAUAAIzqJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAaQALIwAAjQUtDAoELQwHAS0MCAItDAsFLQwJAyYlAAB/AC0IAQsnAgwEBAAQAQwBJwMLBAEAKAsCDC0MDA0uCoBIAA0AKA0CDS4KgEgADQAoDQINLgqASAANLQgBDCcCDQQFABABDQEnAwwEAQAoDAINLQwNDi4KgEgADgAoDgIOLgqASAAOACgOAg4uCoBIAA4AKA4CDi4KgGoADi0IAQ0AAAECAS0OCw0tCAELAAABAgEtDgwLLQgBDAAAAQIBLgqARgAMLQgBDgAAAQIBLgqARQAOJwIPBBAtCAAQLQwNES0MCxItDAwTLQwOFC0MBBUAEAAPACUAAMV3LQQAACcCBAQPLQgADy0MDRAtDAsRLQwMEi0MDhMtDAYUABAABAAlAADFdy0EAAAtDQ4ECygABIBFAAYkAgAGAACORScCDwQAPAkBDycCBAQPLQgADy0MDRAtDAsRLQwMEi0MDhMAEAAEACUAAMagLQQAAC0NDQQtDQsGLQ0MDy0OBA0tDgYLLQ4PDC4KgEkADgEoAAaASgALLQ0LBAsoAAWAWQAGCygABIBIAAskAgAGAACQryMAAI6zCygABYBgAAYkAgAGAACQhSMAAI7ICygABYBhAAYkAgAGAACQWyMAAI7dCygABYBiAAYkAgAGAACQMSMAAI7yCygABYBjAAYkAgAGAACQByMAAI8HCygABYBlAAYkAgAGAACP3SMAAI8cCygABYBnAAYkAgAGAACPsyMAAI8xCygABYBoAAYkAgAGAACPiSMAAI9GCygABYBpAAYkAgAGAACPXycCDAQAPAkBDAsoAAuARQAFJAIABQAAj3QlAADHri0MAQctDAIILQwDCS0MBAojAACQ2QsoAAuARQAFJAIABQAAj54lAADHri0MAQctDAIILQwDCS0MBAojAACQ2QsoAAuARQAFJAIABQAAj8glAADHri0MAQctDAIILQwDCS0MBAojAACQ2QsoAAuARQAFJAIABQAAj/IlAADHri0MAQctDAIILQwDCS0MBAojAACQ2QsoAAuARQAFJAIABQAAkBwlAADHri0MAQctDAIILQwDCS0MBAojAACQ2QsoAAuARQAFJAIABQAAkEYlAADHri0MAQctDAIILQwDCS0MBAojAACQ2QsoAAuARQAFJAIABQAAkHAlAADHri0MAQctDAIILQwDCS0MBAojAACQ2QsoAAuARQAFJAIABQAAkJolAADHri0MAQctDAIILQwDCS0MBAojAACQ2QsoAAuARQAFJAIABQAAkMQlAADHri0MAQctDAIILQwDCS0MBAojAACQ2S0MCgQtDAcBLQwIAi0MCQMmJQAAfwAvDAAEAAUtCAEEJwIGBAIAEAEGAScDBAQBACgEAgYtDAYHLQ4FBycCBgQHLQgABy0MBAgAEAAGACUAAMfALQQAAC0MCAUtDAUBJiUAAH8ALQgBDCcCDQQEABABDQEnAwwEAQAoDAINLQwNDi4KgEgADgAoDgIOLgqASAAOACgOAg4uCoBIAA4tCAENJwIOBAUAEAEOAScDDQQBACgNAg4tDA4PLgqASAAPACgPAg8uCoBIAA8AKA8CDy4KgEgADwAoDwIPLgqAagAPLQgBDgAAAQIBLQ4MDi0IAQwAAAECAS0ODQwtCAENAAABAgEuCoBGAA0tCAEPAAABAgEuCoBFAA8nAhAEES0IABEtDA4SLQwMEy0MDRQtDA8VLQwEFgAQABAAJQAAxXctBAAAJwIEBBAtCAAQLQwOES0MDBItDA0TLQwPFC0MBhUAEAAEACUAAMV3LQQAAC0NDwQLKAAEgEUABiQCAAYAAJJkJwIQBAA8CQEQJwIEBBAtCAAQLQwOES0MDBItDA0TLQwPFAAQAAQAJQAAxqAtBAAALQ0OBC0NDAYtDQ0QLQ4EDi0OBgwtDhANLgqASQAPASgABoBKAAwtDQwECygABYBXAAYLKAAEgEgADCQCAAYAAJVDIwAAktILKAAFgFgABiQCAAYAAJUTIwAAkucLKAAFgFoABiQCAAYAAJTjIwAAkvwLKAAFgFsABiQCAAYAAJSzIwAAkxELKAAFgFwABiQCAAYAAJSDIwAAkyYLKAAFgF0ABiQCAAYAAJRTIwAAkzsLKAAFgF4ABiQCAAYAAJQjIwAAk1ALKAAFgF8ABiQCAAYAAJPzIwAAk2ULKAAFgGQABiQCAAYAAJPDIwAAk3oLKAAFgGYABiQCAAYAAJOTJwINBAA8CQENCygADIBFAAUkAgAFAACTqCUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGcACyMAAJVzCygADIBFAAUkAgAFAACT2CUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGUACyMAAJVzCygADIBFAAUkAgAFAACUCCUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGAACyMAAJVzCygADIBFAAUkAgAFAACUOCUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGEACyMAAJVzCygADIBFAAUkAgAFAACUaCUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGIACyMAAJVzCygADIBFAAUkAgAFAACUmCUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGMACyMAAJVzCygADIBFAAUkAgAFAACUyCUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGQACyMAAJVzCygADIBFAAUkAgAFAACU+CUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGYACyMAAJVzCygADIBFAAUkAgAFAACVKCUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGgACyMAAJVzCygADIBFAAUkAgAFAACVWCUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGkACyMAAJVzLQwKBC0MBwEtDAgCLQwLBS0MCQMmJQAAfwAtCAELJwIMBAQAEAEMAScDCwQBACgLAgwtDAwNLgqASAANACgNAg0uCoBIAA0AKA0CDS4KgEgADS0IAQwnAg0EBQAQAQ0BJwMMBAEAKAwCDS0MDQ4uCoBIAA4AKA4CDi4KgEgADgAoDgIOLgqASAAOACgOAg4uCoBqAA4tCAENAAABAgEtDgsNLQgBCwAAAQIBLQ4MCy0IAQwAAAECAS4KgEYADC0IAQ4AAAECAS4KgEUADicCDwQQLQgAEC0MDREtDAsSLQwMEy0MDhQtDAQVABAADwAlAADFdy0EAAAnAgQEDy0IAA8tDA0QLQwLES0MDBItDA4TLQwGFAAQAAQAJQAAxXctBAAALQ0OBAsoAASARQAGJAIABgAAlrMnAg8EADwJAQ8nAgQEDy0IAA8tDA0QLQwLES0MDBItDA4TABAABAAlAADGoC0EAAAtDQ0ELQ0LBi0NDA8tDgQNLQ4GCy0ODwwuCoBJAA4BKAAGgEoACy0NCwQLKAAFgFkABgsoAASASAALJAIABgAAmR0jAACXIQsoAAWAYAAGJAIABgAAmPMjAACXNgsoAAWAYQAGJAIABgAAmMkjAACXSwsoAAWAYgAGJAIABgAAmJ8jAACXYAsoAAWAYwAGJAIABgAAmHUjAACXdQsoAAWAZQAGJAIABgAAmEsjAACXigsoAAWAZwAGJAIABgAAmCEjAACXnwsoAAWAaAAGJAIABgAAl/cjAACXtAsoAAWAaQAGJAIABgAAl80nAgwEADwJAQwLKAALgEUABSQCAAUAAJfiJQAAx64tDAEHLQwCCC0MAwktDAQKIwAAmUcLKAALgEUABSQCAAUAAJgMJQAAx64tDAEHLQwCCC0MAwktDAQKIwAAmUcLKAALgEUABSQCAAUAAJg2JQAAx64tDAEHLQwCCC0MAwktDAQKIwAAmUcLKAALgEUABSQCAAUAAJhgJQAAx64tDAEHLQwCCC0MAwktDAQKIwAAmUcLKAALgEUABSQCAAUAAJiKJQAAx64tDAEHLQwCCC0MAwktDAQKIwAAmUcLKAALgEUABSQCAAUAAJi0JQAAx64tDAEHLQwCCC0MAwktDAQKIwAAmUcLKAALgEUABSQCAAUAAJjeJQAAx64tDAEHLQwCCC0MAwktDAQKIwAAmUcLKAALgEUABSQCAAUAAJkIJQAAx64tDAEHLQwCCC0MAwktDAQKIwAAmUcLKAALgEUABSQCAAUAAJkyJQAAx64tDAEHLQwCCC0MAwktDAQKIwAAmUctDAoELQwHAS0MCAItDAkDJiUAAH8ALwwABAAFASgABIBLAAYvDAAGAAQtCAEGJwIHBAIAEAEHAScDBgQBACgGAgctDAcILQ4FCCcCBwQILQgACC0MBgkAEAAHACUAAMfALQQAAC0MCQUtCAEGJwIHBAIAEAEHAScDBgQBACgGAgctDAcILQ4ECCcCBwQILQgACC0MBgkAEAAHACUAAMflLQQAAC0MCQQtDAQCLQwFASYqAQABBWRhiKjGz5TLPAEBAiYqAQABBRmJ4yAEPXXCPAEBAiYlAAB/AC0NAgMAKAMCAy0OAwILKAABgEoAAyQCAAMAAJpHJwIEBAA8CQEEASgAAoBEAAMtDQMBLQgBAicCAwQCABABAwEnAwIEAQAoAgIDLQwDBC0OAQQtDAIBJioBAAEFyFBnWaPEvLY8AQECJiUAAH8ALQgBDCcCDQQEABABDQEnAwwEAQAoDAINLQwNDi4KgEgADgAoDgIOLgqASAAOACgOAg4uCoBIAA4tCAENJwIOBAUAEAEOAScDDQQBACgNAg4tDA4PLgqASAAPACgPAg8uCoBIAA8AKA8CDy4KgEgADwAoDwIPLgqAagAPLQgBDgAAAQIBLQ4MDi0IAQwAAAECAS0ODQwtCAENAAABAgEuCoBGAA0tCAEPAAABAgEuCoBFAA8nAhAEES0IABEtDA4SLQwMEy0MDRQtDA8VLQwEFgAQABAAJQAAxXctBAAAJwIEBBAtCAAQLQwOES0MDBItDA0TLQwPFC0MBhUAEAAEACUAAMV3LQQAAC0NDwQLKAAEgEUABiQCAAYAAJu1JwIQBAA8CQEQJwIEBBAtCAAQLQwOES0MDBItDA0TLQwPFAAQAAQAJQAAxqAtBAAALQ0OBC0NDAYtDQ0QLQ4EDi0OBgwtDhANLgqASQAPASgABoBKAAwtDQwECygABYBXAAYLKAAEgEgADCQCAAYAAJ6UIwAAnCMLKAAFgFgABiQCAAYAAJ5kIwAAnDgLKAAFgFoABiQCAAYAAJ40IwAAnE0LKAAFgFsABiQCAAYAAJ4EIwAAnGILKAAFgFwABiQCAAYAAJ3UIwAAnHcLKAAFgF0ABiQCAAYAAJ2kIwAAnIwLKAAFgF4ABiQCAAYAAJ10IwAAnKELKAAFgF8ABiQCAAYAAJ1EIwAAnLYLKAAFgGQABiQCAAYAAJ0UIwAAnMsLKAAFgGYABiQCAAYAAJzkJwINBAA8CQENCygADIBFAAUkAgAFAACc+SUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGcACyMAAJ7ECygADIBFAAUkAgAFAACdKSUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGUACyMAAJ7ECygADIBFAAUkAgAFAACdWSUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGAACyMAAJ7ECygADIBFAAUkAgAFAACdiSUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGEACyMAAJ7ECygADIBFAAUkAgAFAACduSUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGIACyMAAJ7ECygADIBFAAUkAgAFAACd6SUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGMACyMAAJ7ECygADIBFAAUkAgAFAACeGSUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGQACyMAAJ7ECygADIBFAAUkAgAFAACeSSUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGYACyMAAJ7ECygADIBFAAUkAgAFAACeeSUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGgACyMAAJ7ECygADIBFAAUkAgAFAACeqSUAAMeuLQwBBy0MAggtDAMJLQwECi4IgGkACyMAAJ7ELQwKBC0MBwEtDAgCLQwLBS0MCQMmJQAAfwAtCAELJwIMBAQAEAEMAScDCwQBACgLAgwtDAwNLgqASAANACgNAg0uCoBIAA0AKA0CDS4KgEgADS0IAQwnAg0EBQAQAQ0BJwMMBAEAKAwCDS0MDQ4uCoBIAA4AKA4CDi4KgEgADgAoDgIOLgqASAAOACgOAg4uCoBqAA4tCAENAAABAgEtDgsNLQgBCwAAAQIBLQ4MCy0IAQwAAAECAS4KgEYADC0IAQ4AAAECAS4KgEUADicCDwQQLQgAEC0MDREtDAsSLQwMEy0MDhQtDAQVABAADwAlAADFdy0EAAAnAgQEDy0IAA8tDA0QLQwLES0MDBItDA4TLQwGFAAQAAQAJQAAxXctBAAALQ0OBAsoAASARQAGJAIABgAAoAQnAg8EADwJAQ8nAgQEDy0IAA8tDA0QLQwLES0MDBItDA4TABAABAAlAADGoC0EAAAtDQ0ELQ0LBi0NDA8tDgQNLQ4GCy0ODwwuCoBJAA4BKAAGgEoACy0NCwQLKAAFgFkABgsoAASASAALJAIABgAAom4jAACgcgsoAAWAYAAGJAIABgAAokQjAACghwsoAAWAYQAGJAIABgAAohojAACgnAsoAAWAYgAGJAIABgAAofAjAACgsQsoAAWAYwAGJAIABgAAocYjAACgxgsoAAWAZQAGJAIABgAAoZwjAACg2wsoAAWAZwAGJAIABgAAoXIjAACg8AsoAAWAaAAGJAIABgAAoUgjAAChBQsoAAWAaQAGJAIABgAAoR4nAgwEADwJAQwLKAALgEUABSQCAAUAAKEzJQAAx64tDAEHLQwCCC0MAwktDAQKIwAAopgLKAALgEUABSQCAAUAAKFdJQAAx64tDAEHLQwCCC0MAwktDAQKIwAAopgLKAALgEUABSQCAAUAAKGHJQAAx64tDAEHLQwCCC0MAwktDAQKIwAAopgLKAALgEUABSQCAAUAAKGxJQAAx64tDAEHLQwCCC0MAwktDAQKIwAAopgLKAALgEUABSQCAAUAAKHbJQAAx64tDAEHLQwCCC0MAwktDAQKIwAAopgLKAALgEUABSQCAAUAAKIFJQAAx64tDAEHLQwCCC0MAwktDAQKIwAAopgLKAALgEUABSQCAAUAAKIvJQAAx64tDAEHLQwCCC0MAwktDAQKIwAAopgLKAALgEUABSQCAAUAAKJZJQAAx64tDAEHLQwCCC0MAwktDAQKIwAAopgLKAALgEUABSQCAAUAAKKDJQAAx64tDAEHLQwCCC0MAwktDAQKIwAAopgtDAoELQwHAS0MCAItDAkDJiUAAH8ALQgBBicCBwQJABABBwEnAwYEAQAoBgIHLQwHCC4KgEgACAAoCAIILgqASAAIACgIAgguCoBIAAgAKAgCCC4KgEgACAAoCAIILgqASAAIACgIAgguCoBIAAgAKAgCCC4KgEgACAAoCAIILgqASAAILQgBBwAAAQIBLQ4GBy4IgEYABSMAAKM1DSgABYBUAAEkAgABAAClGSMAAKNKLQ0HAQEoAAGASgADLQ0DAgEoAAGATAAELQ0EAy0IAQQnAgUEAgAQAQUBJwMEBAEAKAQCBS0MBQYtDgMGJwIFBAYtCAAGLQwEBwAQAAUAJQAAx8AtBAAALQwHAwEoAAGARAAFLQ0FBAEoAAGATQAGLQ0GBRwMBQcBHAwHBgAcDAYFAQEoAAGATwAHLQ0HBi0IAQcnAggEAgAQAQgBJwMHBAEAKAcCCC0MCAktDgYJJwIIBAktCAAJLQwHCgAQAAgAJQAAx8AtBAAALQwKBgEoAAGAUAAILQ0IBy0IAQgnAgkEAgAQAQkBJwMIBAEAKAgCCS0MCQotDgcKJwIJBAotCAAKLQwICwAQAAkAJQAAx8AtBAAALQwLBwEoAAGAUgAJLQ0JCC0IAQknAgoEAgAQAQoBJwMJBAEAKAkCCi0MCgstDggLJwIKBAstCAALLQwJDAAQAAoAJQAAx8AtBAAALQwMCAEoAAGAVAAKLQ0KCS0IAQEnAgoEAgAQAQoBJwMBBAEAKAECCi0MCgstDgkLJwIKBAstCAALLQwBDAAQAAoAJQAAx8AtBAAALQwMCS0MAgEtDAMCLQwEAy0MBQQtDAYFLQwHBi0MCActDAkIJi0NBwEcDAUCAAA4BAIDLwwAAwACLgQAAYADKACABAQACSUAAMNdLgiABQADACgDAgYAOAYFCC0OAggtDgMHASgABYBKAAEtDAEFIwAAozUlAAB/AC0NBQ8AKA8CDy0ODwUcDAIPAAAoBAICLgQABYADKACABAQAASUAAMP9LgiABQAQLgiABgARLQ4PERYMCAQcDAgFABwMBAgABDgFCQQFKAAIgEMABQA4BAUIFgwKBBwMCgUAHAwECQAEOAULBAUoAAmAQwAFADgEBQkAKBACCi0NCgUnAgsEAgA4CgsEOgPoAAgACQABAAQABSACAAEhAgACLQgBBQAoBQIKLQ0KCScCCwQCADgKCwgiNIBGAAIACC0MAgknAgsEAwA4CQsKABABCgEnAwUEAQAoBQILLQ4JCwAoCwILLQ4JCy0MCQQGKAQCBCQCAAEAAKaWIwAApm0tDQUBACgBAgEtDgEFACgFAgMtDQMCJwIGBAIAOAMGATwNAQIjAACmlicCAgQGLQgABi0MBActDAUIABAAAgAlAACaHC0EAAAtDAcBASgAAYBKAAMtDQMCHAwCAwYcDAMBABwMAQIGLQwCASYqAQABBdTMgfr2el1uPAEBAiYqAQABBSiGkrBH3P1DPAEBAiYlAAB/ACcCBwQILQgACC0MBQkAEAAHACUAALi3LQQAAC0MCQYBKAAGgEoABy0NBwUwDAAFAAQmJQAAfwAtCAEMJwINBAQAEAENAScDDAQBACgMAg0tDA0OLgqASAAOACgOAg4uCoBIAA4AKA4CDi4KgEgADi0IAQ0nAg4EBQAQAQ4BJwMNBAEAKA0CDi0MDg8uCoBIAA8AKA8CDy4KgEgADwAoDwIPLgqASAAPACgPAg8uCoBqAA8tCAEOAAABAgEtDgwOLQgBDAAAAQIBLQ4NDC0IAQ0AAAECAS4KgEYADS0IAQ8AAAECAS4KgEUADycCEAQRLQgAES0MDhItDAwTLQwNFC0MDxUtDAQWABAAEAAlAADFdy0EAAAnAgQEEC0IABAtDA4RLQwMEi0MDRMtDA8ULQwGFQAQAAQAJQAAxXctBAAALQ0PBAsoAASARQAGJAIABgAAqF8nAhAEADwJARAnAgQEEC0IABAtDA4RLQwMEi0MDRMtDA8UABAABAAlAADGoC0EAAAtDQ4ELQ0MBi0NDRAtDgQOLQ4GDC0OEA0uCoBJAA8BKAAGgEoADC0NDAQLKAAFgFcABgsoAASASAAMJAIABgAAqz4jAACozQsoAAWAWAAGJAIABgAAqw4jAACo4gsoAAWAWgAGJAIABgAAqt4jAACo9wsoAAWAWwAGJAIABgAAqq4jAACpDAsoAAWAXAAGJAIABgAAqn4jAACpIQsoAAWAXQAGJAIABgAAqk4jAACpNgsoAAWAXgAGJAIABgAAqh4jAACpSwsoAAWAXwAGJAIABgAAqe4jAACpYAsoAAWAZAAGJAIABgAAqb4jAACpdQsoAAWAZgAGJAIABgAAqY4nAg0EADwJAQ0LKAAMgEUABSQCAAUAAKmjJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAZwALIwAAq24LKAAMgEUABSQCAAUAAKnTJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAZQALIwAAq24LKAAMgEUABSQCAAUAAKoDJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAYAALIwAAq24LKAAMgEUABSQCAAUAAKozJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAYQALIwAAq24LKAAMgEUABSQCAAUAAKpjJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAYgALIwAAq24LKAAMgEUABSQCAAUAAKqTJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAYwALIwAAq24LKAAMgEUABSQCAAUAAKrDJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAZAALIwAAq24LKAAMgEUABSQCAAUAAKrzJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAZgALIwAAq24LKAAMgEUABSQCAAUAAKsjJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAaAALIwAAq24LKAAMgEUABSQCAAUAAKtTJQAAx64tDAEHLQwCCC0MAwktDAQKLgiAaQALIwAAq24tDAoELQwHAS0MCAItDAsFLQwJAyYlAAB/ACcCBgQHLQgABy0MAQgtDAIJABAABgAlAACr/C0EAAAtDAgFCygAA4BOAAEBKAAFgEoABi0NBgIkAgABAACr7iMAAKvMCygAA4BRAAEkAgABAACr5ScCBQQAPAkBBS0MAgQjAACr9y0MAgQjAACr9y0MBAEmJQAAfwAtDQEDLQ0CBA0oAASATQAFJAIABQAArB4lAADDSwAoAwIGADgGBActDQcFLQgBBicCBwQCABABBwEnAwYEAQAoBgIHLQwHCC0OBQgBKAAEgEoABQ44BAUHJAIABwAArGYlAACtRi0OAwEtDgUCLQwGASYlAAB/ACcCBgQHLQgABy0MAQgtDAIJABAABgAlAACr/C0EAAAtDAgFCygAA4BOAAEBKAAFgEoABi0NBgIkAgABAACs3iMAAKy8CygAA4BRAAEkAgABAACs1ScCBQQAPAkBBS0MAgQjAACs5y0MAgQjAACs5y0MBAEmKgEAAQW2SOxlp0llLDwBAQImKgEAAQVIpoXAksBooTwBAQImKgEAAQVeMbOZA86a3zwBAQImKgEAAQUWPCC69BAE5TwBAQImKgEAAQXL1FU3/NnHUDwBAQImKgEAAQVFp8pxGUHkFTwBAQImKgEAAQWQ0MDCajsmvTwBAQImJQAAfwAnAgYEBy0IAActDAEILQwCCQAQAAYAJQAAyAotBAAALQwIBQsoAAOATgABASgABYBKAAYtDQYCJAIAAQAArdUjAACtswsoAAOAUQABJAIAAQAArcwnAgUEADwJAQUtDAIEIwAArd4tDAIEIwAArd4tDAQBJiUAAH8AJwIGBActCAAHLQwBCC0MAgkAEAAGACUAAMgKLQQAAC0MCAULKAADgE4AAQEoAAWASgAGLQ0GAiQCAAEAAK5OIwAAriwLKAADgFEAASQCAAEAAK5FJwIFBAA8CQEFLQwCBCMAAK5XLQwCBCMAAK5XLQwEASYqAQABBTtCwSZzO6FFPAEBAiYlAAB/AC0IAQsnAgwEBAAQAQwBJwMLBAEAKAsCDC0MDA0uCoBIAA0AKA0CDS4KgEgADQAoDQINLgqASAANLQgBDCcCDQQFABABDQEnAwwEAQAoDAINLQwNDi4KgEgADgAoDgIOLgqASAAOACgOAg4uCoBIAA4AKA4CDi4KgGoADi0IAQ0AAAECAS0OCw0tCAELAAABAgEtDgwLLQgBDAAAAQIBLgqARgAMLQgBDgAAAQIBLgqARQAOJwIPBBAtCAAQLQwNES0MCxItDAwTLQwOFC0MBBUAEAAPACUAAMV3LQQAACcCBAQPLQgADy0MDRAtDAsRLQwMEi0MDhMtDAYUABAABAAlAADFdy0EAAAtDQ4ECygABIBFAAYkAgAGAACvmScCDwQAPAkBDycCBAQPLQgADy0MDRAtDAsRLQwMEi0MDhMAEAAEACUAAMagLQQAAC0NDQQtDQsGLQ0MDy0OBA0tDgYLLQ4PDC4KgEkADgEoAAaASgALLQ0LBAsoAAWAWQAGCygABIBIAAskAgAGAACyAyMAALAHCygABYBgAAYkAgAGAACx2SMAALAcCygABYBhAAYkAgAGAACxryMAALAxCygABYBiAAYkAgAGAACxhSMAALBGCygABYBjAAYkAgAGAACxWyMAALBbCygABYBlAAYkAgAGAACxMSMAALBwCygABYBnAAYkAgAGAACxByMAALCFCygABYBoAAYkAgAGAACw3SMAALCaCygABYBpAAYkAgAGAACwsycCDAQAPAkBDAsoAAuARQAFJAIABQAAsMglAADHri0MAQctDAIILQwDCS0MBAojAACyLQsoAAuARQAFJAIABQAAsPIlAADHri0MAQctDAIILQwDCS0MBAojAACyLQsoAAuARQAFJAIABQAAsRwlAADHri0MAQctDAIILQwDCS0MBAojAACyLQsoAAuARQAFJAIABQAAsUYlAADHri0MAQctDAIILQwDCS0MBAojAACyLQsoAAuARQAFJAIABQAAsXAlAADHri0MAQctDAIILQwDCS0MBAojAACyLQsoAAuARQAFJAIABQAAsZolAADHri0MAQctDAIILQwDCS0MBAojAACyLQsoAAuARQAFJAIABQAAscQlAADHri0MAQctDAIILQwDCS0MBAojAACyLQsoAAuARQAFJAIABQAAse4lAADHri0MAQctDAIILQwDCS0MBAojAACyLQsoAAuARQAFJAIABQAAshglAADHri0MAQctDAIILQwDCS0MBAojAACyLS0MCgQtDAcBLQwIAi0MCQMmJQAAfwAvDAAEAAUtCAEEJwIGBAIAEAEGAScDBAQBACgEAgYtDAYHLQ4FBycCBgQHLQgABy0MBAgAEAAGACUAAMflLQQAAC0MCAUtDAUBJiUAAH8ALQgBDCcCDQQEABABDQEnAwwEAQAoDAINLQwNDi4KgEgADgAoDgIOLgqASAAOACgOAg4uCoBIAA4tCAENJwIOBAUAEAEOAScDDQQBACgNAg4tDA4PLgqASAAPACgPAg8uCoBIAA8AKA8CDy4KgEgADwAoDwIPLgqAagAPLQgBDgAAAQIBLQ4MDi0IAQwAAAECAS0ODQwtCAENAAABAgEuCoBGAA0tCAEPAAABAgEuCoBFAA8nAhAEES0I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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "repay_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "asset_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3dris7cqX7LnW9L/gT/OtXaRiG7fZpFFCwG7b7AAdGvfvRWpqZyrnFFCXOSJJBjpvCXLWTUvAboWSMSIn877/8r3/95//7v//xr//2//z7f/7lf/zP//7L3/79X/7pv/767/92+9d//0XT7//vP//PP/3br3/+53/903/811/+h3EU/vjLv/7b/7r96bX5+x9/+X/++rd//cv/0Er9/Y/nqw2p7WrjH1cHnbnYquS+Lrbax9cXa5f0dvXtb/O43ETKXe9d3C73IexXW5V9devtdjVp9e3qf/jjL9oBzRkaDzRnaALQnKGJQHOGJgHNCRqjgOYMjR4cjTMPNN4X0Bht/BaJJvdDNAZoztBYoDlDQ1k0FPUDjS2gIa3p62rS7vEWnn6/g7v8HbK1mbaG9vuUtVEV3uN2vd4vdw8RUshcnFLacuf2apqOEeUUI3eQLLo/TyBIn0DMTyCq/U3sMbF/TeDXsGwN4OOeGj65R2TO5jLDbh8dokcWOfPr5a269uX1tS9vfv7yu2gUnl7eXvvydO3Lu5+/vEnby8enl/c/fnmnt9R3lI4v/3xpiHq7RYcYTOn2bx8fRXuIXKfcQuRpC9n6SMeLf00zzDLNQJuYt3uO/vM04xpqpiXUJDXwNH3YrjbB2D9Hnl0wgtoXyaAOtc1J5Hvt56x/xJ58jqPeS1ar3WPNdkG0ByQDjBwY7UQY+xkoImDkwOiAkQOjL2H87R1fYbTW7GSOGPNkwnZDIntYqG9m5lcwgSGYsJcCZP3rYLQ3+/KrPcX0J5dKcbB4UuN4wmH9CP7JxTs1WDyaNR5/KCWz8Zi0fRCtenzIbx/gX7Hki47birzFcruNvI5F6+i2YG5/R1P4aPm9OWCD1gNXEs6CzSkbAptTNg5sTtl4sDllE0Zn068AdBFsTtkksDlj4xXYnLLRHGzSHr9O9ie2ynOUookeUqVUKtSTS/vtO3n9rVD//Gmht9InQO0nEHZXrlM8PA/LTiC5fXHWh7X5ltx//4fbv/75P/76t7/99X//47fvxapf/6NPvmCT1P7gQX17jvv7cZk++e5JaZStGkVVo1zVKF81KlSNilWjUs2o/JPx4qiq3LBVuWGrcsNW5Yatyg1blRu2KjdsVW7YqtygqtygqtygqtygqtygqtygqtygqtygqtygqtygqtxwVbnhqnLDVeWGq8oNV5Ubrio3XFVuuKrccFW54apyw1flhq/KDV+VG74qN3xVbviq3PBVueGrcsNX5Yavyo1QlRuhKjdCVW6EqtwIVbkRqnIjVOVGqMqNUJUboSo3YlVuxKrciFW5EbO5YZV7PC5K4TDK3UdR1ShXNcpXjQpVo2LVqGxuWK2273VbY9K3UbkmkPd7E/nbF/Zz3yKjuPV03OFBpL5/wVMnxRBPVLvNjjoW4nE+bFc7f/zGqb8HpEcLyIwWkB0tIBotIDdaQH60gMJoAcXRAkpjBWTUYHdqo9rfqQPt32wLxy83577ZZtz+jWXjgn59cdwbxTEcFknK/gLu1rzam+Lu8cKU+960iY+S6tulvwkaEPwhQQuCPyRIIPhDgg4Ef0jQg+APCQYQ/CHBCII/JJhA8GcEtQLBHxKEJ/kpQXiSnxKEJ/kpQQLBHxKEJ/kpQXiSnxKEJ/kpQXiSnxKEJ/khQQNP8lOC8CQ/JQhP8lOC8CQ/JUgg+EOC8CQ/JQhP8lOC8CQ/JQhP8lOCPTyJfhCMr6HouH+DVafj3n3Zl9aU9p9vusO+gF/fEbJqobnqheZqFpqrXWiutNBc3UJz9QvNNSw017jQXBeqm2ihuokWqptoobqJFqqbaKG6iRaqm2ihuokWqptoobqJFqqb3EJ1k1uobnIL1U1uobrJLVQ3uYXqJrdQ3eQWqpvcQnWTW6hu8gvVTX6huskvVDf5heomv1Dd5Beqm/xCdZNfqG7yC9VNfqG6KSxUN4WF6qawUN0UFqqbwkJ1U1iobgoL1U1hobopLFQ3hYXqprhQ3RQXqpviQnVTXKhuigvVTXGhuikuVDfFheqmuFDdFGeqm0zy+0Ht6nAE5xmZQDsZfXjtmIvEq+3sR28OP3eMv0+mMGmmkqwjxpmqvY4YZyokO2KcqUbtiJGAkQPjTJV1R4wzFe0dMc7kBzpinMlqdMQIF8OA0Sq4GBaMcDEsGOFiWDDO5GJuswk7xlQKROtg9hfXSR1eXZursROw98A+k0sShH0mVyUI+0wuTBD2mVybIOwzuTw52PVMrlAQ9plcpCDsM7lOQdjhUrtgJ2DvgR0utQt2uNQu2Bd2qUa5LRJtbjMuYDc3mb4uNzoeoMSYuzqo/epgHt/t83fsC7vUntgXdqkdsZuFXWpP7Au71J7YF3apPbEv7FJ7Yidg74F9YZfaE/vCLrUndrjULtjhUrtgh0vtgX2qI/0EYV/ZpdoYd+xEpcav8Xssxnv3uDrZXCzabC9+e6hxvFrnrrZhj9wm++3q3zKt7GoFybSyCxYkE0EmCTKt7LIFybSyKxck08ouXpBMK7t+QTKt3CWQI9NUB95OLBO6ECJkQhdChEzoQoiQiSCTBJnQhRAhE7oQImRCF0KETOhCiJAJXQgJMk11fPzEMqELIUImdCFEyIQuhAiZCDJJkAldCBEyoQshQiZ0IUTIhC6ECJnQhZAgk0cXQoRM6EKIkAldCBEyoQshQiaCTBJkQhdChEzoQoiQCV0IETKhCyFCJnQhJMgU0IUQIRO6ECJkQhdChEzoQoiQiSCTBJnQhRAhE7oQImRCF0KETOhCiJAJXQgJMkV0IUTIhC6ECJnQhRAhE7oQImQiyCRBJnQhRMiELoQImdCFECETuhAiZEIXQoJMCV0IETKhCyFCJnQhRMiELoQImQgySZAJXQgRMqELIUImdCFEyIQuhAiZ0IUQIBMpdCFEyIQuhAiZ0IUQIRO6ECJkIsgkQSZ0IUTIhC6ECJnQhRAhE7oQImRCF0KCTBpdCBEyoQshQiZ0IUTIhC6ECJkIMkmQCV0IETKhCyFCJnQhRMiELoQImdCFkCCTQRdChEzoQoiQCV0IETKhCyFCJoJMEmRCF0KETOhCiJAJXQgRMqELIUImdCEkyGTRhRAhE7oQImRCF0KETOhCiJCJINM1MhlyO8JYkonSLpNTKj3LhC6ECJnQhRAhE7oQImRCF0KETOhCSJCJ0IUQIRO6ECJkQhdChEzoQoiQiSCTBJnQhRAhE7oQImRCF0KETOhCiJAJXQgJMjl0IUTIhC6ECJnQhRAhE7oQImQiyCRBJnQhRMiELoQImdCFECETuhAiZEIXQoJMHl0IETKhCyFCJnQhRMiELoQImQgySZAJXQgRMqELIUImdCFEyIQuhAiZ0IWQIFNAF0KETOhCiJAJXQgRMqELIUImgkwSZEIXQoRM6EKIkAldCBEyoQshQiZ0ISTIFNGFECETuhAiZEIXQoRM6EKIkIkgkwSZ0IUQIRO6ECJkQhdChEzoQoiQCV0ICTIldCFEyIQuhAiZ0IUQIRO6ECJkIsgkQSZ0IUTIhC6ECJnQhRAhE7oQImRCF0KATLf/DzJJkAldCBEyoQshQiZ0IUTIRJBJgkzoQoiQCV0IETKhCyFCJnQhRMiELoQEmTS6ECJkQhdChEzoQoiQCV0IETIRZJIgE7oQImRCF0KETOhCiJAJXQgRMqELIUEmgy6ECJnQhRAhE7oQImRCF0KETASZJMiELoQImdCFECETuhAiZEIXQoRM6EJIkMmiCyFCJnQhRMiELoQImdCFECETQSYJMqELIUImdCFEyIQuhAiZ0IUQIRO6EBJkInQhRMiELoQImdCFECETuhAiZCLIJEEmdCFEyIQuhAiZ0IUQIRO6ECJkQhdCgkwOXQgRMqELIUImdCFEyIQuhAiZCDJJkAldCBEyoQshQiZ0IUTIhC6ECJnQhZAgk0cXQoRMK3chvNK7TOEYeFam20vqHcpRphNRo9pEDTqVrjYqbVcbE75d/VumlbsQgmRauQshSCaCTBJkWrkLIUimlbsQgmRauQshSKaVuxCCZFq5CyFHprByF0KQTOhCiJAJXQgRMqELIUImgkwSZEIXYgiZyNrtaoqlRyqezNfF3j8ktT43y/R4WKMOYeQv9nq/2hunClfroP3G+/Z3sqVXTztvn/QhF2Pm4nh7tPR1cTTeHC/+nbdoyyBvJeYt+lTIW4l5i8Yd8lZi3qKTibwVmLcRrV3krcS8Ra8beSsxb9H8R95KzFs8DUHeSsxbQt4ibwXmLZ6XIW8l5i2elyFvJeYtnpchbyXmLZ6XIW8l5i2elyFvBeZtwvMy5K3EvMXzMuStxLzF8zLkrcS8xfMy5K3EvCXkLfJWYN7ieRnyVmLe4nkZ8lZi3uJ5GfL28cLGhT1vY+mldfR71L/+pm/X/84uPNVCdl2XXXj2hOy6Kru8whMiZNd12YXnOMiu67ILT1uQXddlF56JILuuyy5CdiG7LssuPF9Adl2XXXgKgOy6LrvQq0d2XZdd6NUju67LLvTqkV2XZZdGrx7ZdV12oVd/UXaF/bsptz+/X/0bPNrYncCjw9sJPAF8H/DoC3YCj5ZZJ/DoJnUCj0ZLJ/DoQfQBb2DPO4GHc+0EHs61E3g4107gCeD7gF/YuVobth6ytuRMAaW+BbO3enUMjx/m+Sx4ZXbwxhyu/Y19Yd/aE/vCrrUn9oU9K6mwx02aQgG7V4+f/vrHtdHdQS7sQVlB2oU9JS/IhT0iL8iFPR8vyIU9HC9IAkgekAt7LF6QC7smXpAL+yBekHA2TCDhbHhAEpwNE0g4GyaQKzsbT2kH6YtfajY2bCSNTYdufUwfN91oZR/UETsBew/sK3usjthXdmQdsa/s3zpiX9ntdcS+sjfsh92t7CQ7Yl/Zd3bEDpfaBTtcahfsBOw9sMOldsEOl/o2dtL7lg1E6hv23yjhPNlQwk2yoYRD5ELp4frYUMLJsaGEO2NDCcfFhpKAkgslnBEbSrgdNpRwO2wo4XbYUMLtcKEMcDtsKOF22FDC7bChhNthQ0lAyYUSbocNJdwOG0q4HTaUcDtsKOF2uFBGuB02lHA7bCjhdthQwu2woSSg5EIJt8OGEm6HDSXcDhtKuB02lHA7XCgT3A4bSrgdNpRwO2wo4XbYUBJQcqGE22FDCbfDhhJuhw0l3A4bSrgdJpRBwe2woYTbYUMJt8OGEm6HDSUBJRdKuB02lHA7bCjhdthQwu2woYTb4UKp4XbYUMLtsKGE22FDCbfDhpKAkgsl3A4bSrgdNpRwO2wo4XbYUMLtcKE0cDtsKOF22FDC7bChhNthQ0lAyYUSbocNJdwOG0q4HTaUcDtsKOF2uFBauB02lHA7bCjhdthQwu2woSSg5EIJt8OGEm6HDSXcDhtKuB02lHA7XCgJbocNJdwOG0q4HTaUcDtsKAkouVDC7bChhNthQwm3w4YSbocNJdwOF0o3lduxtKO0wZeu9nEjaW/NxgNIfUczlXvhRTOVG+FFM5W74EVDQHOGZqrqnxfNVNU8L5qpqnNeNFNV27xopqqeWdF4VMOnaFANn6JBNXyKBtXwKRoCmjM0qIZP0aAaPkWDavgUDarhUzSohs/QzHUWOy8aVMOnaFANn6JBNXyKhoDmDA2q4VM0qIZP0aAaPkWDavgUDarhMzRzndXNiwbV8CkaVMOnaFANn6IhoDlDg2r4FA2q4VM0qIZP0aAaPkWDavgMzVxnOfOiQTV8igbV8CkaVMOnaAhoztCgGj5Fg2r4FA2q4VM0qIZP0aAaPkET5zrrlxcNquFTNKiGT9GgGj5FQ0BzhgbV8CkaVMOnaFANn6JBNXyKBtXwGZq5zoLlRYNq+BQNquFTNKiGT9EQ0JyhQTV8igbV8CkaVMOnaFANn6JBNXyGZq6zQnnRoBo+RYNq+BQNquFTNAQ0Z2hQDZ+iQTV8igbV8CkaVMOnaFANn6GZ6yxJXjSohk/RoBo+RYNq+BQNAc0ZGlTDp2hQDZ+iQTV8igbV8CkaVMNnaOY6a5AXDarhUzSohk/RoBo+RUNAc4YG1fApGlTDp2hQDZ+iQTV8igbV8BkanEV3jgbV8CkaVMOnaFANn6IhoDlDg2r4FA2q4VM0qIZP0aAaPkWDavgMDc6iO0eDavgUDarhUzSohk/RENCcoUE1fIoG1fApGlTDp2hQDZ+iQTV8hgZn0Z2jQTV8igbV8CkaVMOnaAhoztCgGj5Fg2r4FA2q4VM0qIZP0aAaPkODs+jO0aAaPkWDavgUDarhUzQENGdoUA2fokE1fIoG1fApGlTDp2hQDZ+hwVl052hQDZ+iQTV8igbV8CkaApozNKiGT9GgGj5Fg2r4FA2q4VM0qIZP0CScRXeOBtXwKRpUw6doUA2foiGgOUODavgUDarhUzSohk/RoBo+RYNq+AwNzqI7R4Nq+BQNquFTNKiGT9EQ0JyhWbcaJqvM19Vknf+GJhMJhQ2JdvoQSczF7VX8utibwytHd4e+bp3dEfq6FXxH6Ot6g47Q13Ud/aAvfJpgR+jrOqWO0Nf1YB2hr+vuOkInQG8PHY60A3Q40g7Q4Ug7QIcj7QB9Lkcat6stGfft6l+TnewkzcJk53JghcnO5XwKk53LcRQmSytNdq4KuzDZuSrbwmTnqigLk52rkitMdqUKarLTFwuTXamCmuyExMJkV6qgJjvFsDDZlSqoyU4aLEx2pQpqstMAC5NdqYKa7MS+wmRXqqAmO1WvMNmVKqjJTr4rTHalCmqy0+kKk12pgprsBLnCZFeqoCY75a0w2ZUqqMlOYitMdqUKarLT0gqTXamCmuxEs8JkV6qgJjt1rDDZlSqoyU4GK0x2pQpqstO7CpNdqYKa7IStwmRXqqAmOwWrMNmVKqjJTqoqTHalCmqy06QKk12pgprsxKfCZFeqoCY7lakw2ZUqqMlOTipMdqUKaq7Tjcg+Jlv8TaAO2+/2jHq8sok2c23ceUSbCtemnXhK36/9DXyqKk4A8LlOYpIAfKpqVgLwqSpqCcCnquolACcAbwt8KncjAfhUDksC8KlcngTgcJqNgcNpNgWu1VzHnFHcN1iKpEvETdy3TLKWHldrlXttp3c1XVTfrr6TnMtD9iQ5lznsSXIu19eTJIEkE8m5fFpPknMZsJ4k53JWPUnOZZl6kpzLC3UkOdfhdV1JwuNwkYTH4SIJj8NFkkCSiSQ8DhdJeBwukvA4XCThcbhIwuMwkZzrQLuuJOFxuEjC43CRhMfhIkkgyUQSHoeLJDwOF0l4HC6S8DhcJOFxmEjOdVRbV5LwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwk5zpMsStJeBwukvA4XCThcbhIEkgykYTH4SIJj8NFEh6HiyQ8DhdJeBwmknMdd9qVJDwOF0l4HC6S8DhcJAkkmUjC43CRhMfhIgmPw0USHoeLJDwOE8m5DiTuShIeh4skPA4XSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4nkXEeGdyUJj8NFEh6HiyQ8DhdJAkkmkvA4XCThcbhIwuNwkYTH4SIJj8NEMsLjcJGEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EimeBxuEjC43CRhMfhIgmPw0WSQJKJJDwOF0l4HC6S8DhcJOFxuEjC4/CQ1Aoeh4skPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TSQ2Pw0USHoeLJDwOF0l4HC6SBJJMJOFxuEjC43CRhMfhIgmPw0USHoeJpIHH4SIJj8NFEh6HiyQ8DhdJAkkmkvA4XCThcbhIwuNwkYTH4SIJj8NE0sLjcJGEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EiSfA4XCThcbhIwuNwkYTH4SJJIMlEEh6HiyQ8DhdJeBwukvA4XCThcZhIOngcLpLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwkPTwOF0l4HC6S8DhcJOFxuEgSSDKRhMfhIgmPw0USHoeLJDwOF0l4HCaSAR6HiyQ8DhdJeBwukvA4XCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8DhPJCI/DRRIeh4skPA4XSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4lkgsfhIgmPw0USHoeLJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0PSKHgcLpLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwkNTwOF0l4HC6S8DhcJOFxuEgSSDKRhMfhIgmPw0USHoeLJDwOF0l4HCaSBh6HiyQ8DhdJeBwukvA4XCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8DhNJC4/DRRIeh4skPA4XSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4kkweNwkYTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSLp4HG4SMLjcJGEx+EiCY/DRZJAkokkPA4XSXgcLpLwOFwk4XG4SMLjMJH08DhcJOFxuEjC43CRhMfhIkkg+RZJMiF9XU3WmcLVmsL+2k4f4o65WXoVvy72xh+udV8awT2NrxF82fgawfGNrxG85PgawaUOr1GA/x1fIzjr8TWCZx9fI3QDxteIoNHwGqHPML5G6DOMrxH6DONrtHCfwe6BaK9sgboxSn1dbch+1+hOcuFuAC/JuLBnZya5sLNmJrmw/2UmubBLZSZJIMlEcmHHx0xyYV/GTHJh98RMEh6HiyQ8DhPJBI/DRRIeh4skPA4XSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4ekVfA4XCThcbhIwuNwkYTH4SJJIMlEEh6HiyQ8DhdJeBwukvA4XCThcZhIangcLpLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwkDTwOF0l4HC6S8DhcJOFxuEgSSDKRhMfhIgmPw0USHoeLJDwOF0l4HCaSFh6HiyQ8DhdJeBwukvA4XCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8DhNJgsfhIgmPw0USHoeLJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0TSweNwkYTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSLp4XG4SMLjcJGEx+EiCY/DRZJAkokkPA4XSXgcLpLwOFwk4XG4SE7lcaLbSSZF367+PdswlQ8pznYqr1Cc7VT1fHG2U9XcxdnSUrOdqnYtznaq+rI426lqwOJsp6rTirNdqpaa68zz4myXqqXmOju8ONulaqm5zuAuznapWmqus6yLs12qlprrTOjibJeqpeY6W7k426VqqbnOKC7Odqlaaq6zfouzXaqWmuvM3OJsl6ql5jp7tjjblWopmusM1+JsV6qlaK6zUIuzXamWIkVLzXalWormOpuzONuVaima64zL4myXqqXmOiuyONulaqm5zlwsznapWmquswuLs12qlprrDMDibJeqpeY6S68426VqqbnOpCvOdqlaaq6z3YqzXaqWmuuMtOJsl6ql5jprrDjbpWqpuc7sKs52qVpqrrOvirNdqpaa6wyp4myXqqXmOoupONulaqm5zjQqznapWmqus4GKs12qlprrjJ3ibJeqpeY6q6Y426VqqbnOfEna7bP1pat1iF8Xm8MOOCbazLVx5xFtKlyb4hZySt+vvROfqp4TQXyqmlIE8anq2hS2sEmTKlxtgjUb8pCOV4cc8xurDbrR/tvVd5JT1cxdSU5Vj/ckOddZM11JTuUjupKcyqN0JTmV/+lKkkCSieRcnqknybm8UE+S8DhcJOFxuEjC4zCRnOusma4k4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XGYSM51jk1XkvA4XCThcbhIwuNwkSSQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCTnOl+qK0l4HC6S8DhcJOFxuEgSSDKRhMfhIgmPw0USHoeLJDwOF0l4HCaSc5371pUkPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4PSTfXeYxdScLjcJGEx+EiCY/DRZJAkokkPA4XSXgcLpLwOFwk4XG4SMLjMJGc65zUriThcbhIwuNwkYTH4SJJIMlEEh6HiyQ8DhdJeBwukvA4XCThcZhIznV+cVeS8DhcJOFxuEjC43CRJJBkIgmPw0USHoeLJDwOF0l4HC6S8DhMJOc6V7wrSXgcLpLwOFwk4XG4SBJIMpGEx+EiCY/DRRIeh4skPA4XSXgcJpIEj8NFEh6HiyQ8DhdJeBwukgSSTCThcbhIwuNwkYTH4SIJj8NFEh6HiaSDx+EiCY/DRRIeh4skPA4XSQJJJpLwOFwk4XG4SMLjcJGEx+EiCY/DRNLD43CRhMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFxuEjC43CRhMdhIhngcbhIwuNwkYTH4SIJj8NFkkCSiSQ8DhdJeBwukvA4XCThcbhIwuMwkYzwOFwk4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XGYSCZ4HC6S8DhcJOFxuEjC43CRJJBkIgmPw0USHoeLJDwOF0l4HC6S8Dg8JL2Cx+EiCY/DRRIeh4skPA4XSQJJJpLwOFwk4XG4SMLjcJGEx+EiCY/DRFLD43CRhMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFxuEjC43CRhMdhImngcbhIwuNwkYTH4SIJj8NFkkCSiSQ8DhdJeBwukvA4XCThcbhIwuMwkbTwOFwk4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XGYSBI8DhdJeBwukvA4XCThcbhIEkgykYTH4SIJj8NFEh6HiyQ8DhdJeBwmkg4eh4skPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TSQ+Pw0USHoeLJDwOF0l4HC6SBJJMJOFxuEjC43CRhMfhIgmPw0USHoeJZIDH4SIJj8NFEh6HiyQ8DhdJAkkmkvA4XCThcbhIwuNwkYTH4SIJj8NEMsLjcJGEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EimeBxuEjC43CRhMfhIgmPw0WSQJKJJDwOF0l4HC6S8DhcJOFxuEjC4/CQDAoeh4skPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TSQ2Pw0USHoeLJDwOF0l4HC6SBJJMJOFxuEjC43CRhMfhIgmPw0USHoeJpIHH4SIJj8NFEh6HiyQ8DhdJAkkmkvA4XCThcbhIwuNwkYTH4SIJj8NE0sLjcJGEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EiSTN5HNL71aST/3b1fbYz+ZDybGfyCuXZzlTPl2dLS812prq4PNuZatfybGeqL8uznakGLM92pjqtONupzlMvz3apWmqqc8nLs12qlprqfO/ybJeqpaY6J7s826VqqanOmy7Pdqlaaqpzm8uzXaqWmur84/Jsl6qlpjpHuDzbpWqpqc7jLc92qVpqqnNty7Ndqpaa6nzY8myXqqWmOme1PNulaqmpzistz3apWmqqcz/Ls12qlprq/MzybJeqpaY6h7I826VqqanOcyzPdqlaaqpzEcuzXaqWmup8wfJsl6qlpjqnrzzbpWqpqc67K892qVpqqnPjyrNdqpaa6vy18myXqqWmOsesPNulaqmpzgMrz3alWipOda5WebZT1VKk7TbboFVmtlPVUsXZTlVLFWdLS812qlqqONupaqnibKeqpYqznaqWKs52qlqqNNupzu8pz3apWmqqc3DKs12qlprqPJnybJeqpaY6l6U826VqqanONynPdqlaaqpzQsqzXaqWmuq8jfJsl6qlpjq3ojzbpWqpqc5/KM92qVpqqnMUyrNdqpaa6jyC8myXqqWm2te/PNulaqmp9scvz3apWmqqfebLs12qlppqv/bybJeqpeba97w426Vqqbn2PS/Odqlaaq59z4uzXaqWmmvf8+Jsl6ql5tr3vDjbpWqpufY9L852qVpqrn3PC7NNHTqsPmxXOx/tcbb3iDpkm3rwV/45IspGZOwmhLUhFiKyPqnt6qiOP/AIX2/iWryJb/EmocWbxBZvkhq8yYkvZ34T3eJNTIs3sS3epMUnnlp84qnFJ55afOKpxSeeWnziXYtPvGvxiXctPvGuxSfetfjEuxafeNfiE+9afOJdi0+8a/GJ9y0+8b7FJ963+MT7Fp943+IT71t84n2LT7xv8Yn3LT7xvsUnPrT4xIcWn/jQ4hMfWnziQ4tPfGjxiQ8tPvGhxSc+tPjEhxaf+NjiEx9bfOJji098bPGJjy0+8bHFJz62+MRHjk98DPvVSenMm8QWb5IavElSLd5Et3gT0+JNbIs3oRZv4pjfRJvMm3B84uP++Mcmo769yfPVcX/EEu3jCYv59Yzm6drbDenr2pS+X3sPPkgOPkoOPokN3iilJAevJQdvJAdvJQdPkoN3koOXu8Legpe7wt6Cl7vC3oKXvMLqsVdYv12rbytSJvqxl9hS9GOvsaXox15kS9GPvcqWoh97mS1Fz7HOJhP26F0oRP/6O4a3iMJwEcXhIkqjRWTUcBHp4SIyw0Vkh4uIhovIDRfRcPdsM9wd0rS/Q778prpR1g4XUfvPWjCPiEx4jsgNF5EfLqIwXERxuIg6fPrJ7xE5Okb0fLGhPRBDRE/hk5IdvpYdvpEdvpUdPskO38kO38sOPwwevomP8J8LMoqywx991X0dvht81XVuq3mM8/b1xf72uP7rYn/rrz7PdfAl+pO5uhTSy7kOvp67vfdrXNCvL45qe+FIhx9ak/qa6uBrP+dUaZ2pDl5TcE518PqDc6qD1yqMU/Wjr6yfTNVtfccY/LepZl5Y2y1mo93jhcnkLo7bkmfVt0vvCEdfsAUgnKkO6IRwpvqiE0ICwp8inKke6oRwpjqrE8KZ6rdOCAfvd0lAOHjPTQDCAHfyY4RwJz9GCHfyY4RwJz9FGFfNQpXMjvDwVakswhi3IL79ODj7wvr23tsr3/4Oh69gp/jFfNW07cmcwLw581Vte0/mq/r8nsxXbQz0ZL5qJ6En81VbDx2Zp1V7FT2Zr9rc6MkcPrQ9c/jQ9swJzJszhw9tzxw+tD1z+ND2zOFD2zOHD23NXCv40PbM4UPbM4cPbc8cPrQ9cwLz5szhQ9szhw9tzxw+tD1z+ND2zOFDmzPX8KHtmcOHtmcOH9qeOXxoe+YE5s2Zw4e2Zw4f2p45fGh75vCh7ZnDhzZnbuBD2zOHD23PHD60PXP40PbMCcybM4cPbc8cPrQ9c/jQ9szhQ9szhw9tztzCh7ZnDh/anjl8aHvm8KHtmROYN2cOH9qeOXxoe+bwoe2Zw4e2Zw4f2pz56CeYTskcPrQ9c/jQ9szhQ5szF3WGYnx9cfDbtSF8o3ifqaTs+tlMaZmZ9nD0jwPqXSH4Vy99j98Ljz8Ijz8Kjz/Jjr/L+ZGc8euh4ydltwOUSaVUeGlLe7FgKR7Cdl932y7nLPabrV1qtrTUbMeuG7hnO3aVwT3bsWsS7tmOXcFwz3bseod5tmHs6oh7tkvVUkFuLXWPX251dI+fhMcvt4K5xy+3JrnHL7fKuMc/eN2g94YiWU2Fl46Ktma7fczVRJu5NsXthVP6fu2dy+AVRi8ucfBapBuXwauWblwGr2+6cRm8burGhcAly2XwOq8bl8Hrx25cBq9Lu3FBvZvngno3yyWh3s1zQb2b50KDc9FbP5K0yfQD0uh1Rin+0euBUvyjr9ul+EdfX0vxj74Ovo7fqNHXq1L8o68rpfhH73eU4h+9L1GKX/b6a5Ts9dco2euvUbLXX6Nkr79GCV9/tfD1Vwtff7Xw9VcLX3+77O/PGb/w9VcLX3+18PVXC19/tfD11whff43w9dcIX3+N8PW3y77GnPELX3+N8PXXCF9/jfD11whff63w9dcKX3+t8PXXCl9/u+znyBm/8PXXCl9/rfD11wpff63w9ZeEr78kfP0l4esvCV9/Sfj6S8LXXxK+/pLw9ZeEr78kfP11wtdfJ3z9dcLXXyd8/e2y5yBn/MLX38F3EizHL3z9HXwnwXL8wtffwXcSLMcvfP0dfW/AYvzC19/R9+8rxi98/R19j71i/MLX39H3wSvGL3z9HX2vumL8wtff0feTK8YvfP0dfT+5YvzC19/R95Mrxi98/R1+P7lS/MLX3+H3ZyvFL3z9HX6/s1L8wtff4fcPK8UvfP0dfj+uUvzC19/h97cqxS98/R1+v6hS/MLX3yR8/U3C11/h+18Z4ftfGeH7Xxnh+18Z4ftfGeH7X1nh+19Z4ftfWeH7X1nh+19ZJXv9tcPvf3XZvqJ+u1YrZb5dfAez7EbXJTDL7nRdArPsVtclMMvudV0AM/zmZd3AyD3F5B6/3NNG7vGT8PjlVjX3+OUWH/f45dYI9/jlLuX3+OWuuL/jH35XsVL8ck9ruMcvfP0dflexUvzC19/hdxUrxS98/R1+V7FS/MLX3+F3FSvEP/yuYqX4ha+/w+8qVopf+Po7/K5ipfiFr7/D7ypWil/4+jv8rmKl+IWvv8PvKlaKX/j6O/yuYqX4ha+/w+8qVopf+Po7/K5ipfiFr7/D7ypWil/4+jv8rmKl+IWvv8PvKlaKX/j6O/yuYqX4ha+/w+8qVopf+Po7/K5ipfiFr7/D7ypWil/4+jv8rmKl+IWvv8PvKlaKX/j6O/yuYqX4ha+/w+8qVopf+Po7/K5ipfiFr7/D7ypWil/4+jv8rmKl+IWvv8PvKlaKX/j6O/yuYqX4ha+/w+8qVopf+Po7/K5ipfiFr7/D7ypWil/4+jv8rmKl+IWvv8PvKlaKX/j6O/yuYqX4ha+/w+8qVopf+Po7/K5ipfiFr7/D7ypWil/4+jv8rmKl+GWvvzT8rmKl+GWvvzT8rmKl+GWvv6Rkr78keFexe/yy118SvEfXPX7Z6y8J3vHqd/yCN6a6xy98/RW+/xUJ3/+KhO9/RaPvf+Vt2uKPyhZe+qON5eI2w5S+X3vnMvi63o3L4PVCNy6D1yHXcXm9QSONvsFYNzCj71zWD8zgJVk/MIPXev3ADF5E9gNDY4OJ+0tTpBKY4O3XxSH4/VoyX1MdvJDlnOrgtSnnVAcvN19M9R7/4GVhMf7Bq7dS/INvT+c0ue1i7TP2fPDt6crxj12ylOMfu7Iox0/C4x97VS/HP/ZSXY5/7PW3HP/Y6285/rHX32P8Rpvn+Affnq4cv5z1Nx+/nPU3H7+c9Tcfv5z1Nx//4Otv0GG/OKZM/IOvv8X4B19/i/EPvv4W4x98/S3FP/j2dOX4B19/i/EPvv4W4x98/S3GP/j6W4xf+Po7+PZ05fiFr7+Db0/nolXbxcnHwktT2id7/CpTNJlrTVDbccYmmEdl67+4DL6u9+Iy+HZ6/bgMXocwcbnPdfCahXWug9c3rHOlheY6eN3EOtfBayzWuQ5ej30011vLbbuYYmauM9VupbnOVI8V5jr4lom8c52pbirNdaa6qTTXmeqm0lxpobnOVDeV5jpT3eTcXjfFTN00+DaTvHOdqm4qzHWquun1XAff6pJ3rlPVTYW5TlU3FeY6Vd1UmCstNNep6qbCXBeqmwbfHvTVXO/xy62F7vHLrW9+xz/49qDl+OXWIff45dYW9/jHrhe8Ulsg3nqdiZ+Exz/2ul6Of+y1uhz/2OtvOf6x199y/GOvv6X43eDbg5bjH3v9Lcc/9vpbjl/2+uuU7PXXDb49aDl+2euvG3x70HL8stdfN/j2oMX4B98etBy/8PV38O1By/ELX38H3x60HL/w9XfwbTzL8QtffwffFrMcv/D1d/BNJsvxC19/B9+ysRy/8PV38A0Qy/ELX38H36qwHL/w9Xfw/QfL8Qtffwfff7Acv/D1d/D9B8vxC19/B99/sBy/8PV38P0Hy/ELX38H33+wHL/w9Xfw/QfL8Qtffwfff7Acv/D1d/D9B8vxC19/B99/sBy/8PV38P0Hy/ELX38H33+wHL/w9Xfw/QfL8Qtffwfff7Acv/D1d/D9B8vxC19/B99/sBy/8PV38P38yvELX38H30uvHL/w9XfwPe/K8Qtffwffm64cv/D1d/A95MrxC19/B9/rrRy/8PV38D3ZyvELX38H3zutHL/w9XfwPc7K8Qtffwffi6wcv/D1d/A9w8rxC19/B9/bqxy/8PV38D24yvELX38H3yurHL/w9Xfw/a/K8Qtffwff/6ocv/D1d/D9r8rxC19/he9/5YTvf+WE73/lhO9/5YTvf+WE73/lhe9/5YXvf+WF73/lhe9/5ZXs9dcL3//KC9//ygvf/8oL3//KC9//ygvf/8oL3//KC9//ygvf/8qPvv8Vxe1i77TJxD/4+mvDzv82sPDSUdHXxdE+zgo30WauTXF74ZS+X3vnMvi63o3L4PVCNy6D1yHduAxe3/TiMvq+Zd24DF6PdeMyeJ3Xjcvg9WM3LgQuWS6od/NcUO/muaDezXNBvZvngno3y2X0fQK7cVm23vXbtVopkwGzbMFbArNsxVsCQwCTB7NszVsCs2zRWwIzeBXjYtrA3J7AFF5au6TsNl2XtN2v9/fZjr6H34vZ3uMffEUoxj/2jTuEsF0cwqGGy7+0Cd59XW1CsMeXvk927Jsx82THvsEyT3bsVgHzZMf2/8yTHXs55J3s4DsaMk92bPvNPNmx65xPJ5vMNtl4qCr2yY5dFDFPllaa7EwVlDVqK46tMeF5sjNVUMXJzlRBFSc7UwVVnOxMFdRtsurVZAffE/HDyZLerrZk1PNkZ1pni5OdaZ0tTnaqdbY02anWWZviPlmtXr+0S2G7dbuUMnezqRblT8h4td/nvcoUooPvPdkmZ/Jkplruye61DTn9s0/T4PtltiGTzZnBd+L8lMz+6M5Sis+TnatELEx2rhKxMFlaabJzlYiPybrDU/F9slOViKXJTlX1lSY7VSFXmuxUtZl9BOJ0eP3S2setnteBDj+GJXVHM/hmpB+iCftPf21I9mdl6+DbnF5IpmQCB99AtU3O5MnQVGT2l7Z/eiiVudGotH/hTFuVudFMVTdFQzuaVHhpUlvQZL7fgTMYHy0JfWvf7VfbHeNUFVk/jFPVev0wTlVF9sM4VX3aDePgGxOLwTiVJeiHcSr/8BFGu9kHOs5wBzOVfeAEM/iPlnh/gjL6Ns7Msx38R/XMsx38p/LMs13pp2Nh9O2nmWc7+I/VmWcr92eBNbOV+yPCmtnSXLO19JitM4fZ5q82h6v9E5vJKi9WNpPVaaxsJqvqPmBDeve/ZA6PITcyk1WAjGQmqxb5yIy+sXpHMpNVoYxkJqtYGclMVt0ykiGQOSGzbh1cIrNuFVwigxr4jAxq4DMys9XAZy4x89px/0ZmsIcfHZ28dorbJG8YD4ex3Pj/Jjn6pvqCSM5WY/OQvLOZrcrmZDNbnf2y43Wyabred2K0xqTCbHVU26Y9Ouojm5SdrXrMVvnjbO8RhfYRmUdEz5shhJONwntGlEaL6GRz7J4R6eEiMu0jIv+4sxS+8m1ov8UZInoO38oOn2SH72SH72WHH2SHH2WHn0SHT2rw8E18hP9ckJGWHf7oq24h/MFXXee2msc4/7MfIgYafIn+ZK6FnxYGGnw9d9rucw2FfVHifsJwpEPMX9+DDjT42s851cHrBM6pDl5TcE518PqDcapu8FqFc6qjr6yfTNVtYcTgv00188LaPjrnhy2vfm0n8Xzx49f06tuld4SjL9gCEM5UB3RCOFN90QnhTHVLJ4Qz1UN9EIaZio9PEKrHcQH68EgsizDGLYikiz9qvr33/vgvhnA4Jy3FL+aDd3emZD54S2pK5qtW+z2ZE5g3Z76qn+jJfFUD0pP5qo6lJ/NVLU5P5jP1noUwj/Ch7ZnDh7ZnDh/anjl8aHvmBObNmcOHtmcOH9qeOXxoe+bwoe2Zw4c2Z57gQ9szhw9tzxw+tD1z+ND2zAnMmzOHD23PHD60PXP40PbM4UPbM4cPbc08KvjQ9szhQ9szhw9tzxw+tD1zAvPmzOFD2zOHD23PHD60PXP40PbM4UObM9fwoe2Zw4e2Zw4f2p45fGh75gTmzZnDh7ZnDh/anjl8aHvm8KHtmcOHNmdu4EPbM4cPbc8cPrQ9c/jQ9swJzJszhw9tzxw+tD1z+ND2zOFD2zOHD23O3MKHtmcOH9qeOXxoe+bwoe2ZE5g3Zw4f2p45fGh75vCh7ZnDh7ZnDh/anPnoB9xOyRw+tD1z+ND2zOFD2zMnMG/OHD60PXP40PbM4UPbM4cPbc8cPrQ586kOL5fCHD60PXP40PbM4UPbMycwb84cPrQ9c/jQ9szhQ9szhw9tzxw+tDlzDx/anjl8aHvm8KHtmcOHtmdOYN6cOXxoe+bwoe2Zw4e2Zw4f2p45fGhz5gE+tD1z+ND2zOFD2zOHD23PnMC8OXP40PbM4UPbM4cPbc8cPrQ9c/jQ5swjfGh75vCh7ZnDh7ZnDh/anjmBeXPm8KHtmcOHtmcOH9qeOXxoe+bwoc2ZJ/jQ9szhQ9szhw9tzxw+tD1zAvPmzOFD2zOHD23PHD60PXP40PbM4UNbM08KPrQ9c/jQ9szhQ9szhw9tz5zAvDlz+ND2zOFD2zOHD23PHD60PXP40ObMNXxoe+bwoe2Zw4e2Zw4f2p45gXlz5vCh7ZnDh7ZnDh/anjl8aHvm8KHNmRv40PbM4UPbM4cPbc8cPrQ9cwLz5szhQ9szhw9tzxw+tD1z+ND2zOFDmzO38KHtmcOHtmcOH9qeOXxoe+YE5s2Zw4e2Zw4f2p45fGh75vCh7ZnDhzZnTvCh7ZnDh7ZnDh/anjl8aHvmBObNmcOHtmcOH9qeOXxoe+bwoe2Zw4c2Z+7gQ9szhw9tzxw+tD1z+ND2zAnMmzOHD23PHD60PXP40PbM4UPbM4cPbc7cw4e2Zw4f2p45fGh75vCh7ZkTmDdnDh/anjl8aHvm8KHtmcOHtmcOH9qceYAPbc8cPrQ9c/jQ9szhQ9szJzBvzhw+tD1z+ND2zOFD2zOHD23PHD60OfMIH9qeOXxoe+bwoe2Zw4e2Z05g3pw5fGh75vCh7ZnDh7ZnDh/anjl8aHPmCT60PXP40PbM4UPbM4cPbc+cwLw5c/jQ9szhQ9szhw9tzxw+tD1z+NDGzK1S8KHtmcOHtmcOH9qeOXxoe+YE5s2Zw4e2Zw4f2p45fGh75vCh7ZnDhzZnruFD2zOHD23PHD60PXP40PbMCcybM4cPbc8cPrQ9c/jQ9szhQ9szhw9tztzAh7ZnDh/anjl8aHvm8KHtmROYN2cOH9qeOXxoe+bwoe2Zw4e2Zw4f2py5hQ9tzxw+tD1z+ND2zOFD2zMnMG/OHD60PXP40PbM4UPbM4cPbc8cPrQ5c4IPbc8cPrQ9c/jQ9szhQ9szJzBvzhw+tD1z+ND2zOFD2zOHD23PHD60OXMHH9qeOXxoe+bwoe2Zw4e2Z05g3pw5fGh75vCh7ZnDh7ZnDh/anjl8aHPmHj60PXP40PbM4UPbM4cPbc+cwLw5c/jQ9szhQ9szhw9tzxw+tD1z+NDmzAN8aHvm8KHtmcOHtmcOH9qeOYF5c+bwoe2Zw4e2Zw4f2p45fGh75vChzZlH+ND2zOFD2zOHD23PHD60PXMC8+bM4UPbM4cPbc8cPrQ9c/jQ9szhQ5szT/Ch7ZnDh7ZnDh/anjl8aHvmBObNmcOHtmcOH9qeOXxoe+bwoe2Zw4e2Zq4VfGh75vCh7ZnDh7ZnDh/anjmBeXPm8KHtmcOHtmcOH9qeOXxoe+bwoc2Za/jQ9szhQ9szhw9tzxw+tD1zAvPmzOFD2zOHD23PHD60PXP40PbM4UObMzfwoe2Zw4e2Zw4f2p45fGh75gTmzZnDh7ZnDh/anjl8aHPmVpIniq8vDn67NoRvFH/PlCQ5kZ/NVFL9/7OZ9qi69WOmheBfvfQ9fis8fhIevxMevxcefxAefxw8frfdlnUytvDSmlLarnaHWuH20vfJpoUm2+W86W6T1RNN1sSwlxcxpcLV9lYJb5O8pfh+9UZm9AKjH5nRS5d+ZGhdMtannUwMBzLP15LeKZLR4Yni6KWZDIqjF4ifUVRho5i0Klwd9zlG+5iiiTZzbYpbGCl9v/ZOcfQyVQbFmYrlfhRnqsK7UfQzlff9KM7lG3pRnMtj9KI4lx/pRZFAkYHiXN6lF0V4Fw6K8C4cFOFdOCjCuzBQDPAub1H027VaKZPBCPPCghHuhQUj7AsLRgJGDowwMCwYp3Iw6fFUShUxago7G6cPrx1zkXi1PcTy5vBt2ei+OE7lYTpynMrFdOQ4lY/pxzFO5WQ6cpzKynTkSOD4HkfaLvZOZzhivX6T4/7zHO9jhuPC67XTe9jO0jeOdzYLr8ElNmnhdbXIZuG1sshmql7eh/ftPZAbG1e4b9/ePtIjlPT0vcs0VTuvK0kCSSaSUzX1upJcua/HS3Imp2CVDTvJVAqk8M39NFPtz0tmpsqfk4xRM9X9n5HR2rvt8tvfh+05tM5to/H6N1xGzeQS+pKcyVP0JTmTp7iYJNsv6IwiUO9AfSav8in1YPYXv7XybIG6CWH/ekM4bKezkZzJq/Qlua5X4Sa5rrf5lCTn802j1nVOXbnrlX1ZT+4ru7ie3Ff2fD25r+wQe3JHjX0R95ffMzIa9cxF3F9+L8kY1DNvcy9858IY1Ch8LFF38LFELcHHksDy7XWK8/sFxqCP3Is8auJe5NGn7kUefe1e5Bd2greHpTvKW6uZCuRvT1sfp83EA5QYs09y1H51MObP3O3CTrAr94VdY1fuCztMRu53lgs7THaWBJZsLBf2jOwsF3aB7CwX9nXsLBd2ap+yNPvDz1uDXWVYwnuxsST4KT6WqC/5WGIdf5ulI7WxdC7HEus4H0us43mWdzpYmV/QmeqIR346K3cYjd7Py7w9QlaFu1Thd3tTnSHZl+TKFR0vSQLJd0ny/apxqjMt5VBf2bt8o+51Zp1f2Y2U6azsL8p0VvYXNsadDlHxF7He7B0Wbw9Xp/te8WaqEylbsgwZlit7lx+wJJNhubJ7+ZTlHovx3n1jmYvFqz0Wf0CYdHaeYTfsMdrC1dFs04ykv11713RlHzWrpgRNp9N0Zb84q6Yru9FZNV3ZQ8+q6crOf1ZN0a+YTtOpTsNdRlO3fT0zupDRFP0bgZrS/jk9AHxoij6SaE29zWgKfzqCpsbZDcrtEbPJ6ATPOYZOj11RvXYZneAjZegEbyhDJ/g9ETpNdQ7wzDrBl8nQCV5Lhk6oy4fwxOnxRbeU6zFOdZ71zDqhLpehE+pyETpNdY74zDqhLpehE+pyGTqhjrhIJ0NuRxhdQSfro92u9jFldEIdIUEnu/K5xKJ0Qh0hQyfUESPoRHY/JodstBmd8DubIXRKex+WUowZnQg6jaWTUyp338P3jWTohOcaMnTCcw0ZOqEfIUMn9CNE6LTyedyidEI/QoZO6EfI0An9CBk6EXQSoRP6ETJ0Qj9Chk7oR8jQCf0IGTqhHyFCJ4N+hAyd0I+QoRP6ETJ0Qj9Chk4EnUTohH6EDJ3Qj5ChE/oRInSyqMsv0knvpwPcmt3F7y3bXSdrc9+ztKjLh9MpZb63bFGXy9CJoJMInVCXy9AJdbkMnVCXy9AJzwll6ITnhCJ0IjwnlKET+hEydEI/QoZO6EfI0Imgkwid0I+QoRP6ETJ0Qj9Chk7oR8jQCf0IETo59CNk6IR+hAyd0I+QoRP6ETJ0IugkQif0I2TohLq8SqdgCjoFv234GoLfryVzx+5RZnfBjqq5C3YUwW9jD2G73ERlC9iTjRvCROpw7HrMrgUxPdaCw8UhF0eKep+lMq8v1lqFXRz9DUr8ygCU1xwZcGdJYPkuy2jSztKpDEu0+d9n6Wln6f0zy7DyXd7ZPW7jgi6wTGHbZV4rfbi53gK/o1z5dumV3lGGY+BZlLeX3Bcqc3RPJ1VN3E4Vur12Kl2t9X4r1hQKV8e0QUk6c6sJK9+2Z9V05S7HrJqu/A0NqZqmZPcFVcVvoj5f7NM+S590wTXFW2n0dXE03jw5m7ByBYl0+ThdVv6+CtLl43RZuT2PdPk0XeLKjxWQLh+ny8qPQ5AuH6fLyg0+pMvH6YImJtLlg3QhpMtM6XIXFQ3SCUVFh3RCUdHHlCeqVkbtqpIqLNc6+f2Bf0rTfLcooekhMHNv9mAL3CbzfD9K6E3MqCpaCNJVTRlV4fRnVJWg6oSqwpHPqCos+YzVEjz5jKriK0Azqopv6synKin0lmZUFb2lGVVFb2lGVdFbmlFVdCFmVBVdiCFUNWr/1bsx31W964S+ggyd0CmQoRO8vwidNNy8DJ3gz2XoBMc9hk770ds3mVRGJ3hoGToRdBKhE/yTCJ0M6r0xdNq/723snyK564R6bwidrNs/T982i951Qr0nQyfUezJ0IugkQic8rZKhE54/ydAJ/kmGTnj+JEMnPH8aQiey2/cjDEVbuNrTtge494/euvW5WUa3IYkxfbv2t/4WfY619Uf/ZG390ZeZW//0OKlD6VS42Gm7PbZ1OlLhau+t2uOwOpNcaCYhuS5LLkJyIbmuSi607ZBclyUXeo1IrsuSCw1SJNdlyYWuLpLrsuRCKxrJdVVyEfrcSK7LkgtNdCTXZcmFDj2S67LkQoceyXVZchGSC8l1VXKhQ4/kuiy50KFHcl2WXOjQI7kuSy506JFclyUXOvRIrsrkCnbPknAj8pxcDh16JNdlyYUOPZLrsuQiJBeSqza5otuT64D7kVxoRSC5apOLzH7nusWfSS4U9Eiuq5LL48E1kqs2uaLbgIToc8mFB9dIroc2tG8360irTLoQ0gXp8n664OEy0uWDdIFHQ7octNktvYsq8xjF4wEw0uWDdMEjXaTLQRuv9nQxJR+lrTK7Olb9yUnlgD+kv/3tdel653aG2nmVWRwDnBrSt1367rP8lb6laDRFtwdPMWT67xFdLKRvdfpqs7+41S5zd4y4OyK9LkwvQnohva5LL/TJkF4Xphf6akivE21CJl3QV0O6fJAu6KshXT5IF3xXCunyfrok/JwB6fJBuuAHCkiXD9IFXWmkywfpgj4N0uWhTdrPBHEpuky6oO+CdPkgXdB3Qbp8kC7ouyBdHi+s9q+/ea1ztQv6LkiXt9PFKfRdkC4fpAv6LkiXD9IFfRekywfpgm/3IV0+SBdCuiBd3k8XdHWRLu+ni0btgnR5vLCmsKdLZocNp1G7IF0+SBdCuiBd3k8X1C5Ilw/SBU+kkS4fpAueSCNdPkgXPJFGuhzSZb/amz/9LO356mhoy5JovHkEHb9yC4+vkVsX5ZbBs27k1lW5hQfjyK2rcgudaOTWVbmFtjVy66rcIuQWcqsut7R3+wb4t78P2bW3IQx64kivC9MLPXSk14XphZ470uvC9EKPHulVn15BP9IrZtLLot2F9KpOLx9pT6+gMt+9tOh4Ib2q0yuYx+IYyGfSC00vpNeF6UVIL6TXdemFvhfS68L0Qt8L6XVheqHvhfS6ML3Q90J6XZhe+Hoq0qs+vaJ/pNcB+J5ehG+oIr0uTC907ZFeF6YXuvZIr+r0imo/GddHrTPpha490uvC9CKkF9LruvRC1x7pVV97Hb6QE7UpXV9xLP3e+HAupUz64qkA0ldw+uKpA9JXcPriqQbSV3D64qkJ0ldu+jo8lUH6Ck5fPPVB+gpOXzxVQvoKTl88tUL6Dpy++2ML55XKpC8hfZG+zdJ3n+Wv9C1Foyk+BKI/v/49fdF5QPqOm74uPtI3ZL5R5dF5QPoKTl90HpC+gtMXnQekr+D0xTfOkL716esO3/b3ufTCN8KQXhemF76xhfS6ML3wjSqk14Xphb4j0uu69AroCyK9Lkwv9O2QXhemF/pqSK8L0wvfuEF6VadX3Hnf/naZvakDIb2QXtelF7r2SK8L0wtde6TXhemFrj3S68L0QlsV6VWdXunx5XifPD2nV0RbFel1YXqhMYH0qk8v/1gcU0iZ9MIjbaRXbXoFo/cz2W5/u+f0SngohPSqTy9nH+kVMz80THgohPR6vLBxYU+vGH5w9T25UHkhuS5LLkJyIbnqkktH//jZx+3vjGtMeCCE9LowvfBACOl1YXrhgRDS68L0Qs8L6XVheuF5I9LrsvTyCs8bkV4Xphc69kivC9MLHXuk14XphZ490qs6vYJ+CB+czqQXIb2QXtelF7r2SK8L0wtde6TXhemFrj3S68L0Qtce6XVheqFrj/S6Lr00uvZIrwvTC117pNeF6UVIL6RXbXpFtR93FqNWmfSCc0R6VadXOty9ks3dveAcL0qvQLSnF32/+k4epqoTeQO/0Ys8SvFe5PHdkl7k8bWLXuQJ5C8iHx6lc9AZ8nhY34s8nmP3Ig+j3os8PGwv8vCwnchb1PNXkU+PqjL5DHnUNheRj7R1Qk10NkMetU0v8qht8uTvdFB/vKKDGuEFHUIv+hUd9Itf0UEN+IrOyn3XZPavFZiUQmH99+qx9eSh4o3uiySBJBPJlb0DL8mVvQAvyZVre16SK/sAVpJu5brvQ5L7Q1B/+HbqgyTW7rdJ+seX9mKG5MJrt7VhY6MtOVMgqW/B7JtR6BgeX2v12Y6rMnvH1ZjDtXfuC6/0XbkvXBd05b5wFcHI/c5y4d4jN0u/cKeSneXC9S07y4W7oOwsF+6ZsrMksHyf5f5bLK2T0i/rp6TDFnnSh99Abdzh0/pwh0/rwx01bhfuAXXHRdzN7o+TMfGJO2qUPtwJ3LtwRz2T536ng6rjFR30cF/RQaf1FR3UlS/oRHRDX9FZub/p9IOOO/SFHnRWdg5lOivX92U6BDov6KxcK5fprFwrl+msXCuX6axcK5fprFwrF+mklWvlMh3Uyq/ooFZ+RWflWvl2X9npBP2dTubVTdq+cm6tfhyP9tVlTQSSTCRXrsF5Sa5cr39I8nb9TvLbs9rna0nv1Mnop+e6aWUf0I/6yv7iG3WTW+dX9hc3d3Wg87wjT1j51G8brH7QcfpHK05Y+YBrZpIr+xZekit7nA9Jsq3HQRGod6C+snf6Rt3rzDq/tB96HBNyo2MydBb2LaTCHjdp+tnuA2Hl0zSZSS7sW3hJrnxGIjPJhT0OM8mFPQ4zyYXrvk9JvtzvJqx8ntmnJF/udxNWPp+MrN07smT/tAv48/UmhO3Vb3/++RccYeXzxphJrrx285Jcee3+jKQO3u7zDJ6eWS7coWRnSWDJxnLlqpKb5cK9R3aWqCzfZxkeu8zc/k5/ZrnyOUCfswzxwTL6J5Yrr+P0YEPO0DeWdzorr8xlOiuvtWU6K6+eZTorP7kr01m5o1ems3ItVaSz8ulKb9BZuZtWprNyZe1p/84t+WhLlfXL6+80V66t+WkSaDLSXLl2/4zmDcQWuLHq8IQxpi+WK1f63CxX9gXcLFd2EdwsV/YcP2CpzTNLt7JD4Wa5sp/hZgn38zZLu1tJY5P7xjJz9cvTf25Pe8C9C3cC9y7c4b04uN9ZwnvxsYT34mMJ78XHEt6LjeXKJ9qxs4T3epulo22axh1/57yzhPfiYwk/xceSwJKNJepLNpYB6/i7LG/9fLO/+vHqnSXWcT6WU63jlnaWt9tX4erktzlqpR5NH3PDdEcz1bLMi2aqVZYXzVTNwo/QHHZB/PVl88OtSX+xmar5x8xmqmKLmc1UzTlmNlM123jZzHUAGjObqYpoZjbrFsVlNutWxWU2BDanbFAXn7NBXXzOBnXxORvUxedsUBefspnrsDNmNqiLz9mgLj5ng7r4nA2BzSkb1MXnbFAXn7NBXXzOZt26mJTe9uIiTZRhs25dXGIT5zqki5nNunUx6ZB2Nkl9Y5N57ZdHRcW5Dt3qyHHdepuXI4HjexzZjtCKcx2hJYT5ul6CjN3XdnPYZj3PnGLaXpuSMYWrXdhe2qUDvvgFfV2T0hH6wu6nH/SFbVU36HMdOCYF+sJG8DPoyT2g+/Rsqec6m6wryYXN4Ick0/7ZVibT5tEEku+SNDtJihmSC5u8T0nuYSvnMyRh3bhIwo9xkVzYZNl9tySyf2Lz2dV3kgs7J16Sc53h2JXkwh7nI5Kawv5zSKePvy/Oxf36hOE413mPYqgv7J06UidQ70B9YU/WkfrC/q0jddTVl1Cn7WLv9DP1uc66HIe6317a+5ihjhrmTepO75N0lr5Rv5MkkGQiiVqDiyTqBy6SC/d/P1yd9rBvJF1hdboFG+kReHr68tlc54MK4o4auAv3uc40FcQdfes+3OdyfXG72pJx366+z3aqyjbu3y2ySVFmtjOt3aT3q0kn/zzbqc4nu33I92f+QavMbGf63JZnO1OXpDxbmmm24fHtlahU4eq4z/FWAe/X/tqi9vnatN/sU/p+7Z3iTPf6fhRn6mD0ozhT96IfxanqmW4UZ+osdKM41elW/ShOVbN3oziVF+hGcSqP0Y0igSIDRXgXDorwLhwU4V04KMK7vEXx9RlF0cO8cGCc6ky/jhhhX1gwwr+wYISBYcE4Ve1demo61cF25dlOVcsWZztVzWnUvpOKoZiZ7VSlYWm2Ux0QV57tVIVWcbZT1UPF2U5VthRnSzPN1rotbKJDLZW/2vv9V3/xUdAZ87VzwVTHrPGSmapGYyUzVT334nthGRuz74uodTq8tNvQTFX8saKZ6xCx0reA5zoWrDjbqb7PXpztVL8eTvtvAG3ypat12FYGo2yh5cP4HGeuA8FEEJ/qNxsiiE/1q+UxiBeaznOdiSYD+VS/bJaBfKofNUtAnuY6GE4G8qkMlwzkU7m+tO8vRZpKzQ4T7PbrcROOx1KpkIXutkZKVIG+XX0nOZej7EmSQJKJ5FwO8EKSet/iLxrtMyTncnY9Sc5l2HqSnMuH9SQ5l73qSHKu49m6kpzLDPUkCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EiOdeZa11JwuNwkYTH4SIJj8NFkkCSiSQ8DhdJeBwukvA4b5L0+yRjiCZDEh6HiyQ8DhNJC4/zJsnkt0hiijpDEh6HiyQ8DhdJeBwukgSSTCThcbhIwuNwkYTH4SIJj8NFEh6HieRcJxZ2JQmPw0USHuc9kkkZ9XV1UsfTHHeS8DhcJAkkmUjC43CRhMfhIgmPw0USHoeLJDwOE0kHj8NFEh7nXZIhbSR/v94TSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TyalOlO5Lcl2PYx9nAlkTfYGkDo9Igqdj2HeQ61ocZpDrOhxmkASQPCDX9TfMINe1N8wg13U3zCDXNTfMINf1Nh+CTGm72ihVCNsrtT2i8Eo/U5/qbOphqLu0m6Y8dXimd6nvZ/IYZc3rsOlwGuDh52m/QsrcjZJ+3I6SeYRtUvwSCX5MgEjwegJEIog0vkjwqAJEgv8VIBK8tQCR4NsFiISewPgiRbQQBIiEjoMAkdBxECASOg4CRCKINL5I6DgIEAkdBwEioeMgQCR0HASIhI7D+CIldBwEiISOgwCR0HEQIBI6DgJEIog0vkjoOAgQCR0HASKh4yBAJHQcBIiEjsPoIpFS6DgIEAkdBwEioeMgQCR0HASIRBBpfJHQcRAgEjoOAkRCx0GASOg4CBAJHYfxRdLoOAgQCR0HASKh4yBAJHQcBIhEEGl8kdBxECASOg4CRELHQYBI6DgIEAkdh/FFMug4CBAJHQcBIqHjIEAkdBwEiEQQaXyR0HEQIBI6DgJEQsdBgEjoOAgQCR2H8UWy6DgIEAkdhytEstuxLBTiN5Hu0NFB6AAdHYH3oBu9T9LoQyT3421uIAkgeUDCWTOBhPtlAgmH+i5Ia3eQKTGWbDbFbYqk9X613Zcx+NPhJYI7HV0igjcdXiI40+Elgo8dXiK43uElIkg0ukRw6ldI9LphR3D1HaBPZS9t3DGScd+uvs92KqdWmq2byvQUZzuVfyD7mG3what12Jaz21OT/VoTbebauPOINhWuTTvylL5feyc+lR0QQXyq6l4EcQJxbuJ+u1YrZTLIpyq+ZSCfqvSWgXyqR28ykE/ldWQgn8pwiUDup3J9L5DfZ7uK67vPdhXHdZ/tXG4nbg1qG0mXbh4m7p9ya+lxtVbZ1zZuJ0n+29V3kgSSTCTnMic9Sc7lOS4k6fYv9VsXVYbkXFaiJ8m5HEJPknMV/h1Jhrnq+Z4k5/IKPUnO5UN6koTH4SJJIMlEEh6HiyQ8DhdJeBwukvA4XCThcZhIRngcLpLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXicN0kmu/9sTqWYIQmPw0QyweNwkYTHeY8kmQdJ40yGJDwOF0l4HC6SBJJMJOFxuEjC43CRhMfhIgmPw0USHoeHpFbwOO+SDGkjaf9E8rOr79zhiPpwh3/qwx1u6wrumvZNi7TTh7hjbpZebT9w9Obw+47ovjQiaDS8RnCI42sE7zm+RnC142sEvzy8Rho+ZgCNaLvYO53RiKBRf4282TTyMaMR6rpLNHJ6R+KOrx39F3fUan24o/7qwx01VR/ueGJxzRq8T/LG3RXW4NvUHqEkk8J+/ZdKBk9DJKgEzyFBJTxpkaASnstIUInWVck+SPrDtpwn3F9cfSe5sM9mJrmwc2YmubAX/oikMWo7GseQzXzLwCzsbplJLuxXeUnahT0lM8mFfR8zyYW9GTPJhf0TM0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0SS4HG4SMLjcJGEx+EiCY/DRZJAkokkPA4XSXicN0k6s11tXO43jgSP8yZJsmkn6VXhar6zoTXBO42uEDzZ4Ao5eL3RFYKHHF0heNPRFYLnHV0hgkKDKwSPPrpC8P6jK4SewugKoacwukLoKQyukEdPYXSF0FPorpDffyOmlMlIhKbC8BKhqzC8RASJRpcIfYXhJUJjYXiJ4IrelMj5sEuUyjsBJWW3F3fpsC/c12/5g9wa4B6/3AXyHv/gq0eye/okosJLm+C3QEwI9vjS98kOfh/mnezgvVLeyQ7eduSd7OBrFetk4+DNMN7JDt5X4p3s4B0a3skOXud8ONm0bd9roqbnydJKk52rgipMdqYKyhqVHmGH58nOVEEVJztTBVWc7EwVVGmyox/c/elk1cvJzrTO3hoz20tbMup5sjOts8XJzrTOFic71TpbmuxU66xNcZ+sVq9f2qV9G1WXUuZuNtWi/AkZr/b7vFeZQnT0M2+b5EyOjBn9DNsPbx37AyFLh9N8aj5NZvRTZpuQyefMTK0YS8HvZFJ8nuxcJWJhsrTSZOcqEQuTnatEfEzWHZ7P75OdqkQsTXaqqq802akKucJk9VS1mTX7t0ycDoWX9nGr53Wgw9dGSH2hmaoECXF3vCHZn5Wteqp65RMyBRNoRj/Ks0nO5MlMVQk9Xtr+6aFU5qVV2l9aW5W50UxVN0Wzhx1T4aVJbfdrMt/vwJkwHi0JfWvf7VfbHeNUFVk/jFPVev0wTlVFdsM4+omPUjBO1Wjsh3EqS9AP41T+4SOMdrMPFOJzJTj6OYL9wOD3Sr9eu/WPYQyOvuvEHZuW9OGOH91dxN3Sg/thc2Z/crU5XO3/rBKO7BOhErYkkaASdiXpr9Kv79Xt9kqHJ42wLcn4GhE0Gl4jbEwyvkZw+uNrhK7A+BqhgzC+Rug2DK8Rjs4UoBE6DeNrhD7D+BqhzzC+RgSNLtLorE+aee1o92/Va+9Lr532Wd4EPczylgl3TdGXmE9T9DHG1vSuEjoZElRCL6O1Sr+5r3xQpYl7yWYtFUiS2X/8QtYVuVN4lIOH76DomP3JEW0X+8OP6m9z/9JoYV81jkZh4+dvujxrtLCvEqMRQaPhNVrYJ4nRaGHfM5BGetfIZzRa2PWI0WhhzyNGo4Wf346jkd88rPfxWaOVj64UoxH6DONrhD7D+BqhzzC+RgSNhtcIfYbxNUKfYXyNpvJHlnaNbPCFq8kq86B+fKapf0799ROhMJXjGYf6675nmMrDiKE+lSsRQ30qnyGGOoH6JdRf9nhHP454UupTVfdiqE/1XHAc6q9d0ugnRU9KHd60A/XRz86elDq8aQ/q8KY9qMOb9qBOoN6B+lT1urI7dZVKgWjytD3WuP0dj7+MMZnrjYvbr2pvfx6g3P6+s5yqCu/Mcqraui/L0c9KF8Vyqjq4M8upqtvOLKeqWa9lGfatNG4PRFSGJYElG8upnn10ZjnVE43OLOF7uFhahfrybZY+bYHf/rQZlljH32YZ43b5zeK4DEus4++yvDWgHq9uUoYl1nE+lljH+VhiHX+fZTD7q8fva89nV9/Jo9vZizx6o9eQ99HtX4uPhx357ntZ3QCDexfu6Ln24Y7+7EXc0w7FJxOeuMMD9uFO4N6FO7xlH+7woX24w7P24Q7H2oc7/OpV3B8/407uibuBX+3DHX61D3f41T7c4Vf7cCdw78IdfpWD+50lavJ3WRa/O2JQZ7OxtKid+ViiHn6b5bfv2lGGJWpcPpaoW/lYEliysUR9+T5L82BpS3X9rULafkVzW5Toz3W9xfOQPtzxPKQPd3ivi7hbn3bu8dg/+OTau0bwdMNrRPCK42sED9pfo9fn0luCtx1fI3jm8TUiaMSg0Z0lvPj7LB8nh4cQMyzhr99nGfeeekgpwxKeuSovsyzhg/lYwq+ysXSoh99mGd02zdufOZaoW/lYEliysUR9yccS9eX7LMm8Zol1/H2WhX1o5jo/ujNL9HH5WKK+5GNJYMnGcuXehrVqZ2mTL7DUITi7XX/7+4HlqxfsV+5tcLNcuSZiZjnXCbNXswzxwfJw6trGcuWaiJvlyjURN8uVe27cLAks2Viu3HPjZrlyz42bJXwPH0v4HjaWc539+CFLtZ+orklTKLD0jx+OO33obLgvkitXlx+SfHmSvZ3rjMauJAkkmUiuXFfykly5qvyUpN5J+gzJlWtKXpIrV5S8JFfuo39I8uXpvXbpkz15ScLjcJGEx+EiCY/DRZJAkokkPA4XSXgcLpLwODwkaeWTPK3dt6rUlpwpkNQ6xr3LrpM6np7zfHXSYYs86afdCUgtXH125b5wrXotd6M3KMmYZ+4LV7ZduRO4d+G+cNXclfvCNfbF3K3eudv0xH3hirwr94WfUXTlvvATjZ7cVz6Rtyt3+NU+3OFXr+KuzKOOjE/c4Vf7cCdw78IdfrUPd/jVPtzhV/twh1/twx1+tQv3lU/k7codfrUPd1qXu0lm3xXHpPSzX47RymeOfkry5W9LyCxcYzOTXLhqZia5cB3MTHLhyvZjkq9+pUMrn4DLTHLh6pOZ5MLPPz4l+fqbviuffctMkkCSiSQ8DhdJeBwukvA4XCThcbhIwuMwkVz5xEnjld5JhmPgWZK3l9Q7FO8KV5uQHufq/WkHsjv5levPS8lHs7XvTbQxQ55AvhP5levbvuRXroevJa/2M+yiDhnyK9fPfcmvXG/3Jb9yfd6VvFv5mUVf8is/4+hLHh62F3l42F7kCeQ7kYeH7UUeHvYq8uFxFm7IdA8cPGwv8vCwvcjDw3Yiv/Jp0ReT3yO/kU8Z8vCwvcjDw/YiDw97FXmKO3lnM+QJ5DuRh4ftRR4ethd5eNhe5OFhe5GHh+1EPsDD9iKPev4i8n7fFuH22ql0NVm7XU3RFq729PiW8qPzb31ulinuZ/WqQxj5i71xG0BvYumlf+38sH+5Okatvl1/Ty9CeiG9qtOLHsIf716P9IIzQ3pdmF6wn0ivC9MLHhvpxZNe3mTSC40EpNcP0ose6RVc6dXTztun47eRYubiaPbXjuaQubeL74mLPgwSV2LiRrSxkLgiExffZEHiikxcfBEIiSsycfHcBYkrMnEJiYvElZi4eFaExBWZuHgKhcStTtxkdoC3v/236+/phW4r0qv+vpge3wBKKvMNoASHjvSqv3vph/DJ6kx6oapDel1490LthfTiqb1sLr3wDSCk14XphW8AIb0uTC84R6TXZenlFL5Ng/SqTy/7aNgmokx64TsvSK8L0wt9L6TXhemF748gvS5ML0J6Ib2uSy907ZFeF6YXuvZIr/r0KjxzdApde6TXhemFrj3S68L0Qtce6XVdeml07ZFeF6YXuvZIrwvTC117pNeF6YWuPdLrwvQipBfS67r0Qt8L6fV4Yb1ffcs0VUqvYOz+4uE2hUx6oe+F9LowvdD3QnrVp5e3j/QK6Tm9DPpeSK8L0wt9L6TXhemFvhfS68L0Qt8L6VWdXlbt6oRbomTSi5BeSK/r0gvfVkV6XZhe+LYq0qs+veiQXs5l0gtde6TXhemFrj3S68L0Qtce6XVdell07ZFeF6YXuvZIrwvTC117pNeF6YWuPdKrPr3sMb18Jr0I6YX0ui690LVHel2YXujaI73q02uf46+/Uya90LVHel2YXujaI70uTC907ZFe16UXoWuP9LowvdC1R3pdmF7o2iO9LkwvdO2RXvXpFQ7plTKnchAhvZBe16UXuvZIrwvTC117pFd1epHeNx4PZDJ7TBC69kivC9MLXXuk14Xpha490uu69HLo2iO9LkwvdO2RXhemF7r2SK8L0wtde6RXfXqpY3plTkRzhPRCel2XXujaI70uTC907ZFe1ell4mN3QrKudD1ZvV9P2Q2bHLr8SMd26WjdIx2dLl4f3R48xRAz6YunCEjfdunr6JG+Pud88dQB6djnbppLR4+nFEjHgdIRTzWQjgOlI56CIB0HSkc8NUE6tkvH4B/pmMzPnbgnpC/St1n6psfd9NZyz6QjnuIgHbvcTfPpiKc+SMeB0hFPfZCOA6UjnuIgHQdKRzzFQTo2S0fS4ZGO1v7ciQc89UH6tktfe7ibUmbn9YCnPkjHPnfTbDriqQ/S8b/HSUc89UE6DpSOhHREOo6TjniKg3S8JB3v6YWnMkivC9MLT1mQXhemF56aIL3q08s90svEzPaSAU9BkF7XpVfEUwqk14XphacOSK8L0wtPEZBeF6YXngogvS5ML0J6Ib2uSy907ZFeF6YXuvZIrwvTC30vpFdtevnk90faPoX0nF4JfS+kV/XdSz2Ev/3tM+mFvhfS68L0Qt8L6XVheqHvhfSqr72SOqSXyaQXIb2QXtelF/peSK8L0wt9L6TXhemFb6sivS5ML3xbFel1YXqha4/0uiy9vELXHul1YXqha4/0ujC9COmF9Nq10TZt2uhIhasD+e21b3+mTHKh64Xkuiy50PNCcl2WXOh4Iblqk8vrTffgTcgkF/pdSK7LkgvdLiTXVcml0etCcl2WXOh0IbkuSy5CciG5KpPLxS1LgkuZJqqGW0Ry1SZXSFvQIVqdSS64RSTXZckFt4jkuiq5DNwikuuy5IJbRHJdllz4LSOSqza5otN7cmVOc/cGv2REcl2WXITkQnJdlVz4PheS67Lkwve5kFyXJRc69Eiuy5ILHXok12XJhQ49kuuq5LLo0CO5Lksu9LmQXLXJdfw+V65DbwnJheS6KrnQ50JyXZZc6HMhuS5LLvS5kFzVyeX3b0X4EJ+Ti/CtCCRXbXKFnV8ImjLJBbeI5LosuQjJheS6KrngFpFc1TVXCo/kcpnkgltEcl2WXHCLSK6rksvh2SKSq7rm2o9ivP2Zqbkcfv2D5KpOrsOvf7QtXK0puj0Uirm+mENfDMlYm4xR+z0Zcx19h74YkovjTpdNLkJyIbmuSi70xZBclyUX+mJIrsuSC30xJNdlyYVfCyG5rkouj77YEMllaENoTFDfrr7rhJbREDpZs722sWQzOqH7IkMngk4idEJPYIz1KT50+lMkd51gr2XoBKcqQyeYPhk6YbcFEToFfLlIhk7oR8jQCf0IGTqhHyFDp5X9k3IPnW4zLrJUce+VmkOvNMYvlit7HG6WK/sQbpYre4VPWdL+sM04+41lJhaTNvLWHn5x5+/c48q1f0/uK9fyl3K/Pb7ducdw4P7JtXeNVq7jpWi0cg0vRSOCRt01Ir2vR2T0s0YrP0uUohF88PgawV+/rZF9fK/LBlXQyIVNUJcOAL/sY4QV74Idrr0H9gTT3gU7PHsX7LDhb2Onx6MUOr56FvvtPrJdfcvtcAT/fHE0tPGOxptnlWDEJahEUEmASjDjElSCHZegEgy5BJXg3yWoBLs/vkpBwS+9rZIze5vYGfdNpTtLVGLvs6T9S3/OqQxL3OPfZ7lfbpyPGZa4E7Ox1Oim8rFEi5Tjfllxd9VY9XuRR+fzGvI+ug3h7bn6Y4MW/8WdwL0Ld9TEfbij33gR97RDuT1sDE/c0UHswx1+sQ93eMsu3A18aB/u8Kx9uMOx9uEOv3oV9/3BjE/umTuBexfu8Kt9uMOv9uEOv9qHO/xqH+7wqxzcf7O0C9fk+rZibS+ukyrtYq8pbFC008efGOYi948UdvpwrfvivnBNfi33sFuh6DLcCdy7cF+4Ju/KfeGavCv3hWvyi7nvX5z99d+fuC9ck3flvnBN3pM7LfwM6Vru/nFmVcxwX/gZUlfu8Kt9uMOv9uFO4N6FO/xqH+7wq324w6924e5mqt9Nemyrp7Qqcefsp7uZ6vFLOb7uW7mZ6uueHGeql3tyJHBk4ThTPXstx5f9NjdTfdqT40z1Zk+OMz3vuJRjoQ6f6flFR44efoaHI/wMD0f4GR6O8DM8HAkcWTjCz7BwDFmOOuyH9x3aoSbazBvEHXm0qXBtihuVlL5few/GjxRMGCmYOFIwaaBg8ucZ9gpGjxSMGSkYO1IwNFIwI92B40h34Nj2Duz3VVUpk4kmDhVNGimapIaKRg8VjRkqmvzdhlLaS0pnXte2UW2f2kiHEpvU1zv4y98hXP4O8fJ3SBe/Q1Tq8nfQP38HtzmwGPy3d8i4JJU2K2O0elxNuS9pxLjt85y0Kb2wTds8DanHwzO7T9SsMlG7ykRplYmW7/fh20Tvo3zVqFAzSuur71PaXP4O9vJ3oMvfwV3+Dv7ydwiLfKx1XGWiaZGJGrXKRHXNKmFM1ShbM+pkbwaznwNtrX5svLENoppBrmZQ/itIHxxpfX7t/Q3C1W8Qr36D9NM3eH3qdzz52SXjG+ir3yCrgbk99tg+vbeHDk+DUsWg/FfcS4NO7hKfPPq6XfF1sTs+C/x69BWduf4t7PVvQde/hWN9C1KZt/DXv0W4/i3i9W+Rfv4WXm03Bm+ev1IYvbr+LfT1b2Gufwt7/VvQ9W/hrn8Lf/1bhOvfIl7/Ftd/usP1n+5w/ac7XP/pDtd/usP1n+5w/ac7cHwuXv66L0aOjHr5Rah48m0Jp/eviDlL397iPszWDaO6Ya5u2Mn9d/9C222YK+DTycSddjLpyVCcPK1nfpPY4k1Sgzc5eWTO/Cb28o9m4riHvfztWkzu+rfw179FuP4t4vVvka5+i6TU9W/BsZ68/GFWUub6t7DXvwVdvfAm5a5/C3/9W4Tr3yJe/xbp8rfQ6vq30Ne/hbn+LbJJ69zWNXXxWOmZr0GhZlCsGZRPFRX2Wf36O/2pIkknj7lUSHsJq24Pip+G6bphpm6YrRuWv1mq2wOlx7DDJuzbMFc3zNcNC1XD7Ilu6bEdvUpePw07IZniti291ko9kbRUN8zVDQt1c4t1w04+OCnZQ5Duz8NI1Q3TdcNM3TBbN4zqhrm6YfkPzu3S9Bhmjlnyx+c5ld9Pi/tNYos3ST9/k9fPIlP+CSHvW+jr38J8+hb3YbZuGNUNq7tFnjyfKw4LdcNi3bBUNcyrumG6bpipG1a3kPq6hfTkUUdw+401hOPPVHOfFhPU/g2jYMzTW6TL3+LkUQfrW+jr38Jc/xb2+reg69/CXf8W/vq3CNe/xfWf7nD9pzte/+mO13+64/Wf7nj9pzte/+mO13+64/Wf7nj9pzt+/Om+D0tVw5KqG6brhpm6YbZuGNUNc3XDfN2wUDesLktSTZY4pVTdMF03zNQNs3XDqG6Yqxvm64aFumGxblhdlui6LNF1WaLrskTXZYmuyxJdlyW6Lkt0XZbouizRdVli6rLE1GWJqcsSU5clpi5LTF2WmLosMXVZYuqyxNRlia3LEluXJbYuS2xdlti6LLF1WWLrssTWZYmtyxJblyVUlyVUlyVUlyVUlyVUlyVUlyVUlyVUlyVUlyVUlyWuLktcXZa4uixxdVni6rLE1WWJq8sSV5clri5LXF2W+Los8XVZ4uuyxNdlia/LEl+XJb4uS3xdlvi6LPF1WRLqsiTUZUmoy5JQlyWhLktCXZaEuiwJdVkS6rIk1GVJrMuSWJclsS5LYl2WxLosiXVZEuuyJNZlSazLkliXJakuS1JdlqS6LEl1WZLqsiTVZUmqy5JUlyWpLkvqeq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qut6r7qu96rreq+6rveq63qvuq73qk96r2n/hqFOpDPDTrJk39JPp2S+Dctt5ct0UMgtnDBWOHGscNJQ4Zz1tnuFo8cKx4wVjh0rHBorHDdWOGPdleNYd+U41l05jnVXTmPdldNYd+U01l05jXVXTq3vyi/PuLrF4waLxw8WTxgsnjhYPGmoeEz+Ca65la5fw4zRrhDPzaGrPXwf/rx7we1NdIs3MS3exLK8ifWPN/H28CaZX+RFu20MZNVx3yeV305V7XuuKfv47X0yX/HT4PG7nb931j7H74TH74XHH4THH4XHn2THr5Xw+LXw+I3w+Edff0vxC19/tfD1Vwtff7Xw9VcLX3+18PXXCF9/jfD11whff43w9dcIX3+N8PXXCF9/jfD11whff43w9dcKX3+t8PXXCl9/rfD11wpff63w9dcKX3+t8PXXCl9/rfD1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",
      "brillig_names": [
        "discover_new_messages",
        "decompose_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "liquidate_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "market_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "debt_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "user",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "debt_to_cover",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "1VzbbuM2EP0XP/uBw7mQs79SFAsncRYGDCdwkgJFsP9eybUkr2OFqdbHFV8CK5gz5wxvGl7E98XD+u7tx/fN7vHpZfHtj/fF9ul+9bp52jVP7z+Xi7v9Zrvd/Ph++u9FaP+QyQHw8rzatc8vr6v96+IbcRRdLta7h/Y359A4edxs181TaH5/tA8xduZBYm/t6YKxeEhHY3Gy3tj0gnEWyUfjLCanxn8uG/l+HfnunTmR305+ulLpa+5LPxdKnzR18smYP5fvynI09gZ3Lj/Ha8un+Iv8lsTDLUj0IolbD/Kce5Aytl3EcDlmVzuCGov4uRzjjsB0qGW3f/0r1j+B9RNav2P9RwH7B+tnsH7OWP/CYP8J618j2D9YvxHYP3h8MHD/SuD+lX6/fzV12OVM0U5Sgyb/O1BkxlPgo3B8FJ7QFBwingIfBeGjIINTRMJTKJyCA57iBlE4nAKcabBgMyUGZxqsYP0G1m9g/QmsP2EzPc5g/dmw/j2A/QvYP7Z9SmCwf3heIfi8QggfRcRHEeHZkTDhKfBRCD4KgWdHogFPIXgKeI4nho/C4FNdAWcaAs40JBPYv4L9Y9eUxMH6Hatfg4D9g/UTg/1j+5dGAvvHtk/lAPYPfwsofr1CBR+F4KNQxlPA38hq+CjweYWmiKeAT680E54CPjFRx0fhiqfAvqkNnGlYwK7JGEWwf+yam0Ww/gjWzwT2D9YvAewf3L/AeyIG3hMx8OkLu8LpC8qhOxhImfIHBnALTeAeBl6rsAzuAeC1BAOvJaRAYP9l/eaFHmDSGZPZcPxUjgyOZiCBM+TfZ6BI/XFjiqKD+aXDyRyEjtYc9JcztK2gmGYmiOPcBM2tykRnJugLuxo3FmQzE2Rza9T2P5SQd9YcU+EsPwVKofMdIp+f5k9fyFbmrV/r1p9D5forL3+//UuJ+w93mE++iBrRn5h7/UnP9edw+wFRuCtRFkkl/Tn0aVzIHD7ov/34KUSD/lzS79R/yhVc87l+CpXr18r1e936v/C11bz1V17+QpXrr3z81MrLXysvf6u8/K3y8k+V5w+p8vwhVf7++sKnjHPW72FO489B0JwadCtoVjOMgyC5uSCN3Y4ea3HKSezDdRoS+YN+r1t/5Mr157r1c+XlL9dYMuIsA8fpfufhzhq/yk5GiSPjOYzhHBRGdupEepjoUOnR7AizSbCRGW8RptNgPgk28vFNEXa5SQxn9sjisIQqR9TIplIJlaag8hQuGrlz6dMt8gYlU1A0JS4aOSFfQI2cey+hJnHJJC6ZxuVTUCMnw0uoSfU1Mu8voWwKKk1qvSMzywJq5Cx0CZWnoEYuYCmhfAJq7Fa0EmoSF/EkVPqvqJ/N01+r/WZ1t10fb4N8fNvdn1wO+fr38/rsnsjn/dP9+uFtv25vjBwui2yHuihhGV0bNW1hRbclaziMus1jU8fLpsYOVdA+ujSP1mhodPwD",
      "brillig_names": [
        "liquidate_public"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "PriceFeed"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Lending"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "market_assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "market_assets_list",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "market_assets_list_len",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "scaled_deposited_assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "scaled_borrowed_assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "scaled_total_deposited_assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "scaled_total_borrowed_assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposit_accumulators",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "borrow_accumulators",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "on_behalf_of",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::deposit_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::deposit_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_deposit_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_deposit_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "deposit_accumulator",
                    "type": {
                      "fields": [
                        {
                          "name": "value",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "last_updated_ts",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 64
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "accumulator::Accumulator"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::compute_total_deposited_assets_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::compute_total_deposited_assets_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "oracle",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "loan_to_value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "is_borrowable",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "optimal_utilization_rate",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "under_optimal_slope",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "over_optimal_slope",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "deposit_cap",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::add_asset_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::add_asset_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_compute_collateral_debt_value_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_compute_collateral_debt_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::borrow_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::borrow_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_withdraw_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_withdraw_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::borrow_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::borrow_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "debt_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "user",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "debt_to_liquidate_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_liquidate_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_liquidate_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_borrow_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_borrow_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "precision",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "deposit_accumulator",
                    "type": {
                      "fields": [
                        {
                          "name": "value",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "last_updated_ts",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 64
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "accumulator::Accumulator"
                    }
                  },
                  {
                    "name": "borrow_accumulator",
                    "type": {
                      "fields": [
                        {
                          "name": "value",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "last_updated_ts",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 64
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "accumulator::Accumulator"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_compute_utilization_rate_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_compute_utilization_rate_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "asset",
                    "type": {
                      "fields": [
                        {
                          "name": "asset_address",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "loan_to_value",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "oracle",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "is_borrowable",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "optimal_utilization_rate",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "under_optimal_slope",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "over_optimal_slope",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "deposit_cap",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "asset::Asset"
                    }
                  },
                  {
                    "name": "utilization_rate",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "precision",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_compute_borrow_rate_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_compute_borrow_rate_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "on_behalf_of",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::repay_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::repay_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "debt_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "user",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "debt_to_cover",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::liquidate_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::liquidate_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::repay_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::repay_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::withdraw_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::withdraw_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "on_behalf_of",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::deposit_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::deposit_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_compute_total_collateral_value_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_compute_total_collateral_value_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Lending::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::update_accumulators_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::update_accumulators_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::withdraw_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::withdraw_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "market_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "asset_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_repay_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_repay_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "102": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "103": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "104": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n"
    },
    "105": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "106": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "107": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "109": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "110": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "111": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "112": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "133": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "136": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "139": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "140": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "141": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "142": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "143": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "144": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "149": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "150": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "151": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "152": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "154": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "156": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "157": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "159": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "168": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "182": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "185": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "186": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "188": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "189": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "191": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "193": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "204": {
      "path": "/home/jean/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "221": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "223": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "266": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "269": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "271": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "276": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, FromField, Hash, Serialize, ToField},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"
    },
    "283": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "284": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "298": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "300": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "301": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "310": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "321": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "335": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "339": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "340": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "356": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "359": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "369": {
      "path": "/home/jean/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "400": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "52": {
      "path": "/home/jean/work/noir/comet/contracts/src/helpers.nr",
      "source": "use dep::aztec::hash::pedersen_hash;\nuse std::ops::{Add, Sub};\n\n// Utility used to easily get a \"id\" for a private user that sits in the same\n// \"space\" as the public users.\n// It help us to have a single mapping for collateral that have both public and private users.\npub fn compute_identifier(secret: Field, on_behalf_of: Field, self: Field) -> Field {\n    // EITHER secret OR on_behalf_of MUST be set. But not both\n    assert(!((secret == 0) as bool & (on_behalf_of == 0) as bool));\n    if (secret != 0) {\n        pedersen_hash([self, secret], 0)\n    } else {\n        on_behalf_of\n    }\n}\n\npub fn covered_by_collateral(\n    collateral_price: u128,\n    borrow_price: u128,\n    loan_to_value: u128,\n    collateral: u128,\n    increase: u128,\n    decrease: u128,\n) -> u128 {\n    let price_precision = 1000000000 as u128;\n    let ltv_precision = 10000 as u128;\n\n    let collateral = (collateral + increase) - decrease;\n\n    let collateral_value = (collateral * collateral_price) / price_precision;\n    let debt_covered = (collateral_value * loan_to_value * price_precision) / (borrow_price * ltv_precision);\n\n    debt_covered\n}\n\npub struct DebtReturn {\n    debt_value: u128,\n    static_debt: u128,\n}\n\nfn div_up(a: u128, b: u128) -> u128 {\n    let div = a / b;\n    if div * b < a {\n        div + (1 as u128)\n    } else {\n        div\n    }\n}\n\npub fn debt_updates(\n    interest_accumulator: u128,\n    static_debt: u128,\n    increase: u128,\n    decrease: u128,\n) -> DebtReturn {\n    assert(interest_accumulator > (0 as u128));\n    let accumulator_precision = 1000000000 as u128;\n\n    let current_debt_value = (static_debt * interest_accumulator) / accumulator_precision;\n    let new_debt_value = current_debt_value.add(increase).sub(decrease);\n\n    // static_debt_increase = amount / accumulator\n    // rounding up new debt.\n    let static_debt_increase = div_up(increase * accumulator_precision, interest_accumulator);\n    // rounding down repayment.\n    let static_debt_decrease = (decrease * accumulator_precision) / interest_accumulator;\n\n    // We need to allow repaying of the entire debt as well etc. This is very prone to failing\n    // if you try to repay exact due to time diff between sim and execution.\n    let new_static_debt = static_debt.add(static_debt_increase).sub(static_debt_decrease);\n\n    DebtReturn { debt_value: new_debt_value, static_debt: new_static_debt }\n}\n\npub fn debt_value(static_debt: u128, interest_accumulator: u128) -> u128 {\n    let accumulator_precision = 1000000000 as u128;\n    div_up(static_debt * interest_accumulator, accumulator_precision)\n}\n"
    },
    "53": {
      "path": "/home/jean/work/noir/comet/contracts/src/main.nr",
      "source": "mod asset;\nmod position;\nmod helpers;\nmod accumulator;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Lending {\n    use dep::aztec::prelude::{AztecAddress, Map, PublicMutable};\n\n    use crate::asset::Asset;\n    use crate::helpers::{compute_identifier};\n    use crate::position::Position;\n    use dep::price_feed::PriceFeed;\n    use dep::token::Token;\n    use crate::accumulator::Accumulator;\n    use dep::aztec::macros::{\n        functions::{initializer, internal, private, public, view, utility},\n        storage::storage,\n    };\n    use dep::aztec::protocol_types::traits::{FromField, ToField};\n\n    #[storage]\n    struct Storage<Context> {\n        market_assets: Map<Field, Map<AztecAddress, PublicMutable<Asset, Context>, Context>, Context>,\n        market_assets_list: Map<Field, Map<u64, PublicMutable<AztecAddress, Context>, Context>, Context>,\n        market_assets_list_len: Map<Field, PublicMutable<u64, Context>, Context>,\n        scaled_deposited_assets: Map<Field, Map<AztecAddress, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, Context>,\n        scaled_borrowed_assets: Map<Field, Map<AztecAddress, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, Context>, // static debt\n        scaled_total_deposited_assets: Map<Field, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>,\n        scaled_total_borrowed_assets: Map<Field, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, // static debt\n        deposit_accumulators: Map<Field, Map<AztecAddress, PublicMutable<Accumulator, Context>, Context>, Context>,\n        borrow_accumulators: Map<Field, Map<AztecAddress, PublicMutable<Accumulator, Context>, Context>, Context>,\n    }\n\n    #[private]\n    #[initializer]\n    fn constructor() {}\n\n    #[public]\n    fn liquidate_public(market_id: Field, collateral_asset: AztecAddress, debt_asset: AztecAddress, user: AztecAddress, debt_to_cover: u128) {\n        let _ = Lending::at(context.this_address())._liquidate(market_id, collateral_asset, debt_asset, user, debt_to_cover).call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _liquidate(market_id: Field, collateral_token: AztecAddress, debt_token: AztecAddress, user: AztecAddress, debt_to_liquidate_amount: u128) {\n        Lending::at(context.this_address()).update_accumulators(market_id, collateral_token).call(&mut context);\n        Lending::at(context.this_address()).update_accumulators(market_id, debt_token).call(&mut context);\n\n        let scaled_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(debt_token).at(user);\n        let scaled_borrowed_amount: u128 = scaled_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(debt_token);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let borrowed_amount = (scaled_borrowed_amount * borrow_accumulator.value) / 1000000000 as u128;\n\n        assert(borrowed_amount >= debt_to_liquidate_amount, \"Insufficient borrowed amount\");\n\n        let total_collateral_value: u128 = Lending::at(context.this_address())._compute_total_collateral_value(market_id, user).call(&mut context);\n        let collateral_debt_value = Lending::at(context.this_address())._compute_collateral_debt_value(market_id, user).call(&mut context);\n\n        assert(collateral_debt_value > total_collateral_value, \"collateral >= debt\");\n\n        let debt_asset_loc = storage.market_assets.at(market_id).at(debt_token);\n        let debt_asset: Asset = debt_asset_loc.read();\n        let debt_asset_price = PriceFeed::at(debt_asset.oracle).get_price(0).view(&mut context).price;\n        let debt_to_liquidate_price = (debt_to_liquidate_amount * debt_asset_price) / 1000000000 as u128;\n\n        let collateral_asset_loc = storage.market_assets.at(market_id).at(collateral_token);\n        let collateral_asset: Asset = collateral_asset_loc.read();\n        let collateral_asset_price = PriceFeed::at(collateral_asset.oracle).get_price(0).view(&mut context).price;\n        let collateral_amount_to_liquidate = (debt_to_liquidate_price * 1000000000 as u128) / collateral_asset_price;\n\n        let collateral_deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(collateral_token);\n        let collateral_deposit_accumulator: Accumulator = collateral_deposit_accumulator_loc.read();\n        let scaled_collateral_deposit_amount_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_token).at(user);\n        let scaled_collateral_deposit_amount: u128 = scaled_collateral_deposit_amount_loc.read();\n        let collateral_deposit_amount = (scaled_collateral_deposit_amount * collateral_deposit_accumulator.value) / 1000000000 as u128;\n\n        assert(collateral_deposit_amount >= collateral_amount_to_liquidate, \"Insufficient collateral\");\n\n        let scaled_collateral_amount_to_liquidate = (collateral_amount_to_liquidate * 1000000000 as u128) / collateral_deposit_accumulator.value;\n\n        let debt_borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(debt_token);\n        let debt_borrow_accumulator: Accumulator = debt_borrow_accumulator_loc.read();\n        let scaled_debt_amount_to_liquidate = (debt_to_liquidate_amount * 1000000000 as u128) / debt_borrow_accumulator.value;\n\n        let scaled_user_deposited_amount_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_token).at(user);\n        let scaled_user_deposited_amount: u128 = scaled_user_deposited_amount_loc.read();\n        scaled_user_deposited_amount_loc.write(scaled_user_deposited_amount - scaled_collateral_amount_to_liquidate);\n\n        let scaled_total_deposited_asset_loc = storage.scaled_total_deposited_assets.at(market_id).at(collateral_token);\n        let scaled_total_deposited_asset: u128 = scaled_total_deposited_asset_loc.read();\n        scaled_total_deposited_asset_loc.write(scaled_total_deposited_asset - scaled_collateral_amount_to_liquidate);\n\n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(debt_token).at(user);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        scaled_user_borrowed_amount_loc.write(scaled_user_borrowed_amount - scaled_debt_amount_to_liquidate);\n\n        let scaled_total_borrowed_asset_loc = storage.scaled_total_borrowed_assets.at(market_id).at(debt_token);\n        let scaled_total_borrowed_asset: u128 = scaled_total_borrowed_asset_loc.read();\n        scaled_total_borrowed_asset_loc.write(scaled_total_borrowed_asset - scaled_debt_amount_to_liquidate);\n    }\n\n\n\n    #[private]\n    fn repay_private(\n        from: AztecAddress,\n        amount: u128,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        asset_address: AztecAddress,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        // docs:start:private_call\n        let _ = Token::at(asset_address).transfer_to_public(from, context.this_address(), amount, nonce).call(&mut context);\n        // docs:end:private_call\n        let _ = Lending::at(context.this_address())\n            ._repay(AztecAddress::from_field(on_behalf_of), amount, market_id, asset_address)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn repay_public(amount: u128, nonce: Field, owner: AztecAddress, market_id: Field, asset_address: AztecAddress) {\n        let _ = Token::at(asset_address).transfer_in_public(context.msg_sender(), context.this_address(), amount, nonce).call(&mut context);\n        let _ = Lending::at(context.this_address())._repay(owner, amount, market_id, asset_address).call(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _repay(owner: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == asset_address, \"Invalid asset or market id\");\n\n        Lending::at(context.this_address()).update_accumulators(market_id, asset_address).call(&mut context);\n\n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / borrow_accumulator.value;\n\n        assert(scaled_user_borrowed_amount >= scaled_amount, \"Insufficient balance\");\n        scaled_user_borrowed_amount_loc.write(scaled_user_borrowed_amount - scaled_amount);\n\n        let scaled_total_borrowed_asset_loc = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address);\n        let scaled_total_borrowed_asset: u128 = scaled_total_borrowed_asset_loc.read();\n        scaled_total_borrowed_asset_loc.write(scaled_total_borrowed_asset - scaled_amount);\n    }\n\n     #[private]\n    fn borrow_private(secret: Field, to: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let on_behalf_of = compute_identifier(secret, context.msg_sender().to_field(), context.msg_sender().to_field());\n        let _ = Lending::at(context.this_address())\n            ._borrow(AztecAddress::from_field(on_behalf_of), amount, market_id, asset_address)\n            .enqueue(&mut context);\n        // TODO: find a fix to transfer_to_private\n        let _ = Token::at(asset_address)\n        .transfer_in_public(context.this_address(), to, amount, 0)\n        .enqueue(&mut context);\n    }\n\n    #[public]\n    fn borrow_public(to: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let _ = Lending::at(context.this_address())._borrow(context.msg_sender(), amount, market_id, asset_address).call(\n            &mut context,\n        );\n        let _ = Token::at(asset_address)\n        .transfer_in_public(context.this_address(), to, amount, 0)\n        .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _borrow(owner: AztecAddress, amount: u128, market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n\n        assert(asset.is_borrowable, \"Asset is not borrowable\");\n\n        let total_collateral_value: u128 = Lending::at(context.this_address())._compute_total_collateral_value(market_id, owner).call(&mut context);\n        let collateral_debt_value = Lending::at(context.this_address())._compute_collateral_debt_value(market_id, owner).call(&mut context);\n\n        let borrow_price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n        let min_collateral_for_borrow = (amount * borrow_price * 10000 as u128) / (asset.loan_to_value * 1000000000 as u128);\n\n        assert(collateral_debt_value + min_collateral_for_borrow <= total_collateral_value, \"Insufficient collateral\");\n        \n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / borrow_accumulator.value;\n        scaled_user_borrowed_amount_loc.write(scaled_user_borrowed_amount + scaled_amount);\n\n        let scaled_total_borrowed_asset_loc = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address);\n        let scaled_total_borrowed_asset: u128 = scaled_total_borrowed_asset_loc.read();\n        scaled_total_borrowed_asset_loc.write(scaled_total_borrowed_asset + scaled_amount);\n    }\n\n    #[private]\n    fn withdraw_private(secret: Field, to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let on_behalf_of = compute_identifier(secret, 0, context.msg_sender().to_field());\n        Lending::at(context.this_address())\n            ._withdraw(AztecAddress::from_field(on_behalf_of), to, amount, market_id, collateral_asset)\n            .enqueue(&mut context);\n        // TODO: find a fix to transfer_to_private\n        let _ = Token::at(collateral_asset)\n        .transfer_in_public(context.this_address(), to, amount, 0)\n        .enqueue(&mut context);\n    }\n\n    #[public]\n    fn withdraw_public(to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let _ = Lending::at(context.this_address())\n            ._withdraw(context.msg_sender(), to, amount, market_id, collateral_asset)\n            .call(&mut context);\n        let _ = Token::at(collateral_asset)\n        .transfer_in_public(context.this_address(), to, amount, 0)\n        .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _withdraw(owner: AztecAddress, to: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(collateral_asset);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == collateral_asset, \"Invalid asset or market id\");\n        \n        Lending::at(context.this_address()).update_accumulators(market_id, collateral_asset).call(&mut context);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(collateral_asset);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        let scaled_user_deposited_amount_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_asset).at(owner);\n        let scaled_user_deposited_amount: u128 = scaled_user_deposited_amount_loc.read();\n        let user_deposited_amount = (scaled_user_deposited_amount * deposit_accumulator.value) / 1000000000 as u128 ;\n        assert(user_deposited_amount >= amount, \"Insufficient balance\");\n\n        let total_collateral_value: u128 = Lending::at(context.this_address())._compute_total_collateral_value(market_id, owner).call(&mut context);\n\n        let collateral_debt_value = Lending::at(context.this_address())._compute_collateral_debt_value(market_id, owner).call(&mut context);\n\n        let collateral_price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n        let withdraw_amount_value = (amount * collateral_price) / 1000000000 as u128;\n\n        let total_collateral_value_after_withdraw = total_collateral_value - withdraw_amount_value;\n\n        assert(collateral_debt_value <= total_collateral_value_after_withdraw, \"Insufficient collateral\");\n\n        let scaled_withdraw_amount = (amount * 1000000000 as u128) / deposit_accumulator.value;\n        scaled_user_deposited_amount_loc.write(scaled_user_deposited_amount - scaled_withdraw_amount);\n\n        let scaled_total_deposited_asset_loc = storage.scaled_total_deposited_assets.at(market_id).at(collateral_asset);\n        let scaled_total_deposited_asset: u128 = scaled_total_deposited_asset_loc.read();\n        scaled_total_deposited_asset_loc.write(scaled_total_deposited_asset - scaled_withdraw_amount);\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_total_collateral_value(market_id: Field, owner: AztecAddress) -> u128 {\n        let mut total_collateral_value: u128 = 0 as u128;\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id);\n\n        for i in 0..market_assets_list_len {\n            let market_asset_loc = market_assets_list_loc.at(i);\n            let market_asset: AztecAddress = market_asset_loc.read();\n            Lending::at(context.this_address()).update_accumulators(market_id, market_asset).call(&mut context);\n            let collateral_asset_loc = storage.market_assets.at(market_id).at(market_asset);\n            let collateral_asset: Asset = collateral_asset_loc.read();\n            let collateral_price = PriceFeed::at(collateral_asset.oracle).get_price(0).view(&mut context).price;\n            let scaled_collateral_amount_loc = storage.scaled_deposited_assets.at(market_id).at(market_asset).at(owner);\n            let scaled_collateral_amount: u128 = scaled_collateral_amount_loc.read();\n            let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(market_asset);\n            let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n            let collateral_amount = (scaled_collateral_amount * deposit_accumulator.value) / 1000000000 as u128;\n            total_collateral_value += (collateral_amount * collateral_price);\n        }\n        total_collateral_value / 1000000000 as u128\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_collateral_debt_value(market_id: Field, owner: AztecAddress) -> u128 {\n        let mut min_collateral_value: u128 = 0 as u128;\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id);\n\n        for i in 0..market_assets_list_len {\n            let market_asset_loc = market_assets_list_loc.at(i);\n            let market_asset: AztecAddress = market_asset_loc.read();\n            Lending::at(context.this_address()).update_accumulators(market_id, market_asset).call(&mut context);\n            let debt_asset_loc = storage.market_assets.at(market_id).at(market_asset);\n            let debt_asset: Asset = debt_asset_loc.read();\n            if(debt_asset.is_borrowable) {\n                let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(market_asset).at(owner);\n                let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n                let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(market_asset);\n                let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n                let user_borrowed_amount = (scaled_user_borrowed_amount * borrow_accumulator.value) / 1000000000 as u128;\n                \n                let borrow_price= PriceFeed::at(debt_asset.oracle).get_price(0).view(&mut context).price;\n\n                min_collateral_value += (user_borrowed_amount * borrow_price * 10000 as u128) / debt_asset.loan_to_value;\n            }\n        }\n        min_collateral_value / 1000000000 as u128\n    }\n\n    #[private]\n    fn deposit_private(\n        from: AztecAddress,\n        amount: u128,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        let _res = Token::at(collateral_asset)\n            .transfer_to_public(from, context.this_address(), amount, nonce)\n            .call(&mut context);\n        Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, market_id,collateral_asset)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn deposit_public(\n        amount: u128,\n        nonce: Field,\n        on_behalf_of: Field,\n        market_id: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        // docs:start:public_to_public_call\n        let _ = Token::at(collateral_asset)\n            .transfer_in_public(context.msg_sender(), context.this_address(), amount, nonce)\n            .call(&mut context);\n        // docs:end:public_to_public_call\n        let _ = Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, market_id, collateral_asset)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _deposit(owner: AztecAddress, amount: u128, market_id: Field, collateral_asset: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(collateral_asset);\n        let asset: Asset = asset_loc.read();\n        assert(asset.asset_address == collateral_asset, \"Invalid asset or market id\");\n        \n        Lending::at(context.this_address()).update_accumulators(market_id, collateral_asset).call(&mut context);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(collateral_asset);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        let total_deposited_assets = Lending::at(context.this_address()).compute_total_deposited_assets(market_id, collateral_asset, deposit_accumulator).call(&mut context);\n        assert((total_deposited_assets + amount) < asset.deposit_cap, \"Deposit cap exceeded\");\n\n        let scaled_user_deposited_asset_loc = storage.scaled_deposited_assets.at(market_id).at(collateral_asset).at(owner);\n        let scaled_user_deposited_asset: u128 = scaled_user_deposited_asset_loc.read();\n        let scaled_amount = (amount * 1000000000 as u128) / deposit_accumulator.value;\n        scaled_user_deposited_asset_loc.write(scaled_user_deposited_asset + scaled_amount);\n\n        let scaled_total_deposited_asset_loc = storage.scaled_total_deposited_assets.at(market_id).at(collateral_asset);\n        let scaled_total_deposited_asset: u128 = scaled_total_deposited_asset_loc.read();\n        scaled_total_deposited_asset_loc.write(scaled_total_deposited_asset + scaled_amount);\n    }\n\n    #[public]\n    fn compute_total_deposited_assets(market_id: Field, asset_address: AztecAddress, deposit_accumulator: Accumulator) -> u128 {\n        let scaled_total_deposited_asset_static = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let total_deposited_asset = scaled_total_deposited_asset_static * deposit_accumulator.value / 1000000000 as u128;\n        total_deposited_asset\n    }\n\n    #[public]\n    fn add_asset(market_id: Field, asset_address: AztecAddress, oracle: AztecAddress, loan_to_value: u128, is_borrowable: bool, optimal_utilization_rate: u128, under_optimal_slope: u128, over_optimal_slope: u128, deposit_cap: u128) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n\n        assert(loan_to_value <= (10000 as u128));\n\n        asset_loc.write(Asset {\n            asset_address,\n            oracle,\n            loan_to_value,\n            is_borrowable,\n            optimal_utilization_rate,\n            under_optimal_slope,\n            over_optimal_slope,\n            deposit_cap,\n        });\n\n        let market_assets_list_len_loc = storage.market_assets_list_len.at(market_id);\n        let market_assets_list_len: u64 = market_assets_list_len_loc.read();\n        let market_assets_list_loc = storage.market_assets_list.at(market_id).at(market_assets_list_len);\n        market_assets_list_loc.write(asset_address);\n        market_assets_list_len_loc.write(market_assets_list_len + 1);\n\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n\n        assert(deposit_accumulator.last_updated_ts == 0);\n        assert(deposit_accumulator.value == 0 as u128);\n\n        deposit_accumulator_loc.write(Accumulator {\n            // 10**9\n            value: 1000000000 as u128,\n            last_updated_ts: context.timestamp(),\n        });\n\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n\n        assert(borrow_accumulator.last_updated_ts == 0);\n        assert(borrow_accumulator.value == 0 as u128);\n\n        borrow_accumulator_loc.write(Accumulator {\n            // 10**9\n            value: 1000000000 as u128,\n            last_updated_ts: context.timestamp(),\n        });\n    }\n\n\n    // Create a position.\n    #[public]\n    fn update_accumulators(market_id: Field, asset_address: AztecAddress) {\n        let asset_loc = storage.market_assets.at(market_id).at(asset_address);\n        let asset: Asset = asset_loc.read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let mut deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let mut borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n\n        let timestamp = context.timestamp();\n        let time_delta = timestamp - deposit_accumulator.last_updated_ts;\n\n        // Only update if time has passed.\n        if !(time_delta == 0) {\n            let precision = 1000000000 as u128; // 10**9\n            let utilization_rate = _compute_utilization_rate(market_id, asset_address, precision, deposit_accumulator, borrow_accumulator);\n            let borrow_rate_per_year = _compute_borrow_rate(asset, utilization_rate, precision);\n            // TODO: let supply_rate_per_year = borrow_rate_per_year * utilization_rate * (1 - reserve_factor);\n            let supply_rate_per_year = (borrow_rate_per_year * utilization_rate) / precision;\n\n            let new_borrow_accumulator = ((borrow_accumulator.value * borrow_rate_per_year * time_delta as u128) / 31536000 as u128) / precision;\n            let new_deposit_accumulator = ((deposit_accumulator.value * supply_rate_per_year * time_delta as u128) / 31536000 as u128) / precision;\n\n            borrow_accumulator.value += new_borrow_accumulator;\n            borrow_accumulator.last_updated_ts = timestamp;\n            borrow_accumulator_loc.write(borrow_accumulator);\n            deposit_accumulator.value += new_deposit_accumulator;\n            deposit_accumulator.last_updated_ts = timestamp;\n            deposit_accumulator_loc.write(deposit_accumulator);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_utilization_rate(market_id: Field, asset_address: AztecAddress, precision: u128, deposit_accumulator: Accumulator, borrow_accumulator: Accumulator) -> u128 {\n        \n        let scaled_total_deposited_asset = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let scaled_total_borrowed_asset = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address).read();\n\n        let total_deposited_assets = (scaled_total_deposited_asset * deposit_accumulator.value) / precision;\n        let total_borrowed_assets = (scaled_total_borrowed_asset * borrow_accumulator.value) / precision;\n        let mut utilization_rate = 0 as u128;\n        if (total_borrowed_assets != 0) {\n            utilization_rate = (total_borrowed_assets * precision) / total_deposited_assets;\n        } else {\n            utilization_rate = 0;\n        }\n\n        utilization_rate\n    }\n\n    #[public]\n    #[internal]\n    fn _compute_borrow_rate(asset: Asset, utilization_rate: u128, precision: u128) -> u128 {\n        let mut rate = 0 as u128;\n        if utilization_rate < asset.optimal_utilization_rate {\n            // rate = base + utilization * slope1 / optimal No base for now\n            rate = (utilization_rate * asset.under_optimal_slope) / asset.optimal_utilization_rate;\n        } else {\n            // rate = base +slope1 + (utilization - optimal) * slope2 / (1 - optimal) No base for now\n            rate = asset.under_optimal_slope + (utilization_rate - asset.optimal_utilization_rate) * asset.over_optimal_slope / (precision - asset.optimal_utilization_rate);\n        }\n        rate\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_position(owner: AztecAddress, market_id: Field, asset_address: AztecAddress) -> pub Position {\n        let scaled_user_deposited_asset_loc = storage.scaled_deposited_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_deposited_asset: u128 = scaled_user_deposited_asset_loc.read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let collateral = (scaled_user_deposited_asset * deposit_accumulator.value) / 1000000000 as u128;\n        let scaled_user_borrowed_amount_loc = storage.scaled_borrowed_assets.at(market_id).at(asset_address).at(owner);\n        let scaled_user_borrowed_amount: u128 = scaled_user_borrowed_amount_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let debt = (scaled_user_borrowed_amount * borrow_accumulator.value) / 1000000000 as u128;\n        Position { collateral, scaled_debt:scaled_user_borrowed_amount, debt }\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_total_deposited_assets(market_id: Field, asset_address: AztecAddress) -> u128 {\n        let scaled_total_deposited_asset = storage.scaled_total_deposited_assets.at(market_id).at(asset_address).read();\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let total_deposited_assets = (scaled_total_deposited_asset * deposit_accumulator.value) / 1000000000 as u128;\n        total_deposited_assets\n    }\n\n    #[utility]\n    #[view]\n    unconstrained fn get_total_borrowed_assets(market_id: Field, asset_address: AztecAddress) -> u128 {\n        let scaled_total_borrowed_asset = storage.scaled_total_borrowed_assets.at(market_id).at(asset_address).read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        let total_borrowed_assets = (scaled_total_borrowed_asset * borrow_accumulator.value) / 1000000000 as u128;\n        total_borrowed_assets\n    }\n\n\n    #[utility]\n    #[view]\n    unconstrained fn get_accumulators(market_id: Field, asset_address: AztecAddress) -> (Accumulator, Accumulator) {\n        let deposit_accumulator_loc = storage.deposit_accumulators.at(market_id).at(asset_address);\n        let deposit_accumulator: Accumulator = deposit_accumulator_loc.read();\n        let borrow_accumulator_loc = storage.borrow_accumulators.at(market_id).at(asset_address);\n        let borrow_accumulator: Accumulator = borrow_accumulator_loc.read();\n        (deposit_accumulator, borrow_accumulator)\n    }\n}\n"
    },
    "56": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "57": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "64": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "65": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "66": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "67": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "71": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "88": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "92": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "93": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "96": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "97": {
      "path": "/home/jean/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    }
  }
}
